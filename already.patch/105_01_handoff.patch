diff --git a/auto/options b/auto/options
index 11f23c6..b219d9f 100644
--- a/auto/options
+++ b/auto/options
@@ -46,6 +46,7 @@ USE_THREADS=NO
 
 NGX_FILE_AIO=NO
 NGX_IPV6=NO
+NGX_TPROXY=NO
 
 HTTP=YES
 
@@ -189,6 +190,7 @@ do
 
         --with-file-aio)                 NGX_FILE_AIO=YES           ;;
         --with-ipv6)                     NGX_IPV6=YES               ;;
+        --with-tproxy)                   NGX_TPROXY=YES             ;;
 
         --without-http)                  HTTP=NO                    ;;
         --without-http-cache)            HTTP_CACHE=NO              ;;
@@ -345,6 +347,7 @@ cat << END
 
   --with-file-aio                    enable file AIO support
   --with-ipv6                        enable IPv6 support
+  --with-tproxy                      enable TPROXY support
 
   --with-http_ssl_module             enable ngx_http_ssl_module
   --with-http_realip_module          enable ngx_http_realip_module
diff --git a/auto/unix b/auto/unix
index b0a0e4c..bb4f6c4 100755
--- a/auto/unix
+++ b/auto/unix
@@ -496,6 +496,17 @@ if [ $NGX_IPV6 = YES ]; then
     . auto/feature
 fi
 
+if [ $NGX_TPROXY = YES ]; then
+ ngx_feature="Linux TPROXY support"
+ ngx_feature_name="NGX_HAVE_TPROXY"
+ ngx_feature_run=no
+ ngx_feature_incs=
+ ngx_feature_path=
+ ngx_feature_libs=
+ ngx_feature_test=
+
+ . auto/feature
+fi
 
 ngx_feature="setproctitle()"
 ngx_feature_name="NGX_HAVE_SETPROCTITLE"
diff --git a/src/core/ngx_connection.c b/src/core/ngx_connection.c
old mode 100644
new mode 100755
index ba1b3f9..89cf67e
--- a/src/core/ngx_connection.c
+++ b/src/core/ngx_connection.c
@@ -8,7 +8,10 @@
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
-
+#include <linux/netfilter_ipv4.h>
+#ifndef IP_TRANSPARENT
+#define IP_TRANSPARENT        19
+#endif
 
 ngx_os_io_t  ngx_io;
 
@@ -82,6 +85,9 @@ ngx_create_listening(ngx_conf_t *cf, void *sockaddr, socklen_t socklen)
     ls->setfib = -1;
 #endif
 
+#if (NGX_HAVE_TPROXY)
+    ls->tproxy = 0;
+#endif
     return ls;
 }
 
@@ -274,7 +280,9 @@ ngx_open_listening_sockets(ngx_cycle_t *cycle)
     ngx_log_t        *log;
     ngx_socket_t      s;
     ngx_listening_t  *ls;
-
+#if (NGX_HAVE_TPROXY)
+    int tproxy;
+#endif
     reuseaddr = 1;
 #if (NGX_SUPPRESS_WARN)
     failed = 0;
@@ -369,6 +377,19 @@ ngx_open_listening_sockets(ngx_cycle_t *cycle)
                 }
             }
 
+#if (NGX_HAVE_TPROXY)
+            /* TPROXY support requires enabled (SOL_IP, IP_TRANSPARENT) */
+            /* socket option to be able to send datagrams _from_ non-local IP */
+            tproxy = ls[i].tproxy;
+            if (setsockopt(s, SOL_IP, IP_TRANSPARENT, &tproxy,
+                    sizeof(tproxy)) == -1) {
+                ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,
+                "setsockopt(SOL_IP, IP_TRANSPARENT) %V failed",
+                &ls[i].addr_text);
+                return NGX_ERROR;
+            }
+#endif
+
             ngx_log_debug2(NGX_LOG_DEBUG_CORE, log, 0,
                            "bind() %V #%d ", &ls[i].addr_text, s);
 
@@ -1006,6 +1027,66 @@ ngx_drain_connections(void)
     }
 }
 
+#if (NGX_HAVE_TPROXY)
+ngx_int_t
+ngx_connection_dst_sockaddr(ngx_connection_t *c, ngx_str_t *s,
+    ngx_uint_t port)
+{
+    socklen_t             len;
+    ngx_uint_t            addr;
+    u_char                sa[NGX_SOCKADDRLEN];
+    struct sockaddr_in   *sin;
+#if (NGX_HAVE_INET6)
+    ngx_uint_t            i;
+    struct sockaddr_in6  *sin6;
+#endif
+
+    switch (c->dst_sockaddr->sa_family) {
+
+#if (NGX_HAVE_INET6)
+    case AF_INET6:
+        sin6 = (struct sockaddr_in6 *) c->dst_sockaddr;
+
+        for (addr = 0, i = 0; addr == 0 && i < 16; i++) {
+            addr |= sin6->sin6_addr.s6_addr[i];
+        }
+
+        break;
+#endif
+
+    default: /* AF_INET */
+        sin = (struct sockaddr_in *) c->dst_sockaddr;
+        addr = sin->sin_addr.s_addr;
+        break;
+    }
+
+    if (addr == 0) {
+
+        len = NGX_SOCKADDRLEN;
+
+        if (getsockopt (c->fd, SOL_IP, SO_ORIGINAL_DST, (struct sockaddr_in *) &sa, &len)) {
+            ngx_connection_error(c, ngx_socket_errno, "getsockopt(SO_ORIGINAL_DST) failed");
+            return NGX_ERROR;
+        }
+
+        c->dst_sockaddr = ngx_palloc(c->pool, len);
+        if (c->dst_sockaddr == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(c->dst_sockaddr, &sa, len);
+    }
+
+    if (s == NULL) {
+        return NGX_OK;
+    }
+
+    s->len = ngx_sock_ntop(c->dst_sockaddr, s->data, s->len, port);
+
+    return NGX_OK;
+}
+#endif
+
 
 ngx_int_t
 ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,
@@ -1120,6 +1201,7 @@ ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text)
     }
 
     ngx_log_error(level, c->log, err, text);
+	ngx_log_msg(level, c->log, err, text);
 
     return NGX_ERROR;
 }
diff --git a/src/core/ngx_connection.h b/src/core/ngx_connection.h
old mode 100644
new mode 100755
index 34af12e..f092870
--- a/src/core/ngx_connection.h
+++ b/src/core/ngx_connection.h
@@ -72,6 +72,9 @@ struct ngx_listening_s {
     unsigned            deferred_accept:1;
     unsigned            delete_deferred:1;
     unsigned            add_deferred:1;
+#if (NGX_HAVE_TPROXY)
+    unsigned            tproxy:1;
+#endif
 #ifdef SO_ACCEPTFILTER
     char               *accept_filter;
 #endif
@@ -140,6 +143,10 @@ struct ngx_connection_s {
 
     struct sockaddr    *local_sockaddr;
 
+#if (NGX_HAVE_TPROXY)
+    struct sockaddr    *dst_sockaddr;
+#endif
+
     ngx_buf_t          *buffer;
 
     ngx_queue_t         queue;
@@ -189,6 +196,10 @@ ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle);
 void ngx_configure_listening_sockets(ngx_cycle_t *cycle);
 void ngx_close_listening_sockets(ngx_cycle_t *cycle);
 void ngx_close_connection(ngx_connection_t *c);
+#if (NGX_HAVE_TPROXY)
+ngx_int_t ngx_connection_dst_sockaddr(ngx_connection_t *c, ngx_str_t *s,
+    ngx_uint_t port);
+#endif
 ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,
     ngx_uint_t port);
 ngx_int_t ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text);
diff --git a/src/core/ngx_inet.c b/src/core/ngx_inet.c
old mode 100644
new mode 100755
diff --git a/src/core/ngx_inet.h b/src/core/ngx_inet.h
old mode 100644
new mode 100755
diff --git a/src/core/ngx_log.c b/src/core/ngx_log.c
old mode 100644
new mode 100755
index d7830fb..a7d29ec
--- a/src/core/ngx_log.c
+++ b/src/core/ngx_log.c
@@ -7,6 +7,7 @@
 
 #include <ngx_config.h>
 #include <ngx_core.h>
+#include <sys/msg.h>
 
 
 static char *ngx_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
@@ -67,7 +68,7 @@ static ngx_str_t err_levels[] = {
 
 static const char *debug_levels[] = {
     "debug_core", "debug_alloc", "debug_mutex", "debug_event",
-    "debug_http", "debug_mail", "debug_mysql"
+    "debug_http", "debug_mail", "debug_mysql", "debug_tcp", "debug_handoff"
 };
 
 
@@ -457,3 +458,44 @@ ngx_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 
     return ngx_log_set_levels(cf, &cf->cycle->new_log);
 }
+
+
+int  
+ngx_log_msg(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
+    const char *text)
+{
+    long qid;
+    size_t nbytes;
+    struct xqMsgQ msg;
+	u_char  *p, *last;
+
+
+    if ((qid = msgget(NGX_MSG_KEY, 0)) < 0){
+        ngx_log_error_core(level, log, err, "can't open queue key %d", NGX_MSG_KEY);
+		return 1;
+    }
+
+	memset(&msg, 0, sizeof(msg));
+	last = msg.mtext + NGX_MSG_MAXMSZ;
+	p = msg.mtext;	
+
+	p = ngx_slprintf(p, last, "ERROR='%d';ERRMSG='", err);
+	p = ngx_strerror(err, p, last - p);
+    if (p < last) {
+        *p++ = '\'';
+    }
+
+    if (log->handler) {
+        p = log->handler(log, p, last - p);
+    }
+	
+    nbytes = strlen((char *)msg.mtext);
+    msg.mtype = 1;
+    if (msgsnd(qid, &msg, nbytes + sizeof(long), IPC_NOWAIT) < 0){
+        ngx_log_error_core(level, log, err, "can't send message");	
+		return 1;
+    }
+
+	return 0;
+}
+
diff --git a/src/core/ngx_log.h b/src/core/ngx_log.h
old mode 100644
new mode 100755
index 3233647..2f9844c
--- a/src/core/ngx_log.h
+++ b/src/core/ngx_log.h
@@ -30,6 +30,8 @@
 #define NGX_LOG_DEBUG_HTTP        0x100
 #define NGX_LOG_DEBUG_MAIL        0x200
 #define NGX_LOG_DEBUG_MYSQL       0x400
+#define NGX_LOG_DEBUG_TCP         0x800
+#define NGX_LOG_DEBUG_HANDOFF     0x1000
 
 /*
  * do not forget to update debug_levels[] in src/core/ngx_log.c
@@ -37,7 +39,7 @@
  */
 
 #define NGX_LOG_DEBUG_FIRST       NGX_LOG_DEBUG_CORE
-#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_MYSQL
+#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_HANDOFF
 #define NGX_LOG_DEBUG_CONNECTION  0x80000000
 #define NGX_LOG_DEBUG_ALL         0x7ffffff0
 
@@ -247,4 +249,22 @@ extern ngx_module_t  ngx_errlog_module;
 extern ngx_uint_t    ngx_use_stderr;
 
 
+/*
+ * ngx_log_msg
+ */
+ 
+
+#define NGX_MSG_MAXMSZ  512             /* maximum message size */
+#define NGX_MSG_KEY     0x123           /* key for first message queue */
+
+struct xqMsgQ {
+    long mtype;
+    u_char mtext[NGX_MSG_MAXMSZ];
+};
+
+int ngx_log_msg(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
+    const char *text);
+
+
+
 #endif /* _NGX_LOG_H_INCLUDED_ */
diff --git a/src/event/ngx_event_accept.c b/src/event/ngx_event_accept.c
index 6087d60..892833e 100644
--- a/src/event/ngx_event_accept.c
+++ b/src/event/ngx_event_accept.c
@@ -8,7 +8,7 @@
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
-
+#include <linux/netfilter_ipv4.h>
 
 static ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle);
 static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle);
@@ -138,6 +138,7 @@ ngx_event_accept(ngx_event_t *ev)
         (void) ngx_atomic_fetch_add(ngx_stat_accepted, 1);
 #endif
 
+
         ngx_accept_disabled = ngx_cycle->connection_n / 8
                               - ngx_cycle->free_connection_n;
 
@@ -170,6 +171,21 @@ ngx_event_accept(ngx_event_t *ev)
 
         ngx_memcpy(c->sockaddr, sa, socklen);
 
+#if (NGX_HAVE_TPROXY)
+        if (getsockopt (c->fd, SOL_IP, SO_ORIGINAL_DST, (struct sockaddr_in *) sa, &socklen)) {
+            ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_socket_errno, "getsockopt(SO_ORIGINAL_DST) failed");
+            ngx_close_accepted_connection(c);
+            return;
+        }
+        c->dst_sockaddr = ngx_palloc(c->pool, socklen);
+        if (c->dst_sockaddr == NULL) {
+            ngx_close_accepted_connection(c);
+            return;
+        }
+
+        ngx_memcpy(c->dst_sockaddr, sa, socklen);
+#endif
+
         log = ngx_palloc(c->pool, sizeof(ngx_log_t));
         if (log == NULL) {
             ngx_close_accepted_connection(c);
diff --git a/src/event/ngx_event_connect.h b/src/event/ngx_event_connect.h
index 951c24f..ad15efa 100644
--- a/src/event/ngx_event_connect.h
+++ b/src/event/ngx_event_connect.h
@@ -33,6 +33,7 @@ typedef void (*ngx_event_save_peer_session_pt)(ngx_peer_connection_t *pc,
     void *data);
 #endif
 
+#define NGX_INVALID_CHECK_INDEX (ngx_uint_t)(-1)
 
 struct ngx_peer_connection_s {
     ngx_connection_t                *connection;
@@ -43,6 +44,8 @@ struct ngx_peer_connection_s {
 
     ngx_uint_t                       tries;
 
+    ngx_uint_t                       check_index;
+
     ngx_event_get_peer_pt            get;
     ngx_event_free_peer_pt           free;
     void                            *data;
diff --git a/src/handoff/config b/src/handoff/config
new file mode 100755
index 0000000..a02fdcd
--- /dev/null
+++ b/src/handoff/config
@@ -0,0 +1,25 @@
+ngx_feature="nginx_handoff_module"
+ngx_feature_name=
+ngx_feature_run=no
+ngx_feature_incs=
+ngx_feature_path="$ngx_addon_dir/modules $ngx_addon_dir/parsers $ngx_addon_dir"
+ngx_feature_deps="$ngx_addon_dir/ngx_handoff.h $ngx_addon_dir/ngx_handoff_session.h" 
+ngx_handoff_src="$ngx_addon_dir/ngx_handoff.c $ngx_addon_dir/ngx_handoff_core_module.c $ngx_addon_dir/ngx_handoff_log.c $ngx_addon_dir/ngx_handoff_session.c"
+ngx_feature_test="int a;"
+. auto/feature
+
+if [ $ngx_found = yes ]; then
+    CORE_INCS="$CORE_INCS $ngx_feature_path"
+    ngx_addon_name=ngx_handoff_module
+
+    NGX_ADDON_DEPS="$NGX_ADDON_DEPS $ngx_feature_deps $ngx_handoff_parser_deps"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_handoff_src $ngx_handoff_parser_src"
+
+    EVENT_MODULES="$EVENT_MODULES ngx_handoff_module ngx_handoff_core_module"
+    HTTP_MODULES="$HTTP_MODULES"
+else 
+    cat << END
+    $0: error: the ngx_handoff_module addon error.
+END
+    exit 1
+fi
diff --git a/src/handoff/ngx_handoff.c b/src/handoff/ngx_handoff.c
new file mode 100755
index 0000000..c28b03f
--- /dev/null
+++ b/src/handoff/ngx_handoff.c
@@ -0,0 +1,569 @@
+/*
+ * author : yubo@xiaomi.com
+ */
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_handoff.h>
+
+
+static char *ngx_handoff_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static ngx_int_t ngx_handoff_add_ports(ngx_conf_t *cf, ngx_array_t *ports,
+    ngx_handoff_listen_t *listen);
+static char * ngx_handoff_optimize_servers(ngx_conf_t *cf, 
+        ngx_handoff_core_main_conf_t *cmcf, ngx_array_t *ports);
+static ngx_int_t ngx_handoff_add_addrs(ngx_conf_t *cf, ngx_handoff_port_t *mport,
+    ngx_handoff_conf_addr_t *addr);
+#if (NGX_HAVE_INET6)
+static ngx_int_t ngx_handoff_add_addrs6(ngx_conf_t *cf, ngx_handoff_port_t *mport,
+    ngx_handoff_conf_addr_t *addr);
+#endif
+static ngx_int_t ngx_handoff_cmp_conf_addrs(const void *one, const void *two);
+
+
+ngx_uint_t  ngx_handoff_max_module;
+
+
+static ngx_command_t  ngx_handoff_commands[] = {
+
+    { ngx_string("handoff"),
+      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_handoff_block,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_core_module_t  ngx_handoff_module_ctx = {
+    ngx_string("handoff"),
+    NULL,
+    NULL
+};
+
+
+ngx_module_t  ngx_handoff_module = {
+    NGX_MODULE_V1,
+    &ngx_handoff_module_ctx,                   /* module context */
+    ngx_handoff_commands,                      /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static char *
+ngx_handoff_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char                        *rv;
+    ngx_uint_t                   i, m, mi, s;
+    ngx_conf_t                   pcf;
+    ngx_array_t                  ports;
+    ngx_handoff_listen_t           *listen;
+    ngx_handoff_module_t           *module;
+    ngx_handoff_conf_ctx_t         *ctx;
+    ngx_handoff_core_srv_conf_t   **cscfp;
+    ngx_handoff_core_main_conf_t   *cmcf;
+
+
+    /* the main tcp context */
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_handoff_conf_ctx_t));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *(ngx_handoff_conf_ctx_t **) conf = ctx;
+
+    /* count the number of the tcp modules and set up their indices */
+
+    ngx_handoff_max_module = 0;
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_HANDOFF_MODULE) {
+            continue;
+        }
+
+        ngx_modules[m]->ctx_index = ngx_handoff_max_module++;
+    }
+
+
+    /* the tcp main_conf context, it is the same in the all tcp contexts */
+
+    ctx->main_conf = ngx_pcalloc(cf->pool,
+                                 sizeof(void *) * ngx_handoff_max_module);
+    if (ctx->main_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+
+    /*
+     * the tcp null srv_conf context, it is used to merge
+     * the server{}s' srv_conf's
+     */
+
+    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_handoff_max_module);
+    if (ctx->srv_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+
+    /*
+     * create the main_conf's, the null srv_conf's, and the null loc_conf's
+     * of the all handoff modules
+     */
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_HANDOFF_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+        mi = ngx_modules[m]->ctx_index;
+
+        if (module->create_main_conf) {
+            ctx->main_conf[mi] = module->create_main_conf(cf);
+            if (ctx->main_conf[mi] == NULL) {
+                return NGX_CONF_ERROR;
+            }
+        }
+
+        if (module->create_srv_conf) {
+            ctx->srv_conf[mi] = module->create_srv_conf(cf);
+            if (ctx->srv_conf[mi] == NULL) {
+                return NGX_CONF_ERROR;
+            }
+        }
+    }
+
+
+    /* parse inside the handoff{} block */
+
+    pcf = *cf;
+    cf->ctx = ctx;
+
+    cf->module_type = NGX_HANDOFF_MODULE;
+    cf->cmd_type = NGX_HANDOFF_MAIN_CONF;
+    rv = ngx_conf_parse(cf, NULL);
+
+    if (rv != NGX_CONF_OK) {
+        *cf = pcf;
+        return rv;
+    }
+
+
+    /* init tcp{} main_conf's, merge the server{}s' srv_conf's */
+
+    cmcf = ctx->main_conf[ngx_handoff_core_module.ctx_index];
+    cscfp = cmcf->servers.elts;
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_HANDOFF_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+        mi = ngx_modules[m]->ctx_index;
+
+        /* init tcp{} main_conf's */
+
+        cf->ctx = ctx;
+
+        if (module->init_main_conf) {
+            rv = module->init_main_conf(cf, ctx->main_conf[mi]);
+            if (rv != NGX_CONF_OK) {
+                *cf = pcf;
+                return rv;
+            }
+        }
+
+        for (s = 0; s < cmcf->servers.nelts; s++) {
+
+            /* merge the server{}s' srv_conf's */
+
+            cf->ctx = cscfp[s]->ctx;
+
+            if (module->merge_srv_conf) {
+                rv = module->merge_srv_conf(cf, ctx->srv_conf[mi],
+                                            cscfp[s]->ctx->srv_conf[mi]);
+                if (rv != NGX_CONF_OK) {
+                    *cf = pcf;
+                    return rv;
+                }
+            }
+        }
+    }
+
+    *cf = pcf;
+
+    if (ngx_array_init(&ports, cf->temp_pool, 4, sizeof(ngx_handoff_conf_port_t))
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    listen = cmcf->listen.elts;
+
+    for (i = 0; i < cmcf->listen.nelts; i++) {
+        if (ngx_handoff_add_ports(cf, &ports, &listen[i]) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+    }
+
+    return ngx_handoff_optimize_servers(cf, cmcf, &ports);
+}
+
+
+static ngx_int_t
+ngx_handoff_add_ports(ngx_conf_t *cf, ngx_array_t *ports, ngx_handoff_listen_t *listen)
+{
+    in_port_t              p;
+    ngx_uint_t             i;
+    struct sockaddr       *sa;
+    struct sockaddr_in    *sin;
+    ngx_handoff_conf_port_t   *port;
+    ngx_handoff_conf_addr_t   *addr;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6   *sin6;
+#endif
+
+    sa = (struct sockaddr *) &listen->sockaddr;
+
+    switch (sa->sa_family) {
+
+#if (NGX_HAVE_INET6)
+    case AF_INET6:
+        sin6 = (struct sockaddr_in6 *) sa;
+        p = sin6->sin6_port;
+        break;
+#endif
+
+    default: /* AF_INET */
+        sin = (struct sockaddr_in *) sa;
+        p = sin->sin_port;
+        break;
+    }
+
+    port = ports->elts;
+    for (i = 0; i < ports->nelts; i++) {
+        if (p == port[i].port && sa->sa_family == port[i].family) {
+
+            /* a port is already in the port list */
+
+            port = &port[i];
+            goto found;
+        }
+    }
+
+    /* add a port to the port list */
+
+    port = ngx_array_push(ports);
+    if (port == NULL) {
+        return NGX_ERROR;
+    }
+
+    port->family = sa->sa_family;
+    port->port = p;
+
+    if (ngx_array_init(&port->addrs, cf->temp_pool, 2,
+                       sizeof(ngx_handoff_conf_addr_t))
+        != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+found:
+
+    addr = ngx_array_push(&port->addrs);
+    if (addr == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memzero(addr, sizeof(ngx_handoff_conf_addr_t));
+
+    addr->sockaddr = (struct sockaddr *) &listen->sockaddr;
+    addr->socklen = listen->socklen;
+    addr->ctx = listen->ctx;
+    addr->bind = listen->bind;
+    addr->wildcard = listen->wildcard;
+    if (listen->default_port) {
+        addr->default_ctx = listen->ctx;
+    }
+#if (NGX_HANDOFF_SSL)
+    addr->ssl = listen->ssl;
+#endif
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+    addr->ipv6only = listen->ipv6only;
+#endif
+#if (NGX_HAVE_TPROXY)
+	addr->tproxy= listen->tproxy;
+#endif
+
+
+
+    return NGX_OK;
+}
+
+
+
+static char *
+ngx_handoff_optimize_servers(ngx_conf_t *cf, ngx_handoff_core_main_conf_t *cmcf,
+    ngx_array_t *ports)
+{
+    ngx_uint_t             i, p, last, bind_wildcard;
+    ngx_listening_t       *ls;
+    ngx_handoff_port_t        *mport;
+    ngx_handoff_conf_port_t   *port;
+    ngx_handoff_conf_addr_t   *addr;
+
+    port = ports->elts;
+    for (p = 0; p < ports->nelts; p++) {
+
+        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,
+                 sizeof(ngx_handoff_conf_addr_t), ngx_handoff_cmp_conf_addrs);
+
+        addr = port[p].addrs.elts;
+        last = port[p].addrs.nelts;
+
+        /*
+         * if there is the binding to the "*:port" then we need to bind()
+         * to the "*:port" only and ignore the other bindings
+         */
+
+        if (addr[last - 1].wildcard) {
+            addr[last - 1].bind = 1;
+            bind_wildcard = 1;
+
+        } else {
+            bind_wildcard = 0;
+        }
+
+        i = 0;
+
+        while (i < last) {
+
+            if (bind_wildcard && !addr[i].bind) {
+                i++;
+                continue;
+            }
+
+            ls = ngx_create_listening(cf, addr[i].sockaddr, addr[i].socklen);
+            if (ls == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ls->addr_ntop = 1;
+            ls->handler = ngx_handoff_init_connection;
+            ls->pool_size = 256;
+
+            /* TODO: error_log directive */
+            ls->logp = &cf->cycle->new_log;
+            ls->log.data = &ls->addr_text;
+            ls->log.handler = ngx_accept_log_error;
+
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+            ls->ipv6only = addr[i].ipv6only;
+#endif
+
+#if (NGX_HAVE_TPROXY)
+			ls->tproxy = addr[i].tproxy;
+#endif
+
+
+            mport = ngx_palloc(cf->pool, sizeof(ngx_handoff_port_t));
+            if (mport == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ls->servers = mport;
+
+            if (i == last - 1) {
+                mport->naddrs = last;
+
+            } else {
+                mport->naddrs = 1;
+                i = 0;
+            }
+
+            switch (ls->sockaddr->sa_family) {
+#if (NGX_HAVE_INET6)
+            case AF_INET6:
+                if (ngx_handoff_add_addrs6(cf, mport, addr) != NGX_OK) {
+                    return NGX_CONF_ERROR;
+                }
+                break;
+#endif
+            default: /* AF_INET */
+                if (ngx_handoff_add_addrs(cf, mport, addr) != NGX_OK) {
+                    return NGX_CONF_ERROR;
+                }
+                break;
+            }
+
+
+            addr++;
+            last--;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static ngx_int_t
+ngx_handoff_add_addrs(ngx_conf_t *cf, ngx_handoff_port_t *mport,
+    ngx_handoff_conf_addr_t *addr)
+{
+    u_char              *p;
+    size_t               len;
+    ngx_uint_t           i, j;
+    ngx_handoff_in_addr_t   *addrs;
+    struct sockaddr_in  *sin, *sin_b;
+    u_char               buf[NGX_SOCKADDR_STRLEN];
+
+    mport->addrs = ngx_pcalloc(cf->pool,
+                               mport->naddrs * sizeof(ngx_handoff_in_addr_t));
+    if (mport->addrs == NULL) {
+        return NGX_ERROR;
+    }
+
+    addrs = mport->addrs;
+
+    for (i = 0; i < mport->naddrs; i++) {
+
+        sin = (struct sockaddr_in *) addr[i].sockaddr;
+        addrs[i].addr = sin->sin_addr.s_addr;
+
+        addrs[i].conf.ctx = addr[i].ctx;
+
+        for (j = 0; j < mport->naddrs; j++) {
+            sin_b = (struct sockaddr_in *) addr[j].sockaddr;
+            if ((sin->sin_addr.s_addr == sin_b->sin_addr.s_addr) && addr[j].default_ctx) {
+                addrs[i].conf.default_ctx = addr[j].default_ctx;
+            }
+        }
+
+#if (NGX_HANDOFF_SSL)
+        addrs[i].conf.ssl = addr[i].ssl;
+#endif
+
+#if defined(nginx_version) && nginx_version >= 1005003
+        len = ngx_sock_ntop(addr[i].sockaddr, addr[i].socklen, buf, NGX_SOCKADDR_STRLEN, 1);
+#else
+        len = ngx_sock_ntop(addr[i].sockaddr, buf, NGX_SOCKADDR_STRLEN, 1);
+#endif
+
+        p = ngx_pnalloc(cf->pool, len);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(p, buf, len);
+
+        addrs[i].conf.addr_text.len = len;
+        addrs[i].conf.addr_text.data = p;
+    }
+
+    return NGX_OK;
+}
+
+
+#if (NGX_HAVE_INET6)
+
+static ngx_int_t
+ngx_handoff_add_addrs6(ngx_conf_t *cf, ngx_handoff_port_t *mport,
+    ngx_handoff_conf_addr_t *addr)
+{
+    u_char               *p;
+    size_t                len;
+    ngx_uint_t            i, j;
+    ngx_handoff_in6_addr_t   *addrs6;
+    struct sockaddr_in6  *sin6, *sin6_b;
+    u_char                buf[NGX_SOCKADDR_STRLEN];
+
+    mport->addrs = ngx_pcalloc(cf->pool,
+                               mport->naddrs * sizeof(ngx_handoff_in6_addr_t));
+    if (mport->addrs == NULL) {
+        return NGX_ERROR;
+    }
+
+    addrs6 = mport->addrs;
+
+    for (i = 0; i < mport->naddrs; i++) {
+
+        sin6 = (struct sockaddr_in6 *) addr[i].sockaddr;
+        addrs6[i].addr6 = sin6->sin6_addr;
+
+        addrs6[i].conf.ctx = addr[i].ctx;
+
+        for (j = 0; j < mport->naddrs; j++) {
+            sin6_b = (struct sockaddr_in6 *) addr[j].sockaddr;
+
+            if ((ngx_memcmp(&sin6->sin6_addr, &sin6_b->sin6_addr, 16) == 0) && 
+                    addr[j].default_ctx) {
+                addrs6[i].conf.default_ctx = addr[j].default_ctx;
+            }
+        }
+
+#if (NGX_HANDOFF_SSL)
+        addrs6[i].conf.ssl = addr[i].ssl;
+#endif
+
+#if defined(nginx_version) && nginx_version >= 1005003
+        len = ngx_sock_ntop(addr[i].sockaddr, addr[i].socklen, buf, NGX_SOCKADDR_STRLEN, 1);
+#else
+        len = ngx_sock_ntop(addr[i].sockaddr, buf, NGX_SOCKADDR_STRLEN, 1);
+#endif
+
+        p = ngx_pnalloc(cf->pool, len);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(p, buf, len);
+
+        addrs6[i].conf.addr_text.len = len;
+        addrs6[i].conf.addr_text.data = p;
+    }
+
+    return NGX_OK;
+}
+
+#endif
+
+
+static ngx_int_t
+ngx_handoff_cmp_conf_addrs(const void *one, const void *two)
+{
+    ngx_handoff_conf_addr_t  *first, *second;
+
+    first = (ngx_handoff_conf_addr_t *) one;
+    second = (ngx_handoff_conf_addr_t *) two;
+
+    if (first->wildcard) {
+        /* a wildcard must be the last resort, shift it to the end */
+        return 1;
+    }
+
+    if (first->bind && !second->bind) {
+        /* shift explicit bind()ed addresses to the start */
+        return -1;
+    }
+
+    if (!first->bind && second->bind) {
+        /* shift explicit bind()ed addresses to the start */
+        return 1;
+    }
+
+    /* do not sort by default */
+
+    return 0;
+}
diff --git a/src/handoff/ngx_handoff.h b/src/handoff/ngx_handoff.h
new file mode 100755
index 0000000..4c25d1b
--- /dev/null
+++ b/src/handoff/ngx_handoff.h
@@ -0,0 +1,281 @@
+#ifndef _NGX_HANDOFF_H_INCLUDED_
+#define _NGX_HANDOFF_H_INCLUDED_
+/*
+ * author : yubo@xiaomi.com
+ */
+
+#include <nginx.h>
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+
+
+typedef struct ngx_handoff_protocol_s  ngx_handoff_protocol_t;
+typedef struct ngx_handoff_cleanup_s  ngx_handoff_cleanup_t;
+
+typedef struct ngx_handoff_core_srv_conf_s ngx_handoff_core_srv_conf_t;
+
+
+typedef struct check_conf_s check_conf_t;
+
+/* make nginx-0.8.22+ happy */
+#if defined(nginx_version) && nginx_version >= 8022
+typedef ngx_addr_t ngx_peer_addr_t; 
+#endif
+
+#include <ngx_handoff_session.h>
+
+
+typedef struct {
+    void                  **main_conf;
+    void                  **srv_conf;
+} ngx_handoff_conf_ctx_t;
+
+
+typedef struct {
+    u_char                  sockaddr[NGX_SOCKADDRLEN];
+    socklen_t               socklen;
+
+    /* server ctx */
+    ngx_handoff_conf_ctx_t     *ctx;
+
+    unsigned                default_port:1;
+    unsigned                bind:1;
+    unsigned                wildcard:1;
+#if (NGX_HANDOFF_SSL)
+    unsigned                ssl:1;
+#endif
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+    unsigned                ipv6only:2;
+#endif
+#if (NGX_HAVE_TPROXY)
+		unsigned		    tproxy:1;
+#endif
+
+    ngx_handoff_core_srv_conf_t *conf;
+
+
+} ngx_handoff_listen_t;
+
+
+typedef struct {
+    ngx_str_t                name;
+} ngx_handoff_server_name_t;
+
+
+typedef struct {
+    ngx_uint_t               hash;
+    ngx_str_t                name;
+    ngx_handoff_listen_t        *listen;
+    ngx_handoff_conf_ctx_t      *ctx;
+
+	
+} ngx_handoff_virtual_server_t;
+
+
+
+
+typedef struct {
+    ngx_str_t                name;
+} ngx_handoff_core_loc_t;
+
+
+typedef struct {
+    ngx_handoff_conf_ctx_t      *ctx;
+    ngx_handoff_conf_ctx_t      *default_ctx;
+    ngx_str_t                addr_text;
+#if (NGX_HANDOFF_SSL)
+    ngx_uint_t               ssl;    /* unsigned   ssl:1; */
+#endif
+} ngx_handoff_addr_conf_t;
+
+typedef struct {
+    in_addr_t                addr;
+    ngx_handoff_addr_conf_t      conf;
+} ngx_handoff_in_addr_t;
+
+
+#if (NGX_HAVE_INET6)
+
+typedef struct {
+    struct in6_addr          addr6;
+    ngx_handoff_addr_conf_t      conf;
+} ngx_handoff_in6_addr_t;
+
+#endif
+
+
+typedef struct {
+    /* ngx_handoff_in_addr_t or ngx_handoff_in6_addr_t */
+    void                    *addrs;
+    ngx_uint_t               naddrs;
+    ngx_listening_t         *default_ls;    
+#if (NGX_PCRE)
+    ngx_array_t             *regex;
+#endif
+} ngx_handoff_port_t;
+
+typedef struct {
+    ngx_regex_t     *regex;
+    ngx_listening_t *ls;
+} ngx_handoff_regex_elt_t;
+
+
+typedef struct {
+    int                           family;
+    in_port_t                     port;
+    ngx_array_t                   addrs;       /* array of ngx_handoff_conf_addr_t */
+} ngx_handoff_conf_port_t;
+
+
+typedef struct {
+    struct sockaddr         *sockaddr;
+    socklen_t                socklen;
+
+    ngx_handoff_conf_ctx_t      *ctx;
+    ngx_handoff_conf_ctx_t      *default_ctx;
+
+    unsigned                 bind:1;
+    unsigned                 wildcard:1;
+#if (NGX_HANDOFF_SSL)
+    unsigned                 ssl:1;
+#endif
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+    unsigned                 ipv6only:2;
+#endif
+#if (NGX_HAVE_TPROXY)
+    unsigned                 tproxy:1;
+#endif
+} ngx_handoff_conf_addr_t;
+
+typedef struct {
+    in_addr_t                mask;
+    in_addr_t                addr;
+    ngx_uint_t               deny;      /* unsigned  deny:1; */
+} ngx_handoff_access_rule_t;
+
+typedef struct {
+    ngx_array_t              servers;         /* ngx_handoff_core_srv_conf_t */
+    ngx_array_t              listen;          /* ngx_handoff_listen_t */
+    ngx_array_t              virtual_servers; /* ngx_handoff_virtual_server_t */
+    ngx_array_t              regexs;          /* ngx_handoff_regex_t */
+} ngx_handoff_core_main_conf_t;
+
+typedef struct {
+    ngx_open_file_t         *file;
+    time_t                   disk_full_time;
+    time_t                   error_log_time;
+} ngx_handoff_log_t;
+
+typedef struct {
+    u_char                  *start;
+    u_char                  *pos;
+    u_char                  *last;
+} ngx_handoff_log_buf_t;
+
+typedef struct {
+    ngx_array_t             *logs;       /* array of ngx_handoff_log_t */
+
+    ngx_open_file_cache_t   *open_file_cache;
+    time_t                   open_file_cache_valid;
+    ngx_uint_t               open_file_cache_min_uses;
+
+    ngx_uint_t               off;        /* unsigned  off:1 */
+} ngx_handoff_log_srv_conf_t;
+
+
+#define NGX_HANDOFF_GENERIC_PROTOCOL    0
+#define NGX_HANDOFF_WEBSOCKET_PROTOCOL  1
+
+
+
+struct ngx_handoff_core_srv_conf_s {
+
+	ngx_array_t 			*regex;
+	ngx_listening_t         *default_ls;
+
+    size_t                   buffer_size;
+
+    ngx_msec_t               timeout;
+	u_char					*file_name;
+    ngx_int_t                line;
+
+
+    ngx_resolver_t          *resolver;
+
+
+    ngx_handoff_log_srv_conf_t  *access_log;
+
+    /* server ctx */
+    ngx_handoff_conf_ctx_t      *ctx;
+};
+
+
+typedef struct {
+    ngx_str_t              *client;
+    ngx_handoff_session_t      *session;
+} ngx_handoff_log_ctx_t;
+
+
+typedef void (*ngx_handoff_init_session_pt)(ngx_handoff_session_t *s);
+typedef void (*ngx_handoff_init_protocol_pt)(ngx_event_t *rev);
+typedef void (*ngx_handoff_parse_protocol_pt)(ngx_event_t *rev);
+
+
+struct ngx_handoff_protocol_s {
+    ngx_str_t                   name;
+    in_port_t                   port[4];
+    ngx_uint_t                  type;
+
+    ngx_handoff_init_session_pt     init_session;
+    ngx_handoff_init_protocol_pt    init_protocol;
+    ngx_handoff_parse_protocol_pt   parse_protocol;
+
+    ngx_str_t                   internal_server_error;
+};
+
+
+typedef struct {
+    ngx_handoff_protocol_t         *protocol;
+
+    void                       *(*create_main_conf)(ngx_conf_t *cf);
+    char                       *(*init_main_conf)(ngx_conf_t *cf, void *conf);
+
+    void                       *(*create_srv_conf)(ngx_conf_t *cf);
+    char                       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev,
+                                      void *conf);
+} ngx_handoff_module_t;
+
+
+#define NGX_HANDOFF_MODULE         0x00501007     /* "HANDOFF" */
+
+#define NGX_HANDOFF_MAIN_CONF      0x02000000
+#define NGX_HANDOFF_SRV_CONF       0x04000000
+#define NGX_HANDOFF_LOC_CONF       0x08000000
+#define NGX_HANDOFF_UPS_CONF       0x10000000
+
+
+#define NGX_HANDOFF_MAIN_CONF_OFFSET  offsetof(ngx_handoff_conf_ctx_t, main_conf)
+#define NGX_HANDOFF_SRV_CONF_OFFSET   offsetof(ngx_handoff_conf_ctx_t, srv_conf)
+
+
+#define ngx_handoff_get_module_ctx(s, module)     (s)->ctx[module.ctx_index]
+#define ngx_handoff_set_ctx(s, c, module)         s->ctx[module.ctx_index] = c;
+#define ngx_handoff_delete_ctx(s, module)         s->ctx[module.ctx_index] = NULL;
+
+
+#define ngx_handoff_get_module_main_conf(s, module)                             \
+    (s)->main_conf[module.ctx_index]
+#define ngx_handoff_get_module_srv_conf(s, module)  (s)->srv_conf[module.ctx_index]
+
+#define ngx_handoff_conf_get_module_main_conf(cf, module)                       \
+    ((ngx_handoff_conf_ctx_t *) cf->ctx)->main_conf[module.ctx_index]
+#define ngx_handoff_conf_get_module_srv_conf(cf, module)                        \
+    ((ngx_handoff_conf_ctx_t *) cf->ctx)->srv_conf[module.ctx_index]
+
+
+extern ngx_uint_t    ngx_handoff_max_module;
+extern ngx_module_t  ngx_handoff_core_module;
+
+#endif /* _NGX_HANDOFF_H_INCLUDED_ */
diff --git a/src/handoff/ngx_handoff_core_module.c b/src/handoff/ngx_handoff_core_module.c
new file mode 100755
index 0000000..c6b2648
--- /dev/null
+++ b/src/handoff/ngx_handoff_core_module.c
@@ -0,0 +1,727 @@
+/*
+ * author : yubo@xiaomi.com
+ */
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_handoff.h>
+#include <nginx.h>
+
+
+static void *ngx_handoff_core_create_main_conf(ngx_conf_t *cf);
+static void *ngx_handoff_core_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_handoff_core_merge_srv_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+static char *ngx_handoff_core_server(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_handoff_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_handoff_core_redirect(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static ngx_listening_t *ngx_handoff_find_ls(ngx_conf_t *cf, in_port_t port);
+static char *ngx_handoff_log_set_access_log(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+static ngx_command_t  ngx_handoff_core_commands[] = {
+
+    { ngx_string("server"),
+      NGX_HANDOFF_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_MULTI|NGX_CONF_NOARGS,
+      ngx_handoff_core_server,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("listen"),
+      NGX_HANDOFF_SRV_CONF|NGX_CONF_1MORE,
+      ngx_handoff_core_listen,
+      NGX_HANDOFF_SRV_CONF_OFFSET,
+      0,
+      NULL },
+    { ngx_string("redirect"),
+      NGX_HANDOFF_SRV_CONF|NGX_CONF_TAKE2,
+      ngx_handoff_core_redirect,
+      NGX_HANDOFF_SRV_CONF_OFFSET,
+      0,
+      NULL },
+    { ngx_string("timeout"),
+      NGX_HANDOFF_MAIN_CONF|NGX_HANDOFF_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HANDOFF_SRV_CONF_OFFSET,
+      offsetof(ngx_handoff_core_srv_conf_t, timeout),
+      NULL },
+    { ngx_string("access_log"),
+      NGX_HANDOFF_MAIN_CONF|NGX_HANDOFF_SRV_CONF|NGX_CONF_TAKE12,
+      ngx_handoff_log_set_access_log,
+      NGX_HANDOFF_SRV_CONF_OFFSET,
+      0,
+      NULL },
+	{ ngx_string("proxy_buffer"),
+	  NGX_HANDOFF_MAIN_CONF|NGX_HANDOFF_SRV_CONF|NGX_CONF_TAKE1,
+	  ngx_conf_set_size_slot,
+	  NGX_HANDOFF_SRV_CONF_OFFSET,
+	  offsetof(ngx_handoff_core_srv_conf_t, buffer_size),
+	  NULL },
+
+    ngx_null_command
+};
+
+
+static ngx_handoff_module_t  ngx_handoff_core_module_ctx = {
+    NULL,                                  /* protocol */
+
+    ngx_handoff_core_create_main_conf,         /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_handoff_core_create_srv_conf,          /* create server configuration */
+    ngx_handoff_core_merge_srv_conf            /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_handoff_core_module = {
+    NGX_MODULE_V1,
+    &ngx_handoff_core_module_ctx,              /* module context */
+    ngx_handoff_core_commands,                 /* module directives */
+    NGX_HANDOFF_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t  ngx_handoff_access_log = ngx_string("logs/handoff_access.log");
+
+
+static void *
+ngx_handoff_core_create_main_conf(ngx_conf_t *cf) 
+{
+    ngx_handoff_core_main_conf_t  *cmcf;
+
+    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_handoff_core_main_conf_t));
+    if (cmcf == NULL) {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cmcf->servers, cf->pool, 4,
+                       sizeof(ngx_handoff_core_srv_conf_t *))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cmcf->listen, cf->pool, 4, sizeof(ngx_handoff_listen_t))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cmcf->virtual_servers, cf->pool, 4, 
+                       sizeof(ngx_handoff_virtual_server_t)) != NGX_OK)
+    {
+        return NULL;
+    }
+
+
+
+    return cmcf;
+}
+
+
+static void *
+ngx_handoff_core_create_srv_conf(ngx_conf_t *cf) 
+{
+    ngx_handoff_core_srv_conf_t  *cscf;
+    ngx_handoff_log_srv_conf_t   *lscf;
+
+    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_handoff_core_srv_conf_t));
+    if (cscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     cscf->protocol = NULL;
+     */
+
+	cscf->regex = NGX_CONF_UNSET_PTR;
+	cscf->default_ls = NGX_CONF_UNSET_PTR;
+	
+
+
+    cscf->timeout = NGX_CONF_UNSET_MSEC;
+    cscf->buffer_size = NGX_CONF_UNSET_SIZE;
+
+    cscf->file_name = cf->conf_file->file.name.data;
+    cscf->line = cf->conf_file->line;
+
+    lscf = cscf->access_log = ngx_pcalloc(cf->pool, 
+                                          sizeof(ngx_handoff_log_srv_conf_t));
+    if (lscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     lscf->logs = NULL;
+     */
+
+    lscf->open_file_cache = NGX_CONF_UNSET_PTR;
+
+    return cscf;
+}
+
+
+static char *
+ngx_handoff_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child) 
+{
+    ngx_handoff_log_t           *log;
+    ngx_handoff_core_srv_conf_t *prev = parent;
+    ngx_handoff_core_srv_conf_t *conf = child;
+    ngx_handoff_log_srv_conf_t  *plscf = prev->access_log;
+    ngx_handoff_log_srv_conf_t  *lscf = conf->access_log;
+
+    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);
+
+
+
+    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);
+
+
+
+    if (lscf->open_file_cache == NGX_CONF_UNSET_PTR) {
+
+        lscf->open_file_cache = plscf->open_file_cache;
+        lscf->open_file_cache_valid = plscf->open_file_cache_valid;
+        lscf->open_file_cache_min_uses = plscf->open_file_cache_min_uses;
+
+        if (lscf->open_file_cache == NGX_CONF_UNSET_PTR) {
+            lscf->open_file_cache = NULL;
+        }
+    }
+
+    if (lscf->logs || lscf->off) {
+        return NGX_CONF_OK;
+    }
+
+    lscf->logs = plscf->logs;
+    lscf->off = plscf->off;
+
+    if (lscf->logs || lscf->off) {
+        return NGX_CONF_OK;
+    }
+
+    lscf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_handoff_log_t));
+    if (lscf->logs == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    log = ngx_array_push(lscf->logs);
+    if (log == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    log->file = ngx_conf_open_file(cf->cycle, &ngx_handoff_access_log);
+    if (log->file == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    log->disk_full_time = 0;
+    log->error_log_time = 0;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_handoff_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char                       *rv;
+    void                       *mconf;
+    ngx_uint_t                  m;
+    ngx_conf_t                  pcf;
+    ngx_handoff_module_t           *module;
+    ngx_handoff_conf_ctx_t         *ctx, *handoff_ctx;
+    ngx_handoff_core_srv_conf_t    *cscf, **cscfp;
+    ngx_handoff_core_main_conf_t   *cmcf;
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_handoff_conf_ctx_t));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    handoff_ctx = cf->ctx;
+    ctx->main_conf = handoff_ctx->main_conf;
+
+    /* the server{}'s srv_conf */
+
+    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_handoff_max_module);
+    if (ctx->srv_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_HANDOFF_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+
+        if (module->create_srv_conf) {
+            mconf = module->create_srv_conf(cf);
+            if (mconf == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;
+        }
+    }
+
+    /* the server configuration context */
+
+    cscf = ctx->srv_conf[ngx_handoff_core_module.ctx_index];
+    cscf->ctx = ctx;
+
+    cmcf = ctx->main_conf[ngx_handoff_core_module.ctx_index];
+
+    cscfp = ngx_array_push(&cmcf->servers);
+    if (cscfp == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *cscfp = cscf;
+
+    /* parse inside server{} */
+
+    pcf = *cf;
+    cf->ctx = ctx;
+    cf->cmd_type = NGX_HANDOFF_SRV_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    return rv;
+}
+
+
+static char *
+ngx_handoff_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    size_t                      len, off;
+    in_port_t                   port;
+    ngx_str_t                  *value;
+    ngx_url_t                   u;
+    ngx_uint_t                  i;
+    struct sockaddr            *sa;
+    ngx_handoff_listen_t       *ls;
+    struct sockaddr_in         *sin;
+    ngx_handoff_core_main_conf_t   *cmcf;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6        *sin6;
+#endif
+
+    value = cf->args->elts;
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    u.url = value[1];
+    u.listen = 1;
+
+    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+        if (u.err) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "%s in \"%V\" of the \"listen\" directive",
+                               u.err, &u.url);
+        }
+
+        return NGX_CONF_ERROR;
+    }
+
+    cmcf = ngx_handoff_conf_get_module_main_conf(cf, ngx_handoff_core_module);
+
+    ls = cmcf->listen.elts;
+
+    for (i = 0; i < cmcf->listen.nelts; i++) {
+
+        sa = (struct sockaddr *) ls[i].sockaddr;
+
+        if (sa->sa_family != u.family) {
+            continue;
+        }
+
+        switch (sa->sa_family) {
+
+#if (NGX_HAVE_INET6)
+            case AF_INET6:
+                off = offsetof(struct sockaddr_in6, sin6_addr);
+                len = 16;
+                sin6 = (struct sockaddr_in6 *) sa;
+                port = sin6->sin6_port;
+                break;
+#endif
+
+            default: /* AF_INET */
+                off = offsetof(struct sockaddr_in, sin_addr);
+                len = 4;
+                sin = (struct sockaddr_in *) sa;
+                port = sin->sin_port;
+                break;
+        }
+
+        if (ngx_memcmp(ls[i].sockaddr + off, u.sockaddr + off, len) != 0) {
+            continue;
+        }
+
+        if (port != u.port) {
+            continue;
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "duplicate \"%V\" address and port pair", &u.url);
+        return NGX_CONF_ERROR;
+    }
+
+    ls = ngx_array_push(&cmcf->listen);
+    if (ls == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memzero(ls, sizeof(ngx_handoff_listen_t));
+
+    ngx_memcpy(ls->sockaddr, u.sockaddr, u.socklen);
+
+    ls->socklen = u.socklen;
+    ls->wildcard = u.wildcard;
+    ls->ctx = cf->ctx;
+    ls->conf = conf;
+
+    for (i = 2; i < cf->args->nelts; i++) {
+		if (ngx_strcmp(value[i].data, "tproxy") == 0) {
+#if (NGX_HAVE_TPROXY)
+			ls->tproxy = 1; 
+#else
+			ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+			"TPROXY support is not enabled, ignoring option \"tproxy\" in %V",
+			&value[i]);
+#endif
+			continue;
+		}
+
+
+        if (ngx_strcmp(value[i].data, "bind") == 0) {
+            ls->bind = 1;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "default") == 0) {
+            ls->default_port = 1;
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "ipv6only=o", 10) == 0) {
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+            struct sockaddr  *sa;
+            u_char            buf[NGX_SOCKADDR_STRLEN];
+
+            sa = (struct sockaddr *) ls->sockaddr;
+
+            if (sa->sa_family == AF_INET6) {
+
+                if (ngx_strcmp(&value[i].data[10], "n") == 0) {
+                    ls->ipv6only = 1;
+
+                } else if (ngx_strcmp(&value[i].data[10], "ff") == 0) {
+                    ls->ipv6only = 2;
+
+                } else {
+                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                            "invalid ipv6only flags \"%s\"",
+                            &value[i].data[9]);
+                    return NGX_CONF_ERROR;
+                }
+
+                ls->bind = 1;
+
+            } else {
+#if defined(nginx_version) && nginx_version >= 1005003
+                len = ngx_sock_ntop(sa, ls->socklen, buf, NGX_SOCKADDR_STRLEN, 1);
+#else
+                len = ngx_sock_ntop(sa, buf, NGX_SOCKADDR_STRLEN, 1);
+#endif
+
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "ipv6only is not supported "
+                        "on addr \"%*s\", ignored", len, buf);
+            }
+
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "bind ipv6only is not supported "
+                    "on this platform");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
+        if (ngx_strcmp(value[i].data, "ssl") == 0) {
+#if (NGX_HANDOFF_SSL)
+            ls->ssl = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"ssl\" parameter requires "
+                               "ngx_handoff_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "the invalid \"%V\" parameter", &value[i]);
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+
+
+static char *
+ngx_handoff_core_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+#if (NGX_PCRE)
+
+    ngx_handoff_core_srv_conf_t *cscf = conf;
+
+    ngx_str_t                  *value;
+	ngx_handoff_regex_elt_t            *re;
+	ngx_regex_compile_t         rc;
+	int                         port;
+	ngx_listening_t            *ls;
+	u_char                      errstr[NGX_MAX_CONF_ERRSTR];
+
+    value = cf->args->elts;
+
+	//check port
+	port = ngx_atoi(value[2].data, value[2].len);
+	if (port < 1 || port > 65535) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "the invalid \"%V\" port", &value[2]);
+		return NGX_CONF_ERROR;
+	}
+
+	ls = ngx_handoff_find_ls(cf, (in_port_t)port);
+	if(ls == NULL){
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "\"%V\" port isn't listening", &value[3]);
+		return NGX_CONF_ERROR;		
+	}
+
+	// default
+	if (ngx_strcmp(value[1].data, "default") == 0) {
+		if(cscf->default_ls != NGX_CONF_UNSET_PTR){
+	        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+	                "too many redirect default");
+			return NGX_CONF_ERROR;
+		}
+		cscf->default_ls = ls;
+		return NGX_CONF_OK;
+	}
+
+	// regex add 
+	
+
+    if (cscf->regex == NGX_CONF_UNSET_PTR) {
+        cscf->regex = ngx_array_create(cf->pool, 4, sizeof(ngx_handoff_regex_elt_t));
+        if (cscf->regex == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    re = ngx_array_push(cscf->regex);
+    if (re == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+
+	ngx_memzero(&rc, sizeof(ngx_regex_compile_t));
+    rc.pattern = value[1];
+    rc.pool = cf->pool;
+    rc.err.len = NGX_MAX_CONF_ERRSTR;
+    rc.err.data = errstr;
+
+	if (ngx_regex_compile(&rc) != NGX_OK) {
+		ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &rc.err);
+		return NGX_CONF_ERROR;
+	}
+
+	re->regex = rc.regex;
+	re->ls = ls;
+
+    return NGX_CONF_OK;
+#else
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "\"%V\" requires PCRE library", &cmd->name);
+    return NGX_CONF_ERROR;
+
+#endif	
+}
+
+
+
+static ngx_listening_t *
+ngx_handoff_find_ls(ngx_conf_t *cf, in_port_t port)
+{
+	ngx_listening_t       *ls;
+	ngx_uint_t             n; 
+    struct sockaddr       *sa;
+    struct sockaddr_in    *sin;
+    in_port_t              p;
+
+	
+	ls = cf->cycle->listening.elts;
+	for (n = 0; n < cf->cycle->listening.nelts; n++){
+		sa = (struct sockaddr *) (&ls[n])->sockaddr;
+	
+		switch (sa->sa_family) {
+	
+#if (NGX_HAVE_INET6)
+		case AF_INET6:
+			return NULL;
+#endif
+	
+		default: /* AF_INET */
+			sin = (struct sockaddr_in *) sa;
+			p = ntohs(sin->sin_port);
+			break;
+		}
+		if (p == port) {
+			return &ls[n];
+		}
+	}
+	return NULL;
+}
+
+static char *
+ngx_handoff_log_set_access_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_handoff_core_srv_conf_t *cscf = conf;
+    ngx_handoff_log_srv_conf_t  *lscf = cscf->access_log;
+
+    ssize_t                     size;
+    ngx_str_t                  *value, name;
+    ngx_handoff_log_t              *log;
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+    ngx_handoff_log_buf_t         *buffer;
+#endif
+
+    value = cf->args->elts;
+
+    if (ngx_strcmp(value[1].data, "off") == 0) {
+        lscf->off = 1;
+        if (cf->args->nelts == 2) {
+            return NGX_CONF_OK;
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid parameter \"%V\"", &value[2]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (lscf->logs == NULL) {
+        lscf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_handoff_log_t));
+        if (lscf->logs == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    log = ngx_array_push(lscf->logs);
+    if (log == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memzero(log, sizeof(ngx_handoff_log_t));
+
+    log->file = ngx_conf_open_file(cf->cycle, &value[1]);
+    if (log->file == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (cf->args->nelts == 3) {
+        if (ngx_strncmp(value[2].data, "buffer=", 7) != 0) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid parameter \"%V\"", &value[2]);
+            return NGX_CONF_ERROR;
+        }
+
+        name.len = value[2].len - 7;
+        name.data = value[2].data + 7;
+
+        size = ngx_parse_size(&name);
+
+        if (size == NGX_ERROR) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid parameter \"%V\"", &value[2]);
+            return NGX_CONF_ERROR;
+        }
+
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+        if (log->file->data) {
+
+            buffer = log->file->data;
+
+            if (buffer->last - buffer->pos != size) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "access_log \"%V\" already defined "
+                        "with different buffer size", &value[1]);
+                return NGX_CONF_ERROR;
+            }
+
+            return NGX_CONF_OK;
+        }
+
+        buffer = ngx_pcalloc(cf->pool, sizeof(ngx_handoff_log_buf_t));
+        if (buffer == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        buffer->start = ngx_palloc(cf->pool, size);
+        if (buffer->start == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        buffer->pos = buffer->start;
+        buffer->last = buffer->start + size;
+
+        log->file->data = buffer;
+#else
+        if (log->file->buffer) {
+            if (log->file->last - log->file->pos != size) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "access_log \"%V\" already defined "
+                                   "with different buffer size", &value[1]);
+                return NGX_CONF_ERROR;
+            }
+
+            return NGX_CONF_OK;
+        }
+
+        log->file->buffer = ngx_palloc(cf->pool, size);
+        if (log->file->buffer == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        log->file->pos = log->file->buffer;
+        log->file->last = log->file->buffer + size;
+#endif
+    }
+
+    return NGX_CONF_OK;
+}
diff --git a/src/handoff/ngx_handoff_log.c b/src/handoff/ngx_handoff_log.c
new file mode 100755
index 0000000..e40f92f
--- /dev/null
+++ b/src/handoff/ngx_handoff_log.c
@@ -0,0 +1,226 @@
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_handoff.h>
+
+
+static u_char * ngx_handoff_time(u_char *buf, time_t t);
+static u_char *ngx_handoff_log_fill(ngx_handoff_session_t *s, u_char *buf);
+static void ngx_handoff_log_write(ngx_handoff_session_t *s, ngx_handoff_log_t *log,
+    u_char *buf, size_t len);
+
+
+ngx_int_t
+ngx_handoff_log_handler(ngx_handoff_session_t *s)
+{
+    u_char                   *line, *p;
+    size_t                    len;
+    ngx_uint_t                l;
+    ngx_connection_t         *c;
+    ngx_handoff_log_t            *log;
+    ngx_open_file_t          *file;
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+    ngx_handoff_log_buf_t        *buffer;
+#endif
+   ngx_handoff_log_srv_conf_t    *lscf;
+    ngx_handoff_core_srv_conf_t  *cscf;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "tcp access log handler");
+
+    cscf = ngx_handoff_get_module_srv_conf(s, ngx_handoff_core_module);
+    lscf = cscf->access_log;
+
+    if (lscf->off) {
+        return NGX_OK;
+    }
+
+    c = s->connection;
+    log = lscf->logs->elts;
+    for (l = 0; l < lscf->logs->nelts; l++) {
+
+        if (ngx_time() == log[l].disk_full_time) {
+
+            /*
+             * on FreeBSD writing to a full filesystem with enabled softupdates
+             * may block process for much longer time than writing to non-full
+             * filesystem, so we skip writing to a log for one second
+             */
+
+            continue;
+        }
+
+        len = 0;
+
+        /* Calculate the length */
+        len += sizeof("1970/09/28 12:00:00");   /* log time */
+        len += NGX_INT64_LEN + 2;               /* [ngx_pid] */
+        len += c->addr_text.len + 1;            /* client address */
+        len += s->addr_text->len + 1;           /* this session address */
+        len += sizeof("1970/09/28 12:00:00");   /* accept time */
+        len += sizeof("255.255.255.255:65536"); /* upstream address */
+        len += NGX_OFF_T_LEN + 1;               /* read bytes from client */
+        len += NGX_OFF_T_LEN + 1;               /* write bytes to client */
+        len += NGX_LINEFEED_SIZE;
+
+        file = log[l].file;
+
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+        if (file && file->data) {
+
+            buffer = file->data;
+
+            if (len > (size_t) (buffer->last - buffer->pos)) {
+
+                ngx_handoff_log_write(s, &log[l], buffer->start,
+                                  buffer->pos - buffer->start);
+
+                buffer->pos = buffer->start;
+            }
+
+            if (len <= (size_t) (buffer->last - buffer->pos)) {
+
+                p = buffer->pos;
+
+                p = ngx_handoff_log_fill(s, p);
+
+                buffer->pos = p;
+
+                continue;
+            }
+        }
+#else
+        if (file && file->buffer) {
+
+            if (len > (size_t) (file->last - file->pos)) {
+
+                ngx_handoff_log_write(s, &log[l], file->buffer,
+                                  file->pos - file->buffer);
+
+                file->pos = file->buffer;
+            }
+
+            if (len <= (size_t) (file->last - file->pos)) {
+
+                p = file->pos;
+
+                p = ngx_handoff_log_fill(s, p);
+
+                file->pos = p;
+
+                continue;
+            }
+        }
+#endif
+
+        line = ngx_pnalloc(s->pool, len);
+        if (line == NULL) {
+            return NGX_ERROR;
+        }
+
+        p = line;
+
+        p = ngx_handoff_log_fill(s, p);
+
+        ngx_handoff_log_write(s, &log[l], line, p - line);
+    }
+
+    return NGX_OK;
+}
+
+
+static u_char *
+ngx_handoff_time(u_char *buf, time_t t)
+{
+    ngx_tm_t    tm;
+
+    ngx_localtime(t, &tm);
+
+    return ngx_sprintf(buf, "%4d/%02d/%02d %02d:%02d:%02d",
+                       tm.ngx_tm_year, tm.ngx_tm_mon,
+                       tm.ngx_tm_mday, tm.ngx_tm_hour,
+                       tm.ngx_tm_min, tm.ngx_tm_sec);
+}
+
+
+static u_char *
+ngx_handoff_log_fill(ngx_handoff_session_t *s, u_char *buf) 
+{
+    u_char              *last;
+    ngx_str_t           *name;
+    ngx_connection_t    *c;
+
+    c = s->connection;
+
+    last = ngx_cpymem(buf, ngx_cached_err_log_time.data,
+            ngx_cached_err_log_time.len);
+
+    last = ngx_sprintf(last, " [%P]", ngx_pid);
+    last = ngx_sprintf(last, " %V", &c->addr_text);
+    last = ngx_sprintf(last, " %V ", s->addr_text);
+    last = ngx_handoff_time(last, s->start_sec);
+    
+    name = NULL;
+
+    if (name) {
+        last = ngx_sprintf(last, " %V", name);
+    }
+    else {
+        last = ngx_sprintf(last, " -");
+    }
+
+    last = ngx_sprintf(last, " %O", s->bytes_read);
+    last = ngx_sprintf(last, " %O", s->bytes_write);
+
+    ngx_linefeed(last);
+
+    return last;
+}
+
+
+static void
+ngx_handoff_log_write(ngx_handoff_session_t *s, ngx_handoff_log_t *log, u_char *buf,
+    size_t len)
+{
+    u_char     *name;
+    time_t      now;
+    ssize_t     n;
+    ngx_err_t   err;
+
+    if(len == 0) return;
+
+    name = log->file->name.data;
+    n = ngx_write_fd(log->file->fd, buf, len);
+
+    if (n == (ssize_t) len) {
+        return;
+    }
+
+    now = ngx_time();
+
+    if (n == -1) {
+        err = ngx_errno;
+
+        if (err == NGX_ENOSPC) {
+            log->disk_full_time = now;
+        }
+
+        if (now - log->error_log_time > 59) {
+            ngx_log_error(NGX_LOG_ALERT, s->connection->log, err,
+                          ngx_write_fd_n " to \"%s\" failed", name);
+
+            log->error_log_time = now;
+        }
+
+        return;
+    }
+
+    if (now - log->error_log_time > 59) {
+        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,
+                      ngx_write_fd_n " to \"%s\" was incomplete: %z of %uz",
+                      name, n, len);
+
+        log->error_log_time = now;
+    }
+}
diff --git a/src/handoff/ngx_handoff_session.c b/src/handoff/ngx_handoff_session.c
new file mode 100755
index 0000000..6824025
--- /dev/null
+++ b/src/handoff/ngx_handoff_session.c
@@ -0,0 +1,493 @@
+/*
+ * author : yubo@xiaomi.com
+ */
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_handoff.h>
+
+
+static void ngx_handoff_init_session_connection(ngx_connection_t *c);
+static void ngx_handoff_init_session(ngx_handoff_session_t *s);
+static void ngx_handoff_write_handler(ngx_event_t *wev);
+static void ngx_handoff_read_handler(ngx_event_t *rev);
+static void ngx_handoff_redirect_to(ngx_event_t *rev, ngx_listening_t *ls);
+static int ngx_handoff_redirect_regex(ngx_connection_t *c, ngx_listening_t **lsp);
+
+
+
+
+#if (NGX_HANDOFF_SSL)
+static void ngx_handoff_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);
+static void ngx_handoff_ssl_handshake_handler(ngx_connection_t *c);
+#endif
+
+
+void
+ngx_handoff_init_connection(ngx_connection_t *c)
+{
+    ngx_uint_t            i;
+    ngx_handoff_port_t       *port;
+    struct sockaddr      *sa;
+    struct sockaddr_in   *sin;
+    ngx_handoff_log_ctx_t    *ctx;
+    ngx_handoff_in_addr_t    *addr;
+    ngx_handoff_session_t    *s;
+    ngx_handoff_addr_conf_t  *addr_conf;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6  *sin6;
+    ngx_handoff_in6_addr_t   *addr6;
+#endif
+
+
+    /* find the server configuration for the address:port */
+
+    /* AF_INET only */
+
+    port = c->listening->servers;
+
+    if (port->naddrs > 1) {
+
+        /*
+         * There are several addresses on this port and one of them
+         * is the "*:port" wildcard so getsockname() is needed to determine
+         * the server address.
+         *
+         * AcceptEx() already gave this address.
+         */
+
+        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {
+            ngx_handoff_close_connection(c);
+            return;
+        }
+
+        sa = c->local_sockaddr;
+
+        switch (sa->sa_family) {
+
+#if (NGX_HAVE_INET6)
+        case AF_INET6:
+            sin6 = (struct sockaddr_in6 *) sa;
+
+            addr6 = port->addrs;
+
+            /* the last address is "*" */
+
+            for (i = 0; i < port->naddrs - 1; i++) {
+                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {
+                    break;
+                }
+            }
+
+            addr_conf = &addr6[i].conf;
+
+            break;
+#endif
+
+        default: /* AF_INET */
+            sin = (struct sockaddr_in *) sa;
+
+            addr = port->addrs;
+
+            /* the last address is "*" */
+
+            for (i = 0; i < port->naddrs - 1; i++) {
+                if (addr[i].addr == sin->sin_addr.s_addr) {
+                    break;
+                }
+            }
+
+            addr_conf = &addr[i].conf;
+
+            break;
+        }
+
+    } else {
+        switch (c->local_sockaddr->sa_family) {
+
+#if (NGX_HAVE_INET6)
+        case AF_INET6:
+            addr6 = port->addrs;
+            addr_conf = &addr6[0].conf;
+            break;
+#endif
+
+        default: /* AF_INET */
+            addr = port->addrs;
+            addr_conf = &addr[0].conf;
+            break;
+        }
+    }
+
+    s = ngx_pcalloc(c->pool, sizeof(ngx_handoff_session_t));
+    if (s == NULL) {
+        ngx_handoff_close_connection(c);
+        return;
+    }
+
+    if (addr_conf->default_ctx) {
+        s->main_conf = addr_conf->default_ctx->main_conf;
+        s->srv_conf = addr_conf->default_ctx->srv_conf;
+    }
+    else {
+        s->main_conf = addr_conf->ctx->main_conf;
+        s->srv_conf = addr_conf->ctx->srv_conf;
+    }
+
+    s->addr_text = &addr_conf->addr_text;
+
+    c->data = s;
+    s->connection = c;
+
+    ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%ui client %V connected to %V",
+                  c->number, &c->addr_text, s->addr_text);
+
+    ctx = ngx_palloc(c->pool, sizeof(ngx_handoff_log_ctx_t));
+    if (ctx == NULL) {
+        ngx_handoff_close_connection(c);
+        return;
+    }
+
+    ctx->client = &c->addr_text;
+    ctx->session = s;
+
+    c->log->connection = c->number;
+    c->log->handler = ngx_handoff_log_error;
+    c->log->data = ctx;
+    c->log->action = "nginx tcp module init connection";
+
+    c->log_error = NGX_ERROR_INFO;
+
+
+    ngx_handoff_init_session_connection(c);
+}
+
+
+
+
+
+static void
+ngx_handoff_init_session_connection(ngx_connection_t *c)
+{
+    ngx_time_t               *tp;
+    ngx_handoff_session_t        *s;
+    ngx_handoff_core_srv_conf_t  *cscf;
+
+    s = c->data;
+
+    s->signature = NGX_HANDOFF_MODULE;
+    s->pool = c->pool;
+
+    cscf = ngx_handoff_get_module_srv_conf(s, ngx_handoff_core_module);
+    if (cscf == NULL) {
+        ngx_handoff_finalize_session(s);
+        return;
+    }
+
+    s->ctx = ngx_pcalloc(s->pool, sizeof(void *) * ngx_handoff_max_module);
+    if (s->ctx == NULL) {
+        ngx_handoff_finalize_session(s);
+        return;
+    }
+
+    tp = ngx_timeofday();
+    s->start_sec = tp->sec;
+    s->start_msec = tp->msec;
+
+    s->bytes_read = 0;
+    s->bytes_write = 0;
+    ngx_handoff_init_session(s);
+}
+
+
+
+
+
+
+static void
+ngx_handoff_init_session(ngx_handoff_session_t *s)
+{
+    ngx_connection_t             *c;
+    ngx_handoff_core_srv_conf_t  *cscf;
+
+	c = s->connection;
+
+	ngx_log_debug0(NGX_LOG_DEBUG_HANDOFF, c->log, 0, "handoff init session");
+
+	cscf = ngx_handoff_get_module_srv_conf(s, ngx_handoff_core_module);
+
+    s->buffer = ngx_create_temp_buf(s->connection->pool, cscf->buffer_size);
+    if (s->buffer == NULL) {
+		ngx_handoff_close_connection(c);
+        return;
+    }
+
+	s->out.len = 0;
+
+	c->write->handler = ngx_handoff_write_handler;
+	c->read->handler = ngx_handoff_read_handler;
+
+	//timeout handle ?
+	ngx_add_timer(c->read, cscf->timeout);
+
+	if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+#if (NGX_STAT_STUB)
+		(void) ngx_atomic_fetch_add(ngx_stat_reading, -1);
+#endif
+		ngx_handoff_close_connection(c);
+		return;
+	}	
+	return;
+	
+
+}
+
+
+static void
+ngx_handoff_write_handler(ngx_event_t *wev) 
+{
+    ngx_connection_t    *c;
+
+    c = wev->data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HANDOFF, wev->log, 0,
+                   "handoff dummy write handler: %d", c->fd);
+
+	return;
+}
+
+static void
+ngx_handoff_read_handler(ngx_event_t *rev) 
+{
+    ngx_connection_t    *c;
+	int                 ret;
+	ngx_handoff_core_srv_conf_t  *cscf;
+	ngx_listening_t     *ls;
+
+    c = rev->data;
+	cscf = ngx_handoff_get_module_srv_conf((ngx_handoff_session_t *)c->data, ngx_handoff_core_module);
+	ngx_event_add_timer(rev, cscf->timeout);
+
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HANDOFF, rev->log, 0,
+                   "handoff dummy read handler: %d", c->fd);	
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out redirect to default");
+        ngx_handoff_redirect_to(rev, cscf->default_ls);
+		
+        return;
+    }
+
+	ret = ngx_handoff_redirect_regex(c, &ls);
+
+	if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+#if (NGX_STAT_STUB)
+		(void) ngx_atomic_fetch_add(ngx_stat_reading, -1);
+#endif
+		ngx_handoff_close_connection(c);
+		return;
+	}
+
+	
+	switch (ret) {
+		case NGX_ERROR:
+			ngx_handoff_close_connection(c);
+            break;
+		case NGX_REDIRECT_TO:
+			ngx_handoff_redirect_to(rev, ls);
+			break;
+		case NGX_REDIRECT_TO_DEFAULT:
+			ngx_handoff_redirect_to(rev, cscf->default_ls);
+			break;			
+		default: // NGX_REDIRECT_PAAS
+		    break;
+	}
+	return;
+
+}
+
+
+static int ngx_handoff_redirect_regex(ngx_connection_t *c, ngx_listening_t **lsp)
+{
+    ngx_handoff_session_t   *s;
+	ngx_handoff_core_srv_conf_t  *cscf;
+	ngx_uint_t                  i;
+    ssize_t                     n;
+    ngx_int_t                   ret;
+	ngx_err_t            err;
+	char                 buf[NGX_BUF_SIZE];
+    ngx_handoff_regex_elt_t  *re;
+
+    s = c->data;
+	cscf = ngx_handoff_get_module_srv_conf(s, ngx_handoff_core_module);
+
+	re = cscf->regex->elts;
+	
+	n = recv(c->fd, buf, NGX_BUF_SIZE, MSG_PEEK);
+	err = ngx_socket_errno;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err,
+			   "handoff check recv(): [%d](%s)", n, buf);
+
+	n = recv(c->fd, buf, NGX_BUF_SIZE, MSG_PEEK);
+	err = ngx_socket_errno;
+	if (n > 0 || err == NGX_EAGAIN) {
+
+		ret = NGX_REGEX_NO_MATCHED;
+		for (i = 0; i < cscf->regex->nelts; i++) {
+		
+			ret = pcre_exec(re[i].regex->code, re[i].regex->extra, \
+				(const char *) buf, (size_t)n > cscf->buffer_size ? cscf->buffer_size : (size_t)n, 0, PCRE_BSR_ANYCRLF, NULL, 0);
+			if (ret == NGX_REGEX_NO_MATCHED) {
+				continue;
+			}
+			if (ret < 0) {
+				ngx_log_error(NGX_LOG_ALERT, c->log, 0,
+							  ngx_regex_exec_n " failed: %i on \"%s\"",
+							  ret, buf);
+				break;
+			}
+		
+			/* match */
+			*lsp = re[i].ls;
+			break;
+		}
+
+		
+        if (ret == NGX_REGEX_NO_MATCHED) {
+			if (n >= (ngx_int_t)cscf->buffer_size) {
+            	return NGX_REDIRECT_TO_DEFAULT;
+			}
+			return NGX_REDIRECT_PAAS;
+        }else if (ret < 0) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HANDOFF, c->log, 0,
+                          " failed: %i on \"%s\"",
+                          n, buf);
+			return NGX_ERROR;
+        }else{  /* match */
+	        return NGX_REDIRECT_TO;
+        }
+	}
+
+    if (n == NGX_AGAIN || n == 0) {
+        return NGX_REDIRECT_PAAS;;
+    }
+
+    if (n == NGX_ERROR) {
+        return NGX_REDIRECT_TO_DEFAULT;
+    }
+
+    return NGX_REDIRECT_PAAS;
+}
+
+static void ngx_handoff_redirect_to(ngx_event_t *rev, ngx_listening_t *ls) {
+	ngx_connection_t *c;
+	ngx_handoff_session_t   *s;
+	ngx_handoff_core_srv_conf_t  *cscf;  
+
+    c = rev->data;
+    s = c->data;
+	cscf = ngx_handoff_get_module_srv_conf(s, ngx_handoff_core_module);
+
+	rev->timedout = 0;
+	ngx_event_add_timer(rev, cscf->timeout);
+	c->listening->post_accept_timeout = cscf->timeout;
+
+	c->listening = ls;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HANDOFF, c->log, 0,
+                   "handoff ngx_handoff_redirect_to: %V", &ls->addr_text);
+	c->data = NULL;
+	ls->handler(c);
+
+//    ngx_log_debug(NGX_LOG_DEBUG_HANDOFF, c->log, 0,
+//                   "handoff c->read->handler(c->read)");
+	if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+		ngx_handoff_close_connection(c);
+		return;
+	}
+}
+
+
+
+
+void 
+ngx_handoff_finalize_session(ngx_handoff_session_t *s)
+{
+    ngx_connection_t *c;
+    ngx_handoff_cleanup_t *cln;
+
+    c = s->connection;
+
+    ngx_handoff_log_handler(s);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HANDOFF, c->log, 0,
+                   "close tcp session: %d", c->fd);
+
+    for (cln = s->cleanup; cln; cln = cln->next) {
+        if (cln->handler) {
+            cln->handler(cln->data);
+            cln->handler = NULL;
+        }
+    }
+
+    ngx_handoff_close_connection(c);
+
+    return;
+}
+
+
+void
+ngx_handoff_close_connection(ngx_connection_t *c)
+{
+    ngx_pool_t  *pool;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HANDOFF, c->log, 0,
+                   "close HANDOFF connection: %d", c->fd);
+
+
+#if (NGX_STAT_STUB)
+    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
+#endif
+
+    c->destroyed = 1;
+
+    pool = c->pool;
+
+    ngx_close_connection(c);
+
+    ngx_destroy_pool(pool);
+}
+
+
+u_char *
+ngx_handoff_log_error(ngx_log_t *log, u_char *buf, size_t len)
+{
+    u_char              *p;
+    ngx_handoff_session_t   *s;
+    ngx_handoff_log_ctx_t   *ctx;
+
+    p = buf;
+
+    if (log->action) {
+        p = ngx_snprintf(p, len + (buf - p), " while %s", log->action);
+    }
+
+    ctx = log->data;
+
+    p = ngx_snprintf(p, len + (buf - p), ", client: %V", ctx->client);
+
+    s = ctx->session;
+
+    if (s == NULL) {
+        return p;
+    }
+
+    p = ngx_snprintf(p, len + (buf - p), ", server: %V", s->addr_text);
+
+
+    return p;
+}
+
+
diff --git a/src/handoff/ngx_handoff_session.h b/src/handoff/ngx_handoff_session.h
new file mode 100755
index 0000000..c0f3d43
--- /dev/null
+++ b/src/handoff/ngx_handoff_session.h
@@ -0,0 +1,72 @@
+
+#ifndef _NGX_HANDOFF_SESSION_H_INCLUDED_
+#define _NGX_HANDOFF_SESSION_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+#include <ngx_handoff.h>
+
+
+#define NGX_REDIRECT_TO          1
+#define NGX_REDIRECT_PAAS        2
+#define NGX_REDIRECT_TO_DEFAULT  3
+
+#define NGX_BUF_SIZE               10240
+
+
+
+typedef struct ngx_handoff_session_s {
+    uint32_t                signature;         /* "HANDOFF" */
+
+    ngx_pool_t             *pool;
+
+    ngx_connection_t       *connection;
+
+    ngx_str_t               out;
+    ngx_buf_t              *buffer;
+
+    void                  **ctx;
+    void                  **main_conf;
+    void                  **srv_conf;
+
+    ngx_resolver_ctx_t     *resolver_ctx;
+
+    ngx_handoff_cleanup_t  *cleanup;
+
+    time_t                  start_sec;
+    ngx_msec_t              start_msec;
+
+    off_t                   bytes_read;
+    off_t                   bytes_write;
+
+    unsigned                quit:1;
+    ngx_str_t              *addr_text;
+    ngx_str_t               host;
+
+} ngx_handoff_session_t;
+
+
+typedef void (*ngx_handoff_cleanup_pt)(void *data);
+
+
+struct ngx_handoff_cleanup_s {
+    ngx_handoff_cleanup_pt      handler;
+    void                       *data;
+    ngx_handoff_cleanup_t      *next;
+};
+
+void ngx_handoff_init_connection(ngx_connection_t *c);
+
+void ngx_handoff_close_connection(ngx_connection_t *c);
+
+u_char *ngx_handoff_log_error(ngx_log_t *log, u_char *buf, size_t len);
+
+void ngx_handoff_finalize_session(ngx_handoff_session_t *s);
+
+
+ngx_int_t ngx_handoff_log_handler(ngx_handoff_session_t *s);
+
+#endif
diff --git a/src/http/ngx_http.c b/src/http/ngx_http.c
index 3e077fb..7f7f808 100644
--- a/src/http/ngx_http.c
+++ b/src/http/ngx_http.c
@@ -1785,6 +1785,9 @@ ngx_http_add_listening(ngx_conf_t *cf, ngx_http_conf_addr_t *addr)
 #if (NGX_HAVE_SETFIB)
     ls->setfib = addr->opt.setfib;
 #endif
+#if (NGX_HAVE_TPROXY)
+    ls->tproxy = addr->opt.tproxy;
+#endif
 
     return ls;
 }
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 5bb01d9..19001a9 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -3865,6 +3865,11 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 #if (NGX_HAVE_SETFIB)
     lsopt.setfib = -1;
 #endif
+
+#if (NGX_HAVE_TPROXY)
+    lsopt.tproxy = 0; 
+#endif
+
     lsopt.wildcard = u.wildcard;
 
     (void) ngx_sock_ntop(&lsopt.u.sockaddr, lsopt.addr,
@@ -3885,6 +3890,17 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
             continue;
         }
 
+        if (ngx_strcmp(value[n].data, "tproxy") == 0) {
+#if (NGX_HAVE_TPROXY)
+            lsopt.tproxy = 1; 
+#else
+            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+            "TPROXY support is not enabled, ignoring option \"tproxy\" in %V",
+            &value[n]);
+#endif
+            continue;
+        }
+
 #if (NGX_HAVE_SETFIB)
         if (ngx_strncmp(value[n].data, "setfib=", 7) == 0) {
             lsopt.setfib = ngx_atoi(value[n].data + 7, value[n].len - 7);
diff --git a/src/http/ngx_http_core_module.h b/src/http/ngx_http_core_module.h
index e95d1e0..7bc1108 100644
--- a/src/http/ngx_http_core_module.h
+++ b/src/http/ngx_http_core_module.h
@@ -79,7 +79,9 @@ typedef struct {
     unsigned                   ipv6only:2;
 #endif
     unsigned                   so_keepalive:2;
-
+#if (NGX_HAVE_TPROXY)
+    unsigned                   tproxy:1;
+#endif
     int                        backlog;
     int                        rcvbuf;
     int                        sndbuf;
diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c
old mode 100644
new mode 100755
index e0ae524..08b8e00
--- a/src/http/ngx_http_request.c
+++ b/src/http/ngx_http_request.c
@@ -3128,14 +3128,14 @@ ngx_http_log_error(ngx_log_t *log, u_char *buf, size_t len)
     ngx_http_log_ctx_t  *ctx;
 
     if (log->action) {
-        p = ngx_snprintf(buf, len, " while %s", log->action);
+        p = ngx_snprintf(buf, len, ";ACT='%s'", log->action);
         len -= p - buf;
         buf = p;
     }
 
     ctx = log->data;
 
-    p = ngx_snprintf(buf, len, ", client: %V", &ctx->connection->addr_text);
+    p = ngx_snprintf(buf, len, ";CLI='%V'", &ctx->connection->addr_text);
     len -= p - buf;
 
     r = ctx->request;
@@ -3144,7 +3144,7 @@ ngx_http_log_error(ngx_log_t *log, u_char *buf, size_t len)
         return r->log_handler(r, ctx->current_request, p, len);
 
     } else {
-        p = ngx_snprintf(p, len, ", server: %V",
+        p = ngx_snprintf(p, len, ";SRV='%V'",
                          &ctx->connection->listening->addr_text);
     }
 
@@ -3163,9 +3163,9 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,
 
     cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
 
-    p = ngx_snprintf(buf, len, ", server: %V", &cscf->server_name);
-    len -= p - buf;
-    buf = p;
+    //p = ngx_snprintf(buf, len, ", server: %V", &cscf->server_name);
+    //len -= p - buf;
+    //buf = p;
 
     if (r->request_line.data == NULL && r->request_start) {
         for (p = r->request_start; p < r->header_in->last; p++) {
@@ -3178,14 +3178,21 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,
         r->request_line.data = r->request_start;
     }
 
+	if (r->connection->listening->addr_text.len) {
+        p = ngx_snprintf(buf, len, ";SRV='%V'", &r->connection->listening->addr_text);
+        len -= p - buf;
+        buf = p;		
+	}
+
+
     if (r->request_line.len) {
-        p = ngx_snprintf(buf, len, ", request: \"%V\"", &r->request_line);
+        p = ngx_snprintf(buf, len, ";REQUEST='%V'", &r->request_line);
         len -= p - buf;
         buf = p;
     }
 
     if (r != sr) {
-        p = ngx_snprintf(buf, len, ", subrequest: \"%V\"", &sr->uri);
+        p = ngx_snprintf(buf, len, ";SUBREQUEST'%V'", &sr->uri);
         len -= p - buf;
         buf = p;
     }
@@ -3202,7 +3209,7 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,
         }
 #endif
 
-        p = ngx_snprintf(buf, len, ", upstream: \"%V%V%s%V\"",
+        p = ngx_snprintf(buf, len, ";UPSTREAM='%V%V%s%V'",
                          &u->schema, u->peer.name,
                          uri_separator, &u->uri);
         len -= p - buf;
@@ -3210,14 +3217,14 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,
     }
 
     if (r->headers_in.host) {
-        p = ngx_snprintf(buf, len, ", host: \"%V\"",
+        p = ngx_snprintf(buf, len, ";HOST='%V'",
                          &r->headers_in.host->value);
         len -= p - buf;
         buf = p;
     }
 
     if (r->headers_in.referer) {
-        p = ngx_snprintf(buf, len, ", referrer: \"%V\"",
+        p = ngx_snprintf(buf, len, ";REFERRER='%V'",
                          &r->headers_in.referer->value);
         buf = p;
     }
diff --git a/src/http/ngx_http_upstream.c b/src/http/ngx_http_upstream.c
index 3730a20..c303bbf 100644
--- a/src/http/ngx_http_upstream.c
+++ b/src/http/ngx_http_upstream.c
@@ -1095,7 +1095,7 @@ ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)
     ngx_time_t        *tp;
     ngx_connection_t  *c;
 
-    r->connection->log->action = "connecting to upstream";
+    r->connection->log->action = "connecting to upstream [1]";
 
     r->connection->single_connection = 0;
 
@@ -1810,7 +1810,7 @@ ngx_http_upstream_test_connect(ngx_connection_t *c)
 
     if (ngx_event_flags & NGX_USE_KQUEUE_EVENT)  {
         if (c->write->pending_eof) {
-            c->log->action = "connecting to upstream";
+            c->log->action = "connecting to upstream [2]";
             (void) ngx_connection_error(c, c->write->kq_errno,
                                     "kevent() reported that connect() failed");
             return NGX_ERROR;
@@ -1834,7 +1834,7 @@ ngx_http_upstream_test_connect(ngx_connection_t *c)
         }
 
         if (err) {
-            c->log->action = "connecting to upstream";
+            c->log->action = "connecting to upstream [3]";
             (void) ngx_connection_error(c, err, "connect() failed");
             return NGX_ERROR;
         }
diff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c
index f34a6d9..a9c0c38 100644
--- a/src/http/ngx_http_variables.c
+++ b/src/http/ngx_http_variables.c
@@ -47,6 +47,12 @@ static ngx_int_t ngx_http_variable_remote_addr(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data);
 static ngx_int_t ngx_http_variable_remote_port(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data);
+#if (NGX_HAVE_TPROXY)
+static ngx_int_t ngx_http_variable_dst_addr(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data);
+static ngx_int_t ngx_http_variable_dst_port(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data);
+#endif
 static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data);
 static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r,
@@ -157,6 +163,12 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {
 
     { ngx_string("remote_port"), NULL, ngx_http_variable_remote_port, 0, 0, 0 },
 
+#if (NGX_HAVE_TPROXY)
+    { ngx_string("dst_addr"), NULL, ngx_http_variable_dst_addr, 0, 0, 0 },
+
+    { ngx_string("dst_port"), NULL, ngx_http_variable_dst_port, 0, 0, 0 },
+
+#endif
     { ngx_string("server_addr"), NULL, ngx_http_variable_server_addr, 0, 0, 0 },
 
     { ngx_string("server_port"), NULL, ngx_http_variable_server_port, 0, 0, 0 },
@@ -1084,6 +1096,84 @@ ngx_http_variable_remote_port(ngx_http_request_t *r,
     return NGX_OK;
 }
 
+#if (NGX_HAVE_TPROXY)
+static ngx_int_t
+ngx_http_variable_dst_addr(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data)
+{
+    ngx_str_t  s;
+    u_char     addr[NGX_SOCKADDR_STRLEN];
+
+    s.len = NGX_SOCKADDR_STRLEN;
+    s.data = addr;
+
+    if (ngx_connection_dst_sockaddr(r->connection, &s, 0) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    s.data = ngx_pnalloc(r->pool, s.len);
+    if (s.data == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(s.data, addr, s.len);
+
+    v->len = s.len;
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+    v->data = s.data;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_variable_dst_port(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data)
+{
+    ngx_uint_t            port;
+    struct sockaddr_in   *sin;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6  *sin6;
+#endif
+
+    v->len = 0;
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+
+    if (ngx_connection_dst_sockaddr(r->connection, NULL, 0) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    v->data = ngx_pnalloc(r->pool, sizeof("65535") - 1);
+    if (v->data == NULL) {
+        return NGX_ERROR;
+    }
+
+    switch (r->connection->dst_sockaddr->sa_family) {
+
+#if (NGX_HAVE_INET6)
+    case AF_INET6:
+        sin6 = (struct sockaddr_in6 *) r->connection->dst_sockaddr;
+        port = ntohs(sin6->sin6_port);
+        break;
+#endif
+
+    default: /* AF_INET */
+        sin = (struct sockaddr_in *) r->connection->dst_sockaddr;
+        port = ntohs(sin->sin_port);
+        break;
+    }
+
+    if (port > 0 && port < 65536) {
+        v->len = ngx_sprintf(v->data, "%ui", port) - v->data;
+    }
+
+    return NGX_OK;
+}
+#endif
 
 static ngx_int_t
 ngx_http_variable_server_addr(ngx_http_request_t *r,
diff --git a/src/tcp/README b/src/tcp/README
new file mode 100755
index 0000000..3b5a577
--- /dev/null
+++ b/src/tcp/README
@@ -0,0 +1,757 @@
+Name
+    nginx_tcp_proxy_module - support TCP proxy with Nginx
+
+Installation
+    Download the latest stable version of the release tarball of this module
+    from github (<http://github.com/yaoweibin/nginx_tcp_proxy_module>)
+
+    Grab the nginx source code from nginx.org (<http://nginx.org/>), for
+    example, the version 1.2.1 (see nginx compatibility), and then build the
+    source with this module:
+
+        $ wget 'http://nginx.org/download/nginx-1.2.1.tar.gz'
+        $ tar -xzvf nginx-1.2.1.tar.gz
+        $ cd nginx-1.2.1/
+        $ patch -p1 < /path/to/nginx_tcp_proxy_module/tcp.patch
+
+        $ ./configure --add-module=/path/to/nginx_tcp_proxy_module
+
+        $ make
+        $ make install
+
+Synopsis
+    http {
+
+        server {
+            listen 80;
+
+            location /status {
+                tcp_check_status;
+            }
+        }
+    }
+
+    #You can also include tcp_proxy.conf file individually
+
+    #include /path/to/tcp_proxy.conf;
+
+    tcp {
+
+        upstream cluster {
+            # simple round-robin
+            server 192.168.0.1:80;
+            server 192.168.0.2:80;
+
+            check interval=3000 rise=2 fall=5 timeout=1000;
+
+            #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;
+
+            #check interval=3000 rise=2 fall=5 timeout=1000 type=http;
+            #check_http_send "GET / HTTP/1.0\r\n\r\n";
+            #check_http_expect_alive http_2xx http_3xx;
+        }
+
+        server {
+            listen 8888;
+
+            proxy_pass cluster;
+        }
+    }
+
+Description
+    This module actually include many modules: ngx_tcp_module,
+    ngx_tcp_core_module, ngx_tcp_upstream_module, ngx_tcp_proxy_module,
+    ngx_tcp_websocket_module, ngx_tcp_ssl_module,
+    ngx_tcp_upstream_ip_hash_module. All these modules work together to
+    support TCP proxy with Nginx. I also added other features: ip_hash,
+    upstream server health check, status monitor.
+
+    The motivation of writing these modules is Nginx's high performance and
+    robustness. At first, I developed this module just for general TCP
+    proxy. And now, this module is frequently used in websocket reverse
+    proxying.
+
+    Note, You can't use the same listening port with HTTP modules.
+
+Directives
+  ngx_tcp_moodule
+   tcp
+    syntax: *tcp {...}*
+
+    default: *none*
+
+    context: *main*
+
+    description: All the tcp related directives are contained in the tcp
+    block.
+
+    ngx_tcp_core_moodule
+
+   server
+    syntax: *server {...}*
+
+    default: *none*
+
+    context: *tcp*
+
+    description: All the specific server directives are contained in the
+    server block.
+
+   listen
+    syntax: *listen address:port [ bind | ssl | default]*
+
+    default: *none*
+
+    context: *server*
+
+    description: The same as listen
+    (<http://wiki.nginx.org/NginxMailCoreModule#listen>). The parameter of
+    default means the default server if you have several server blocks with
+    the same port.
+
+   access_log
+    syntax: *access_log path [buffer=size] | off*
+
+    default: *access_log logs/tcp_access.log*
+
+    context: *tcp, server*
+
+    description: Set the access.log. Each record's format is like this:
+
+    log_time worker_process_pid client_ip host_ip accept_time upstream_ip
+    bytes_read bytes_write
+
+    2011/08/02 06:19:07 [5972] 127.0.0.1 0.0.0.0:1982 2011/08/02 06:18:19
+    172.19.0.129:80 80 236305
+
+    *   *log_time*: The current time when writing this log. The log action
+        is called when the proxy session is closed.
+
+    *   *worker_process_pid*: the pid of worker process
+
+    *   *client_ip*: the client ip
+
+    *   *host_ip*: the server ip and port
+
+    *   *accept_time*: the time when the server accepts client's connection
+
+    *   *upstream_ip*: the upstream server's ip
+
+    *   *bytes_read*: the bytes read from client
+
+    *   *bytes_write*: the bytes written to client
+
+   allow
+    syntax: *allow [ address | CIDR | all ]*
+
+    default: *none*
+
+    context: *server*
+
+    description: Directive grants access for the network or addresses
+    indicated.
+
+   deny
+    syntax: *deny [ address | CIDR | all ]*
+
+    default: *none*
+
+    context: *server*
+
+    description: Directive grants access for the network or addresses
+    indicated.
+
+   so_keepalive
+    syntax: *so_keepalive on|off*
+
+    default: *off*
+
+    context: *main, server*
+
+    description: The same as so_keepalive
+    (<http://wiki.nginx.org/NginxMailCoreModule#so_keepalive>).
+
+   tcp_nodelay
+    syntax: *tcp_nodelay on|off*
+
+    default: *on*
+
+    context: *main, server*
+
+    description: The same as tcp_nodelay
+    (<http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay>).
+
+   timeout
+    syntax: *timeout milliseconds*
+
+    default: *60000*
+
+    context: *main, server*
+
+    description: set the timeout value with clients.
+
+   server_name
+    syntax: *server_name name*
+
+    default: *The name of the host, obtained through gethostname()*
+
+    context: *tcp, server*
+
+    description: The same as server_name
+    (<http://wiki.nginx.org/NginxMailCoreModule#server_name>). You can
+    specify several server name in different server block with the same
+    port. They can be used in websocket module.
+
+   resolver
+    syntax: *resolver address*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    description: DNS server
+
+   resolver_timeout
+    syntax: *resolver_timeout time*
+
+    default: *30s*
+
+    context: *tcp, server*
+
+    description: Resolver timeout in seconds.
+
+  ngx_tcp_upstream_module
+   upstream
+    syntax: *upstream {...}*
+
+    default: *none*
+
+    context: *tcp*
+
+    description: All the upstream directives are contained in this block.
+    The upstream server will be dispatched with round robin by default.
+
+   server
+    syntax: *server name [parameters]*
+
+    default: *none*
+
+    context: *upstream*
+
+    description: Most of the parameters are the same as server
+    (<http://wiki.nginx.org/NginxHttpUpstreamModule#server>). Default port
+    is 80.
+
+   check
+    syntax: *check interval=milliseconds [fall=count] [rise=count]
+    [timeout=milliseconds] [type=tcp|ssl_hello|smtp|mysql|pop3|imap]*
+
+    default: *none, if parameters omitted, default parameters are
+    interval=30000 fall=5 rise=2 timeout=1000*
+
+    context: *upstream*
+
+    description: Add the health check for the upstream servers. At present,
+    the check method is a simple tcp connect.
+
+    The parameters' meanings are:
+
+    *   *interval*: the check request's interval time.
+
+    *   *fall*(fall_count): After fall_count check failures, the server is
+        marked down.
+
+    *   *rise*(rise_count): After rise_count check success, the server is
+        marked up.
+
+    *   *timeout*: the check request's timeout.
+
+    *   *type*: the check protocol type:
+
+        1.  *tcp* is a simple tcp socket connect and peek one byte.
+
+        2.  *ssl_hello* sends a client ssl hello packet and receives the
+            server ssl hello packet.
+
+        3.  *http* sends a http request packet, receives and parses the http
+            response to diagnose if the upstream server is alive.
+
+        4.  *smtp* sends a smtp request packet, receives and parses the smtp
+            response to diagnose if the upstream server is alive. The
+            response begins with '2' should be an OK response.
+
+        5.  *mysql* connects to the mysql server, receives the greeting
+            response to diagnose if the upstream server is alive.
+
+        6.  *pop3* receives and parses the pop3 response to diagnose if the
+            upstream server is alive. The response begins with '+' should be
+            an OK response.
+
+        7.  *imap* connects to the imap server, receives the greeting
+            response to diagnose if the upstream server is alive.
+
+   check_http_send
+    syntax: *check_http_send http_packet*
+
+    default: *"GET / HTTP/1.0\r\n\r\n"*
+
+    context: *upstream*
+
+    description: If you set the check type is http, then the check function
+    will sends this http packet to check the upstream server.
+
+   check_http_expect_alive
+    syntax: *check_http_expect_alive [ http_2xx | http_3xx | http_4xx |
+    http_5xx ]*
+
+    default: *http_2xx | http_3xx*
+
+    context: *upstream*
+
+    description: These status codes indicate the upstream server's http
+    response is OK, the backend is alive.
+
+   check_smtp_send
+    syntax: *check_smtp_send smtp_packet*
+
+    default: *"HELO smtp.localdomain\r\n"*
+
+    context: *upstream*
+
+    description: If you set the check type is smtp, then the check function
+    will sends this smtp packet to check the upstream server.
+
+   check_smtp_expect_alive
+    syntax: *check_smtp_expect_alive [smtp_2xx | smtp_3xx | smtp_4xx |
+    smtp_5xx]*
+
+    default: *smtp_2xx*
+
+    context: *upstream*
+
+    description: These status codes indicate the upstream server's smtp
+    response is OK, the backend is alive.
+
+   check_shm_size
+    syntax: *check_shm_size size*
+
+    default: *(number_of_checked_upstream_blocks + 1) * pagesize*
+
+    context: *tcp*
+
+    description: If you store hundreds of servers in one upstream block, the
+    shared memory for health check may be not enough, you can enlarged it by
+    this directive.
+
+   tcp_check_status
+    syntax: *tcp_check_status*
+
+    default: *none*
+
+    context: *location*
+
+    description: Display the health checking servers' status by HTTP. This
+    directive is set in the http block.
+
+    The table field meanings are:
+
+    *   *Index*: The server index in the check table
+
+    *   *Name* : The upstream server name
+
+    *   *Status*: The marked status of the server.
+
+    *   *Busyness*: The number of connections which are connecting to the
+        server.
+
+    *   *Rise counts*: Count the successful checking
+
+    *   *Fall counts*: Count the unsuccessful checking
+
+    *   *Access counts*: Count the times accessing to this server
+
+    *   *Check type*: The type of the check packet
+
+    ngx_tcp_upstream_busyness_module
+
+   busyness
+    syntax: *busyness*
+
+    default: *none*
+
+    context: *upstream*
+
+    description: the upstream server will be dispatched by backend servers'
+    busyness.
+
+    ngx_tcp_upstream_ip_hash_module
+
+   ip_hash
+    syntax: *ip_hash*
+
+    default: *none*
+
+    context: *upstream*
+
+    description: the upstream server will be dispatched by ip_hash.
+
+  ngx_tcp_proxy_module
+   proxy_pass
+    syntax: *proxy_pass host:port*
+
+    default: *none*
+
+    context: *server*
+
+    description: proxy the request to the backend server. Default port is
+    80.
+
+   proxy_buffer
+    syntax: *proxy_buffer size*
+
+    default: *4k*
+
+    context: *tcp, server*
+
+    description: set the size of proxy buffer.
+
+   proxy_connect_timeout
+    syntax: *proxy_connect_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of connection to backends.
+
+   proxy_read_timeout
+    syntax: *proxy_read_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of reading from backends.
+
+   proxy_send_timeout
+    syntax: *proxy_send_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of sending to backends.
+
+  ngx_tcp_websocket_module
+   websocket_pass
+    syntax: *websocket_pass [path] host:port*
+
+    default: *none*
+
+    context: *server*
+
+    description: proxy the websocket request to the backend server. Default
+    port is 80. You can specify several different paths in the same server
+    block.
+
+   websocket_buffer
+    syntax: *websocket_buffer size*
+
+    default: *4k*
+
+    context: *tcp, server*
+
+    description: set the size of proxy buffer.
+
+   websocket_connect_timeout
+    syntax: *websocket_connect_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of connection to backends.
+
+   websocket_read_timeout
+    syntax: *websocket_read_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of reading from backends. Your
+    timeout will be the minimum of this and the *timeout* parameter, so if
+    you want a long timeout for your websockets, make sure to set both
+    paramaters.
+
+   websocket_send_timeout
+    syntax: *websocket_send_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of sending to backends.
+
+  ngx_tcp_ssl_module
+    The default config file includes this ngx_tcp_ssl_module. If you want to
+    just compile nginx without ngx_tcp_ssl_module, copy the
+    ngx_tcp_proxy_module/config_without_ssl to ngx_tcp_proxy_module/config,
+    reconfigrure and compile nginx.
+
+   ssl
+    syntax: *ssl [on|off] *
+
+    default: *ssl off*
+
+    context: *tcp, server*
+
+    Enables SSL for a server.
+
+   ssl_certificate
+    syntax: *ssl_certificate file*
+
+    default: *ssl_certificate cert.pem*
+
+    context: *tcp, server*
+
+    This directive specifies the file containing the certificate, in PEM
+    format. This file can contain also other certificates and the server
+    private key.
+
+   ssl_certificate_key
+    syntax: *ssl_certificate_key file*
+
+    default: *ssl_certificate_key cert.pem*
+
+    context: *tcp, server*
+
+    This directive specifies the file containing the private key, in PEM
+    format.
+
+   ssl_client_certificate
+    syntax: *ssl_client_certificate file*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    This directive specifies the file containing the CA (root) certificate,
+    in PEM format, that is used for validating client certificates.
+
+   ssl_dhparam
+    syntax: *ssl_dhparam file*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    This directive specifies a file containing Diffie-Hellman key agreement
+    protocol cryptographic parameters, in PEM format, utilized for
+    exchanging session keys between server and client.
+
+   ssl_ciphers
+    syntax: *ssl_ciphers openssl_cipherlist_spec*
+
+    default: *ssl_ciphers HIGH:!aNULL:!MD5*
+
+    context: *tcp, server*
+
+    This directive describes the list of cipher suites the server supports
+    for establishing a secure connection. Cipher suites are specified in the
+    OpenSSL (<http://openssl.org/docs/apps/ciphers.html>) cipherlist format,
+    for example:
+
+    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
+
+    The complete cipherlist supported by the currently installed version of
+    OpenSSL in your platform can be obtained by issuing the command: openssl
+    ciphers
+
+   ssl_crl
+    syntax: *ssl_crl file*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    This directive specifies the filename of a Certificate Revocation List,
+    in PEM format, which is used to check the revocation status of
+    certificates.
+
+   ssl_prefer_server_ciphers
+    syntax: *ssl_prefer_server_ciphers [on|off] *
+
+    default: *ssl_prefer_server_ciphers off*
+
+    context: *tcp, server*
+
+    The server requires that the cipher suite list for protocols SSLv3 and
+    TLSv1 are to be preferred over the client supported cipher suite list.
+
+   ssl_protocols
+    syntax: *ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]*
+
+    default: *ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2*
+
+    context: *tcp, server*
+
+    This directive enables the protocol versions specified.
+
+   ssl_verify_client
+    syntax: *ssl_verify_client on|off|optional*
+
+    default: *ssl_verify_client off*
+
+    context: *tcp, server*
+
+    This directive enables the verification of the client identity.
+    Parameter 'optional' checks the client identity using its certificate in
+    case it was made available to the server.
+
+   ssl_verify_depth
+    syntax: *ssl_verify_depth number*
+
+    default: *ssl_verify_depth 1*
+
+    context: *tcp, server*
+
+    This directive sets how deep the server should go in the client provided
+    certificate chain in order to verify the client identity.
+
+   ssl_session_cache
+    syntax: *ssl_session_cache off|none|builtin:size and/or
+    shared:name:size*
+
+    default: *ssl_session_cache off*
+
+    context: *tcp, server*
+
+    The directive sets the types and sizes of caches to store the SSL
+    sessions.
+
+    The cache types are:
+
+    *   off -- Hard off: nginx says explicitly to a client that sessions can
+        not reused.
+
+    *   none -- Soft off: nginx says to a client that session can be resued,
+        but nginx actually never reuses them. This is workaround for some
+        mail clients as ssl_session_cache may be used in mail proxy as well
+        as in HTTP server.
+
+    *   builtin -- the OpenSSL builtin cache, is used inside one worker
+        process only. The cache size is assigned in the number of the
+        sessions. Note: there appears to be a memory fragmentation issue
+        using this method, please take that into consideration when using
+        this. See "References" below.
+
+    *   shared -- the cache is shared between all worker processes. The size
+        of the cache is assigned in bytes: 1 MB cache can contain roughly
+        4000 sessions. Each shared cache must be given an arbitrary name. A
+        shared cache with a given name can be used in several virtual hosts.
+
+    It's possible to use both types of cache &mdash; builtin and shared
+    &mdash; simultaneously, for example:
+
+    ssl_session_cache builtin:1000 shared:SSL:10m;
+
+    Bear in mind however, that using only shared cache, i.e., without
+    builtin, should be more effective.
+
+   ssl_session_timeout
+    syntax: *ssl_session_timeout time*
+
+    default: *ssl_session_timeout 5m*
+
+    context: *tcp, server*
+
+    This directive defines the maximum time during which the client can
+    re-use the previously negotiated cryptographic parameters of the secure
+    session that is stored in the SSL cache.
+
+Compatibility
+    *   My test bed is 0.7.65+
+
+Notes
+    The http_response_parse.rl and smtp_response_parse.rl are ragel
+    (<http://www.complang.org/ragel/>) scripts , you can edit the script and
+    compile it like this:
+
+        $ ragel -G2 http_response_parse.rl
+        $ ragel -G2 smtp_response_parse.rl
+
+TODO
+    *   refact this module, make it more extendable for adding third-party
+        modules
+
+    *   manipulate header like http module's proxy_set_header
+
+    *   built-in variable support
+
+    *   custom log format
+
+    *   syslog support
+
+    *   FTP/IRC proxying
+
+Known Issues
+    *   This module can't use the same listening port with the HTTP module.
+
+Changelogs
+  v0.2.0
+    *   add ssl proxy module
+
+    *   add websocket proxy module
+
+    *   add upstream busyness module
+
+    *   add tcp access log module
+
+  v0.19
+    *   add many check methods
+
+  v0.1
+    *   first release
+
+Authors
+    Weibin Yao(姚伟斌) *yaoweibin at gmail dot com*
+
+Copyright & License
+    This README template copy from agentzh (<http://github.com/agentzh>).
+
+    I borrowed a lot of code from upstream and mail module from the nginx
+    0.7.* core. This part of code is copyrighted by Igor Sysoev. And the
+    health check part is borrowed the design of Jack Lindamood's healthcheck
+    module healthcheck_nginx_upstreams
+    (<http://github.com/cep21/healthcheck_nginx_upstreams>);
+
+    This module is licensed under the BSD license.
+
+    Copyright (C) 2013 by Weibin Yao <yaoweibin@gmail.com>.
+
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+    *   Redistributions of source code must retain the above copyright
+        notice, this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
diff --git a/src/tcp/config b/src/tcp/config
new file mode 100755
index 0000000..b661fc9
--- /dev/null
+++ b/src/tcp/config
@@ -0,0 +1,38 @@
+ngx_feature="nginx_tcp_module"
+ngx_feature_name=
+ngx_feature_run=no
+ngx_feature_incs=
+ngx_feature_path="$ngx_addon_dir/modules $ngx_addon_dir/parsers $ngx_addon_dir"
+ngx_feature_deps="$ngx_addon_dir/ngx_tcp.h $ngx_addon_dir/ngx_tcp_session.h $ngx_addon_dir/ngx_tcp_upstream.h $ngx_addon_dir/ngx_tcp_upstream_check.h $ngx_addon_dir/ngx_tcp_upstream_round_robin.h"
+ngx_tcp_src="$ngx_addon_dir/ngx_tcp.c $ngx_addon_dir/ngx_tcp_core_module.c $ngx_addon_dir/ngx_tcp_session.c $ngx_addon_dir/ngx_tcp_access.c $ngx_addon_dir/ngx_tcp_log.c $ngx_addon_dir/ngx_tcp_upstream.c $ngx_addon_dir/ngx_tcp_upstream_round_robin.c $ngx_addon_dir/modules/ngx_tcp_generic_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_websocket_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_ip_hash_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_busyness_module.c $ngx_addon_dir/ngx_tcp_upstream_check.c "
+ngx_tcp_ssl_deps="$ngx_addon_dir/modules/ngx_tcp_ssl_module.h"
+ngx_tcp_ssl_src="$ngx_addon_dir/modules/ngx_tcp_ssl_module.c"
+ngx_tcp_parser_deps="$ngx_addon_dir/parsers/parser.h $ngx_addon_dir/parsers/http_request_parser.h $ngx_addon_dir/parsers/http_response_parser.h $ngx_addon_dir/parsers/smtp_response_parser.h"
+ngx_tcp_parser_src="$ngx_addon_dir/parsers/http_request_parser.c $ngx_addon_dir/parsers/http_response_parser.c $ngx_addon_dir/parsers/smtp_response_parser.c"
+ngx_feature_test="int a;"
+. auto/feature
+
+if [ $ngx_found = yes ]; then
+    CORE_INCS="$CORE_INCS $ngx_feature_path"
+    ngx_addon_name=ngx_tcp_module
+
+    TCP_CORE_MODULES="ngx_tcp_module ngx_tcp_core_module ngx_tcp_upstream_module"
+    TCP_MODULES="ngx_tcp_proxy_module ngx_tcp_websocket_module ngx_tcp_upstream_ip_hash_module ngx_tcp_upstream_busyness_module"
+
+    NGX_ADDON_DEPS="$NGX_ADDON_DEPS $ngx_feature_deps $ngx_tcp_parser_deps"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_tcp_src $ngx_tcp_parser_src"
+
+    have=NGX_TCP_SSL . auto/have
+    USE_OPENSSL=YES
+    TCP_MODULES="$TCP_MODULES ngx_tcp_ssl_module"
+    NGX_ADDON_DEPS="$NGX_ADDON_DEPS $ngx_tcp_ssl_deps"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_tcp_ssl_src"
+
+    EVENT_MODULES="$EVENT_MODULES $TCP_CORE_MODULES $TCP_MODULES"
+    HTTP_MODULES="$HTTP_MODULES ngx_tcp_upstream_check_status_module"
+else 
+    cat << END
+    $0: error: the ngx_tcp_module addon error.
+END
+    exit 1
+fi
diff --git a/src/tcp/config_without_ssl b/src/tcp/config_without_ssl
new file mode 100755
index 0000000..42c4a6e
--- /dev/null
+++ b/src/tcp/config_without_ssl
@@ -0,0 +1,38 @@
+ngx_feature="nginx_tcp_module"
+ngx_feature_name=
+ngx_feature_run=no
+ngx_feature_incs=
+ngx_feature_path="$ngx_addon_dir/modules $ngx_addon_dir/parsers $ngx_addon_dir"
+ngx_feature_deps="$ngx_addon_dir/ngx_tcp.h $ngx_addon_dir/ngx_tcp_session.h $ngx_addon_dir/ngx_tcp_upstream.h $ngx_addon_dir/ngx_tcp_upstream_check.h $ngx_addon_dir/ngx_tcp_upstream_round_robin.h"
+ngx_tcp_src="$ngx_addon_dir/ngx_tcp.c $ngx_addon_dir/ngx_tcp_core_module.c $ngx_addon_dir/ngx_tcp_session.c $ngx_addon_dir/ngx_tcp_access.c $ngx_addon_dir/ngx_tcp_log.c $ngx_addon_dir/ngx_tcp_upstream.c $ngx_addon_dir/ngx_tcp_upstream_round_robin.c $ngx_addon_dir/modules/ngx_tcp_generic_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_websocket_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_ip_hash_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_busyness_module.c $ngx_addon_dir/ngx_tcp_upstream_check.c "
+ngx_tcp_ssl_deps="$ngx_addon_dir/modules/ngx_tcp_ssl_module.h"
+ngx_tcp_ssl_src="$ngx_addon_dir/modules/ngx_tcp_ssl_module.c"
+ngx_tcp_parser_deps="$ngx_addon_dir/parsers/parser.h $ngx_addon_dir/parsers/http_request_parser.h $ngx_addon_dir/parsers/http_response_parser.h $ngx_addon_dir/parsers/smtp_response_parser.h"
+ngx_tcp_parser_src="$ngx_addon_dir/parsers/http_request_parser.c $ngx_addon_dir/parsers/http_response_parser.c $ngx_addon_dir/parsers/smtp_response_parser.c"
+ngx_feature_test="int a;"
+. auto/feature
+
+if [ $ngx_found = yes ]; then
+    CORE_INCS="$CORE_INCS $ngx_feature_path"
+    ngx_addon_name=ngx_tcp_module
+
+    TCP_CORE_MODULES="ngx_tcp_module ngx_tcp_core_module ngx_tcp_upstream_module"
+    TCP_MODULES="ngx_tcp_proxy_module ngx_tcp_websocket_module ngx_tcp_upstream_ip_hash_module ngx_tcp_upstream_busyness_module"
+
+    NGX_ADDON_DEPS="$NGX_ADDON_DEPS $ngx_feature_deps $ngx_tcp_parser_deps"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_tcp_src $ngx_tcp_parser_src"
+
+    #have=NGX_TCP_SSL . auto/have
+    #USE_OPENSSL=YES
+    #TCP_MODULES="$TCP_MODULES ngx_tcp_ssl_module"
+    #NGX_ADDON_DEPS="$NGX_ADDON_DEPS $ngx_tcp_ssl_deps"
+    #NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_tcp_ssl_src"
+
+    EVENT_MODULES="$EVENT_MODULES $TCP_CORE_MODULES $TCP_MODULES"
+    HTTP_MODULES="$HTTP_MODULES ngx_tcp_upstream_check_status_module"
+else 
+    cat << END
+    $0: error: the ngx_tcp_module addon error.
+END
+    exit 1
+fi
diff --git a/src/tcp/doc/README.html b/src/tcp/doc/README.html
new file mode 100755
index 0000000..34cfe30
--- /dev/null
+++ b/src/tcp/doc/README.html
@@ -0,0 +1,756 @@
+<?xml version="1.0" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>Name</title>
+<meta http-equiv="content-type" content="text/html; charset=utf-8" />
+<link rev="made" href="mailto:root@localhost" />
+</head>
+
+<body style="background-color: white">
+
+<p><a name="__index__"></a></p>
+<!-- INDEX BEGIN -->
+
+<ul>
+
+	<li><a href="#name">Name</a></li>
+	<li><a href="#installation">Installation</a></li>
+	<li><a href="#synopsis">Synopsis</a></li>
+	<li><a href="#description">Description</a></li>
+	<li><a href="#directives">Directives</a></li>
+	<ul>
+
+		<li><a href="#ngx_tcp_moodule">ngx_tcp_moodule</a></li>
+		<ul>
+
+			<li><a href="#tcp">tcp</a></li>
+			<li><a href="#server">server</a></li>
+			<li><a href="#listen">listen</a></li>
+			<li><a href="#access_log">access_log</a></li>
+			<li><a href="#allow">allow</a></li>
+			<li><a href="#deny">deny</a></li>
+			<li><a href="#so_keepalive">so_keepalive</a></li>
+			<li><a href="#tcp_nodelay">tcp_nodelay</a></li>
+			<li><a href="#timeout">timeout</a></li>
+			<li><a href="#server_name">server_name</a></li>
+			<li><a href="#resolver">resolver</a></li>
+			<li><a href="#resolver_timeout">resolver_timeout</a></li>
+		</ul>
+
+		<li><a href="#ngx_tcp_upstream_module">ngx_tcp_upstream_module</a></li>
+		<ul>
+
+			<li><a href="#upstream">upstream</a></li>
+			<li><a href="#server">server</a></li>
+			<li><a href="#check">check</a></li>
+			<li><a href="#check_http_send">check_http_send</a></li>
+			<li><a href="#check_http_expect_alive">check_http_expect_alive</a></li>
+			<li><a href="#check_smtp_send">check_smtp_send</a></li>
+			<li><a href="#check_smtp_expect_alive">check_smtp_expect_alive</a></li>
+			<li><a href="#check_shm_size">check_shm_size</a></li>
+			<li><a href="#tcp_check_status">tcp_check_status</a></li>
+			<li><a href="#busyness">busyness</a></li>
+			<li><a href="#ip_hash">ip_hash</a></li>
+		</ul>
+
+		<li><a href="#ngx_tcp_proxy_module">ngx_tcp_proxy_module</a></li>
+		<ul>
+
+			<li><a href="#proxy_pass">proxy_pass</a></li>
+			<li><a href="#proxy_buffer">proxy_buffer</a></li>
+			<li><a href="#proxy_connect_timeout">proxy_connect_timeout</a></li>
+			<li><a href="#proxy_read_timeout">proxy_read_timeout</a></li>
+			<li><a href="#proxy_send_timeout">proxy_send_timeout</a></li>
+		</ul>
+
+		<li><a href="#ngx_tcp_websocket_module">ngx_tcp_websocket_module</a></li>
+		<ul>
+
+			<li><a href="#websocket_pass">websocket_pass</a></li>
+			<li><a href="#websocket_buffer">websocket_buffer</a></li>
+			<li><a href="#websocket_connect_timeout">websocket_connect_timeout</a></li>
+			<li><a href="#websocket_read_timeout">websocket_read_timeout</a></li>
+			<li><a href="#websocket_send_timeout">websocket_send_timeout</a></li>
+		</ul>
+
+		<li><a href="#ngx_tcp_ssl_module">ngx_tcp_ssl_module</a></li>
+		<ul>
+
+			<li><a href="#ssl">ssl</a></li>
+			<li><a href="#ssl_certificate">ssl_certificate</a></li>
+			<li><a href="#ssl_certificate_key">ssl_certificate_key</a></li>
+			<li><a href="#ssl_client_certificate">ssl_client_certificate</a></li>
+			<li><a href="#ssl_dhparam">ssl_dhparam</a></li>
+			<li><a href="#ssl_ciphers">ssl_ciphers</a></li>
+			<li><a href="#ssl_crl">ssl_crl</a></li>
+			<li><a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a></li>
+			<li><a href="#ssl_protocols">ssl_protocols</a></li>
+			<li><a href="#ssl_verify_client">ssl_verify_client</a></li>
+			<li><a href="#ssl_verify_depth">ssl_verify_depth</a></li>
+			<li><a href="#ssl_session_cache">ssl_session_cache</a></li>
+			<li><a href="#ssl_session_timeout">ssl_session_timeout</a></li>
+		</ul>
+
+	</ul>
+
+	<li><a href="#compatibility">Compatibility</a></li>
+	<li><a href="#notes">Notes</a></li>
+	<li><a href="#todo">TODO</a></li>
+	<li><a href="#known_issues">Known Issues</a></li>
+	<li><a href="#changelogs">Changelogs</a></li>
+	<ul>
+
+		<li><a href="#v0_2_0">v0.2.0</a></li>
+		<li><a href="#v0_19">v0.19</a></li>
+		<li><a href="#v0_1">v0.1</a></li>
+	</ul>
+
+	<li><a href="#authors">Authors</a></li>
+	<li><a href="#copyright___license">Copyright &amp; License</a></li>
+</ul>
+<!-- INDEX END -->
+
+<hr />
+<p>
+</p>
+<hr />
+<h1><a name="name">Name</a></h1>
+<p><strong>nginx_tcp_proxy_module</strong> - support TCP proxy with Nginx</p>
+<p>
+</p>
+<hr />
+<h1><a name="installation">Installation</a></h1>
+<p>Download the latest stable version of the release tarball of this module from github (<a href="http://github.com/yaoweibin/nginx_tcp_proxy_module">http://github.com/yaoweibin/nginx_tcp_proxy_module</a>)</p>
+<p>Grab the nginx source code from nginx.org (<a href="http://nginx.org/">http://nginx.org/</a>), for example, the version 1.2.1 (see nginx compatibility), and then build the source with this module:</p>
+<pre>
+    $ wget '<a href="http://nginx.org/download/nginx-1.2.1.tar.gz">http://nginx.org/download/nginx-1.2.1.tar.gz</a>'
+    $ tar -xzvf nginx-1.2.1.tar.gz
+    $ cd nginx-1.2.1/
+    $ patch -p1 &lt; /path/to/nginx_tcp_proxy_module/tcp.patch</pre>
+<pre>
+    $ ./configure --add-module=/path/to/nginx_tcp_proxy_module</pre>
+<pre>
+    $ make
+    $ make install</pre>
+<p>
+</p>
+<hr />
+<h1><a name="synopsis">Synopsis</a></h1>
+<p>http {</p>
+<pre>
+    server {
+        listen 80;</pre>
+<pre>
+        location /status {
+            tcp_check_status;
+        }
+    }
+}</pre>
+<p>#You can also include tcp_proxy.conf file individually</p>
+<p>#include /path/to/tcp_proxy.conf;</p>
+<p>tcp {</p>
+<pre>
+    upstream cluster {
+        # simple round-robin
+        server 192.168.0.1:80;
+        server 192.168.0.2:80;</pre>
+<pre>
+        check interval=3000 rise=2 fall=5 timeout=1000;</pre>
+<pre>
+        #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;</pre>
+<pre>
+        #check interval=3000 rise=2 fall=5 timeout=1000 type=http;
+        #check_http_send &quot;GET / HTTP/1.0\r\n\r\n&quot;;
+        #check_http_expect_alive http_2xx http_3xx;
+    }</pre>
+<pre>
+    server {
+        listen 8888;</pre>
+<pre>
+        proxy_pass cluster;
+    }
+}</pre>
+<p>
+</p>
+<hr />
+<h1><a name="description">Description</a></h1>
+<p>This module actually include many modules: ngx_tcp_module, ngx_tcp_core_module, ngx_tcp_upstream_module, ngx_tcp_proxy_module, ngx_tcp_websocket_module, ngx_tcp_ssl_module, ngx_tcp_upstream_ip_hash_module. All these modules work together to support TCP proxy with Nginx. I also added other features: ip_hash, upstream server health check, status monitor.</p>
+<p>The motivation of writing these modules is Nginx's high performance and robustness. At first, I developed this module just for general TCP proxy. And now, this module is frequently used in websocket reverse proxying.</p>
+<p>Note, You can't use the same listening port with HTTP modules.</p>
+<p>
+</p>
+<hr />
+<h1><a name="directives">Directives</a></h1>
+<p>
+</p>
+<h2><a name="ngx_tcp_moodule">ngx_tcp_moodule</a></h2>
+<p>
+</p>
+<h3><a name="tcp">tcp</a></h3>
+<p><strong>syntax:</strong> <em>tcp {...}</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>main</em></p>
+<p><strong>description:</strong> All the tcp related directives are contained in the tcp block.</p>
+<p><strong>ngx_tcp_core_moodule</strong></p>
+<p>
+</p>
+<h3><a name="server">server</a></h3>
+<p><strong>syntax:</strong> <em>server {...}</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>tcp</em></p>
+<p><strong>description:</strong> All the specific server directives are contained in the server block.</p>
+<p>
+</p>
+<h3><a name="listen">listen</a></h3>
+<p><strong>syntax:</strong> <em>listen address:port [ bind | ssl | default]</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>server</em></p>
+<p><strong>description:</strong> The same as listen (<a href="http://wiki.nginx.org/NginxMailCoreModule#listen">http://wiki.nginx.org/NginxMailCoreModule#listen</a>). The parameter of default means the default server if you have several server blocks with the same port.</p>
+<p>
+</p>
+<h3><a name="access_log">access_log</a></h3>
+<p><strong>syntax:</strong> <em>access_log path [buffer=size] | off</em></p>
+<p><strong>default:</strong> <em>access_log logs/tcp_access.log</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> Set the access.log. Each record's format is like this:</p>
+<p>log_time worker_process_pid client_ip host_ip accept_time upstream_ip bytes_read bytes_write</p>
+<p>2011/08/02 06:19:07 [5972] 127.0.0.1 0.0.0.0:1982 2011/08/02 06:18:19 172.19.0.129:80 80 236305</p>
+<ul>
+<li>
+<p><em>log_time</em>: The current time when writing this log. The log action is called when the proxy session is closed.</p>
+</li>
+<li>
+<p><em>worker_process_pid</em>: the pid of worker process</p>
+</li>
+<li>
+<p><em>client_ip</em>: the client ip</p>
+</li>
+<li>
+<p><em>host_ip</em>: the server ip and port</p>
+</li>
+<li>
+<p><em>accept_time</em>: the time when the server accepts client's connection</p>
+</li>
+<li>
+<p><em>upstream_ip</em>: the upstream server's ip</p>
+</li>
+<li>
+<p><em>bytes_read</em>: the bytes read from client</p>
+</li>
+<li>
+<p><em>bytes_write</em>: the bytes written to client</p>
+</li>
+</ul>
+<p>
+</p>
+<h3><a name="allow">allow</a></h3>
+<p><strong>syntax:</strong> <em>allow [ address | CIDR | all ]</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>server</em></p>
+<p><strong>description:</strong> Directive grants access for the network or addresses indicated.</p>
+<p>
+</p>
+<h3><a name="deny">deny</a></h3>
+<p><strong>syntax:</strong> <em>deny [ address | CIDR | all ]</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>server</em></p>
+<p><strong>description:</strong> Directive grants access for the network or addresses indicated.</p>
+<p>
+</p>
+<h3><a name="so_keepalive">so_keepalive</a></h3>
+<p><strong>syntax:</strong> <em>so_keepalive on|off</em></p>
+<p><strong>default:</strong> <em>off</em></p>
+<p><strong>context:</strong> <em>main, server</em></p>
+<p><strong>description:</strong> The same as so_keepalive (<a href="http://wiki.nginx.org/NginxMailCoreModule#so_keepalive">http://wiki.nginx.org/NginxMailCoreModule#so_keepalive</a>).</p>
+<p>
+</p>
+<h3><a name="tcp_nodelay">tcp_nodelay</a></h3>
+<p><strong>syntax:</strong> <em>tcp_nodelay on|off</em></p>
+<p><strong>default:</strong> <em>on</em></p>
+<p><strong>context:</strong> <em>main, server</em></p>
+<p><strong>description:</strong> The same as tcp_nodelay (<a href="http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay">http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay</a>).</p>
+<p>
+</p>
+<h3><a name="timeout">timeout</a></h3>
+<p><strong>syntax:</strong> <em>timeout milliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>main, server</em></p>
+<p><strong>description:</strong> set the timeout value with clients.</p>
+<p>
+</p>
+<h3><a name="server_name">server_name</a></h3>
+<p><strong>syntax:</strong> <em>server_name name</em></p>
+<p><strong>default:</strong> <em>The name of the host, obtained through gethostname()</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> The same as server_name (<a href="http://wiki.nginx.org/NginxMailCoreModule#server_name">http://wiki.nginx.org/NginxMailCoreModule#server_name</a>). You can specify several server name in different server block with the same port. They can be used in websocket module.</p>
+<p>
+</p>
+<h3><a name="resolver">resolver</a></h3>
+<p><strong>syntax:</strong> <em>resolver address</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> DNS server</p>
+<p>
+</p>
+<h3><a name="resolver_timeout">resolver_timeout</a></h3>
+<p><strong>syntax:</strong> <em>resolver_timeout time</em></p>
+<p><strong>default:</strong> <em>30s</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> Resolver timeout in seconds.</p>
+<p>
+</p>
+<h2><a name="ngx_tcp_upstream_module">ngx_tcp_upstream_module</a></h2>
+<p>
+</p>
+<h3><a name="upstream">upstream</a></h3>
+<p><strong>syntax:</strong> <em>upstream {...}</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>tcp</em></p>
+<p><strong>description:</strong> All the upstream directives are contained in this  block. The upstream server will be dispatched with round robin by default.</p>
+<p>
+</p>
+<h3><a name="server">server</a></h3>
+<p><strong>syntax:</strong> <em>server name [parameters]</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> Most of the parameters are the same as server (<a href="http://wiki.nginx.org/NginxHttpUpstreamModule#server">http://wiki.nginx.org/NginxHttpUpstreamModule#server</a>). Default port is 80.</p>
+<p>
+</p>
+<h3><a name="check">check</a></h3>
+<p><strong>syntax:</strong> <em>check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [type=tcp|ssl_hello|smtp|mysql|pop3|imap]</em></p>
+<p><strong>default:</strong> <em>none, if parameters omitted, default parameters are interval=30000 fall=5 rise=2 timeout=1000</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> Add the health check for the upstream servers. At present, the check method is a simple tcp connect.</p>
+<p>The parameters' meanings are:</p>
+<ul>
+<li>
+<p><em>interval</em>: the check request's interval time.</p>
+</li>
+<li>
+<p><em>fall</em>(fall_count): After fall_count check failures, the server is marked down.</p>
+</li>
+<li>
+<p><em>rise</em>(rise_count): After rise_count check success, the server is marked up.</p>
+</li>
+<li>
+<p><em>timeout</em>: the check request's timeout.</p>
+</li>
+<li>
+<p><em>type</em>: the check protocol type:</p>
+<ol>
+<li>
+<p><em>tcp</em> is a simple tcp socket connect and peek one byte.</p>
+</li>
+<li>
+<p><em>ssl_hello</em> sends a client ssl hello packet and receives the server ssl hello packet.</p>
+</li>
+<li>
+<p><em>http</em> sends a http request packet, receives and parses the http response to diagnose if the upstream server is alive.</p>
+</li>
+<li>
+<p><em>smtp</em> sends a smtp request packet, receives and parses the smtp response to diagnose if the upstream server is alive. The response begins with '2' should be an OK response.</p>
+</li>
+<li>
+<p><em>mysql</em> connects to the mysql server, receives the greeting response to diagnose if the upstream server is alive.</p>
+</li>
+<li>
+<p><em>pop3</em> receives and parses the pop3 response to diagnose if the upstream server is alive. The response begins with '+' should be an OK response.</p>
+</li>
+<li>
+<p><em>imap</em> connects to the imap server, receives the greeting response to diagnose if the upstream server is alive.</p>
+</li>
+</ol>
+</ul>
+<p>
+</p>
+<h3><a name="check_http_send">check_http_send</a></h3>
+<p><strong>syntax:</strong> <em>check_http_send http_packet</em></p>
+<p><strong>default:</strong> <em>``GET / HTTP/1.0\r\n\r\n''</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> If you set the check type is http, then the check function will sends this http packet to check the upstream server.</p>
+<p>
+</p>
+<h3><a name="check_http_expect_alive">check_http_expect_alive</a></h3>
+<p><strong>syntax:</strong> <em>check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]</em></p>
+<p><strong>default:</strong> <em>http_2xx | http_3xx</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> These status codes indicate the upstream server's http response is OK, the backend is alive.</p>
+<p>
+</p>
+<h3><a name="check_smtp_send">check_smtp_send</a></h3>
+<p><strong>syntax:</strong> <em>check_smtp_send smtp_packet</em></p>
+<p><strong>default:</strong> <em>``HELO smtp.localdomain\r\n''</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> If you set the check type is smtp, then the check function will sends this smtp packet to check the upstream server.</p>
+<p>
+</p>
+<h3><a name="check_smtp_expect_alive">check_smtp_expect_alive</a></h3>
+<p><strong>syntax:</strong> <em>check_smtp_expect_alive [smtp_2xx | smtp_3xx | smtp_4xx | smtp_5xx]</em></p>
+<p><strong>default:</strong> <em>smtp_2xx</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> These status codes indicate the upstream server's smtp response is OK, the backend is alive.</p>
+<p>
+</p>
+<h3><a name="check_shm_size">check_shm_size</a></h3>
+<p><strong>syntax:</strong> <em>check_shm_size size</em></p>
+<p><strong>default:</strong> <em>(number_of_checked_upstream_blocks + 1) * pagesize</em></p>
+<p><strong>context:</strong> <em>tcp</em></p>
+<p><strong>description:</strong> If you store hundreds of servers in one upstream block, the shared memory for health check may be not enough, you can enlarged it by this directive.</p>
+<p>
+</p>
+<h3><a name="tcp_check_status">tcp_check_status</a></h3>
+<p><strong>syntax:</strong> <em>tcp_check_status</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>location</em></p>
+<p><strong>description:</strong> Display the health checking servers' status by HTTP. This directive is set in the http block.</p>
+<p>The table field meanings are:</p>
+<ul>
+<li>
+<p><em>Index</em>: The server index in the check table</p>
+</li>
+<li>
+<p><em>Name</em> : The upstream server name</p>
+</li>
+<li>
+<p><em>Status</em>: The marked status of the server.</p>
+</li>
+<li>
+<p><em>Busyness</em>: The number of connections which are connecting to the server.</p>
+</li>
+<li>
+<p><em>Rise counts</em>: Count the successful checking</p>
+</li>
+<li>
+<p><em>Fall counts</em>: Count the unsuccessful checking</p>
+</li>
+<li>
+<p><em>Access counts</em>: Count the times accessing to this server</p>
+</li>
+<li>
+<p><em>Check type</em>: The type of the check packet</p>
+</li>
+</ul>
+<p><strong>ngx_tcp_upstream_busyness_module</strong></p>
+<p>
+</p>
+<h3><a name="busyness">busyness</a></h3>
+<p><strong>syntax:</strong> <em>busyness</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> the upstream server will be dispatched by backend servers' busyness.</p>
+<p><strong>ngx_tcp_upstream_ip_hash_module</strong></p>
+<p>
+</p>
+<h3><a name="ip_hash">ip_hash</a></h3>
+<p><strong>syntax:</strong> <em>ip_hash</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>upstream</em></p>
+<p><strong>description:</strong> the upstream server will be dispatched by ip_hash.</p>
+<p>
+</p>
+<h2><a name="ngx_tcp_proxy_module">ngx_tcp_proxy_module</a></h2>
+<p>
+</p>
+<h3><a name="proxy_pass">proxy_pass</a></h3>
+<p><strong>syntax:</strong> <em>proxy_pass host:port</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>server</em></p>
+<p><strong>description:</strong> proxy the request to the backend server. Default port is 80.</p>
+<p>
+</p>
+<h3><a name="proxy_buffer">proxy_buffer</a></h3>
+<p><strong>syntax:</strong> <em>proxy_buffer size</em></p>
+<p><strong>default:</strong> <em>4k</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the size of proxy buffer.</p>
+<p>
+</p>
+<h3><a name="proxy_connect_timeout">proxy_connect_timeout</a></h3>
+<p><strong>syntax:</strong> <em>proxy_connect_timeout miliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the timeout value of connection to backends.</p>
+<p>
+</p>
+<h3><a name="proxy_read_timeout">proxy_read_timeout</a></h3>
+<p><strong>syntax:</strong> <em>proxy_read_timeout miliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the timeout value of reading from backends.</p>
+<p>
+</p>
+<h3><a name="proxy_send_timeout">proxy_send_timeout</a></h3>
+<p><strong>syntax:</strong> <em>proxy_send_timeout miliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the timeout value of sending to backends.</p>
+<p>
+</p>
+<h2><a name="ngx_tcp_websocket_module">ngx_tcp_websocket_module</a></h2>
+<p>
+</p>
+<h3><a name="websocket_pass">websocket_pass</a></h3>
+<p><strong>syntax:</strong> <em>websocket_pass [path] host:port</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>server</em></p>
+<p><strong>description:</strong> proxy the websocket request to the backend server. Default port is 80. You can specify several different paths in the same server block.</p>
+<p>
+</p>
+<h3><a name="websocket_buffer">websocket_buffer</a></h3>
+<p><strong>syntax:</strong> <em>websocket_buffer size</em></p>
+<p><strong>default:</strong> <em>4k</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the size of proxy buffer.</p>
+<p>
+</p>
+<h3><a name="websocket_connect_timeout">websocket_connect_timeout</a></h3>
+<p><strong>syntax:</strong> <em>websocket_connect_timeout miliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the timeout value of connection to backends.</p>
+<p>
+</p>
+<h3><a name="websocket_read_timeout">websocket_read_timeout</a></h3>
+<p><strong>syntax:</strong> <em>websocket_read_timeout miliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the timeout value of reading from backends. Your timeout will be the minimum of this and the *timeout* parameter, so if you want a long timeout for your websockets, make sure to set both paramaters.</p>
+<p>
+</p>
+<h3><a name="websocket_send_timeout">websocket_send_timeout</a></h3>
+<p><strong>syntax:</strong> <em>websocket_send_timeout miliseconds</em></p>
+<p><strong>default:</strong> <em>60000</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p><strong>description:</strong> set the timeout value of sending to backends.</p>
+<p>
+</p>
+<h2><a name="ngx_tcp_ssl_module">ngx_tcp_ssl_module</a></h2>
+<p>The default config file includes this ngx_tcp_ssl_module. If you want to just compile nginx without ngx_tcp_ssl_module, copy the ngx_tcp_proxy_module/config_without_ssl to ngx_tcp_proxy_module/config,  reconfigrure and compile nginx.</p>
+<p>
+</p>
+<h3><a name="ssl">ssl</a></h3>
+<p><strong>syntax:</strong> <em>ssl [on|off] </em></p>
+<p><strong>default:</strong> <em>ssl off</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>Enables SSL for a server.</p>
+<p>
+</p>
+<h3><a name="ssl_certificate">ssl_certificate</a></h3>
+<p><strong>syntax:</strong> <em>ssl_certificate file</em></p>
+<p><strong>default:</strong> <em>ssl_certificate cert.pem</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive specifies the file containing the certificate, in PEM format. This file can contain also other certificates and the server private key.</p>
+<p>
+</p>
+<h3><a name="ssl_certificate_key">ssl_certificate_key</a></h3>
+<p><strong>syntax:</strong> <em>ssl_certificate_key file</em></p>
+<p><strong>default:</strong> <em>ssl_certificate_key cert.pem</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive specifies the file containing the private key, in PEM format.</p>
+<p>
+</p>
+<h3><a name="ssl_client_certificate">ssl_client_certificate</a></h3>
+<p><strong>syntax:</strong> <em>ssl_client_certificate file</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive specifies the file containing the CA (root) certificate, in PEM format, that is used for validating client certificates.</p>
+<p>
+</p>
+<h3><a name="ssl_dhparam">ssl_dhparam</a></h3>
+<p><strong>syntax:</strong> <em>ssl_dhparam file</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive specifies a file containing Diffie-Hellman key agreement protocol cryptographic parameters, in PEM format, utilized for exchanging session keys between server and client.</p>
+<p>
+</p>
+<h3><a name="ssl_ciphers">ssl_ciphers</a></h3>
+<p><strong>syntax:</strong> <em>ssl_ciphers openssl_cipherlist_spec</em></p>
+<p><strong>default:</strong> <em>ssl_ciphers HIGH:!aNULL:!MD5</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive describes the list of cipher suites the server supports for establishing a secure connection. Cipher suites are specified in the OpenSSL (<a href="http://openssl.org/docs/apps/ciphers.html">http://openssl.org/docs/apps/ciphers.html</a>) cipherlist format, for example:</p>
+<p>ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</p>
+<p>The complete cipherlist supported by the currently installed version of OpenSSL in your platform can be obtained by issuing the command:
+openssl ciphers</p>
+<p>
+</p>
+<h3><a name="ssl_crl">ssl_crl</a></h3>
+<p><strong>syntax:</strong> <em>ssl_crl file</em></p>
+<p><strong>default:</strong> <em>none</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive specifies the filename of a Certificate Revocation List, in PEM format, which is used to check the revocation status of certificates.</p>
+<p>
+</p>
+<h3><a name="ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a></h3>
+<p><strong>syntax:</strong> <em>ssl_prefer_server_ciphers [on|off] </em></p>
+<p><strong>default:</strong> <em>ssl_prefer_server_ciphers off</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>The server requires that the cipher suite list for protocols SSLv3 and TLSv1 are to be preferred over the client supported cipher suite list.</p>
+<p>
+</p>
+<h3><a name="ssl_protocols">ssl_protocols</a></h3>
+<p><strong>syntax:</strong> <em>ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]</em></p>
+<p><strong>default:</strong> <em>ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive enables the protocol versions specified.</p>
+<p>
+</p>
+<h3><a name="ssl_verify_client">ssl_verify_client</a></h3>
+<p><strong>syntax:</strong> <em>ssl_verify_client on|off|optional</em></p>
+<p><strong>default:</strong> <em>ssl_verify_client off</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive enables the verification of the client identity. Parameter 'optional' checks the client identity using its certificate in case it was made available to the server.</p>
+<p>
+</p>
+<h3><a name="ssl_verify_depth">ssl_verify_depth</a></h3>
+<p><strong>syntax:</strong> <em>ssl_verify_depth number</em></p>
+<p><strong>default:</strong> <em>ssl_verify_depth 1</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive sets how deep the server should go in the client provided certificate chain in order to verify the client identity.</p>
+<p>
+</p>
+<h3><a name="ssl_session_cache">ssl_session_cache</a></h3>
+<p><strong>syntax:</strong> <em>ssl_session_cache off|none|builtin:size and/or shared:name:size</em></p>
+<p><strong>default:</strong> <em>ssl_session_cache off</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>The directive sets the types and sizes of caches to store the SSL sessions.</p>
+<p>The cache types are:</p>
+<ul>
+<li>
+<p>off -- Hard off: nginx says explicitly to a client that sessions can not reused.</p>
+</li>
+<li>
+<p>none -- Soft off: nginx says to a client that session can be resued, but nginx actually never reuses them. This is workaround for some mail clients as ssl_session_cache may be used in mail proxy as well as in HTTP server.</p>
+</li>
+<li>
+<p>builtin -- the OpenSSL builtin cache, is used inside one worker process only. The cache size is assigned in the number of the sessions. Note: there appears to be a memory fragmentation issue using this method, please take that into consideration when using this. See ``References'' below.</p>
+</li>
+<li>
+<p>shared -- the cache is shared between all worker processes. The size of the cache is assigned in bytes: 1 MB cache can contain roughly 4000 sessions. Each shared cache must be given an arbitrary name. A shared cache with a given name can be used in several virtual hosts.</p>
+</li>
+</ul>
+<p>It's possible to use both types of cache &amp;mdash; builtin and shared &amp;mdash; simultaneously, for example:</p>
+<p>ssl_session_cache  builtin:1000  shared:SSL:10m;</p>
+<p>Bear in mind however, that using only shared cache, i.e., without builtin, should be more effective.</p>
+<p>
+</p>
+<h3><a name="ssl_session_timeout">ssl_session_timeout</a></h3>
+<p><strong>syntax:</strong> <em>ssl_session_timeout time</em></p>
+<p><strong>default:</strong> <em>ssl_session_timeout 5m</em></p>
+<p><strong>context:</strong> <em>tcp, server</em></p>
+<p>This directive defines the maximum time during which the client can re-use the previously negotiated cryptographic parameters of the secure session that is stored in the SSL cache.</p>
+<p>
+</p>
+<hr />
+<h1><a name="compatibility">Compatibility</a></h1>
+<ul>
+<li>
+<p>My test bed is 0.7.65+</p>
+</li>
+</ul>
+<p>
+</p>
+<hr />
+<h1><a name="notes">Notes</a></h1>
+<p>The http_response_parse.rl and smtp_response_parse.rl are ragel (<a href="http://www.complang.org/ragel/">http://www.complang.org/ragel/</a>) scripts , you can edit the script and compile it like this:</p>
+<pre>
+    $ ragel -G2 http_response_parse.rl
+    $ ragel -G2 smtp_response_parse.rl</pre>
+<p>
+</p>
+<hr />
+<h1><a name="todo">TODO</a></h1>
+<ul>
+<li>
+<p>refact this module, make it more extendable for adding third-party modules</p>
+</li>
+<li>
+<p>manipulate header like http module's proxy_set_header</p>
+</li>
+<li>
+<p>built-in variable support</p>
+</li>
+<li>
+<p>custom log format</p>
+</li>
+<li>
+<p>syslog support</p>
+</li>
+<li>
+<p>FTP/IRC proxying</p>
+</li>
+</ul>
+<p>
+</p>
+<hr />
+<h1><a name="known_issues">Known Issues</a></h1>
+<ul>
+<li>
+<p>This module can't use the same listening port with the HTTP module.</p>
+</li>
+</ul>
+<p>
+</p>
+<hr />
+<h1><a name="changelogs">Changelogs</a></h1>
+<p>
+</p>
+<h2><a name="v0_2_0">v0.2.0</a></h2>
+<ul>
+<li>
+<p>add ssl proxy module</p>
+</li>
+<li>
+<p>add websocket proxy module</p>
+</li>
+<li>
+<p>add upstream busyness module</p>
+</li>
+<li>
+<p>add tcp access log module</p>
+</li>
+</ul>
+<p>
+</p>
+<h2><a name="v0_19">v0.19</a></h2>
+<ul>
+<li>
+<p>add many check methods</p>
+</li>
+</ul>
+<p>
+</p>
+<h2><a name="v0_1">v0.1</a></h2>
+<ul>
+<li>
+<p>first release</p>
+</li>
+</ul>
+<p>
+</p>
+<hr />
+<h1><a name="authors">Authors</a></h1>
+<p>Weibin <code>Yao(姚伟斌)</code> <em>yaoweibin at gmail dot com</em></p>
+<p>
+</p>
+<hr />
+<h1><a name="copyright___license">Copyright &amp; License</a></h1>
+<p>This README template copy from agentzh (<a href="http://github.com/agentzh">http://github.com/agentzh</a>).</p>
+<p>I borrowed a lot of code from upstream and mail module from the nginx 0.7.* core. This part of code is copyrighted by Igor Sysoev. And the health check part is borrowed the design of Jack Lindamood's healthcheck module healthcheck_nginx_upstreams (<a href="http://github.com/cep21/healthcheck_nginx_upstreams">http://github.com/cep21/healthcheck_nginx_upstreams</a>);</p>
+<p>This module is licensed under the BSD license.</p>
+<p>Copyright (C) 2013 by Weibin Yao &lt;<a href="mailto:yaoweibin@gmail.com">yaoweibin@gmail.com</a>&gt;.</p>
+<p>All rights reserved.</p>
+<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
+<ul>
+<li>
+<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
+</li>
+<li>
+<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
+</li>
+</ul>
+<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
+
+</body>
+
+</html>
diff --git a/src/tcp/doc/README.txt b/src/tcp/doc/README.txt
new file mode 100755
index 0000000..3b5a577
--- /dev/null
+++ b/src/tcp/doc/README.txt
@@ -0,0 +1,757 @@
+Name
+    nginx_tcp_proxy_module - support TCP proxy with Nginx
+
+Installation
+    Download the latest stable version of the release tarball of this module
+    from github (<http://github.com/yaoweibin/nginx_tcp_proxy_module>)
+
+    Grab the nginx source code from nginx.org (<http://nginx.org/>), for
+    example, the version 1.2.1 (see nginx compatibility), and then build the
+    source with this module:
+
+        $ wget 'http://nginx.org/download/nginx-1.2.1.tar.gz'
+        $ tar -xzvf nginx-1.2.1.tar.gz
+        $ cd nginx-1.2.1/
+        $ patch -p1 < /path/to/nginx_tcp_proxy_module/tcp.patch
+
+        $ ./configure --add-module=/path/to/nginx_tcp_proxy_module
+
+        $ make
+        $ make install
+
+Synopsis
+    http {
+
+        server {
+            listen 80;
+
+            location /status {
+                tcp_check_status;
+            }
+        }
+    }
+
+    #You can also include tcp_proxy.conf file individually
+
+    #include /path/to/tcp_proxy.conf;
+
+    tcp {
+
+        upstream cluster {
+            # simple round-robin
+            server 192.168.0.1:80;
+            server 192.168.0.2:80;
+
+            check interval=3000 rise=2 fall=5 timeout=1000;
+
+            #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;
+
+            #check interval=3000 rise=2 fall=5 timeout=1000 type=http;
+            #check_http_send "GET / HTTP/1.0\r\n\r\n";
+            #check_http_expect_alive http_2xx http_3xx;
+        }
+
+        server {
+            listen 8888;
+
+            proxy_pass cluster;
+        }
+    }
+
+Description
+    This module actually include many modules: ngx_tcp_module,
+    ngx_tcp_core_module, ngx_tcp_upstream_module, ngx_tcp_proxy_module,
+    ngx_tcp_websocket_module, ngx_tcp_ssl_module,
+    ngx_tcp_upstream_ip_hash_module. All these modules work together to
+    support TCP proxy with Nginx. I also added other features: ip_hash,
+    upstream server health check, status monitor.
+
+    The motivation of writing these modules is Nginx's high performance and
+    robustness. At first, I developed this module just for general TCP
+    proxy. And now, this module is frequently used in websocket reverse
+    proxying.
+
+    Note, You can't use the same listening port with HTTP modules.
+
+Directives
+  ngx_tcp_moodule
+   tcp
+    syntax: *tcp {...}*
+
+    default: *none*
+
+    context: *main*
+
+    description: All the tcp related directives are contained in the tcp
+    block.
+
+    ngx_tcp_core_moodule
+
+   server
+    syntax: *server {...}*
+
+    default: *none*
+
+    context: *tcp*
+
+    description: All the specific server directives are contained in the
+    server block.
+
+   listen
+    syntax: *listen address:port [ bind | ssl | default]*
+
+    default: *none*
+
+    context: *server*
+
+    description: The same as listen
+    (<http://wiki.nginx.org/NginxMailCoreModule#listen>). The parameter of
+    default means the default server if you have several server blocks with
+    the same port.
+
+   access_log
+    syntax: *access_log path [buffer=size] | off*
+
+    default: *access_log logs/tcp_access.log*
+
+    context: *tcp, server*
+
+    description: Set the access.log. Each record's format is like this:
+
+    log_time worker_process_pid client_ip host_ip accept_time upstream_ip
+    bytes_read bytes_write
+
+    2011/08/02 06:19:07 [5972] 127.0.0.1 0.0.0.0:1982 2011/08/02 06:18:19
+    172.19.0.129:80 80 236305
+
+    *   *log_time*: The current time when writing this log. The log action
+        is called when the proxy session is closed.
+
+    *   *worker_process_pid*: the pid of worker process
+
+    *   *client_ip*: the client ip
+
+    *   *host_ip*: the server ip and port
+
+    *   *accept_time*: the time when the server accepts client's connection
+
+    *   *upstream_ip*: the upstream server's ip
+
+    *   *bytes_read*: the bytes read from client
+
+    *   *bytes_write*: the bytes written to client
+
+   allow
+    syntax: *allow [ address | CIDR | all ]*
+
+    default: *none*
+
+    context: *server*
+
+    description: Directive grants access for the network or addresses
+    indicated.
+
+   deny
+    syntax: *deny [ address | CIDR | all ]*
+
+    default: *none*
+
+    context: *server*
+
+    description: Directive grants access for the network or addresses
+    indicated.
+
+   so_keepalive
+    syntax: *so_keepalive on|off*
+
+    default: *off*
+
+    context: *main, server*
+
+    description: The same as so_keepalive
+    (<http://wiki.nginx.org/NginxMailCoreModule#so_keepalive>).
+
+   tcp_nodelay
+    syntax: *tcp_nodelay on|off*
+
+    default: *on*
+
+    context: *main, server*
+
+    description: The same as tcp_nodelay
+    (<http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay>).
+
+   timeout
+    syntax: *timeout milliseconds*
+
+    default: *60000*
+
+    context: *main, server*
+
+    description: set the timeout value with clients.
+
+   server_name
+    syntax: *server_name name*
+
+    default: *The name of the host, obtained through gethostname()*
+
+    context: *tcp, server*
+
+    description: The same as server_name
+    (<http://wiki.nginx.org/NginxMailCoreModule#server_name>). You can
+    specify several server name in different server block with the same
+    port. They can be used in websocket module.
+
+   resolver
+    syntax: *resolver address*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    description: DNS server
+
+   resolver_timeout
+    syntax: *resolver_timeout time*
+
+    default: *30s*
+
+    context: *tcp, server*
+
+    description: Resolver timeout in seconds.
+
+  ngx_tcp_upstream_module
+   upstream
+    syntax: *upstream {...}*
+
+    default: *none*
+
+    context: *tcp*
+
+    description: All the upstream directives are contained in this block.
+    The upstream server will be dispatched with round robin by default.
+
+   server
+    syntax: *server name [parameters]*
+
+    default: *none*
+
+    context: *upstream*
+
+    description: Most of the parameters are the same as server
+    (<http://wiki.nginx.org/NginxHttpUpstreamModule#server>). Default port
+    is 80.
+
+   check
+    syntax: *check interval=milliseconds [fall=count] [rise=count]
+    [timeout=milliseconds] [type=tcp|ssl_hello|smtp|mysql|pop3|imap]*
+
+    default: *none, if parameters omitted, default parameters are
+    interval=30000 fall=5 rise=2 timeout=1000*
+
+    context: *upstream*
+
+    description: Add the health check for the upstream servers. At present,
+    the check method is a simple tcp connect.
+
+    The parameters' meanings are:
+
+    *   *interval*: the check request's interval time.
+
+    *   *fall*(fall_count): After fall_count check failures, the server is
+        marked down.
+
+    *   *rise*(rise_count): After rise_count check success, the server is
+        marked up.
+
+    *   *timeout*: the check request's timeout.
+
+    *   *type*: the check protocol type:
+
+        1.  *tcp* is a simple tcp socket connect and peek one byte.
+
+        2.  *ssl_hello* sends a client ssl hello packet and receives the
+            server ssl hello packet.
+
+        3.  *http* sends a http request packet, receives and parses the http
+            response to diagnose if the upstream server is alive.
+
+        4.  *smtp* sends a smtp request packet, receives and parses the smtp
+            response to diagnose if the upstream server is alive. The
+            response begins with '2' should be an OK response.
+
+        5.  *mysql* connects to the mysql server, receives the greeting
+            response to diagnose if the upstream server is alive.
+
+        6.  *pop3* receives and parses the pop3 response to diagnose if the
+            upstream server is alive. The response begins with '+' should be
+            an OK response.
+
+        7.  *imap* connects to the imap server, receives the greeting
+            response to diagnose if the upstream server is alive.
+
+   check_http_send
+    syntax: *check_http_send http_packet*
+
+    default: *"GET / HTTP/1.0\r\n\r\n"*
+
+    context: *upstream*
+
+    description: If you set the check type is http, then the check function
+    will sends this http packet to check the upstream server.
+
+   check_http_expect_alive
+    syntax: *check_http_expect_alive [ http_2xx | http_3xx | http_4xx |
+    http_5xx ]*
+
+    default: *http_2xx | http_3xx*
+
+    context: *upstream*
+
+    description: These status codes indicate the upstream server's http
+    response is OK, the backend is alive.
+
+   check_smtp_send
+    syntax: *check_smtp_send smtp_packet*
+
+    default: *"HELO smtp.localdomain\r\n"*
+
+    context: *upstream*
+
+    description: If you set the check type is smtp, then the check function
+    will sends this smtp packet to check the upstream server.
+
+   check_smtp_expect_alive
+    syntax: *check_smtp_expect_alive [smtp_2xx | smtp_3xx | smtp_4xx |
+    smtp_5xx]*
+
+    default: *smtp_2xx*
+
+    context: *upstream*
+
+    description: These status codes indicate the upstream server's smtp
+    response is OK, the backend is alive.
+
+   check_shm_size
+    syntax: *check_shm_size size*
+
+    default: *(number_of_checked_upstream_blocks + 1) * pagesize*
+
+    context: *tcp*
+
+    description: If you store hundreds of servers in one upstream block, the
+    shared memory for health check may be not enough, you can enlarged it by
+    this directive.
+
+   tcp_check_status
+    syntax: *tcp_check_status*
+
+    default: *none*
+
+    context: *location*
+
+    description: Display the health checking servers' status by HTTP. This
+    directive is set in the http block.
+
+    The table field meanings are:
+
+    *   *Index*: The server index in the check table
+
+    *   *Name* : The upstream server name
+
+    *   *Status*: The marked status of the server.
+
+    *   *Busyness*: The number of connections which are connecting to the
+        server.
+
+    *   *Rise counts*: Count the successful checking
+
+    *   *Fall counts*: Count the unsuccessful checking
+
+    *   *Access counts*: Count the times accessing to this server
+
+    *   *Check type*: The type of the check packet
+
+    ngx_tcp_upstream_busyness_module
+
+   busyness
+    syntax: *busyness*
+
+    default: *none*
+
+    context: *upstream*
+
+    description: the upstream server will be dispatched by backend servers'
+    busyness.
+
+    ngx_tcp_upstream_ip_hash_module
+
+   ip_hash
+    syntax: *ip_hash*
+
+    default: *none*
+
+    context: *upstream*
+
+    description: the upstream server will be dispatched by ip_hash.
+
+  ngx_tcp_proxy_module
+   proxy_pass
+    syntax: *proxy_pass host:port*
+
+    default: *none*
+
+    context: *server*
+
+    description: proxy the request to the backend server. Default port is
+    80.
+
+   proxy_buffer
+    syntax: *proxy_buffer size*
+
+    default: *4k*
+
+    context: *tcp, server*
+
+    description: set the size of proxy buffer.
+
+   proxy_connect_timeout
+    syntax: *proxy_connect_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of connection to backends.
+
+   proxy_read_timeout
+    syntax: *proxy_read_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of reading from backends.
+
+   proxy_send_timeout
+    syntax: *proxy_send_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of sending to backends.
+
+  ngx_tcp_websocket_module
+   websocket_pass
+    syntax: *websocket_pass [path] host:port*
+
+    default: *none*
+
+    context: *server*
+
+    description: proxy the websocket request to the backend server. Default
+    port is 80. You can specify several different paths in the same server
+    block.
+
+   websocket_buffer
+    syntax: *websocket_buffer size*
+
+    default: *4k*
+
+    context: *tcp, server*
+
+    description: set the size of proxy buffer.
+
+   websocket_connect_timeout
+    syntax: *websocket_connect_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of connection to backends.
+
+   websocket_read_timeout
+    syntax: *websocket_read_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of reading from backends. Your
+    timeout will be the minimum of this and the *timeout* parameter, so if
+    you want a long timeout for your websockets, make sure to set both
+    paramaters.
+
+   websocket_send_timeout
+    syntax: *websocket_send_timeout miliseconds*
+
+    default: *60000*
+
+    context: *tcp, server*
+
+    description: set the timeout value of sending to backends.
+
+  ngx_tcp_ssl_module
+    The default config file includes this ngx_tcp_ssl_module. If you want to
+    just compile nginx without ngx_tcp_ssl_module, copy the
+    ngx_tcp_proxy_module/config_without_ssl to ngx_tcp_proxy_module/config,
+    reconfigrure and compile nginx.
+
+   ssl
+    syntax: *ssl [on|off] *
+
+    default: *ssl off*
+
+    context: *tcp, server*
+
+    Enables SSL for a server.
+
+   ssl_certificate
+    syntax: *ssl_certificate file*
+
+    default: *ssl_certificate cert.pem*
+
+    context: *tcp, server*
+
+    This directive specifies the file containing the certificate, in PEM
+    format. This file can contain also other certificates and the server
+    private key.
+
+   ssl_certificate_key
+    syntax: *ssl_certificate_key file*
+
+    default: *ssl_certificate_key cert.pem*
+
+    context: *tcp, server*
+
+    This directive specifies the file containing the private key, in PEM
+    format.
+
+   ssl_client_certificate
+    syntax: *ssl_client_certificate file*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    This directive specifies the file containing the CA (root) certificate,
+    in PEM format, that is used for validating client certificates.
+
+   ssl_dhparam
+    syntax: *ssl_dhparam file*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    This directive specifies a file containing Diffie-Hellman key agreement
+    protocol cryptographic parameters, in PEM format, utilized for
+    exchanging session keys between server and client.
+
+   ssl_ciphers
+    syntax: *ssl_ciphers openssl_cipherlist_spec*
+
+    default: *ssl_ciphers HIGH:!aNULL:!MD5*
+
+    context: *tcp, server*
+
+    This directive describes the list of cipher suites the server supports
+    for establishing a secure connection. Cipher suites are specified in the
+    OpenSSL (<http://openssl.org/docs/apps/ciphers.html>) cipherlist format,
+    for example:
+
+    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
+
+    The complete cipherlist supported by the currently installed version of
+    OpenSSL in your platform can be obtained by issuing the command: openssl
+    ciphers
+
+   ssl_crl
+    syntax: *ssl_crl file*
+
+    default: *none*
+
+    context: *tcp, server*
+
+    This directive specifies the filename of a Certificate Revocation List,
+    in PEM format, which is used to check the revocation status of
+    certificates.
+
+   ssl_prefer_server_ciphers
+    syntax: *ssl_prefer_server_ciphers [on|off] *
+
+    default: *ssl_prefer_server_ciphers off*
+
+    context: *tcp, server*
+
+    The server requires that the cipher suite list for protocols SSLv3 and
+    TLSv1 are to be preferred over the client supported cipher suite list.
+
+   ssl_protocols
+    syntax: *ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]*
+
+    default: *ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2*
+
+    context: *tcp, server*
+
+    This directive enables the protocol versions specified.
+
+   ssl_verify_client
+    syntax: *ssl_verify_client on|off|optional*
+
+    default: *ssl_verify_client off*
+
+    context: *tcp, server*
+
+    This directive enables the verification of the client identity.
+    Parameter 'optional' checks the client identity using its certificate in
+    case it was made available to the server.
+
+   ssl_verify_depth
+    syntax: *ssl_verify_depth number*
+
+    default: *ssl_verify_depth 1*
+
+    context: *tcp, server*
+
+    This directive sets how deep the server should go in the client provided
+    certificate chain in order to verify the client identity.
+
+   ssl_session_cache
+    syntax: *ssl_session_cache off|none|builtin:size and/or
+    shared:name:size*
+
+    default: *ssl_session_cache off*
+
+    context: *tcp, server*
+
+    The directive sets the types and sizes of caches to store the SSL
+    sessions.
+
+    The cache types are:
+
+    *   off -- Hard off: nginx says explicitly to a client that sessions can
+        not reused.
+
+    *   none -- Soft off: nginx says to a client that session can be resued,
+        but nginx actually never reuses them. This is workaround for some
+        mail clients as ssl_session_cache may be used in mail proxy as well
+        as in HTTP server.
+
+    *   builtin -- the OpenSSL builtin cache, is used inside one worker
+        process only. The cache size is assigned in the number of the
+        sessions. Note: there appears to be a memory fragmentation issue
+        using this method, please take that into consideration when using
+        this. See "References" below.
+
+    *   shared -- the cache is shared between all worker processes. The size
+        of the cache is assigned in bytes: 1 MB cache can contain roughly
+        4000 sessions. Each shared cache must be given an arbitrary name. A
+        shared cache with a given name can be used in several virtual hosts.
+
+    It's possible to use both types of cache &mdash; builtin and shared
+    &mdash; simultaneously, for example:
+
+    ssl_session_cache builtin:1000 shared:SSL:10m;
+
+    Bear in mind however, that using only shared cache, i.e., without
+    builtin, should be more effective.
+
+   ssl_session_timeout
+    syntax: *ssl_session_timeout time*
+
+    default: *ssl_session_timeout 5m*
+
+    context: *tcp, server*
+
+    This directive defines the maximum time during which the client can
+    re-use the previously negotiated cryptographic parameters of the secure
+    session that is stored in the SSL cache.
+
+Compatibility
+    *   My test bed is 0.7.65+
+
+Notes
+    The http_response_parse.rl and smtp_response_parse.rl are ragel
+    (<http://www.complang.org/ragel/>) scripts , you can edit the script and
+    compile it like this:
+
+        $ ragel -G2 http_response_parse.rl
+        $ ragel -G2 smtp_response_parse.rl
+
+TODO
+    *   refact this module, make it more extendable for adding third-party
+        modules
+
+    *   manipulate header like http module's proxy_set_header
+
+    *   built-in variable support
+
+    *   custom log format
+
+    *   syslog support
+
+    *   FTP/IRC proxying
+
+Known Issues
+    *   This module can't use the same listening port with the HTTP module.
+
+Changelogs
+  v0.2.0
+    *   add ssl proxy module
+
+    *   add websocket proxy module
+
+    *   add upstream busyness module
+
+    *   add tcp access log module
+
+  v0.19
+    *   add many check methods
+
+  v0.1
+    *   first release
+
+Authors
+    Weibin Yao(姚伟斌) *yaoweibin at gmail dot com*
+
+Copyright & License
+    This README template copy from agentzh (<http://github.com/agentzh>).
+
+    I borrowed a lot of code from upstream and mail module from the nginx
+    0.7.* core. This part of code is copyrighted by Igor Sysoev. And the
+    health check part is borrowed the design of Jack Lindamood's healthcheck
+    module healthcheck_nginx_upstreams
+    (<http://github.com/cep21/healthcheck_nginx_upstreams>);
+
+    This module is licensed under the BSD license.
+
+    Copyright (C) 2013 by Weibin Yao <yaoweibin@gmail.com>.
+
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+    *   Redistributions of source code must retain the above copyright
+        notice, this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
diff --git a/src/tcp/doc/README.wiki b/src/tcp/doc/README.wiki
new file mode 100755
index 0000000..546c329
--- /dev/null
+++ b/src/tcp/doc/README.wiki
@@ -0,0 +1,694 @@
+﻿﻿= Name =
+
+'''nginx_tcp_proxy_module''' - support TCP proxy with Nginx
+
+= Installation =
+
+Download the latest stable version of the release tarball of this module from [http://github.com/yaoweibin/nginx_tcp_proxy_module github]
+
+Grab the nginx source code from [http://nginx.org/ nginx.org], for example, the version 1.2.1 (see nginx compatibility), and then build the source with this module:
+
+<geshi lang="bash">
+    $ wget 'http://nginx.org/download/nginx-1.2.1.tar.gz'
+    $ tar -xzvf nginx-1.2.1.tar.gz
+    $ cd nginx-1.2.1/
+    $ patch -p1 < /path/to/nginx_tcp_proxy_module/tcp.patch
+
+    $ ./configure --add-module=/path/to/nginx_tcp_proxy_module
+
+    $ make
+    $ make install
+</geshi>
+    
+
+= Synopsis =
+
+<geshi lang="nginx">
+http {
+
+    server {
+        listen 80;
+
+        location /status {
+            tcp_check_status;
+        }
+    }
+}
+</geshi>
+
+<geshi lang="nginx">
+
+#You can also include tcp_proxy.conf file individually
+
+#include /path/to/tcp_proxy.conf;
+
+tcp {
+
+    upstream cluster {
+        # simple round-robin
+        server 192.168.0.1:80;
+        server 192.168.0.2:80;
+
+        check interval=3000 rise=2 fall=5 timeout=1000;
+
+        #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;
+
+        #check interval=3000 rise=2 fall=5 timeout=1000 type=http;
+        #check_http_send "GET / HTTP/1.0\r\n\r\n";
+        #check_http_expect_alive http_2xx http_3xx;
+    }
+
+    server {
+        listen 8888;
+
+        proxy_pass cluster;
+    }
+}
+</geshi>
+
+= Description =
+
+This module actually include many modules: ngx_tcp_module, ngx_tcp_core_module, ngx_tcp_upstream_module, ngx_tcp_proxy_module, ngx_tcp_websocket_module, ngx_tcp_ssl_module, ngx_tcp_upstream_ip_hash_module. All these modules work together to support TCP proxy with Nginx. I also added other features: ip_hash, upstream server health check, status monitor.
+
+The motivation of writing these modules is Nginx's high performance and robustness. At first, I developed this module just for general TCP proxy. And now, this module is frequently used in websocket reverse proxying. 
+
+Note, You can't use the same listening port with HTTP modules. 
+
+= Directives =
+
+== ngx_tcp_moodule ==
+
+=== tcp ===
+
+'''syntax:''' ''tcp {...}''
+
+'''default:''' ''none''
+
+'''context:''' ''main''
+
+'''description:''' All the tcp related directives are contained in the tcp block.
+
+
+'''ngx_tcp_core_moodule'''
+
+=== server ===
+
+'''syntax:''' ''server {...}''
+
+'''default:''' ''none''
+
+'''context:''' ''tcp''
+
+'''description:''' All the specific server directives are contained in the server block.
+
+=== listen ===
+
+'''syntax:''' ''listen address:port [ bind | ssl | default]''
+
+'''default:''' ''none''
+
+'''context:''' ''server''
+
+'''description:''' The same as [http://wiki.nginx.org/NginxMailCoreModule#listen listen]. The parameter of default means the default server if you have several server blocks with the same port.
+
+=== access_log ===
+
+'''syntax:''' ''access_log path [buffer=size] | off'' 
+
+'''default:''' ''access_log logs/tcp_access.log''
+
+'''context:''' ''tcp, server''
+
+'''description:''' Set the access.log. Each record's format is like this:
+
+<pre>
+
+log_time worker_process_pid client_ip host_ip accept_time upstream_ip bytes_read bytes_write
+
+2011/08/02 06:19:07 [5972] 127.0.0.1 0.0.0.0:1982 2011/08/02 06:18:19 172.19.0.129:80 80 236305
+
+</pre>
+
+* ''log_time'': The current time when writing this log. The log action is called when the proxy session is closed.
+* ''worker_process_pid'': the pid of worker process
+* ''client_ip'': the client ip
+* ''host_ip'': the server ip and port
+* ''accept_time'': the time when the server accepts client's connection
+* ''upstream_ip'': the upstream server's ip
+* ''bytes_read'': the bytes read from client
+* ''bytes_write'': the bytes written to client
+
+=== allow ===
+
+'''syntax:''' ''allow [ address | CIDR | all ]'' 
+
+'''default:''' ''none''
+
+'''context:''' ''server''
+
+'''description:''' Directive grants access for the network or addresses indicated.
+
+=== deny ===
+
+'''syntax:''' ''deny [ address | CIDR | all ]''
+
+'''default:''' ''none''
+
+'''context:''' ''server''
+
+'''description:''' Directive grants access for the network or addresses indicated.
+
+=== so_keepalive ===
+
+'''syntax:''' ''so_keepalive on|off''
+
+'''default:''' ''off''
+
+'''context:''' ''main, server''
+
+'''description:''' The same as [http://wiki.nginx.org/NginxMailCoreModule#so_keepalive so_keepalive].
+
+=== tcp_nodelay ===
+
+'''syntax:''' ''tcp_nodelay on|off''
+
+'''default:''' ''on''
+
+'''context:''' ''main, server''
+
+'''description:''' The same as [http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay tcp_nodelay].
+
+=== timeout ===
+
+'''syntax:''' ''timeout milliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''main, server''
+
+'''description:''' set the timeout value with clients.
+
+=== server_name ===
+
+'''syntax:''' ''server_name name''
+
+'''default:''' ''The name of the host, obtained through gethostname()''
+
+'''context:''' ''tcp, server''
+
+'''description:''' The same as [http://wiki.nginx.org/NginxMailCoreModule#server_name server_name]. You can specify several server name in different server block with the same port. They can be used in websocket module.
+
+=== resolver ===
+
+'''syntax:''' ''resolver address''
+
+'''default:''' ''none''
+
+'''context:''' ''tcp, server''
+
+'''description:''' DNS server
+
+=== resolver_timeout ===
+
+'''syntax:''' ''resolver_timeout time''
+
+'''default:''' ''30s''
+
+'''context:''' ''tcp, server''
+
+'''description:''' Resolver timeout in seconds.
+
+
+== ngx_tcp_upstream_module ==
+
+=== upstream ===
+
+'''syntax:''' ''upstream {...}''
+
+'''default:''' ''none''
+
+'''context:''' ''tcp''
+
+'''description:''' All the upstream directives are contained in this  block. The upstream server will be dispatched with round robin by default. 
+
+=== server ===
+
+'''syntax:''' ''server name [parameters]''
+
+'''default:''' ''none''
+
+'''context:''' ''upstream''
+
+'''description:''' Most of the parameters are the same as [http://wiki.nginx.org/NginxHttpUpstreamModule#server server]. Default port is 80.  
+
+=== check ===
+
+'''syntax:''' ''check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [type=tcp|ssl_hello|smtp|mysql|pop3|imap]''
+
+'''default:''' ''none, if parameters omitted, default parameters are interval=30000 fall=5 rise=2 timeout=1000''
+
+'''context:''' ''upstream''
+
+'''description:''' Add the health check for the upstream servers. At present, the check method is a simple tcp connect.
+
+The parameters' meanings are:
+
+* ''interval'': the check request's interval time.
+* ''fall''(fall_count): After fall_count check failures, the server is marked down. 
+* ''rise''(rise_count): After rise_count check success, the server is marked up. 
+* ''timeout'': the check request's timeout.
+* ''type'': the check protocol type:
+# ''tcp'' is a simple tcp socket connect and peek one byte. 
+# ''ssl_hello'' sends a client ssl hello packet and receives the server ssl hello packet.
+# ''http'' sends a http request packet, receives and parses the http response to diagnose if the upstream server is alive.  
+# ''smtp'' sends a smtp request packet, receives and parses the smtp response to diagnose if the upstream server is alive. The response begins with '2' should be an OK response. 
+# ''mysql'' connects to the mysql server, receives the greeting response to diagnose if the upstream server is alive.  
+# ''pop3'' receives and parses the pop3 response to diagnose if the upstream server is alive. The response begins with '+' should be an OK response.
+# ''imap'' connects to the imap server, receives the greeting response to diagnose if the upstream server is alive.  
+
+=== check_http_send ===
+
+'''syntax:''' ''check_http_send http_packet''
+
+'''default:''' ''"GET / HTTP/1.0\r\n\r\n"''
+
+'''context:''' ''upstream''
+
+'''description:''' If you set the check type is http, then the check function will sends this http packet to check the upstream server.
+
+=== check_http_expect_alive ===
+
+'''syntax:''' ''check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]''
+
+'''default:''' ''http_2xx | http_3xx''
+
+'''context:''' ''upstream''
+
+'''description:''' These status codes indicate the upstream server's http response is OK, the backend is alive.
+
+=== check_smtp_send ===
+
+'''syntax:''' ''check_smtp_send smtp_packet''
+
+'''default:''' ''"HELO smtp.localdomain\r\n"''
+
+'''context:''' ''upstream''
+
+'''description:''' If you set the check type is smtp, then the check function will sends this smtp packet to check the upstream server.
+
+=== check_smtp_expect_alive ===
+
+'''syntax:''' ''check_smtp_expect_alive [smtp_2xx | smtp_3xx | smtp_4xx | smtp_5xx]''
+
+'''default:''' ''smtp_2xx''
+
+'''context:''' ''upstream''
+
+'''description:''' These status codes indicate the upstream server's smtp response is OK, the backend is alive.
+
+=== check_shm_size ===
+
+'''syntax:''' ''check_shm_size size''
+
+'''default:''' ''(number_of_checked_upstream_blocks + 1) * pagesize''
+
+'''context:''' ''tcp''
+
+'''description:''' If you store hundreds of servers in one upstream block, the shared memory for health check may be not enough, you can enlarged it by this directive.
+
+=== tcp_check_status ===
+
+'''syntax:''' ''tcp_check_status''
+
+'''default:''' ''none''
+
+'''context:''' ''location''
+
+'''description:''' Display the health checking servers' status by HTTP. This directive is set in the http block.
+
+The table field meanings are:
+
+* ''Index'': The server index in the check table 
+* ''Name'' : The upstream server name
+* ''Status'': The marked status of the server.
+* ''Busyness'': The number of connections which are connecting to the server.
+* ''Rise counts'': Count the successful checking
+* ''Fall counts'': Count the unsuccessful checking
+* ''Access counts'': Count the times accessing to this server
+* ''Check type'': The type of the check packet
+
+
+'''ngx_tcp_upstream_busyness_module'''
+
+=== busyness ===
+
+'''syntax:''' ''busyness''
+
+'''default:''' ''none''
+
+'''context:''' ''upstream''
+
+'''description:''' the upstream server will be dispatched by backend servers' busyness.
+
+
+'''ngx_tcp_upstream_ip_hash_module'''
+
+=== ip_hash ===
+
+'''syntax:''' ''ip_hash''
+
+'''default:''' ''none''
+
+'''context:''' ''upstream''
+
+'''description:''' the upstream server will be dispatched by ip_hash.
+
+
+== ngx_tcp_proxy_module ==
+
+=== proxy_pass ===
+
+'''syntax:''' ''proxy_pass host:port''
+
+'''default:''' ''none''
+
+'''context:''' ''server''
+
+'''description:''' proxy the request to the backend server. Default port is 80.
+
+=== proxy_buffer ===
+
+'''syntax:''' ''proxy_buffer size''
+
+'''default:''' ''4k''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the size of proxy buffer.
+
+=== proxy_connect_timeout ===
+
+'''syntax:''' ''proxy_connect_timeout miliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the timeout value of connection to backends.
+
+=== proxy_read_timeout ===
+
+'''syntax:''' ''proxy_read_timeout miliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the timeout value of reading from backends.
+
+=== proxy_send_timeout ===
+
+'''syntax:''' ''proxy_send_timeout miliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the timeout value of sending to backends.
+
+
+== ngx_tcp_websocket_module ==
+
+=== websocket_pass ===
+
+'''syntax:''' ''websocket_pass [path] host:port''
+
+'''default:''' ''none''
+
+'''context:''' ''server''
+
+'''description:''' proxy the websocket request to the backend server. Default port is 80. You can specify several different paths in the same server block.
+
+=== websocket_buffer ===
+
+'''syntax:''' ''websocket_buffer size''
+
+'''default:''' ''4k''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the size of proxy buffer.
+
+=== websocket_connect_timeout ===
+
+'''syntax:''' ''websocket_connect_timeout miliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the timeout value of connection to backends.
+
+=== websocket_read_timeout ===
+
+'''syntax:''' ''websocket_read_timeout miliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the timeout value of reading from backends. Your timeout will be the minimum of this and the *timeout* parameter, so if you want a long timeout for your websockets, make sure to set both paramaters.
+
+=== websocket_send_timeout ===
+
+'''syntax:''' ''websocket_send_timeout miliseconds''
+
+'''default:''' ''60000''
+
+'''context:''' ''tcp, server''
+
+'''description:''' set the timeout value of sending to backends.
+
+
+== ngx_tcp_ssl_module ==
+
+The default config file includes this ngx_tcp_ssl_module. If you want to just compile nginx without ngx_tcp_ssl_module, copy the ngx_tcp_proxy_module/config_without_ssl to ngx_tcp_proxy_module/config,  reconfigrure and compile nginx.
+
+=== ssl ===
+
+'''syntax:''' ''ssl [on|off] ''
+
+'''default:''' ''ssl off''
+
+'''context:''' ''tcp, server''
+
+Enables SSL for a server.
+
+=== ssl_certificate ===
+
+'''syntax:''' ''ssl_certificate file''
+
+'''default:''' ''ssl_certificate cert.pem''
+
+'''context:''' ''tcp, server''
+
+This directive specifies the file containing the certificate, in PEM format. This file can contain also other certificates and the server private key.
+
+=== ssl_certificate_key ===
+
+'''syntax:''' ''ssl_certificate_key file''
+
+'''default:''' ''ssl_certificate_key cert.pem''
+
+'''context:''' ''tcp, server''
+
+This directive specifies the file containing the private key, in PEM format.
+
+=== ssl_client_certificate ===
+
+'''syntax:''' ''ssl_client_certificate file''
+
+'''default:''' ''none''
+
+'''context:''' ''tcp, server''
+
+This directive specifies the file containing the CA (root) certificate, in PEM format, that is used for validating client certificates.
+
+=== ssl_dhparam ===
+
+'''syntax:''' ''ssl_dhparam file''
+
+'''default:''' ''none''
+
+'''context:''' ''tcp, server''
+
+This directive specifies a file containing Diffie-Hellman key agreement protocol cryptographic parameters, in PEM format, utilized for exchanging session keys between server and client.
+
+=== ssl_ciphers ===
+
+'''syntax:''' ''ssl_ciphers openssl_cipherlist_spec''
+
+'''default:''' ''ssl_ciphers HIGH:!aNULL:!MD5''
+
+'''context:''' ''tcp, server''
+
+This directive describes the list of cipher suites the server supports for establishing a secure connection. Cipher suites are specified in the [http://openssl.org/docs/apps/ciphers.html OpenSSL] cipherlist format, for example:
+
+<geshi lang="nginx">
+ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
+</geshi>
+
+The complete cipherlist supported by the currently installed version of OpenSSL in your platform can be obtained by issuing the command:
+<pre>
+openssl ciphers
+</pre>
+
+=== ssl_crl ===
+
+'''syntax:''' ''ssl_crl file''
+
+'''default:''' ''none''
+
+'''context:''' ''tcp, server''
+
+This directive specifies the filename of a Certificate Revocation List, in PEM format, which is used to check the revocation status of certificates.
+
+=== ssl_prefer_server_ciphers ===
+
+'''syntax:''' ''ssl_prefer_server_ciphers [on|off] ''
+
+'''default:''' ''ssl_prefer_server_ciphers off''
+
+'''context:''' ''tcp, server''
+
+The server requires that the cipher suite list for protocols SSLv3 and TLSv1 are to be preferred over the client supported cipher suite list.
+
+=== ssl_protocols ===
+
+'''syntax:''' ''ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]''
+
+'''default:''' ''ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2''
+
+'''context:''' ''tcp, server''
+
+This directive enables the protocol versions specified.
+
+=== ssl_verify_client ===
+
+'''syntax:''' ''ssl_verify_client on|off|optional''
+
+'''default:''' ''ssl_verify_client off''
+
+'''context:''' ''tcp, server''
+
+This directive enables the verification of the client identity. Parameter 'optional' checks the client identity using its certificate in case it was made available to the server.
+
+=== ssl_verify_depth ===
+
+'''syntax:''' ''ssl_verify_depth number''
+
+'''default:''' ''ssl_verify_depth 1''
+
+'''context:''' ''tcp, server''
+
+This directive sets how deep the server should go in the client provided certificate chain in order to verify the client identity.
+
+=== ssl_session_cache ===
+
+'''syntax:''' ''ssl_session_cache off|none|builtin:size and/or shared:name:size''
+
+'''default:''' ''ssl_session_cache off''
+
+'''context:''' ''tcp, server''
+
+The directive sets the types and sizes of caches to store the SSL sessions.
+
+The cache types are:
+
+* off -- Hard off: nginx says explicitly to a client that sessions can not reused.
+* none -- Soft off: nginx says to a client that session can be resued, but nginx actually never reuses them. This is workaround for some mail clients as ssl_session_cache may be used in mail proxy as well as in HTTP server.
+* builtin -- the OpenSSL builtin cache, is used inside one worker process only. The cache size is assigned in the number of the sessions. Note: there appears to be a memory fragmentation issue using this method, please take that into consideration when using this. See "References" below.
+* shared -- the cache is shared between all worker processes. The size of the cache is assigned in bytes: 1 MB cache can contain roughly 4000 sessions. Each shared cache must be given an arbitrary name. A shared cache with a given name can be used in several virtual hosts.
+It's possible to use both types of cache &mdash; builtin and shared &mdash; simultaneously, for example:
+
+<geshi lang="nginx">
+ssl_session_cache  builtin:1000  shared:SSL:10m;
+</geshi>
+
+Bear in mind however, that using only shared cache, i.e., without builtin, should be more effective.
+
+=== ssl_session_timeout ===
+
+'''syntax:''' ''ssl_session_timeout time''
+
+'''default:''' ''ssl_session_timeout 5m''
+
+'''context:''' ''tcp, server''
+
+This directive defines the maximum time during which the client can re-use the previously negotiated cryptographic parameters of the secure session that is stored in the SSL cache.
+
+= Compatibility =
+
+* My test bed is 0.7.65+
+
+= Notes =
+
+The http_response_parse.rl and smtp_response_parse.rl are [http://www.complang.org/ragel/ ragel] scripts , you can edit the script and compile it like this:
+
+<geshi lang="bash">
+    $ ragel -G2 http_response_parse.rl
+    $ ragel -G2 smtp_response_parse.rl
+</geshi>
+
+= TODO =
+
+* refact this module, make it more extendable for adding third-party modules
+* manipulate header like http module's proxy_set_header
+* built-in variable support
+* custom log format
+* syslog support
+* FTP/IRC proxying
+
+= Known Issues =
+
+* This module can't use the same listening port with the HTTP module.
+
+= Changelogs =
+
+== v0.2.0 ==
+
+* add ssl proxy module
+* add websocket proxy module
+* add upstream busyness module
+* add tcp access log module
+
+== v0.19 ==
+
+* add many check methods
+
+== v0.1 ==
+
+* first release
+
+= Authors =
+
+Weibin Yao(姚伟斌) ''yaoweibin at gmail dot com''
+
+= Copyright & License =
+
+This README template copy from [http://github.com/agentzh agentzh].
+
+I borrowed a lot of code from upstream and mail module from the nginx 0.7.* core. This part of code is copyrighted by Igor Sysoev. And the health check part is borrowed the design of Jack Lindamood's healthcheck module [http://github.com/cep21/healthcheck_nginx_upstreams healthcheck_nginx_upstreams];
+
+This module is licensed under the BSD license.
+
+Copyright (C) 2013 by Weibin Yao <yaoweibin@gmail.com>.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/tcp/modules/ngx_tcp_generic_proxy_module.c b/src/tcp/modules/ngx_tcp_generic_proxy_module.c
new file mode 100755
index 0000000..bc555d6
--- /dev/null
+++ b/src/tcp/modules/ngx_tcp_generic_proxy_module.c
@@ -0,0 +1,616 @@
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+typedef struct ngx_tcp_proxy_s {
+    ngx_peer_connection_t    *upstream;
+    ngx_buf_t                *buffer;
+} ngx_tcp_proxy_ctx_t;
+
+
+typedef struct ngx_tcp_proxy_conf_s {
+    ngx_tcp_upstream_conf_t   upstream;
+
+    ngx_str_t                 url;
+    size_t                    buffer_size;
+} ngx_tcp_proxy_conf_t;
+
+
+static void ngx_tcp_proxy_init_session(ngx_tcp_session_t *s); 
+static  void ngx_tcp_proxy_init_upstream(ngx_connection_t *c, 
+    ngx_tcp_session_t *s);
+static void ngx_tcp_upstream_init_proxy_handler(ngx_tcp_session_t *s, 
+    ngx_tcp_upstream_t *u);
+static char *ngx_tcp_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static void ngx_tcp_proxy_dummy_read_handler(ngx_event_t *ev);
+static void ngx_tcp_proxy_dummy_write_handler(ngx_event_t *ev);
+static void ngx_tcp_proxy_handler(ngx_event_t *ev);
+static void *ngx_tcp_proxy_create_conf(ngx_conf_t *cf);
+static char *ngx_tcp_proxy_merge_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+
+
+static ngx_tcp_protocol_t  ngx_tcp_generic_protocol = {
+
+    ngx_string("tcp_generic"),
+    { 0, 0, 0, 0 },
+    NGX_TCP_GENERIC_PROTOCOL,
+    ngx_tcp_proxy_init_session,
+    NULL,
+    NULL,
+    ngx_string("500 Internal server error" CRLF)
+
+};
+
+
+static ngx_command_t  ngx_tcp_proxy_commands[] = {
+
+    { ngx_string("proxy_pass"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_tcp_proxy_pass,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("proxy_buffer"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_proxy_conf_t, buffer_size),
+      NULL },
+
+    { ngx_string("proxy_connect_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_proxy_conf_t, upstream.connect_timeout),
+      NULL },
+
+    { ngx_string("proxy_read_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_proxy_conf_t, upstream.read_timeout),
+      NULL },
+
+    { ngx_string("proxy_send_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_proxy_conf_t, upstream.send_timeout),
+      NULL },
+
+    ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_proxy_module_ctx = {
+    &ngx_tcp_generic_protocol,             /* protocol */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_tcp_proxy_create_conf,             /* create server configuration */
+    ngx_tcp_proxy_merge_conf               /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_proxy_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_proxy_module_ctx,             /* module context */
+    ngx_tcp_proxy_commands,                /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static void 
+ngx_tcp_proxy_init_session(ngx_tcp_session_t *s) 
+{
+    ngx_connection_t         *c;
+    ngx_tcp_proxy_conf_t     *pcf;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    c = s->connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, c->log, 0, "tcp proxy init session");
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    pcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_proxy_module);
+
+    s->buffer = ngx_create_temp_buf(s->connection->pool, pcf->buffer_size);
+    if (s->buffer == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    s->out.len = 0;
+
+    c->write->handler = ngx_tcp_proxy_dummy_write_handler;
+    c->read->handler = ngx_tcp_proxy_dummy_read_handler;
+
+    ngx_add_timer(c->read, cscf->timeout);
+
+    ngx_tcp_proxy_init_upstream(c, s);
+
+    return;
+}
+
+
+static void
+ngx_tcp_proxy_dummy_write_handler(ngx_event_t *wev) 
+{
+    ngx_connection_t    *c;
+    ngx_tcp_session_t   *s;
+
+    c = wev->data;
+    s = c->data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, wev->log, 0,
+                   "tcp proxy dummy write handler: %d", c->fd);
+
+    if (ngx_handle_write_event(wev, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+    }
+}
+
+
+static void
+ngx_tcp_proxy_dummy_read_handler(ngx_event_t *rev) 
+{
+    ngx_connection_t    *c;
+    ngx_tcp_session_t   *s;
+
+    c = rev->data;
+    s = c->data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, rev->log, 0,
+                   "tcp proxy dummy read handler: %d", c->fd);
+
+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+    }
+}
+
+
+static  void
+ngx_tcp_proxy_init_upstream(ngx_connection_t *c, ngx_tcp_session_t *s)
+{
+    ngx_tcp_upstream_t       *u;
+    ngx_tcp_proxy_ctx_t      *p;
+    ngx_tcp_proxy_conf_t     *pcf;
+
+    s->connection->log->action = "ngx_tcp_proxy_init_upstream";
+
+    pcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_proxy_module);
+    if (pcf->upstream.upstream == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    p = ngx_pcalloc(s->connection->pool, sizeof(ngx_tcp_proxy_ctx_t));
+    if (p == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ngx_tcp_set_ctx(s, p, ngx_tcp_proxy_module);
+
+    if (ngx_tcp_upstream_create(s) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    u = s->upstream;
+
+    u->conf = &pcf->upstream;
+
+    u->write_event_handler = ngx_tcp_upstream_init_proxy_handler;
+    u->read_event_handler = ngx_tcp_upstream_init_proxy_handler;
+
+    p->upstream = &u->peer;
+
+    p->buffer = ngx_create_temp_buf(s->connection->pool, pcf->buffer_size);
+    if (p->buffer == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ngx_tcp_upstream_init(s);
+
+    return;
+}
+
+
+static void 
+ngx_tcp_upstream_init_proxy_handler(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u)
+{
+    ngx_connection_t         *c;
+    ngx_tcp_proxy_ctx_t      *pctx;
+    ngx_tcp_proxy_conf_t     *pcf;
+
+    c = s->connection;
+    c->log->action = "ngx_tcp_upstream_init_proxy_handler";
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "tcp proxy upstream init proxy");
+
+    pcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_proxy_module);
+
+    pctx = ngx_tcp_get_module_ctx(s, ngx_tcp_proxy_module);
+
+    if (pcf == NULL || pctx == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    pctx->upstream = &s->upstream->peer;
+
+    c = pctx->upstream->connection;
+
+	if(!(u->conf->upstream->flags & NGX_TCP_UPSTREAM_TPROXY)){	
+	    if (c->read->timedout || c->write->timedout) {
+	        ngx_tcp_upstream_next(s, u, NGX_TCP_UPSTREAM_FT_TIMEOUT);
+	        return;
+	    }
+
+	    if (ngx_tcp_upstream_check_broken_connection(s) != NGX_OK){
+	        ngx_tcp_upstream_next(s, u, NGX_TCP_UPSTREAM_FT_ERROR);
+	        return;
+	    }
+	}
+
+    s->connection->read->handler = ngx_tcp_proxy_handler;
+    s->connection->write->handler = ngx_tcp_proxy_handler;
+
+    c->read->handler = ngx_tcp_proxy_handler;
+    c->write->handler = ngx_tcp_proxy_handler;
+
+	ngx_add_timer(c->read, pcf->upstream.read_timeout);
+	ngx_add_timer(c->write, pcf->upstream.send_timeout);
+	if (ngx_handle_read_event(s->connection->read, 0) != NGX_OK) {
+		ngx_tcp_finalize_session(s);
+		return;
+	}
+
+
+
+#if (NGX_TCP_SSL)
+
+    /* 
+     * The ssl connection with client may not trigger the read event again,
+     * So I trigger it in this function.
+     * */
+    if (s->connection->ssl) {
+        ngx_tcp_proxy_handler(s->connection->read); 
+    }
+
+#endif
+
+	// check connection revc buff
+	ngx_tcp_proxy_handler(s->connection->read);
+
+    return;
+}
+
+
+static void
+ngx_tcp_proxy_handler(ngx_event_t *ev) 
+{
+    char                     *action, *recv_action, *send_action;
+    off_t                    *read_bytes, *write_bytes;
+    size_t                    size;
+    ssize_t                   n;
+    ngx_buf_t                *b;
+    ngx_err_t                 err;
+    ngx_uint_t                do_write, first_read;
+    ngx_connection_t         *c, *src, *dst;
+    ngx_tcp_session_t        *s;
+    ngx_tcp_proxy_conf_t     *pcf;
+    ngx_tcp_proxy_ctx_t      *pctx;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    c = ev->data;
+    s = c->data;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    if (ev->timedout) {
+        c->log->action = "proxying";
+
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "proxy timed out");
+        c->timedout = 1;
+
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    pctx = ngx_tcp_get_module_ctx(s, ngx_tcp_proxy_module);
+
+    if (pctx == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    read_bytes = NULL;
+    write_bytes = NULL;
+
+    if (c == s->connection) {
+        if (ev->write) {
+            recv_action = "client write: proxying and reading from upstream";
+            send_action = "client write: proxying and sending to client";
+            src = pctx->upstream->connection;
+            dst = c;
+            b = pctx->buffer;
+            write_bytes = &s->bytes_write;
+        } else {
+            recv_action = "client read: proxying and reading from client";
+            send_action = "client read: proxying and sending to upstream";
+            src = c;
+            dst = pctx->upstream->connection;
+            b = s->buffer;
+            read_bytes = &s->bytes_read;
+        }
+
+    } else {
+        if (ev->write) {
+            recv_action = "upstream write: proxying and reading from client";
+            send_action = "upstream write: proxying and sending to upstream";
+            src = s->connection;
+            dst = c;
+            b = s->buffer;
+            read_bytes = &s->bytes_read;
+        } else {
+            recv_action = "upstream read: proxying and reading from upstream";
+            send_action = "upstream read: proxying and sending to client";
+            src = c;
+            dst = s->connection;
+            b = pctx->buffer;
+            write_bytes = &s->bytes_write;
+        }
+    }
+
+    do_write = ev->write ? 1 : 0;
+
+#if (NGX_TCP_SSL)
+    /* SSL Need this */
+    if (s->connection->ssl) {
+        first_read = 1;
+    }
+#else
+    first_read = 0;
+#endif
+
+    ngx_log_debug4(NGX_LOG_DEBUG_TCP, ev->log, 0,
+                   "tcp proxy handler: %d, #%d > #%d, time:%ui",
+                   do_write, src->fd, dst->fd, ngx_current_msec);
+
+    for ( ;; ) {
+
+        if (do_write) {
+
+            size = b->last - b->pos;
+
+            if (size && dst->write->ready) {
+                c->log->action = send_action;
+
+                n = dst->send(dst, b->pos, size);
+                err = ngx_socket_errno;
+
+                ngx_log_debug1(NGX_LOG_DEBUG_TCP, ev->log, 0,
+                               "tcp proxy handler send:%d", n);
+
+                if (n == NGX_ERROR) {
+                    ngx_log_error(NGX_LOG_ERR, c->log, err, "proxy send error");
+
+                    ngx_tcp_finalize_session(s);
+                    return;
+                }
+
+                if (n > 0) {
+                    b->pos += n;
+
+                    if (write_bytes) {
+                        *write_bytes += n;
+                    }
+
+                    if (b->pos == b->last) {
+                        b->pos = b->start;
+                        b->last = b->start;
+                    }
+                }
+            }
+        }
+
+        size = b->end - b->last;
+
+        if (size) {
+            if (src->read->ready || first_read) { 
+
+                first_read = 0;
+                c->log->action = recv_action;
+
+                n = src->recv(src, b->last, size);
+                err = ngx_socket_errno;
+
+                ngx_log_debug1(NGX_LOG_DEBUG_TCP, ev->log, 0,
+                               "tcp proxy handler recv:%d", n);
+
+                if (n == NGX_AGAIN || n == 0) {
+                    break;
+                }
+
+                if (n > 0) {
+                    do_write = 1;
+                    b->last += n;
+
+                    if (read_bytes) {
+                        *read_bytes += n;
+                    }
+
+                    continue;
+                }
+
+                if (n == NGX_ERROR) {
+                    src->read->eof = 1;
+                }
+            }
+        }
+
+        break;
+    }
+
+    c->log->action = "nginx tcp proxying";
+
+    if ((s->connection->read->eof && s->buffer->pos == s->buffer->last)
+            || (pctx->upstream->connection->read->eof
+                && pctx->buffer->pos == pctx->buffer->last)
+            || (s->connection->read->eof
+                && pctx->upstream->connection->read->eof))
+    {
+        action = c->log->action;
+        c->log->action = NULL;
+        ngx_log_error(NGX_LOG_DEBUG, c->log, 0, "proxied session done");
+        c->log->action = action;
+
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_write_event(dst->write, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_read_event(dst->read, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_write_event(src->write, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_read_event(src->read, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    pcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_proxy_module);
+
+    if (c == s->connection) {
+        ngx_add_timer(c->read, cscf->timeout);
+    }
+
+    if (c == pctx->upstream->connection) {
+        if (ev->write) {
+            ngx_add_timer(c->write, pcf->upstream.send_timeout);
+        } else {
+            ngx_add_timer(c->read, pcf->upstream.read_timeout);
+        }
+    }
+
+    return;
+}
+
+
+static char *
+ngx_tcp_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    ngx_tcp_proxy_conf_t *pcf = conf;
+
+    u_short                     port = 80;
+    ngx_str_t                  *value, *url = &pcf->url;
+    ngx_url_t                   u;
+    ngx_tcp_core_srv_conf_t    *cscf;
+
+    cscf = ngx_tcp_conf_get_module_srv_conf(cf, ngx_tcp_core_module);
+
+    if (cscf->protocol && ngx_strncmp(cscf->protocol->name.data,
+                                      (u_char *)"tcp_generic",
+                                      sizeof("tcp_generic") - 1) != 0) {
+
+        return "the protocol should be tcp_generic";
+    }
+
+    if (cscf->protocol == NULL) {
+        cscf->protocol = &ngx_tcp_generic_protocol;
+    }
+
+    if (pcf->upstream.upstream) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    url = &value[1];
+
+    ngx_memzero(&u, sizeof(u));
+
+    u.url.len = url->len;
+    u.url.data = url->data;
+    u.default_port = port;
+    u.uri_part = 1;
+    u.no_resolve = 1;
+
+    pcf->upstream.upstream = ngx_tcp_upstream_add(cf, &u, 0);
+    if (pcf->upstream.upstream == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_tcp_proxy_create_conf(ngx_conf_t *cf) 
+{
+    ngx_tcp_proxy_conf_t  *pcf;
+
+    pcf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_proxy_conf_t));
+    if (pcf == NULL) {
+        return NULL;
+    }
+
+    pcf->buffer_size = NGX_CONF_UNSET_SIZE;
+
+    pcf->upstream.connect_timeout = NGX_CONF_UNSET_MSEC;
+    pcf->upstream.send_timeout = NGX_CONF_UNSET_MSEC;
+    pcf->upstream.read_timeout = NGX_CONF_UNSET_MSEC;
+
+    return pcf;
+}
+
+
+static char *
+ngx_tcp_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child) 
+{
+    ngx_tcp_proxy_conf_t *prev = parent;
+    ngx_tcp_proxy_conf_t *conf = child;
+
+    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
+                              (size_t) ngx_pagesize);
+
+    ngx_conf_merge_msec_value(conf->upstream.connect_timeout,
+                              prev->upstream.connect_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->upstream.send_timeout,
+                              prev->upstream.send_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->upstream.read_timeout,
+                              prev->upstream.read_timeout, 60000);
+
+    return NGX_CONF_OK;
+}
diff --git a/src/tcp/modules/ngx_tcp_ssl_module.c b/src/tcp/modules/ngx_tcp_ssl_module.c
new file mode 100755
index 0000000..6f9836e
--- /dev/null
+++ b/src/tcp/modules/ngx_tcp_ssl_module.c
@@ -0,0 +1,532 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+#define NGX_DEFAULT_CIPHERS  "HIGH:!aNULL:!MD5"
+#if defined(nginx_version) && nginx_version >= 1000006
+#define NGX_DEFAULT_ECDH_CURVE  "prime256v1" 
+#endif
+
+
+static void *ngx_tcp_ssl_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_tcp_ssl_merge_srv_conf(ngx_conf_t *cf,
+    void *parent, void *child);
+
+static char *ngx_tcp_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+
+static ngx_conf_bitmask_t  ngx_tcp_ssl_protocols[] = {
+    { ngx_string("SSLv2"), NGX_SSL_SSLv2 },
+    { ngx_string("SSLv3"), NGX_SSL_SSLv3 },
+    { ngx_string("TLSv1"), NGX_SSL_TLSv1 },
+#if defined(nginx_version) && nginx_version >= 1000012
+    { ngx_string("TLSv1.1"), NGX_SSL_TLSv1_1 },
+    { ngx_string("TLSv1.2"), NGX_SSL_TLSv1_2 },
+#endif
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_conf_enum_t  ngx_tcp_ssl_verify[] = {
+    { ngx_string("off"), 0 },
+    { ngx_string("on"), 1 },
+    { ngx_string("optional"), 2 },
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_command_t  ngx_tcp_ssl_commands[] = {
+
+    { ngx_string("ssl"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_tcp_ssl_enable,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, enable),
+      NULL },
+
+    { ngx_string("ssl_certificate"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, certificate),
+      NULL },
+
+    { ngx_string("ssl_certificate_key"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, certificate_key),
+      NULL },
+
+    { ngx_string("ssl_dhparam"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, dhparam),
+      NULL },
+
+#if defined(nginx_version) && nginx_version >= 1000006
+    { ngx_string("ssl_ecdh_curve"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, ecdh_curve),
+      NULL },
+
+#endif
+    { ngx_string("ssl_protocols"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, protocols),
+      &ngx_tcp_ssl_protocols },
+
+    { ngx_string("ssl_ciphers"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, ciphers),
+      NULL },
+
+    { ngx_string("ssl_verify_client"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_enum_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, verify),
+      &ngx_tcp_ssl_verify },
+
+    { ngx_string("ssl_verify_depth"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_num_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, verify_depth),
+      NULL },
+
+    { ngx_string("ssl_client_certificate"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, client_certificate),
+      NULL },
+
+    { ngx_string("ssl_prefer_server_ciphers"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, prefer_server_ciphers),
+      NULL },
+
+    { ngx_string("ssl_session_cache"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE12,
+      ngx_tcp_ssl_session_cache,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("ssl_session_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_sec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, session_timeout),
+      NULL },
+
+    { ngx_string("ssl_crl"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_ssl_srv_conf_t, crl),
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_ssl_module_ctx = {
+    NULL,                                  /* */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_tcp_ssl_create_srv_conf,           /* create server configuration */
+    ngx_tcp_ssl_merge_srv_conf,            /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_ssl_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_ssl_module_ctx,               /* module context */
+    ngx_tcp_ssl_commands,                  /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t ngx_tcp_ssl_sess_id_ctx = ngx_string("TCP");
+
+
+static void *
+ngx_tcp_ssl_create_srv_conf(ngx_conf_t *cf)
+{
+    ngx_tcp_ssl_srv_conf_t  *sscf;
+
+    sscf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_ssl_srv_conf_t));
+    if (sscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     sscf->protocols = 0;
+     *     sscf->certificate = { 0, NULL };
+     *     sscf->certificate_key = { 0, NULL };
+     *     sscf->dhparam = { 0, NULL };
+     *     sscf->ecdh_curve = { 0, NULL };
+     *     sscf->client_certificate = { 0, NULL };
+     *     sscf->crl = { 0, NULL };
+     *     sscf->ciphers.len = 0;
+     *     sscf->ciphers.data = NULL;
+     *     sscf->shm_zone = NULL;
+     */
+
+    sscf->enable = NGX_CONF_UNSET;
+    sscf->prefer_server_ciphers = NGX_CONF_UNSET;
+    sscf->verify = NGX_CONF_UNSET_UINT;
+    sscf->verify_depth = NGX_CONF_UNSET_UINT;
+    sscf->builtin_session_cache = NGX_CONF_UNSET;
+    sscf->session_timeout = NGX_CONF_UNSET;
+
+    return sscf;
+}
+
+
+static char *
+ngx_tcp_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_tcp_ssl_srv_conf_t *prev = parent;
+    ngx_tcp_ssl_srv_conf_t *conf = child;
+
+    ngx_pool_cleanup_t  *cln;
+
+    ngx_conf_merge_value(conf->enable, prev->enable, 0);
+
+    ngx_conf_merge_value(conf->session_timeout,
+                         prev->session_timeout, 300);
+
+    ngx_conf_merge_value(conf->prefer_server_ciphers,
+                         prev->prefer_server_ciphers, 0);
+
+    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                         (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+#if defined(nginx_version) && nginx_version >= 1000012
+                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2
+#endif
+                          ));
+
+    ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
+    ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);
+
+    ngx_conf_merge_str_value(conf->certificate, prev->certificate, "");
+    ngx_conf_merge_str_value(conf->certificate_key, prev->certificate_key, "");
+
+    ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+#if defined(nginx_version) && nginx_version >= 1000006
+    ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve, 
+                             NGX_DEFAULT_ECDH_CURVE); 
+
+#endif
+    ngx_conf_merge_str_value(conf->client_certificate, prev->client_certificate,
+                             "");
+    ngx_conf_merge_str_value(conf->crl, prev->crl, "");
+
+    ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+
+    conf->ssl.log = cf->log;
+
+    if (conf->enable) {
+
+        if (conf->certificate.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate\" is defined for "
+                          "the \"ssl\" directive in %s:%ui",
+                          conf->file, conf->line);
+            return NGX_CONF_ERROR;
+        }
+
+        if (conf->certificate_key.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate_key\" is defined for "
+                          "the \"ssl\" directive in %s:%ui",
+                          conf->file, conf->line);
+            return NGX_CONF_ERROR;
+        }
+
+    } else {
+
+        if (conf->certificate.len == 0) {
+            return NGX_CONF_OK;
+        }
+
+        if (conf->certificate_key.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate_key\" is defined "
+                          "for certificate \"%V\"", &conf->certificate);
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_ssl_cleanup_ctx;
+    cln->data = &conf->ssl;
+
+#if defined(tengine_version)
+    ngx_str_t pass_phrase_dialog              = ngx_string("builtin");
+    ngx_str_t ngx_tcp_ssl_unknown_server_name = ngx_string("unknown");
+
+    ngx_tcp_core_srv_conf_t            *cscf;
+    ngx_http_ssl_pphrase_dialog_conf_t  dialog;
+
+    cscf = ngx_tcp_conf_get_module_srv_conf(cf, ngx_tcp_core_module);
+    dialog.ssl = &conf->ssl;
+    dialog.type = &pass_phrase_dialog;
+    if (cscf->server_name.len != 0) {
+        dialog.server_name = &cscf->server_name;
+    } else {
+        dialog.server_name = &ngx_tcp_ssl_unknown_server_name;
+    }
+
+    if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
+                            &conf->certificate_key, &dialog)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+#else
+    if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
+                            &conf->certificate_key)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
+    if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                (const char *) conf->ciphers.data)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
+                      "SSL_CTX_set_cipher_list(\"%V\") failed",
+                      &conf->ciphers);
+    }
+
+    if (conf->verify) {
+
+        if (conf->client_certificate.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no ssl_client_certificate for ssl_client_verify");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_ssl_client_certificate(cf, &conf->ssl,
+                                       &conf->client_certificate,
+                                       conf->verify_depth)
+            != NGX_OK)
+        {
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_ssl_crl(cf, &conf->ssl, &conf->crl) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    if (conf->prefer_server_ciphers) {
+        SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
+    }
+
+    /* a temporary 512-bit RSA key is required for export versions of MSIE */
+#if defined(nginx_version) && nginx_version >= 1000006
+    SSL_CTX_set_tmp_rsa_callback(conf->ssl.ctx, ngx_ssl_rsa512_key_callback); 
+#else
+    if (ngx_ssl_generate_rsa512_key(&conf->ssl) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
+    if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_merge_value(conf->builtin_session_cache,
+                         prev->builtin_session_cache, NGX_SSL_NONE_SCACHE);
+
+    if (conf->shm_zone == NULL) {
+        conf->shm_zone = prev->shm_zone;
+    }
+
+    if (ngx_ssl_session_cache(&conf->ssl, &ngx_tcp_ssl_sess_id_ctx,
+                              conf->builtin_session_cache,
+                              conf->shm_zone, conf->session_timeout)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_ssl_srv_conf_t *sscf = conf;
+
+    char  *rv;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    sscf->file = cf->conf_file->file.name.data;
+    sscf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_ssl_srv_conf_t *sscf = conf;
+
+    size_t       len;
+    ngx_str_t   *value, name, size;
+    ngx_int_t    n;
+    ngx_uint_t   i, j;
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+
+        if (ngx_strcmp(value[i].data, "off") == 0) {
+            sscf->builtin_session_cache = NGX_SSL_NO_SCACHE;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "none") == 0) {
+            sscf->builtin_session_cache = NGX_SSL_NONE_SCACHE;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "builtin") == 0) {
+            sscf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;
+            continue;
+        }
+
+        if (value[i].len > sizeof("builtin:") - 1
+            && ngx_strncmp(value[i].data, "builtin:", sizeof("builtin:") - 1)
+               == 0)
+        {
+            n = ngx_atoi(value[i].data + sizeof("builtin:") - 1,
+                         value[i].len - (sizeof("builtin:") - 1));
+
+            if (n == NGX_ERROR) {
+                goto invalid;
+            }
+
+            sscf->builtin_session_cache = n;
+
+            continue;
+        }
+
+        if (value[i].len > sizeof("shared:") - 1
+            && ngx_strncmp(value[i].data, "shared:", sizeof("shared:") - 1)
+               == 0)
+        {
+            len = 0;
+
+            for (j = sizeof("shared:") - 1; j < value[i].len; j++) {
+                if (value[i].data[j] == ':') {
+                    value[i].data[j] = '\0';
+                    break;
+                }
+
+                len++;
+            }
+
+            if (len == 0) {
+                goto invalid;
+            }
+
+            name.len = len;
+            name.data = value[i].data + sizeof("shared:") - 1;
+
+            size.len = value[i].len - j - 1;
+            size.data = name.data + len + 1;
+
+            n = ngx_parse_size(&size);
+
+            if (n == NGX_ERROR) {
+                goto invalid;
+            }
+
+            if (n < (ngx_int_t) (8 * ngx_pagesize)) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "session cache \"%V\" is too small",
+                                   &value[i]);
+
+                return NGX_CONF_ERROR;
+            }
+
+            sscf->shm_zone = ngx_shared_memory_add(cf, &name, n,
+                                                   &ngx_tcp_ssl_module);
+            if (sscf->shm_zone == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+#if defined(nginx_version) && nginx_version >= 1000007
+            sscf->shm_zone->init = ngx_ssl_session_cache_init;
+#endif
+            continue;
+        }
+
+        goto invalid;
+    }
+
+    if (sscf->shm_zone && sscf->builtin_session_cache == NGX_CONF_UNSET) {
+        sscf->builtin_session_cache = NGX_SSL_NO_BUILTIN_SCACHE;
+    }
+
+    return NGX_CONF_OK;
+
+invalid:
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid session cache \"%V\"", &value[i]);
+
+    return NGX_CONF_ERROR;
+}
diff --git a/src/tcp/modules/ngx_tcp_ssl_module.h b/src/tcp/modules/ngx_tcp_ssl_module.h
new file mode 100755
index 0000000..103e090
--- /dev/null
+++ b/src/tcp/modules/ngx_tcp_ssl_module.h
@@ -0,0 +1,48 @@
+
+#ifndef _NGX_TCP_SSL_H_INCLUDED_
+#define _NGX_TCP_SSL_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+typedef struct {
+    ngx_flag_t                      enable;
+
+    ngx_ssl_t                       ssl;
+
+    ngx_flag_t                      prefer_server_ciphers;
+
+    ngx_uint_t                      protocols;
+
+    ngx_uint_t                      verify;
+    ngx_uint_t                      verify_depth;
+
+    ssize_t                         builtin_session_cache;
+
+    time_t                          session_timeout;
+
+    ngx_str_t                       certificate;
+    ngx_str_t                       certificate_key;
+    ngx_str_t                       dhparam;
+#if defined(nginx_version) && nginx_version >= 1000006
+    ngx_str_t                       ecdh_curve; 
+#endif
+    ngx_str_t                       client_certificate;
+    ngx_str_t                       crl;
+
+    ngx_str_t                       ciphers;
+
+    ngx_shm_zone_t                 *shm_zone;
+
+    u_char                         *file;
+    ngx_uint_t                      line;
+} ngx_tcp_ssl_srv_conf_t;
+
+
+extern ngx_module_t  ngx_tcp_ssl_module;
+
+
+#endif /* _NGX_TCP_SSL_H_INCLUDED_ */
diff --git a/src/tcp/modules/ngx_tcp_upstream_busyness_module.c b/src/tcp/modules/ngx_tcp_upstream_busyness_module.c
new file mode 100755
index 0000000..09d1f55
--- /dev/null
+++ b/src/tcp/modules/ngx_tcp_upstream_busyness_module.c
@@ -0,0 +1,235 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+typedef struct {
+    /* the round robin data must be first */
+    ngx_tcp_upstream_rr_peer_data_t    rrp;
+
+    u_char                             tries;
+
+    ngx_event_get_peer_pt              get_rr_peer;
+} ngx_tcp_upstream_busyness_peer_data_t;
+
+
+static ngx_int_t ngx_tcp_upstream_init_busyness_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_srv_conf_t *us);
+static ngx_int_t ngx_tcp_upstream_get_busyness_peer(ngx_peer_connection_t *pc,
+    void *data);
+static char *ngx_tcp_upstream_busyness(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+
+static ngx_command_t  ngx_tcp_upstream_busyness_commands[] = {
+
+    { ngx_string("busyness"),
+      NGX_TCP_UPS_CONF|NGX_CONF_NOARGS,
+      ngx_tcp_upstream_busyness,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_upstream_busyness_module_ctx = {
+    NULL,                                 
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    NULL,                                  /* create server configuration */
+    NULL,                                  /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_upstream_busyness_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_upstream_busyness_module_ctx, /* module context */
+    ngx_tcp_upstream_busyness_commands,    /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+ngx_int_t
+ngx_tcp_upstream_init_busyness(ngx_conf_t *cf, ngx_tcp_upstream_srv_conf_t *us)
+{
+    if (ngx_tcp_upstream_init_round_robin(cf, us) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    us->peer.init = ngx_tcp_upstream_init_busyness_peer;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_tcp_upstream_init_busyness_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_srv_conf_t *us)
+{
+    ngx_tcp_upstream_busyness_peer_data_t  *bp;
+
+    bp = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_busyness_peer_data_t));
+    if (bp == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->upstream->peer.data = &bp->rrp;
+
+    if (ngx_tcp_upstream_init_round_robin_peer(s, us) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    s->upstream->peer.get = ngx_tcp_upstream_get_busyness_peer;
+
+    bp->tries = 0;
+    bp->get_rr_peer = ngx_tcp_upstream_get_round_robin_peer;
+
+    return NGX_OK;
+}
+
+
+static ngx_uint_t
+ngx_tcp_upstream_get_least_busy_index(ngx_tcp_upstream_rr_peers_t *rrps) 
+{
+    ngx_uint_t i, j, peer_index, check_index, busyness, min_busyness, start;
+
+    min_busyness = (ngx_uint_t) (-1);
+
+    peer_index = start = ngx_random() % rrps->number;
+
+    for (i = 0; i < rrps->number; i++, start++) {
+
+        j =  start % rrps->number;
+        check_index = rrps->peer[j].check_index;
+
+        busyness = ngx_tcp_check_get_peer_busyness(check_index);
+        if (busyness < min_busyness && !ngx_tcp_check_peer_down(check_index)) {
+            min_busyness = busyness;
+            peer_index = j;
+        }
+    }
+
+    return peer_index;
+}
+
+
+static ngx_int_t
+ngx_tcp_upstream_get_busyness_peer(ngx_peer_connection_t *pc, void *data)
+{
+    ngx_tcp_upstream_busyness_peer_data_t  *bp = data;
+
+    time_t                        now;
+    uintptr_t                     m;
+    ngx_uint_t                    n, p;
+    ngx_tcp_upstream_rr_peer_t   *peer;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                   "get busyness peer, try: %ui", pc->tries);
+
+    /* TODO: cached */
+
+    if (bp->tries > 20 || bp->rrp.peers->single ||
+            bp->rrp.peers->peer[0].check_index
+                                    == (ngx_uint_t) NGX_INVALID_CHECK_INDEX) {
+
+        ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                       "get busyness peer0, bp->tries: %ui", bp->tries);
+
+        return bp->get_rr_peer(pc, &bp->rrp);
+    }
+
+    now = ngx_time();
+
+    pc->cached = 0;
+    pc->connection = NULL;
+
+    for ( ;; ) {
+        p = ngx_tcp_upstream_get_least_busy_index(bp->rrp.peers);
+
+        n = p / (8 * sizeof(uintptr_t));
+        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+
+        if (!(bp->rrp.tried[n] & m)) {
+
+            peer = &bp->rrp.peers->peer[p];
+
+            ngx_log_debug4(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                           "get busyness peer, check_index: %ui, %ui, "
+                           "%04XA, num: %d",
+                           peer->check_index, p, m, bp->rrp.peers->number);
+
+            /* ngx_lock_mutex(bp->rrp.peers->mutex); */
+
+            if (!peer->down) {
+                if (peer->max_fails == 0 || peer->fails < peer->max_fails) {
+                    break;
+                }
+
+                if (now - peer->accessed > peer->fail_timeout) {
+                    peer->fails = 0;
+                    break;
+                }
+            }
+
+            bp->rrp.tried[n] |= m;
+
+            /* ngx_unlock_mutex(bp->rrp.peers->mutex); */
+
+            pc->tries--;
+
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                       "get busyness peer, bp->tries: %ui, p: %ui",
+                       bp->tries, p);
+
+        if (++bp->tries >= 20) {
+            return bp->get_rr_peer(pc, &bp->rrp);
+        }
+    }
+
+    bp->rrp.current = p;
+
+    pc->sockaddr = peer->sockaddr;
+    pc->socklen = peer->socklen;
+    pc->name = &peer->name;
+    pc->check_index = peer->check_index;
+
+    /* ngx_unlock_mutex(bp->rrp.peers->mutex); */
+
+    bp->rrp.tried[n] |= m;
+
+    return NGX_OK;
+}
+
+
+static char *
+ngx_tcp_upstream_busyness(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+
+    uscf = ngx_tcp_conf_get_module_srv_conf(cf, ngx_tcp_upstream_module);
+
+    uscf->peer.init_upstream = ngx_tcp_upstream_init_busyness;
+
+    uscf->flags = NGX_TCP_UPSTREAM_CREATE
+                  |NGX_TCP_UPSTREAM_MAX_FAILS
+                  |NGX_TCP_UPSTREAM_FAIL_TIMEOUT
+                  |NGX_TCP_UPSTREAM_MAX_BUSY
+                  |NGX_TCP_UPSTREAM_DOWN;
+
+    return NGX_CONF_OK;
+}
diff --git a/src/tcp/modules/ngx_tcp_upstream_ip_hash_module.c b/src/tcp/modules/ngx_tcp_upstream_ip_hash_module.c
new file mode 100755
index 0000000..99f49fc
--- /dev/null
+++ b/src/tcp/modules/ngx_tcp_upstream_ip_hash_module.c
@@ -0,0 +1,232 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+typedef struct {
+    /* the round robin data must be first */
+    ngx_tcp_upstream_rr_peer_data_t    rrp;
+
+    ngx_uint_t                         hash;
+
+    u_char                             addr[3];
+
+    u_char                             tries;
+
+    ngx_event_get_peer_pt              get_rr_peer;
+} ngx_tcp_upstream_ip_hash_peer_data_t;
+
+
+static ngx_int_t ngx_tcp_upstream_init_ip_hash_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_srv_conf_t *us);
+static ngx_int_t ngx_tcp_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc,
+    void *data);
+static char *ngx_tcp_upstream_ip_hash(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+
+static ngx_command_t  ngx_tcp_upstream_ip_hash_commands[] = {
+
+    { ngx_string("ip_hash"),
+      NGX_TCP_UPS_CONF|NGX_CONF_NOARGS,
+      ngx_tcp_upstream_ip_hash,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_upstream_ip_hash_module_ctx = {
+    NULL,                                 
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    NULL,                                  /* create server configuration */
+    NULL,                                  /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_upstream_ip_hash_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_upstream_ip_hash_module_ctx,  /* module context */
+    ngx_tcp_upstream_ip_hash_commands,     /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+ngx_int_t
+ngx_tcp_upstream_init_ip_hash(ngx_conf_t *cf, ngx_tcp_upstream_srv_conf_t *us)
+{
+    if (ngx_tcp_upstream_init_round_robin(cf, us) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    us->peer.init = ngx_tcp_upstream_init_ip_hash_peer;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_tcp_upstream_init_ip_hash_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_srv_conf_t *us)
+{
+    u_char                                 *p;
+    struct sockaddr_in                     *sin;
+    ngx_tcp_upstream_ip_hash_peer_data_t   *iphp;
+
+    iphp = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_ip_hash_peer_data_t));
+    if (iphp == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->upstream->peer.data = &iphp->rrp;
+
+    if (ngx_tcp_upstream_init_round_robin_peer(s, us) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    s->upstream->peer.get = ngx_tcp_upstream_get_ip_hash_peer;
+
+    /* AF_INET only */
+
+    if (s->connection->sockaddr->sa_family == AF_INET) {
+
+        sin = (struct sockaddr_in *) s->connection->sockaddr;
+        p = (u_char *) &sin->sin_addr.s_addr;
+        iphp->addr[0] = p[0];
+        iphp->addr[1] = p[1];
+        iphp->addr[2] = p[2];
+
+    } else {
+        iphp->addr[0] = 0;
+        iphp->addr[1] = 0;
+        iphp->addr[2] = 0;
+    }
+
+    iphp->hash = 89;
+    iphp->tries = 0;
+    iphp->get_rr_peer = ngx_tcp_upstream_get_round_robin_peer;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_tcp_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
+{
+    ngx_tcp_upstream_ip_hash_peer_data_t  *iphp = data;
+
+    time_t                        now;
+    uintptr_t                     m;
+    ngx_uint_t                    i, n, p, hash;
+    ngx_tcp_upstream_rr_peer_t   *peer;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                   "get ip hash peer, try: %ui", pc->tries);
+
+    /* TODO: cached */
+
+    if (iphp->tries > 20 || iphp->rrp.peers->single) {
+        return iphp->get_rr_peer(pc, &iphp->rrp);
+    }
+
+    now = ngx_time();
+
+    pc->cached = 0;
+    pc->connection = NULL;
+
+    hash = iphp->hash;
+
+    for ( ;; ) {
+
+        for (i = 0; i < 3; i++) {
+            hash = (hash * 113 + iphp->addr[i]) % 6271;
+        }
+
+        p = hash % iphp->rrp.peers->number;
+
+        n = p / (8 * sizeof(uintptr_t));
+        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+
+        if (!(iphp->rrp.tried[n] & m)) {
+
+            ngx_log_debug4(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                           "get ip hash peer, hash: %d, %ui, %04XA, num: %d",
+                           hash, p, m, iphp->rrp.peers->number);
+
+            peer = &iphp->rrp.peers->peer[p];
+
+            /* ngx_lock_mutex(iphp->rrp.peers->mutex); */
+
+            if (!peer->down) {
+                if (!ngx_tcp_check_peer_down(peer->check_index)) {
+
+                    if (peer->max_fails == 0 || peer->fails < peer->max_fails) {
+                        break;
+                    }
+
+                    if (now - peer->accessed > peer->fail_timeout) {
+                        peer->fails = 0;
+                        break;
+                    }
+                }
+            }
+
+            iphp->rrp.tried[n] |= m;
+
+            /* ngx_unlock_mutex(iphp->rrp.peers->mutex); */
+
+            pc->tries--;
+        }
+
+        if (++iphp->tries >= 20) {
+            return iphp->get_rr_peer(pc, &iphp->rrp);
+        }
+    }
+
+    iphp->rrp.current = p;
+
+    pc->sockaddr = peer->sockaddr;
+    pc->socklen = peer->socklen;
+    pc->name = &peer->name;
+    pc->check_index = peer->check_index;
+
+    /* ngx_unlock_mutex(iphp->rrp.peers->mutex); */
+
+    iphp->rrp.tried[n] |= m;
+    iphp->hash = hash;
+
+    return NGX_OK;
+}
+
+
+static char *
+ngx_tcp_upstream_ip_hash(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+
+    uscf = ngx_tcp_conf_get_module_srv_conf(cf, ngx_tcp_upstream_module);
+
+    uscf->peer.init_upstream = ngx_tcp_upstream_init_ip_hash;
+
+    uscf->flags = NGX_TCP_UPSTREAM_CREATE
+                  |NGX_TCP_UPSTREAM_MAX_FAILS
+                  |NGX_TCP_UPSTREAM_FAIL_TIMEOUT
+                  |NGX_TCP_UPSTREAM_MAX_BUSY
+                  |NGX_TCP_UPSTREAM_DOWN;
+
+    return NGX_CONF_OK;
+}
diff --git a/src/tcp/modules/ngx_tcp_websocket_proxy_module.c b/src/tcp/modules/ngx_tcp_websocket_proxy_module.c
new file mode 100755
index 0000000..d4c032d
--- /dev/null
+++ b/src/tcp/modules/ngx_tcp_websocket_proxy_module.c
@@ -0,0 +1,1216 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+#include <http_request_parser.h>
+
+
+typedef struct ngx_tcp_websocket_s {
+
+    ngx_peer_connection_t            *upstream;
+    ngx_buf_t                        *buffer;
+
+    http_request_parser              *parser;
+
+    ngx_str_t                         path;
+    ngx_str_t                         host;
+
+} ngx_tcp_websocket_ctx_t;
+
+
+typedef struct ngx_tcp_path_upstream_s {
+
+    ngx_str_t                         path;
+    ngx_tcp_upstream_srv_conf_t      *upstream;
+
+} ngx_tcp_path_upstream_t;
+
+
+typedef struct ngx_tcp_websocket_conf_s {
+
+    /* Default */
+    ngx_tcp_upstream_conf_t           upstream;   
+    size_t                            buffer_size;
+    ngx_str_t                         scheme;
+    ngx_str_t                         url;
+
+    /* Array of ngx_tcp_path_upstream_t */
+    ngx_array_t                       path_upstreams; 
+
+    /*TODO: support for the variable in the websocket_pass*/
+    ngx_array_t                      *websocket_lengths;
+    ngx_array_t                      *websocket_values;
+
+} ngx_tcp_websocket_conf_t;
+
+
+static void ngx_tcp_websocket_init_session(ngx_tcp_session_t *s);
+static ngx_tcp_virtual_server_t * ngx_tcp_websocket_find_virtual_server(
+    ngx_tcp_session_t *s, ngx_tcp_websocket_ctx_t *ctx);
+static ngx_tcp_path_upstream_t * ngx_tcp_websocket_find_path_upstream(
+    ngx_tcp_session_t *s, ngx_tcp_websocket_ctx_t *ctx);
+static  void ngx_tcp_websocket_init_upstream(ngx_connection_t *c, 
+    ngx_tcp_session_t *s);
+static void ngx_tcp_upstream_websocket_proxy_init_handler(ngx_tcp_session_t *s, 
+    ngx_tcp_upstream_t *u);
+static char *ngx_tcp_websocket_pass(ngx_conf_t *cf, ngx_command_t *cmd, 
+    void *conf);
+static void ngx_tcp_websocket_dummy_read_handler(ngx_event_t *ev);
+static void ngx_tcp_websocket_dummy_write_handler(ngx_event_t *ev);
+static void ngx_tcp_websocket_init_protocol(ngx_event_t *ev);
+static void websocket_http_request_parser_init(http_request_parser *hp, 
+    void *data); 
+
+static void request_method(void *data, const signed char *at, size_t length);
+static void request_uri(void *data, const signed char *at, size_t length);
+static void fragment(void *data, const signed char *at, size_t length);
+static void request_path(void *data, const signed char *at, size_t length);
+static void query_string(void *data, const signed char *at, size_t length);
+static void http_version(void *data, const signed char *at, size_t length);
+static void header_done(void *data, const signed char *at, size_t length);
+static void http_field(void *data, const signed char *field, size_t flen, 
+    const signed char *value, size_t vlen);
+
+static void ngx_tcp_websocket_parse_protocol(ngx_event_t *ev);
+static ngx_int_t websocket_http_request_parser_execute(http_request_parser *hp);
+
+static void ngx_tcp_websocket_proxy_handler(ngx_event_t *ev);
+static void *ngx_tcp_websocket_create_conf(ngx_conf_t *cf);
+static char *ngx_tcp_websocket_merge_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+
+static ngx_tcp_protocol_t  ngx_tcp_websocket_protocol = {
+    ngx_string("tcp_websocket"),
+    { 80, 443, 0, 0 },
+    NGX_TCP_WEBSOCKET_PROTOCOL,
+    ngx_tcp_websocket_init_session,
+    ngx_tcp_websocket_init_protocol,
+    ngx_tcp_websocket_parse_protocol,
+    ngx_string("500 Internal server error" CRLF)
+};
+
+
+static ngx_command_t  ngx_tcp_websocket_commands[] = {
+
+    { ngx_string("websocket_pass"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE12,
+      ngx_tcp_websocket_pass,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("websocket_buffer"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_websocket_conf_t, buffer_size),
+      NULL },
+
+    { ngx_string("websocket_connect_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_websocket_conf_t, upstream.connect_timeout),
+      NULL },
+
+    { ngx_string("websocket_read_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_websocket_conf_t, upstream.read_timeout),
+      NULL },
+
+    { ngx_string("websocket_send_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_websocket_conf_t, upstream.send_timeout),
+      NULL },
+
+    ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_websocket_module_ctx = {
+    &ngx_tcp_websocket_protocol,           /* protocol */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_tcp_websocket_create_conf,         /* create server configuration */
+    ngx_tcp_websocket_merge_conf           /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_websocket_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_websocket_module_ctx,         /* module context */
+    ngx_tcp_websocket_commands,            /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static void 
+ngx_tcp_websocket_init_session(ngx_tcp_session_t *s) 
+{
+    ngx_connection_t             *c;
+    ngx_tcp_websocket_ctx_t      *wctx;
+    ngx_tcp_core_srv_conf_t      *cscf;
+    ngx_tcp_websocket_conf_t     *wcf;
+
+    c = s->connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, c->log, 0, "tcp websocket init session");
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    wcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_websocket_module);
+
+    wctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_tcp_websocket_ctx_t));
+    if (wctx == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+    ngx_tcp_set_ctx(s, wctx, ngx_tcp_websocket_module);
+
+    s->out.len = 0;
+
+    s->buffer = ngx_create_temp_buf(s->connection->pool, wcf->buffer_size);
+    if (s->buffer == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    c->write->handler = ngx_tcp_websocket_dummy_write_handler;
+    c->read->handler = ngx_tcp_websocket_init_protocol;
+
+    ngx_add_timer(c->read, cscf->timeout);
+
+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+    }
+
+#if (NGX_TCP_SSL)
+
+    /*
+     * The ssl connection with client may not trigger the read event again,
+     * So I trigger it in this function.
+     * */
+    if (c->ssl) {
+        ngx_tcp_websocket_init_protocol(c->read);
+        return;
+    }
+
+#endif
+
+    if (c->read->ready) {
+        ngx_tcp_websocket_init_protocol(c->read);
+    }
+
+    return;
+}
+
+
+static void
+ngx_tcp_websocket_dummy_write_handler(ngx_event_t *wev) 
+{
+    ngx_connection_t    *c;
+    ngx_tcp_session_t   *s;
+
+    c = wev->data;
+    s = c->data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, wev->log, 0, 
+                   "tcp websocket dummy write handler: %d", c->fd);
+
+    if (ngx_handle_write_event(wev, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+    }
+}
+
+
+static void
+ngx_tcp_websocket_dummy_read_handler(ngx_event_t *rev) 
+{
+    ngx_connection_t    *c;
+    ngx_tcp_session_t   *s;
+
+    c = rev->data;
+    s = c->data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, rev->log, 0, 
+                   "tcp websocket dummy read handler: %d", c->fd);
+
+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+    }
+}
+
+
+static void
+ngx_tcp_websocket_init_protocol(ngx_event_t *ev) 
+{
+    ngx_connection_t             *c;
+    ngx_tcp_session_t            *s;
+    ngx_tcp_websocket_ctx_t      *wctx;
+
+    c = ev->data;
+    s = c->data;
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+    wctx->parser = ngx_pcalloc(s->connection->pool,
+                               sizeof(http_request_parser));
+    if (wctx->parser == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    websocket_http_request_parser_init(wctx->parser, s);
+
+    c->read->handler = ngx_tcp_websocket_parse_protocol;
+
+    ngx_tcp_websocket_parse_protocol(ev);
+}
+
+
+static void 
+websocket_http_request_parser_init(http_request_parser *hp, void *data) 
+{
+    hp->data           = data;
+    hp->request_method = request_method;
+    hp->request_uri    = request_uri;
+    hp->fragment       = fragment;
+    hp->request_path   = request_path;
+    hp->query_string   = query_string;
+    hp->http_version   = http_version;
+    hp->http_field     = http_field;
+    hp->header_done    = header_done;
+    
+    http_request_parser_init(hp);
+}
+
+
+static void 
+request_method(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t          str;
+    ngx_tcp_session_t *s = data;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "METHOD: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+request_uri(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t          str;
+    ngx_tcp_session_t *s = data;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "URI: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+fragment(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t          str;
+    ngx_tcp_session_t *s = data;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "FRAGMENT: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+request_path(void *data, const signed char *at, size_t length)
+{
+    u_char                    *p, *last;
+    ngx_str_t                 *path;
+    ngx_tcp_session_t         *s = data;
+    ngx_tcp_websocket_ctx_t   *wctx;
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+#if (NGX_DEBUG)
+    ngx_str_t          str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "PATH: \"%V\"", &str);
+#endif
+    if (length == 0) {
+        return;
+    }
+
+    p = (u_char *)at;
+    last = p + length;
+    p++;
+
+    while (p != last) {
+
+        if (*p == '/' || *p == '?' || *p == '#') {
+            break;
+        }
+
+        p++;
+    }
+
+    path = &wctx->path;
+    path->len = p - (u_char *)at;
+    path->data = ngx_palloc(s->connection->pool, path->len); 
+    if (path->data == NULL) {
+        return;
+    }
+
+    ngx_memcpy(path->data, (u_char *) at, path->len);
+}
+
+
+static void 
+query_string(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t          str;
+    ngx_tcp_session_t *s = data;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "QUERY: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+http_version(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t          str;
+    ngx_tcp_session_t *s = data;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "VERSION: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+http_field(void *data, const signed char *field, 
+    size_t flen, const signed char *value, size_t vlen)
+{
+    u_char                    *last;
+    ngx_str_t                 *str;
+    ngx_tcp_session_t         *s = data;
+    ngx_tcp_websocket_ctx_t   *wctx;
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+#if (NGX_DEBUG)
+    ngx_str_t             str_field, str_value;
+
+    str_field.data = (u_char *) field;
+    str_field.len = flen;
+
+    str_value.data = (u_char *) value;
+    str_value.len = vlen;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "%V: %V", &str_field, &str_value);
+#endif
+
+    if ((flen == (sizeof("Host") - 1)) && 
+            (ngx_strncasecmp((u_char *)"Host", (u_char *)field, flen) == 0)) {
+
+        /*trim the port part from host string*/
+        last = ngx_strlchr((u_char *)value,
+                           (u_char *)value + vlen, (u_char)':');
+        if (last) {
+            vlen = last - (u_char *)value;
+        }
+
+        str = &wctx->host;
+
+        str->len = vlen;
+        str->data = ngx_palloc(s->connection->pool, vlen);
+        if (str->data == NULL) {
+            return;
+        }
+
+        ngx_memcpy(str->data, (u_char *)value, vlen);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                       "true host: %V", str);
+    }
+}
+
+
+static void 
+header_done(void *data, const signed char *at, size_t length)
+{
+    /*void */
+}
+
+
+static void 
+ngx_tcp_websocket_parse_protocol(ngx_event_t *ev)
+{
+    u_char                       *new_buf;
+    ssize_t                       size, n;
+    ngx_int_t                     rc;
+    ngx_connection_t             *c;
+    ngx_tcp_session_t            *s;
+    ngx_tcp_websocket_ctx_t      *wctx;
+    ngx_tcp_websocket_conf_t     *wcf;
+
+    c = ev->data;
+    s = c->data;
+
+    wcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_websocket_module);
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+    while (1) {
+        n = s->buffer->end - s->buffer->last;
+        /*Not enough buffer? Enlarge twice*/
+        if (n == 0) {
+            size = s->buffer->end - s->buffer->start;
+
+            if ((size_t)size > wcf->buffer_size << 3) {
+
+                ngx_log_error(NGX_LOG_ERR, ev->log, 0,
+                              "too large websocket handshake packet "
+                              "error with client: %V #%d",
+                              &c->addr_text, c->fd);
+
+                ngx_tcp_finalize_session(s);
+                return;
+            }
+
+            new_buf = ngx_palloc(c->pool, size * 2);
+            if (new_buf == NULL) {
+                goto websocket_recv_fail;
+            }
+
+            ngx_memcpy(new_buf, s->buffer->start, size);
+            
+            n = s->buffer->pos - s->buffer->start;
+            s->buffer->start = new_buf;
+            s->buffer->pos = new_buf + n;
+            s->buffer->last = new_buf + size;
+            s->buffer->end = new_buf + size * 2;
+
+            n = s->buffer->end - s->buffer->last;
+        }
+
+        size = c->recv(c, s->buffer->last, n);
+
+#if (NGX_DEBUG)
+        ngx_err_t                      err;
+
+        if (size >= 0 || size == NGX_AGAIN) {
+            err = 0;
+
+        } else {
+            err = ngx_socket_errno;
+
+        }
+
+        ngx_log_debug3(NGX_LOG_DEBUG_TCP, ev->log, err,
+                       "tcp websocket recv size: %d, client: %V #%d",
+                       size, &c->addr_text, c->fd);
+#endif
+
+        if (size > 0) {
+            s->buffer->last += size;
+            continue;
+
+        } else if (size == 0 || size == NGX_AGAIN) {
+            break;
+
+        } else {
+            c->error = 1;
+            goto websocket_recv_fail;
+        }
+    }
+
+    rc = websocket_http_request_parser_execute(wctx->parser);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, 0, 
+                   "tcp websocket parse rc: %d, fd: %d", rc, c->fd);
+
+    switch (rc) {
+
+    case NGX_AGAIN:
+        return;
+
+    case NGX_ERROR:
+        goto websocket_recv_fail;
+
+    case NGX_OK:
+        /* pass through */
+
+    default:
+        ngx_tcp_websocket_init_upstream(c, s);
+    }
+
+    return;
+
+websocket_recv_fail:
+
+    ngx_log_error(NGX_LOG_ERR, ev->log, 0,
+                  "recv websocket handshake packet error with client: %V #%d",
+                  &c->addr_text, c->fd);
+
+    ngx_tcp_finalize_session(s);
+}
+
+
+static ngx_int_t 
+websocket_http_request_parser_execute(http_request_parser *hp) 
+{
+    ssize_t                       n, offset, length;
+    ngx_int_t                     rc;
+    ngx_tcp_session_t            *s;
+
+    s = hp->data;
+
+    if ((s->buffer->last - s->buffer->pos) > 0) {
+        offset = s->buffer->pos - s->buffer->start;
+        length = s->buffer->last - s->buffer->start;
+
+        n = http_request_parser_execute(hp, (signed char *)s->buffer->start,
+                                        length, offset);
+        s->buffer->pos = s->buffer->start + n;
+
+        rc = http_request_parser_finish(hp);
+
+        if (rc == 0) {
+            return NGX_AGAIN;
+
+        } else if (rc == 1){
+            return NGX_OK;
+
+        } else {
+            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                          "http request parse error with client: %V #%d",
+                          &s->connection->addr_text, s->connection->fd);
+            return NGX_ERROR;
+        }
+    }
+    
+    return NGX_AGAIN;
+}
+
+
+static  void
+ngx_tcp_websocket_init_upstream(ngx_connection_t *c, ngx_tcp_session_t *s) 
+{
+    ngx_tcp_upstream_t           *u;
+    ngx_tcp_path_upstream_t      *pu;     
+    ngx_tcp_upstream_conf_t      *ucf;
+    ngx_tcp_websocket_ctx_t      *wctx;
+    ngx_tcp_websocket_conf_t     *wcf;
+    ngx_tcp_virtual_server_t     *vs;
+
+    s->connection->log->action = "ngx_tcp_websocket_init_upstream";
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+    vs = ngx_tcp_websocket_find_virtual_server(s, wctx);
+
+    if (vs) {
+        s->main_conf = vs->ctx->main_conf;
+        s->srv_conf = vs->ctx->srv_conf;
+    }
+
+    wcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_websocket_module);
+    if (wcf->upstream.upstream == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ngx_log_debug3(NGX_LOG_DEBUG_TCP, s->connection->log, 0, 
+                   "tcp websocket init upstream, scheme: \"%V\" "
+                   "path: \"%V\", host: \"%V\"",
+                   &wcf->scheme, &wctx->path, &wctx->host);
+
+    c->write->handler = ngx_tcp_websocket_dummy_write_handler;
+    c->read->handler = ngx_tcp_websocket_dummy_read_handler;
+
+    if (ngx_tcp_upstream_create(s) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    u = s->upstream;
+
+    u->conf = &wcf->upstream;
+
+    pu = ngx_tcp_websocket_find_path_upstream(s, wctx);
+
+    if (pu) {
+        ucf = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_conf_t));
+        if (ucf == NULL) {
+            ngx_tcp_finalize_session(s);
+            return;
+        }
+
+        ngx_memcpy(ucf, &wcf->upstream, sizeof(ngx_tcp_upstream_conf_t));
+
+        ucf->upstream = pu->upstream;
+
+        u->conf = ucf;
+    }
+
+    u->write_event_handler = ngx_tcp_upstream_websocket_proxy_init_handler;
+    u->read_event_handler = ngx_tcp_upstream_websocket_proxy_init_handler;
+
+    wctx->upstream = &u->peer;
+
+    wctx->buffer = ngx_create_temp_buf(s->connection->pool, 
+                                       (s->buffer->end - s->buffer->start));
+    if (wctx->buffer == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    /* move back to the start position, send the handshake 
+     * packet to backend server */
+    s->buffer->pos = s->buffer->start;
+    s->connection->read->ready = 1;
+
+    ngx_tcp_upstream_init(s);
+
+    return;
+}
+
+
+static ngx_tcp_virtual_server_t * 
+ngx_tcp_websocket_find_virtual_server(ngx_tcp_session_t *s, 
+    ngx_tcp_websocket_ctx_t *ctx)
+{
+    ngx_uint_t                 hash, i;
+    ngx_tcp_core_main_conf_t  *cmcf;
+    ngx_tcp_virtual_server_t  *vs;
+
+    cmcf = ngx_tcp_get_module_main_conf(s, ngx_tcp_core_module);
+
+    if (ctx->host.len == 0) {
+        return NULL;
+    }
+
+    hash = ngx_hash_key(ctx->host.data, ctx->host.len);
+
+    vs = cmcf->virtual_servers.elts;
+    for (i = 0; i < cmcf->virtual_servers.nelts; i++) {
+
+        if (vs[i].hash != hash) {
+            continue;
+        }
+
+        if ((vs[i].name.len != ctx->host.len)
+                || ngx_memcmp(vs[i].name.data, ctx->host.data,
+                              ctx->host.len) != 0){
+            continue;
+        }
+
+        return &vs[i];
+    }
+
+    return NULL;
+}
+
+
+static ngx_tcp_path_upstream_t *
+ngx_tcp_websocket_find_path_upstream(ngx_tcp_session_t *s,
+    ngx_tcp_websocket_ctx_t *ctx)
+{
+    ngx_uint_t                    i;
+    ngx_tcp_path_upstream_t      *pu;
+    ngx_tcp_websocket_conf_t     *wcf;
+
+    wcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_websocket_module);
+
+    pu = wcf->path_upstreams.elts;
+    for (i = 0; i < wcf->path_upstreams.nelts; i++) {
+        if ((pu[i].path.len != ctx->path.len)
+                || ngx_memcmp(pu[i].path.data, ctx->path.data,
+                              ctx->path.len) != 0) {
+            continue;
+        }
+
+        return &pu[i];
+    }
+
+    return NULL;
+}
+
+
+static void 
+ngx_tcp_upstream_websocket_proxy_init_handler(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_t *u)
+{
+    ngx_connection_t             *c;
+    ngx_tcp_websocket_ctx_t      *wctx;
+    ngx_tcp_websocket_conf_t     *wcf;
+
+    c = s->connection;
+    c->log->action = "ngx_tcp_upstream_websocket_proxy_init_handler";
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, s->connection->log, 
+                   0, "tcp upstream websocket proxy init handler");
+
+    wcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_websocket_module);
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+    if (wcf == NULL || wctx == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    wctx->upstream = &s->upstream->peer;
+
+    c = wctx->upstream->connection;
+    if (c->read->timedout || c->write->timedout) {
+        ngx_tcp_upstream_next(s, u, NGX_TCP_UPSTREAM_FT_TIMEOUT);
+        return;
+    }
+
+    if (ngx_tcp_upstream_check_broken_connection(s) != NGX_OK){
+        ngx_tcp_upstream_next(s, u, NGX_TCP_UPSTREAM_FT_ERROR);
+        return;
+    }
+
+    s->connection->read->handler = ngx_tcp_websocket_proxy_handler;
+    s->connection->write->handler = ngx_tcp_websocket_proxy_handler;
+
+    c->read->handler = ngx_tcp_websocket_proxy_handler;
+    c->write->handler = ngx_tcp_websocket_proxy_handler;
+
+    ngx_add_timer(c->read, wcf->upstream.read_timeout);
+    ngx_add_timer(c->write, wcf->upstream.send_timeout);
+
+#if (NGX_TCP_SSL)
+
+    if (s->connection->ssl) {
+        ngx_tcp_websocket_proxy_handler(s->connection->read); 
+        return;
+    }
+
+#endif
+
+    if (ngx_handle_read_event(s->connection->read, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ngx_tcp_websocket_proxy_handler(s->connection->read);
+
+    return;
+}
+
+
+static void
+ngx_tcp_websocket_proxy_handler(ngx_event_t *ev) 
+{
+    char                      *action, *recv_action, *send_action;
+    off_t                     *read_bytes, *write_bytes;
+    size_t                     size;
+    ssize_t                    n;
+    ngx_buf_t                 *b;
+    ngx_err_t                  err;
+    ngx_uint_t                 do_write;
+    ngx_connection_t          *c, *src, *dst;
+    ngx_tcp_session_t         *s;
+    ngx_tcp_websocket_ctx_t   *wctx;
+    ngx_tcp_core_srv_conf_t   *cscf;
+    ngx_tcp_websocket_conf_t  *wcf;
+
+    c = ev->data;
+    s = c->data;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    if (ev->timedout) {
+        c->log->action = "websocket proxying";
+
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
+                      "websocket timed out");
+
+        c->timedout = 1;
+
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    wctx = ngx_tcp_get_module_ctx(s, ngx_tcp_websocket_module);
+
+    if (wctx == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    read_bytes = NULL;
+    write_bytes = NULL;
+
+    if (c == s->connection) {
+        if (ev->write) {
+            recv_action = "client write: websocket proxying and reading from upstream";
+            send_action = "client write: websocket proxying and sending to client";
+            src = wctx->upstream->connection;
+            dst = c;
+            b = wctx->buffer;
+            write_bytes = &s->bytes_write;
+        } else {
+            recv_action = "client read: websocket proxying and reading from client";
+            send_action = "client read: websocket proxying and sending to upstream";
+            src = c;
+            dst = wctx->upstream->connection;
+            b = s->buffer;
+            read_bytes = &s->bytes_read;
+        }
+
+    } else {
+        if (ev->write) {
+            recv_action = "upstream write: websocket proxying and reading from client";
+            send_action = "upstream write: websocket proxying and sending to upstream";
+            src = s->connection;
+            dst = c;
+            b = s->buffer;
+            read_bytes = &s->bytes_read;
+        } else {
+            recv_action = "upstream read: websocket proxying and reading from upstream";
+            send_action = "upstream read: websocket proxying and sending to client";
+            src = c;
+            dst = s->connection;
+            b = wctx->buffer;
+            write_bytes = &s->bytes_write;
+        }
+    }
+
+    do_write = ev->write ? 1 : 0;
+
+    if (b->pos != b->last) {
+        do_write = 1;
+        if (read_bytes) {
+            *read_bytes += b->last - b->pos;
+        }
+    }
+
+    ngx_log_debug4(NGX_LOG_DEBUG_TCP, ev->log, 0,
+                   "tcp websocket proxy handler: %d, #%d > #%d, time:%ui",
+                   do_write, src->fd, dst->fd, ngx_current_msec);
+
+    for ( ;; ) {
+
+        if (do_write) {
+
+            size = b->last - b->pos;
+
+            if (size && dst->write->ready) {
+                c->log->action = send_action;
+
+                n = dst->send(dst, b->pos, size);
+                err = ngx_socket_errno;
+
+                ngx_log_debug1(NGX_LOG_DEBUG_TCP, ev->log, 0, 
+                               "tcp websocket proxy handler send:%d", n);
+
+                if (n == NGX_ERROR) {
+                    ngx_log_error(NGX_LOG_ERR, c->log, err, "websocket send error");
+
+                    ngx_tcp_finalize_session(s);
+                    return;
+                }
+
+                if (n > 0) {
+                    b->pos += n;
+
+                    if (write_bytes) {
+                        *write_bytes += n;
+                    }
+
+                    if (b->pos == b->last) {
+                        b->pos = b->start;
+                        b->last = b->start;
+                    }
+                }
+            }
+        }
+
+        size = b->end - b->last;
+
+        if (size && src->read->ready) {
+            c->log->action = recv_action;
+
+            n = src->recv(src, b->last, size);
+            err = ngx_socket_errno;
+
+            ngx_log_debug1(NGX_LOG_DEBUG_TCP, ev->log, 0,
+                           "tcp websocket proxy handler recv:%d", n);
+
+            if (n == NGX_AGAIN || n == 0) {
+                break;
+            }
+
+            if (n > 0) {
+                do_write = 1;
+                b->last += n;
+
+                if (read_bytes) {
+                    *read_bytes += n;
+                }
+
+                continue;
+            }
+
+            if (n == NGX_ERROR) {
+                src->read->eof = 1;
+            }
+        }
+
+        break;
+    }
+
+    c->log->action = "nginx tcp websocketing";
+
+    if ((s->connection->read->eof && s->buffer->pos == s->buffer->last)
+         || (wctx->upstream->connection->read->eof
+             && wctx->buffer->pos == wctx->buffer->last)
+         || (s->connection->read->eof
+             && wctx->upstream->connection->read->eof))
+    {
+        action = c->log->action;
+        c->log->action = NULL;
+        ngx_log_error(NGX_LOG_DEBUG, c->log, 0, "proxied session done");
+        c->log->action = action;
+
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_write_event(dst->write, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_read_event(dst->read, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_write_event(src->write, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    if (ngx_handle_read_event(src->read, 0) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    wcf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_websocket_module);
+
+    if (c == s->connection) {
+        ngx_add_timer(c->read, cscf->timeout);
+    }
+
+    if (c == wctx->upstream->connection) {
+        if (ev->write) {
+            ngx_add_timer(c->write, wcf->upstream.send_timeout);
+        } else {
+            ngx_add_timer(c->read, wcf->upstream.read_timeout);
+        }
+    }
+
+    return;
+}
+
+
+static char *
+ngx_tcp_websocket_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    ngx_tcp_websocket_conf_t   *wcf = conf;
+
+    size_t                      add = 0;
+    u_short                     port = 80;
+    ngx_str_t                  *value, *url = &wcf->url;
+    ngx_url_t                   u;
+    ngx_tcp_core_srv_conf_t    *cscf;
+    ngx_tcp_path_upstream_t    *pu;
+
+    cscf = ngx_tcp_conf_get_module_srv_conf(cf, ngx_tcp_core_module);
+
+    if (cscf->protocol && ngx_strncmp(cscf->protocol->name.data, 
+                                      (u_char *)"tcp_websocket",
+                                      sizeof("tcp_websocket") - 1) != 0) {
+
+        return "the protocol should be tcp_websocket";
+    }
+
+    if (cscf->protocol == NULL) {
+        cscf->protocol = &ngx_tcp_websocket_protocol;
+    }
+
+    value = cf->args->elts;
+
+    if (cf->args->nelts == 3) {
+        url = &value[2];
+    }
+    else {
+        url = &value[1];
+    }
+
+    if (ngx_strncasecmp(url->data, (u_char *)"ws://", 5) == 0) {
+        add = 5;
+        port = 80;
+    }
+    else if (ngx_strncasecmp(url->data, (u_char *)"wss://", 6) == 0) {
+        add = 6;
+        port = 443;
+    }
+
+    if (add) {
+        wcf->scheme.data = url->data;
+        wcf->scheme.len = add;
+    }
+    else {
+        wcf->scheme.data = (u_char *)"ws://";
+        wcf->scheme.len = 5;
+    }
+
+    url->data += add;
+    url->len  -= add;
+
+    ngx_memzero(&u, sizeof(u));
+
+    u.url.len = url->len;
+    u.url.data = url->data;
+    u.default_port = port;
+    u.uri_part = 1;
+    u.no_resolve = 1;
+
+    if (cf->args->nelts == 3) {
+        pu = ngx_array_push(&wcf->path_upstreams);
+        if (pu == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        pu->path = value[1];
+        pu->upstream = ngx_tcp_upstream_add(cf, &u, 0);
+    }
+    else {
+        if (wcf->upstream.upstream) {
+            return "is duplicate default upstream";
+        }
+
+        wcf->upstream.upstream = ngx_tcp_upstream_add(cf, &u, 0);
+        if (wcf->upstream.upstream == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_tcp_websocket_create_conf(ngx_conf_t *cf) 
+{
+    ngx_tcp_websocket_conf_t  *wcf;
+
+    wcf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_websocket_conf_t));
+    if (wcf == NULL) {
+        return NULL;
+    }
+
+    if (ngx_array_init(&wcf->path_upstreams, cf->pool, 
+                       4, sizeof(ngx_tcp_path_upstream_t)) != NGX_OK)  {
+        return NULL;
+    }
+ 
+    wcf->buffer_size = NGX_CONF_UNSET_SIZE;
+
+    wcf->upstream.connect_timeout = NGX_CONF_UNSET_MSEC;
+    wcf->upstream.send_timeout = NGX_CONF_UNSET_MSEC;
+    wcf->upstream.read_timeout = NGX_CONF_UNSET_MSEC;
+
+    return wcf;
+}
+
+
+static char *
+ngx_tcp_websocket_merge_conf(ngx_conf_t *cf, void *parent, void *child) 
+{
+    ngx_tcp_path_upstream_t  *pu;
+    ngx_tcp_websocket_conf_t *prev = parent;
+    ngx_tcp_websocket_conf_t *conf = child;
+    ngx_tcp_core_srv_conf_t    *cscf;
+
+    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size, (size_t) ngx_pagesize);
+
+    ngx_conf_merge_msec_value(conf->upstream.connect_timeout,
+                              prev->upstream.connect_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->upstream.send_timeout,
+                              prev->upstream.send_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->upstream.read_timeout,
+                              prev->upstream.read_timeout, 60000);
+
+    if (conf->upstream.upstream == NULL) {
+
+        if (conf->path_upstreams.nelts) {
+            pu = conf->path_upstreams.elts;
+            conf->upstream.upstream = pu[0].upstream;
+
+        } else {
+            cscf = ngx_tcp_conf_get_module_srv_conf(cf, ngx_tcp_core_module);
+            if (cscf->protocol && ngx_strncmp(cscf->protocol->name.data,
+                                              (u_char *)"tcp_websocket",
+                                              sizeof("tcp_websocket") - 1) == 0) {
+
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "You must add at least one websocket_pass "
+                                   "directive in the server block.");
+
+                return NGX_CONF_ERROR;
+            }
+        }
+    }
+
+    return NGX_CONF_OK;
+}
diff --git a/src/tcp/ngx_tcp.c b/src/tcp/ngx_tcp.c
new file mode 100755
index 0000000..b13c59a
--- /dev/null
+++ b/src/tcp/ngx_tcp.c
@@ -0,0 +1,594 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_tcp.h>
+
+
+static char *ngx_tcp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static ngx_int_t ngx_tcp_add_ports(ngx_conf_t *cf, ngx_array_t *ports,
+    ngx_tcp_listen_t *listen);
+static ngx_int_t ngx_tcp_add_virtual_servers(ngx_conf_t *cf, 
+        ngx_tcp_core_main_conf_t *cmcf, ngx_tcp_listen_t *listen);
+static char * ngx_tcp_optimize_servers(ngx_conf_t *cf, 
+        ngx_tcp_core_main_conf_t *cmcf, ngx_array_t *ports);
+static ngx_int_t ngx_tcp_add_addrs(ngx_conf_t *cf, ngx_tcp_port_t *mport,
+    ngx_tcp_conf_addr_t *addr);
+#if (NGX_HAVE_INET6)
+static ngx_int_t ngx_tcp_add_addrs6(ngx_conf_t *cf, ngx_tcp_port_t *mport,
+    ngx_tcp_conf_addr_t *addr);
+#endif
+static ngx_int_t ngx_tcp_cmp_conf_addrs(const void *one, const void *two);
+
+
+ngx_uint_t  ngx_tcp_max_module;
+
+
+static ngx_command_t  ngx_tcp_commands[] = {
+
+    { ngx_string("tcp"),
+      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_tcp_block,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_core_module_t  ngx_tcp_module_ctx = {
+    ngx_string("tcp"),
+    NULL,
+    NULL
+};
+
+
+ngx_module_t  ngx_tcp_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_module_ctx,                   /* module context */
+    ngx_tcp_commands,                      /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static char *
+ngx_tcp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char                        *rv;
+    ngx_uint_t                   i, m, mi, s;
+    ngx_conf_t                   pcf;
+    ngx_array_t                  ports;
+    ngx_tcp_listen_t           *listen;
+    ngx_tcp_module_t           *module;
+    ngx_tcp_conf_ctx_t         *ctx;
+    ngx_tcp_core_srv_conf_t   **cscfp;
+    ngx_tcp_core_main_conf_t   *cmcf;
+
+
+    /* the main tcp context */
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_conf_ctx_t));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *(ngx_tcp_conf_ctx_t **) conf = ctx;
+
+    /* count the number of the tcp modules and set up their indices */
+
+    ngx_tcp_max_module = 0;
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+            continue;
+        }
+
+        ngx_modules[m]->ctx_index = ngx_tcp_max_module++;
+    }
+
+
+    /* the tcp main_conf context, it is the same in the all tcp contexts */
+
+    ctx->main_conf = ngx_pcalloc(cf->pool,
+                                 sizeof(void *) * ngx_tcp_max_module);
+    if (ctx->main_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+
+    /*
+     * the tcp null srv_conf context, it is used to merge
+     * the server{}s' srv_conf's
+     */
+
+    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_tcp_max_module);
+    if (ctx->srv_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+
+    /*
+     * create the main_conf's, the null srv_conf's, and the null loc_conf's
+     * of the all tcp modules
+     */
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+        mi = ngx_modules[m]->ctx_index;
+
+        if (module->create_main_conf) {
+            ctx->main_conf[mi] = module->create_main_conf(cf);
+            if (ctx->main_conf[mi] == NULL) {
+                return NGX_CONF_ERROR;
+            }
+        }
+
+        if (module->create_srv_conf) {
+            ctx->srv_conf[mi] = module->create_srv_conf(cf);
+            if (ctx->srv_conf[mi] == NULL) {
+                return NGX_CONF_ERROR;
+            }
+        }
+    }
+
+
+    /* parse inside the tcp{} block */
+
+    pcf = *cf;
+    cf->ctx = ctx;
+
+    cf->module_type = NGX_TCP_MODULE;
+    cf->cmd_type = NGX_TCP_MAIN_CONF;
+    rv = ngx_conf_parse(cf, NULL);
+
+    if (rv != NGX_CONF_OK) {
+        *cf = pcf;
+        return rv;
+    }
+
+
+    /* init tcp{} main_conf's, merge the server{}s' srv_conf's */
+
+    cmcf = ctx->main_conf[ngx_tcp_core_module.ctx_index];
+    cscfp = cmcf->servers.elts;
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+        mi = ngx_modules[m]->ctx_index;
+
+        /* init tcp{} main_conf's */
+
+        cf->ctx = ctx;
+
+        if (module->init_main_conf) {
+            rv = module->init_main_conf(cf, ctx->main_conf[mi]);
+            if (rv != NGX_CONF_OK) {
+                *cf = pcf;
+                return rv;
+            }
+        }
+
+        for (s = 0; s < cmcf->servers.nelts; s++) {
+
+            /* merge the server{}s' srv_conf's */
+
+            cf->ctx = cscfp[s]->ctx;
+
+            if (module->merge_srv_conf) {
+                rv = module->merge_srv_conf(cf, ctx->srv_conf[mi],
+                                            cscfp[s]->ctx->srv_conf[mi]);
+                if (rv != NGX_CONF_OK) {
+                    *cf = pcf;
+                    return rv;
+                }
+            }
+        }
+    }
+
+    *cf = pcf;
+
+    if (ngx_array_init(&ports, cf->temp_pool, 4, sizeof(ngx_tcp_conf_port_t))
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    listen = cmcf->listen.elts;
+
+    for (i = 0; i < cmcf->listen.nelts; i++) {
+        if (ngx_tcp_add_ports(cf, &ports, &listen[i]) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_tcp_add_virtual_servers(cf, cmcf, &listen[i]) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    return ngx_tcp_optimize_servers(cf, cmcf, &ports);
+}
+
+
+static ngx_int_t
+ngx_tcp_add_ports(ngx_conf_t *cf, ngx_array_t *ports, ngx_tcp_listen_t *listen)
+{
+    in_port_t              p;
+    ngx_uint_t             i;
+    struct sockaddr       *sa;
+    struct sockaddr_in    *sin;
+    ngx_tcp_conf_port_t   *port;
+    ngx_tcp_conf_addr_t   *addr;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6   *sin6;
+#endif
+
+    sa = (struct sockaddr *) &listen->sockaddr;
+
+    switch (sa->sa_family) {
+
+#if (NGX_HAVE_INET6)
+    case AF_INET6:
+        sin6 = (struct sockaddr_in6 *) sa;
+        p = sin6->sin6_port;
+        break;
+#endif
+
+    default: /* AF_INET */
+        sin = (struct sockaddr_in *) sa;
+        p = sin->sin_port;
+        break;
+    }
+
+    port = ports->elts;
+    for (i = 0; i < ports->nelts; i++) {
+        if (p == port[i].port && sa->sa_family == port[i].family) {
+
+            /* a port is already in the port list */
+
+            port = &port[i];
+            goto found;
+        }
+    }
+
+    /* add a port to the port list */
+
+    port = ngx_array_push(ports);
+    if (port == NULL) {
+        return NGX_ERROR;
+    }
+
+    port->family = sa->sa_family;
+    port->port = p;
+
+    if (ngx_array_init(&port->addrs, cf->temp_pool, 2,
+                       sizeof(ngx_tcp_conf_addr_t))
+        != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+found:
+
+    addr = ngx_array_push(&port->addrs);
+    if (addr == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memzero(addr, sizeof(ngx_tcp_conf_addr_t));
+
+    addr->sockaddr = (struct sockaddr *) &listen->sockaddr;
+    addr->socklen = listen->socklen;
+    addr->ctx = listen->ctx;
+    addr->bind = listen->bind;
+    addr->wildcard = listen->wildcard;
+    if (listen->default_port) {
+        addr->default_ctx = listen->ctx;
+    }
+#if (NGX_TCP_SSL)
+    addr->ssl = listen->ssl;
+#endif
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+    addr->ipv6only = listen->ipv6only;
+#endif
+#if (NGX_HAVE_TPROXY)
+	addr->tproxy= listen->tproxy;
+#endif
+
+    return NGX_OK;
+}
+
+
+
+static ngx_int_t 
+ngx_tcp_add_virtual_servers(ngx_conf_t *cf, ngx_tcp_core_main_conf_t *cmcf,
+    ngx_tcp_listen_t *listen)
+{
+    ngx_tcp_core_srv_conf_t   *cscf;
+    ngx_tcp_virtual_server_t  *vs;
+
+    cscf = listen->conf;
+    if (cscf == NULL || cscf->server_name.len == 0) {
+        return NGX_OK;
+    }
+
+    vs = ngx_array_push(&cmcf->virtual_servers);
+    if (vs == NULL) {
+        return NGX_ERROR;
+    }
+
+    vs->name.len = cscf->server_name.len;
+    vs->name.data = cscf->server_name.data;
+    vs->hash = ngx_hash_key(vs->name.data, vs->name.len);
+    vs->listen = listen;
+    vs->ctx = listen->ctx;
+
+    return NGX_OK;
+}
+
+
+static char *
+ngx_tcp_optimize_servers(ngx_conf_t *cf, ngx_tcp_core_main_conf_t *cmcf,
+    ngx_array_t *ports)
+{
+    ngx_uint_t             i, p, last, bind_wildcard;
+    ngx_listening_t       *ls;
+    ngx_tcp_port_t        *mport;
+    ngx_tcp_conf_port_t   *port;
+    ngx_tcp_conf_addr_t   *addr;
+
+    port = ports->elts;
+    for (p = 0; p < ports->nelts; p++) {
+
+        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,
+                 sizeof(ngx_tcp_conf_addr_t), ngx_tcp_cmp_conf_addrs);
+
+        addr = port[p].addrs.elts;
+        last = port[p].addrs.nelts;
+
+        /*
+         * if there is the binding to the "*:port" then we need to bind()
+         * to the "*:port" only and ignore the other bindings
+         */
+
+        if (addr[last - 1].wildcard) {
+            addr[last - 1].bind = 1;
+            bind_wildcard = 1;
+
+        } else {
+            bind_wildcard = 0;
+        }
+
+        i = 0;
+
+        while (i < last) {
+
+            if (bind_wildcard && !addr[i].bind) {
+                i++;
+                continue;
+            }
+
+            ls = ngx_create_listening(cf, addr[i].sockaddr, addr[i].socklen);
+            if (ls == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ls->addr_ntop = 1;
+            ls->handler = ngx_tcp_init_connection;
+            ls->pool_size = 256;
+
+            /* TODO: error_log directive */
+            ls->logp = &cf->cycle->new_log;
+            ls->log.data = &ls->addr_text;
+            ls->log.handler = ngx_accept_log_error;
+
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+            ls->ipv6only = addr[i].ipv6only;
+#endif
+
+#if (NGX_HAVE_TPROXY)
+	 		ls->tproxy = addr[i].tproxy;
+#endif
+            mport = ngx_palloc(cf->pool, sizeof(ngx_tcp_port_t));
+            if (mport == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ls->servers = mport;
+
+            if (i == last - 1) {
+                mport->naddrs = last;
+
+            } else {
+                mport->naddrs = 1;
+                i = 0;
+            }
+
+            switch (ls->sockaddr->sa_family) {
+#if (NGX_HAVE_INET6)
+            case AF_INET6:
+                if (ngx_tcp_add_addrs6(cf, mport, addr) != NGX_OK) {
+                    return NGX_CONF_ERROR;
+                }
+                break;
+#endif
+            default: /* AF_INET */
+                if (ngx_tcp_add_addrs(cf, mport, addr) != NGX_OK) {
+                    return NGX_CONF_ERROR;
+                }
+                break;
+            }
+
+            addr++;
+            last--;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static ngx_int_t
+ngx_tcp_add_addrs(ngx_conf_t *cf, ngx_tcp_port_t *mport,
+    ngx_tcp_conf_addr_t *addr)
+{
+    u_char              *p;
+    size_t               len;
+    ngx_uint_t           i, j;
+    ngx_tcp_in_addr_t   *addrs;
+    struct sockaddr_in  *sin, *sin_b;
+    u_char               buf[NGX_SOCKADDR_STRLEN];
+
+    mport->addrs = ngx_pcalloc(cf->pool,
+                               mport->naddrs * sizeof(ngx_tcp_in_addr_t));
+    if (mport->addrs == NULL) {
+        return NGX_ERROR;
+    }
+
+    addrs = mport->addrs;
+
+    for (i = 0; i < mport->naddrs; i++) {
+
+        sin = (struct sockaddr_in *) addr[i].sockaddr;
+        addrs[i].addr = sin->sin_addr.s_addr;
+
+        addrs[i].conf.ctx = addr[i].ctx;
+
+        for (j = 0; j < mport->naddrs; j++) {
+            sin_b = (struct sockaddr_in *) addr[j].sockaddr;
+            if ((sin->sin_addr.s_addr == sin_b->sin_addr.s_addr) && addr[j].default_ctx) {
+                addrs[i].conf.default_ctx = addr[j].default_ctx;
+            }
+        }
+
+#if (NGX_TCP_SSL)
+        addrs[i].conf.ssl = addr[i].ssl;
+#endif
+
+#if defined(nginx_version) && nginx_version >= 1005003
+        len = ngx_sock_ntop(addr[i].sockaddr, addr[i].socklen, buf, NGX_SOCKADDR_STRLEN, 1);
+#else
+        len = ngx_sock_ntop(addr[i].sockaddr, buf, NGX_SOCKADDR_STRLEN, 1);
+#endif
+
+        p = ngx_pnalloc(cf->pool, len);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(p, buf, len);
+
+        addrs[i].conf.addr_text.len = len;
+        addrs[i].conf.addr_text.data = p;
+    }
+
+    return NGX_OK;
+}
+
+
+#if (NGX_HAVE_INET6)
+
+static ngx_int_t
+ngx_tcp_add_addrs6(ngx_conf_t *cf, ngx_tcp_port_t *mport,
+    ngx_tcp_conf_addr_t *addr)
+{
+    u_char               *p;
+    size_t                len;
+    ngx_uint_t            i, j;
+    ngx_tcp_in6_addr_t   *addrs6;
+    struct sockaddr_in6  *sin6, *sin6_b;
+    u_char                buf[NGX_SOCKADDR_STRLEN];
+
+    mport->addrs = ngx_pcalloc(cf->pool,
+                               mport->naddrs * sizeof(ngx_tcp_in6_addr_t));
+    if (mport->addrs == NULL) {
+        return NGX_ERROR;
+    }
+
+    addrs6 = mport->addrs;
+
+    for (i = 0; i < mport->naddrs; i++) {
+
+        sin6 = (struct sockaddr_in6 *) addr[i].sockaddr;
+        addrs6[i].addr6 = sin6->sin6_addr;
+
+        addrs6[i].conf.ctx = addr[i].ctx;
+
+        for (j = 0; j < mport->naddrs; j++) {
+            sin6_b = (struct sockaddr_in6 *) addr[j].sockaddr;
+
+            if ((ngx_memcmp(&sin6->sin6_addr, &sin6_b->sin6_addr, 16) == 0) && 
+                    addr[j].default_ctx) {
+                addrs6[i].conf.default_ctx = addr[j].default_ctx;
+            }
+        }
+
+#if (NGX_TCP_SSL)
+        addrs6[i].conf.ssl = addr[i].ssl;
+#endif
+
+#if defined(nginx_version) && nginx_version >= 1005003
+        len = ngx_sock_ntop(addr[i].sockaddr, addr[i].socklen, buf, NGX_SOCKADDR_STRLEN, 1);
+#else
+        len = ngx_sock_ntop(addr[i].sockaddr, buf, NGX_SOCKADDR_STRLEN, 1);
+#endif
+
+        p = ngx_pnalloc(cf->pool, len);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(p, buf, len);
+
+        addrs6[i].conf.addr_text.len = len;
+        addrs6[i].conf.addr_text.data = p;
+    }
+
+    return NGX_OK;
+}
+
+#endif
+
+
+static ngx_int_t
+ngx_tcp_cmp_conf_addrs(const void *one, const void *two)
+{
+    ngx_tcp_conf_addr_t  *first, *second;
+
+    first = (ngx_tcp_conf_addr_t *) one;
+    second = (ngx_tcp_conf_addr_t *) two;
+
+    if (first->wildcard) {
+        /* a wildcard must be the last resort, shift it to the end */
+        return 1;
+    }
+
+    if (first->bind && !second->bind) {
+        /* shift explicit bind()ed addresses to the start */
+        return -1;
+    }
+
+    if (!first->bind && second->bind) {
+        /* shift explicit bind()ed addresses to the start */
+        return 1;
+    }
+
+    /* do not sort by default */
+
+    return 0;
+}
diff --git a/src/tcp/ngx_tcp.h b/src/tcp/ngx_tcp.h
new file mode 100755
index 0000000..ae98a18
--- /dev/null
+++ b/src/tcp/ngx_tcp.h
@@ -0,0 +1,286 @@
+
+#ifndef _NGX_TCP_H_INCLUDED_
+#define _NGX_TCP_H_INCLUDED_
+
+
+#include <nginx.h>
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+
+
+typedef struct ngx_tcp_protocol_s  ngx_tcp_protocol_t;
+typedef struct ngx_tcp_upstream_s  ngx_tcp_upstream_t;
+typedef struct ngx_tcp_cleanup_s  ngx_tcp_cleanup_t;
+
+typedef struct ngx_tcp_core_srv_conf_s ngx_tcp_core_srv_conf_t;
+
+typedef struct ngx_tcp_upstream_srv_conf_s  ngx_tcp_upstream_srv_conf_t;
+typedef struct ngx_tcp_upstream_resolved_s  ngx_tcp_upstream_resolved_t;
+
+typedef struct ngx_tcp_check_peer_conf_s ngx_tcp_check_peer_conf_t;
+typedef struct ngx_tcp_check_peers_conf_s ngx_tcp_check_peers_conf_t;
+typedef struct check_conf_s check_conf_t;
+
+/* make nginx-0.8.22+ happy */
+#if defined(nginx_version) && nginx_version >= 8022
+typedef ngx_addr_t ngx_peer_addr_t; 
+#endif
+
+#include <ngx_tcp_session.h>
+#include <ngx_tcp_upstream.h>
+#include <ngx_tcp_upstream_check.h>
+#include <ngx_tcp_upstream_round_robin.h>
+
+#if (NGX_TCP_SSL)
+#include <ngx_tcp_ssl_module.h>
+#endif
+
+
+typedef struct {
+    void                  **main_conf;
+    void                  **srv_conf;
+} ngx_tcp_conf_ctx_t;
+
+
+typedef struct {
+    u_char                  sockaddr[NGX_SOCKADDRLEN];
+    socklen_t               socklen;
+
+    /* server ctx */
+    ngx_tcp_conf_ctx_t     *ctx;
+
+    unsigned                default_port:1;
+    unsigned                bind:1;
+    unsigned                wildcard:1;
+#if (NGX_TCP_SSL)
+    unsigned                ssl:1;
+#endif
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+    unsigned                ipv6only:2;
+#endif
+#if (NGX_HAVE_TPROXY)
+	 unsigned				tproxy:1;
+#endif
+
+    ngx_tcp_core_srv_conf_t *conf;
+} ngx_tcp_listen_t;
+
+
+typedef struct {
+    ngx_str_t                name;
+} ngx_tcp_server_name_t;
+
+
+typedef struct {
+    ngx_uint_t               hash;
+    ngx_str_t                name;
+    ngx_tcp_listen_t        *listen;
+    ngx_tcp_conf_ctx_t      *ctx;
+} ngx_tcp_virtual_server_t;
+
+
+typedef struct {
+    ngx_str_t                name;
+} ngx_tcp_core_loc_t;
+
+
+typedef struct {
+    ngx_tcp_conf_ctx_t      *ctx;
+    ngx_tcp_conf_ctx_t      *default_ctx;
+    ngx_str_t                addr_text;
+#if (NGX_TCP_SSL)
+    ngx_uint_t               ssl;    /* unsigned   ssl:1; */
+#endif
+} ngx_tcp_addr_conf_t;
+
+typedef struct {
+    in_addr_t                addr;
+    ngx_tcp_addr_conf_t      conf;
+} ngx_tcp_in_addr_t;
+
+
+#if (NGX_HAVE_INET6)
+
+typedef struct {
+    struct in6_addr          addr6;
+    ngx_tcp_addr_conf_t      conf;
+} ngx_tcp_in6_addr_t;
+
+#endif
+
+
+typedef struct {
+    /* ngx_tcp_in_addr_t or ngx_tcp_in6_addr_t */
+    void                    *addrs;
+    ngx_uint_t               naddrs;
+} ngx_tcp_port_t;
+
+
+typedef struct {
+    int                      family;
+    in_port_t                port;
+    ngx_array_t              addrs;       /* array of ngx_tcp_conf_addr_t */
+} ngx_tcp_conf_port_t;
+
+
+typedef struct {
+    struct sockaddr         *sockaddr;
+    socklen_t                socklen;
+
+    ngx_tcp_conf_ctx_t      *ctx;
+    ngx_tcp_conf_ctx_t      *default_ctx;
+
+    unsigned                 bind:1;
+    unsigned                 wildcard:1;
+#if (NGX_TCP_SSL)
+    unsigned                 ssl:1;
+#endif
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+    unsigned                 ipv6only:2;
+#endif
+#if (NGX_HAVE_TPROXY)
+    unsigned                 tproxy:1;
+#endif
+
+} ngx_tcp_conf_addr_t;
+
+typedef struct {
+    in_addr_t                mask;
+    in_addr_t                addr;
+    ngx_uint_t               deny;      /* unsigned  deny:1; */
+} ngx_tcp_access_rule_t;
+
+typedef struct {
+    ngx_array_t              servers;         /* ngx_tcp_core_srv_conf_t */
+    ngx_array_t              listen;          /* ngx_tcp_listen_t */
+    ngx_array_t              virtual_servers; /* ngx_tcp_virtual_server_t */
+} ngx_tcp_core_main_conf_t;
+
+typedef struct {
+    ngx_open_file_t         *file;
+    time_t                   disk_full_time;
+    time_t                   error_log_time;
+} ngx_tcp_log_t;
+
+typedef struct {
+    u_char                  *start;
+    u_char                  *pos;
+    u_char                  *last;
+} ngx_tcp_log_buf_t;
+
+typedef struct {
+    ngx_array_t             *logs;       /* array of ngx_tcp_log_t */
+
+    ngx_open_file_cache_t   *open_file_cache;
+    time_t                   open_file_cache_valid;
+    ngx_uint_t               open_file_cache_min_uses;
+
+    ngx_uint_t               off;        /* unsigned  off:1 */
+} ngx_tcp_log_srv_conf_t;
+
+
+#define NGX_TCP_GENERIC_PROTOCOL    0
+#define NGX_TCP_WEBSOCKET_PROTOCOL  1
+
+
+struct ngx_tcp_core_srv_conf_s {
+    /* array of the ngx_tcp_server_name_t, "server_name" directive */
+    ngx_array_t              server_names;
+
+    /* array of the ngx_tcp_core_loc_t, "location" directive */
+    ngx_array_t              locations;
+
+    ngx_tcp_protocol_t      *protocol;
+
+    ngx_msec_t               timeout;
+    ngx_msec_t               resolver_timeout;
+
+    ngx_flag_t               so_keepalive;
+    ngx_flag_t               tcp_nodelay;
+
+    ngx_str_t                server_name;
+
+    u_char                  *file_name;
+    ngx_int_t                line;
+
+    ngx_resolver_t          *resolver;
+
+    /*ACL rules*/
+    ngx_array_t             *rules;
+
+    ngx_tcp_log_srv_conf_t  *access_log;
+
+    /* server ctx */
+    ngx_tcp_conf_ctx_t      *ctx;
+};
+
+
+typedef struct {
+    ngx_str_t              *client;
+    ngx_tcp_session_t      *session;
+} ngx_tcp_log_ctx_t;
+
+
+typedef void (*ngx_tcp_init_session_pt)(ngx_tcp_session_t *s);
+typedef void (*ngx_tcp_init_protocol_pt)(ngx_event_t *rev);
+typedef void (*ngx_tcp_parse_protocol_pt)(ngx_event_t *rev);
+
+
+struct ngx_tcp_protocol_s {
+    ngx_str_t                   name;
+    in_port_t                   port[4];
+    ngx_uint_t                  type;
+
+    ngx_tcp_init_session_pt     init_session;
+    ngx_tcp_init_protocol_pt    init_protocol;
+    ngx_tcp_parse_protocol_pt   parse_protocol;
+
+    ngx_str_t                   internal_server_error;
+};
+
+
+typedef struct {
+    ngx_tcp_protocol_t         *protocol;
+
+    void                       *(*create_main_conf)(ngx_conf_t *cf);
+    char                       *(*init_main_conf)(ngx_conf_t *cf, void *conf);
+
+    void                       *(*create_srv_conf)(ngx_conf_t *cf);
+    char                       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev,
+                                      void *conf);
+} ngx_tcp_module_t;
+
+
+#define NGX_TCP_MODULE         0x00504354     /* "TCP" */
+
+#define NGX_TCP_MAIN_CONF      0x02000000
+#define NGX_TCP_SRV_CONF       0x04000000
+#define NGX_TCP_LOC_CONF       0x08000000
+#define NGX_TCP_UPS_CONF       0x10000000
+
+
+#define NGX_TCP_MAIN_CONF_OFFSET  offsetof(ngx_tcp_conf_ctx_t, main_conf)
+#define NGX_TCP_SRV_CONF_OFFSET   offsetof(ngx_tcp_conf_ctx_t, srv_conf)
+
+
+#define ngx_tcp_get_module_ctx(s, module)     (s)->ctx[module.ctx_index]
+#define ngx_tcp_set_ctx(s, c, module)         s->ctx[module.ctx_index] = c;
+#define ngx_tcp_delete_ctx(s, module)         s->ctx[module.ctx_index] = NULL;
+
+
+#define ngx_tcp_get_module_main_conf(s, module)                             \
+    (s)->main_conf[module.ctx_index]
+#define ngx_tcp_get_module_srv_conf(s, module)  (s)->srv_conf[module.ctx_index]
+
+#define ngx_tcp_conf_get_module_main_conf(cf, module)                       \
+    ((ngx_tcp_conf_ctx_t *) cf->ctx)->main_conf[module.ctx_index]
+#define ngx_tcp_conf_get_module_srv_conf(cf, module)                        \
+    ((ngx_tcp_conf_ctx_t *) cf->ctx)->srv_conf[module.ctx_index]
+
+
+extern ngx_uint_t    ngx_tcp_max_module;
+extern ngx_module_t  ngx_tcp_core_module;
+
+#endif /* _NGX_TCP_H_INCLUDED_ */
diff --git a/src/tcp/ngx_tcp_access.c b/src/tcp/ngx_tcp_access.c
new file mode 100755
index 0000000..e172bb3
--- /dev/null
+++ b/src/tcp/ngx_tcp_access.c
@@ -0,0 +1,49 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+ngx_int_t
+ngx_tcp_access_handler(ngx_tcp_session_t *s) 
+{
+    ngx_uint_t                   i;
+    struct sockaddr_in          *sin;
+    ngx_tcp_access_rule_t       *rule;
+    ngx_tcp_core_srv_conf_t     *cscf;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    if (cscf->rules == NULL) {
+        return NGX_DECLINED;
+    }
+
+    /* AF_INET only */
+
+    if (s->connection->sockaddr->sa_family != AF_INET) {
+        return NGX_DECLINED;
+    }
+
+    sin = (struct sockaddr_in *) s->connection->sockaddr;
+
+    rule = cscf->rules->elts;
+    for (i = 0; i < cscf->rules->nelts; i++) {
+
+        ngx_log_debug3(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                       "access: %08XD %08XD %08XD",
+                       sin->sin_addr.s_addr, rule[i].mask, rule[i].addr);
+
+        if ((sin->sin_addr.s_addr & rule[i].mask) == rule[i].addr) {
+            if (rule[i].deny) {
+                ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                              "access forbidden by rule");
+
+                return NGX_ERROR;
+            }
+
+            return NGX_OK;
+        }
+    }
+
+    return NGX_DECLINED;
+}
diff --git a/src/tcp/ngx_tcp_core_module.c b/src/tcp/ngx_tcp_core_module.c
new file mode 100755
index 0000000..2a0eeed
--- /dev/null
+++ b/src/tcp/ngx_tcp_core_module.c
@@ -0,0 +1,919 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_tcp.h>
+#include <nginx.h>
+
+
+static void *ngx_tcp_core_create_main_conf(ngx_conf_t *cf);
+static void *ngx_tcp_core_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_tcp_core_merge_srv_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+static char *ngx_tcp_core_server(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_core_location(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_access_rule(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_log_set_access_log(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+static ngx_command_t  ngx_tcp_core_commands[] = {
+
+    { ngx_string("server"),
+      NGX_TCP_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_MULTI|NGX_CONF_NOARGS,
+      ngx_tcp_core_server,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("listen"),
+      NGX_TCP_SRV_CONF|NGX_CONF_1MORE,
+      ngx_tcp_core_listen,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("server_names"),
+      NGX_TCP_SRV_CONF|NGX_CONF_1MORE,
+      ngx_tcp_core_server_name,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("location"),
+      NGX_TCP_SRV_CONF|NGX_TCP_LOC_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE1,
+      ngx_tcp_core_location,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("protocol"),
+      NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_tcp_core_protocol,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("so_keepalive"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_core_srv_conf_t, so_keepalive),
+      NULL },
+
+    { ngx_string("tcp_nodelay"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_core_srv_conf_t, tcp_nodelay),
+      NULL },
+
+    { ngx_string("timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_core_srv_conf_t, timeout),
+      NULL },
+
+    { ngx_string("server_name"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_core_srv_conf_t, server_name),
+      NULL },
+
+    { ngx_string("resolver"),
+#if defined(nginx_version) && nginx_version >= 1001007
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_1MORE,
+#else
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+#endif
+      ngx_tcp_core_resolver,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("resolver_timeout"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_core_srv_conf_t, resolver_timeout),
+      NULL },
+
+    { ngx_string("allow"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_tcp_access_rule,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("deny"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_tcp_access_rule,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("access_log"),
+      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE12,
+      ngx_tcp_log_set_access_log,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_core_module_ctx = {
+    NULL,                                  /* protocol */
+
+    ngx_tcp_core_create_main_conf,         /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_tcp_core_create_srv_conf,          /* create server configuration */
+    ngx_tcp_core_merge_srv_conf            /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_core_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_core_module_ctx,              /* module context */
+    ngx_tcp_core_commands,                 /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t  ngx_tcp_access_log = ngx_string("logs/tcp_access.log");
+
+
+static void *
+ngx_tcp_core_create_main_conf(ngx_conf_t *cf) 
+{
+    ngx_tcp_core_main_conf_t  *cmcf;
+
+    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_core_main_conf_t));
+    if (cmcf == NULL) {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cmcf->servers, cf->pool, 4,
+                       sizeof(ngx_tcp_core_srv_conf_t *))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cmcf->listen, cf->pool, 4, sizeof(ngx_tcp_listen_t))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cmcf->virtual_servers, cf->pool, 4, 
+                       sizeof(ngx_tcp_virtual_server_t)) != NGX_OK)
+    {
+        return NULL;
+    }
+
+
+    return cmcf;
+}
+
+
+static void *
+ngx_tcp_core_create_srv_conf(ngx_conf_t *cf) 
+{
+    ngx_tcp_core_srv_conf_t  *cscf;
+    ngx_tcp_log_srv_conf_t   *lscf;
+
+    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_core_srv_conf_t));
+    if (cscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     cscf->protocol = NULL;
+     */
+
+    if (ngx_array_init(&cscf->server_names, cf->pool, 4,
+                       sizeof(ngx_tcp_server_name_t))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    if (ngx_array_init(&cscf->locations, cf->pool, 4,
+                       sizeof(ngx_tcp_core_loc_t))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    cscf->timeout = NGX_CONF_UNSET_MSEC;
+    cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;
+    cscf->so_keepalive = NGX_CONF_UNSET;
+    cscf->tcp_nodelay = NGX_CONF_UNSET;
+
+    cscf->resolver = NGX_CONF_UNSET_PTR;
+
+    cscf->file_name = cf->conf_file->file.name.data;
+    cscf->line = cf->conf_file->line;
+
+    lscf = cscf->access_log = ngx_pcalloc(cf->pool, 
+                                          sizeof(ngx_tcp_log_srv_conf_t));
+    if (lscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     lscf->logs = NULL;
+     */
+
+    lscf->open_file_cache = NGX_CONF_UNSET_PTR;
+
+    return cscf;
+}
+
+
+static char *
+ngx_tcp_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child) 
+{
+    ngx_uint_t               m;
+    ngx_tcp_log_t           *log;
+    ngx_tcp_module_t        *module;
+    ngx_tcp_core_srv_conf_t *prev = parent;
+    ngx_tcp_core_srv_conf_t *conf = child;
+    ngx_tcp_log_srv_conf_t  *plscf = prev->access_log;
+    ngx_tcp_log_srv_conf_t  *lscf = conf->access_log;
+
+    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);
+    ngx_conf_merge_msec_value(conf->resolver_timeout,
+                              prev->resolver_timeout, 30000);
+
+    ngx_conf_merge_value(conf->so_keepalive, prev->so_keepalive, 0);
+    ngx_conf_merge_value(conf->tcp_nodelay, prev->tcp_nodelay, 1);
+
+    ngx_conf_merge_str_value(conf->server_name, prev->server_name, "");
+
+    if (conf->protocol == NULL) {
+        for (m = 0; ngx_modules[m]; m++) {
+            if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+                continue;
+            }
+
+            module = ngx_modules[m]->ctx;
+
+            /* TODO: use a function */
+            if (module->protocol 
+                    && (ngx_strcmp(module->protocol->name.data, "tcp_generic")) == 0)
+            {
+                conf->protocol = module->protocol;
+            }
+        }
+    }
+
+    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);
+
+    if (conf->rules == NULL) {
+        conf->rules = prev->rules;
+    }
+
+    if (lscf->open_file_cache == NGX_CONF_UNSET_PTR) {
+
+        lscf->open_file_cache = plscf->open_file_cache;
+        lscf->open_file_cache_valid = plscf->open_file_cache_valid;
+        lscf->open_file_cache_min_uses = plscf->open_file_cache_min_uses;
+
+        if (lscf->open_file_cache == NGX_CONF_UNSET_PTR) {
+            lscf->open_file_cache = NULL;
+        }
+    }
+
+    if (lscf->logs || lscf->off) {
+        return NGX_CONF_OK;
+    }
+
+    lscf->logs = plscf->logs;
+    lscf->off = plscf->off;
+
+    if (lscf->logs || lscf->off) {
+        return NGX_CONF_OK;
+    }
+
+    lscf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_tcp_log_t));
+    if (lscf->logs == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    log = ngx_array_push(lscf->logs);
+    if (log == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    log->file = ngx_conf_open_file(cf->cycle, &ngx_tcp_access_log);
+    if (log->file == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    log->disk_full_time = 0;
+    log->error_log_time = 0;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char                       *rv;
+    void                       *mconf;
+    ngx_uint_t                  m;
+    ngx_conf_t                  pcf;
+    ngx_tcp_module_t           *module;
+    ngx_tcp_conf_ctx_t         *ctx, *tcp_ctx;
+    ngx_tcp_core_srv_conf_t    *cscf, **cscfp;
+    ngx_tcp_core_main_conf_t   *cmcf;
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_conf_ctx_t));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    tcp_ctx = cf->ctx;
+    ctx->main_conf = tcp_ctx->main_conf;
+
+    /* the server{}'s srv_conf */
+
+    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_tcp_max_module);
+    if (ctx->srv_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+
+        if (module->create_srv_conf) {
+            mconf = module->create_srv_conf(cf);
+            if (mconf == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;
+        }
+    }
+
+    /* the server configuration context */
+
+    cscf = ctx->srv_conf[ngx_tcp_core_module.ctx_index];
+    cscf->ctx = ctx;
+
+    cmcf = ctx->main_conf[ngx_tcp_core_module.ctx_index];
+
+    cscfp = ngx_array_push(&cmcf->servers);
+    if (cscfp == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *cscfp = cscf;
+
+    /* parse inside server{} */
+
+    pcf = *cf;
+    cf->ctx = ctx;
+    cf->cmd_type = NGX_TCP_SRV_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    return rv;
+}
+
+
+static char *
+ngx_tcp_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    size_t                      len, off;
+    in_port_t                   port;
+    ngx_str_t                  *value;
+    ngx_url_t                   u;
+    ngx_uint_t                  i;
+    struct sockaddr            *sa;
+    ngx_tcp_listen_t           *ls;
+    struct sockaddr_in         *sin;
+    ngx_tcp_core_main_conf_t   *cmcf;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6        *sin6;
+#endif
+
+    value = cf->args->elts;
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    u.url = value[1];
+    u.listen = 1;
+
+    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+        if (u.err) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "%s in \"%V\" of the \"listen\" directive",
+                               u.err, &u.url);
+        }
+
+        return NGX_CONF_ERROR;
+    }
+
+    cmcf = ngx_tcp_conf_get_module_main_conf(cf, ngx_tcp_core_module);
+
+    ls = cmcf->listen.elts;
+
+    for (i = 0; i < cmcf->listen.nelts; i++) {
+
+        sa = (struct sockaddr *) ls[i].sockaddr;
+
+        if (sa->sa_family != u.family) {
+            continue;
+        }
+
+        switch (sa->sa_family) {
+
+#if (NGX_HAVE_INET6)
+            case AF_INET6:
+                off = offsetof(struct sockaddr_in6, sin6_addr);
+                len = 16;
+                sin6 = (struct sockaddr_in6 *) sa;
+                port = sin6->sin6_port;
+                break;
+#endif
+
+            default: /* AF_INET */
+                off = offsetof(struct sockaddr_in, sin_addr);
+                len = 4;
+                sin = (struct sockaddr_in *) sa;
+                port = sin->sin_port;
+                break;
+        }
+
+        if (ngx_memcmp(ls[i].sockaddr + off, u.sockaddr + off, len) != 0) {
+            continue;
+        }
+
+        if (port != u.port) {
+            continue;
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "duplicate \"%V\" address and port pair", &u.url);
+        return NGX_CONF_ERROR;
+    }
+
+    ls = ngx_array_push(&cmcf->listen);
+    if (ls == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memzero(ls, sizeof(ngx_tcp_listen_t));
+
+    ngx_memcpy(ls->sockaddr, u.sockaddr, u.socklen);
+
+    ls->socklen = u.socklen;
+    ls->wildcard = u.wildcard;
+    ls->ctx = cf->ctx;
+    ls->conf = conf;
+
+    for (i = 2; i < cf->args->nelts; i++) {
+
+
+		if (ngx_strcmp(value[i].data, "tproxy") == 0) {
+#if (NGX_HAVE_TPROXY)
+			ls->tproxy = 1; 
+#else
+			ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+			"TPROXY support is not enabled, ignoring option \"tproxy\" in %V",
+			&value[i]);
+#endif
+			continue;
+		}
+
+
+        if (ngx_strcmp(value[i].data, "bind") == 0) {
+            ls->bind = 1;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "default") == 0) {
+            ls->default_port = 1;
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "ipv6only=o", 10) == 0) {
+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
+            struct sockaddr  *sa;
+            u_char            buf[NGX_SOCKADDR_STRLEN];
+
+            sa = (struct sockaddr *) ls->sockaddr;
+
+            if (sa->sa_family == AF_INET6) {
+
+                if (ngx_strcmp(&value[i].data[10], "n") == 0) {
+                    ls->ipv6only = 1;
+
+                } else if (ngx_strcmp(&value[i].data[10], "ff") == 0) {
+                    ls->ipv6only = 2;
+
+                } else {
+                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                            "invalid ipv6only flags \"%s\"",
+                            &value[i].data[9]);
+                    return NGX_CONF_ERROR;
+                }
+
+                ls->bind = 1;
+
+            } else {
+#if defined(nginx_version) && nginx_version >= 1005003
+                len = ngx_sock_ntop(sa, ls->socklen, buf, NGX_SOCKADDR_STRLEN, 1);
+#else
+                len = ngx_sock_ntop(sa, buf, NGX_SOCKADDR_STRLEN, 1);
+#endif
+
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "ipv6only is not supported "
+                        "on addr \"%*s\", ignored", len, buf);
+            }
+
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "bind ipv6only is not supported "
+                    "on this platform");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
+        if (ngx_strcmp(value[i].data, "ssl") == 0) {
+#if (NGX_TCP_SSL)
+            ls->ssl = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"ssl\" parameter requires "
+                               "ngx_tcp_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "the invalid \"%V\" parameter", &value[i]);
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_core_srv_conf_t *cscf = conf;
+
+    ngx_str_t               *value;
+    ngx_uint_t               i;
+    ngx_tcp_server_name_t   *sn;
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+
+        sn = ngx_array_push(&cscf->server_names);
+        if (sn == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcasecmp(value[i].data, (u_char *) "$hostname") == 0) {
+            sn->name = cf->cycle->hostname;
+
+        } else {
+            sn->name = value[i];
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_core_location(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_core_srv_conf_t   *cscf = conf;
+
+    char                      *rv;
+    ngx_str_t                 *value;
+    ngx_conf_t                 save;
+    ngx_tcp_core_loc_t        *clcf;
+
+    clcf = ngx_array_push(&cscf->locations);
+    if (clcf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    value = cf->args->elts;
+
+    clcf->name = value[1];
+
+    save = *cf;
+    cf->cmd_type = NGX_TCP_LOC_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = save;
+
+    return rv;
+}
+
+
+static char *
+ngx_tcp_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_core_srv_conf_t  *cscf = conf;
+
+    ngx_str_t          *value;
+    ngx_uint_t          m;
+    ngx_tcp_module_t   *module;
+
+    value = cf->args->elts;
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+
+        if (module->protocol
+            && ngx_strcmp(module->protocol->name.data, value[1].data) == 0)
+        {
+            cscf->protocol = module->protocol;
+
+            return NGX_CONF_OK;
+        }
+    }
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "unknown protocol \"%V\"", &value[1]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static char *
+ngx_tcp_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    ngx_tcp_core_srv_conf_t  *cscf = conf;
+
+#if defined(nginx_version) && nginx_version < 1001007
+    ngx_url_t   u;
+#endif
+    ngx_str_t  *value;
+
+    value = cf->args->elts;
+
+    if (cscf->resolver != NGX_CONF_UNSET_PTR) {
+        return "is duplicate";
+    }
+
+    if (ngx_strcmp(value[1].data, "off") == 0) {
+        cscf->resolver = NULL;
+        return NGX_CONF_OK;
+    }
+
+#if defined(nginx_version) && nginx_version < 1001007
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    u.host = value[1];
+    u.port = 53;
+
+    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V: %s", &u.host, u.err);
+        return NGX_CONF_ERROR;
+    }
+    cscf->resolver = ngx_resolver_create(cf, &u.addrs[0]);
+    if (cscf->resolver == NULL) {
+        return NGX_CONF_OK;
+    }
+#else
+
+    cscf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);
+    if (cscf->resolver == NULL) {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_access_rule(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    ngx_tcp_core_srv_conf_t *cscf = conf;
+
+    ngx_int_t                rc;
+    ngx_str_t               *value;
+    ngx_cidr_t               cidr;
+    ngx_tcp_access_rule_t   *rule;
+
+    if (cscf->rules == NULL) {
+        cscf->rules = ngx_array_create(cf->pool, 4,
+                                       sizeof(ngx_tcp_access_rule_t));
+        if (cscf->rules == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    rule = ngx_array_push(cscf->rules);
+    if (rule == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    value = cf->args->elts;
+
+    rule->deny = (value[0].data[0] == 'd') ? 1 : 0;
+
+    if (value[1].len == 3 && ngx_strcmp(value[1].data, "all") == 0) {
+        rule->mask = 0;
+        rule->addr = 0;
+
+        return NGX_CONF_OK;
+    }
+
+    rc = ngx_ptocidr(&value[1], &cidr);
+
+    if (rc == NGX_ERROR) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "invalid parameter \"%V\"",
+                           &value[1]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (cidr.family != AF_INET) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "\"allow\" supports IPv4 only");
+        return NGX_CONF_ERROR;
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                           "low address bits of %V are meaningless", &value[1]);
+    }
+
+    rule->mask = cidr.u.in.mask;
+    rule->addr = cidr.u.in.addr;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_log_set_access_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_tcp_core_srv_conf_t *cscf = conf;
+    ngx_tcp_log_srv_conf_t  *lscf = cscf->access_log;
+
+    ssize_t                     size;
+    ngx_str_t                  *value, name;
+    ngx_tcp_log_t              *log;
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+    ngx_tcp_log_buf_t         *buffer;
+#endif
+
+    value = cf->args->elts;
+
+    if (ngx_strcmp(value[1].data, "off") == 0) {
+        lscf->off = 1;
+        if (cf->args->nelts == 2) {
+            return NGX_CONF_OK;
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid parameter \"%V\"", &value[2]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (lscf->logs == NULL) {
+        lscf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_tcp_log_t));
+        if (lscf->logs == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    log = ngx_array_push(lscf->logs);
+    if (log == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memzero(log, sizeof(ngx_tcp_log_t));
+
+    log->file = ngx_conf_open_file(cf->cycle, &value[1]);
+    if (log->file == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (cf->args->nelts == 3) {
+        if (ngx_strncmp(value[2].data, "buffer=", 7) != 0) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid parameter \"%V\"", &value[2]);
+            return NGX_CONF_ERROR;
+        }
+
+        name.len = value[2].len - 7;
+        name.data = value[2].data + 7;
+
+        size = ngx_parse_size(&name);
+
+        if (size == NGX_ERROR) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid parameter \"%V\"", &value[2]);
+            return NGX_CONF_ERROR;
+        }
+
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+        if (log->file->data) {
+
+            buffer = log->file->data;
+
+            if (buffer->last - buffer->pos != size) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "access_log \"%V\" already defined "
+                        "with different buffer size", &value[1]);
+                return NGX_CONF_ERROR;
+            }
+
+            return NGX_CONF_OK;
+        }
+
+        buffer = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_log_buf_t));
+        if (buffer == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        buffer->start = ngx_palloc(cf->pool, size);
+        if (buffer->start == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        buffer->pos = buffer->start;
+        buffer->last = buffer->start + size;
+
+        log->file->data = buffer;
+#else
+        if (log->file->buffer) {
+            if (log->file->last - log->file->pos != size) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "access_log \"%V\" already defined "
+                                   "with different buffer size", &value[1]);
+                return NGX_CONF_ERROR;
+            }
+
+            return NGX_CONF_OK;
+        }
+
+        log->file->buffer = ngx_palloc(cf->pool, size);
+        if (log->file->buffer == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        log->file->pos = log->file->buffer;
+        log->file->last = log->file->buffer + size;
+#endif
+    }
+
+    return NGX_CONF_OK;
+}
diff --git a/src/tcp/ngx_tcp_log.c b/src/tcp/ngx_tcp_log.c
new file mode 100755
index 0000000..572affd
--- /dev/null
+++ b/src/tcp/ngx_tcp_log.c
@@ -0,0 +1,233 @@
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+static u_char * ngx_tcp_time(u_char *buf, time_t t);
+static u_char *ngx_tcp_log_fill(ngx_tcp_session_t *s, u_char *buf);
+static void ngx_tcp_log_write(ngx_tcp_session_t *s, ngx_tcp_log_t *log,
+    u_char *buf, size_t len);
+
+
+ngx_int_t
+ngx_tcp_log_handler(ngx_tcp_session_t *s)
+{
+    u_char                   *line, *p;
+    size_t                    len;
+    ngx_uint_t                l;
+    ngx_connection_t         *c;
+    ngx_tcp_log_t            *log;
+    ngx_open_file_t          *file;
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+    ngx_tcp_log_buf_t        *buffer;
+#endif
+   ngx_tcp_log_srv_conf_t    *lscf;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "tcp access log handler");
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+    lscf = cscf->access_log;
+
+    if (lscf->off) {
+        return NGX_OK;
+    }
+
+    c = s->connection;
+    log = lscf->logs->elts;
+    for (l = 0; l < lscf->logs->nelts; l++) {
+
+        if (ngx_time() == log[l].disk_full_time) {
+
+            /*
+             * on FreeBSD writing to a full filesystem with enabled softupdates
+             * may block process for much longer time than writing to non-full
+             * filesystem, so we skip writing to a log for one second
+             */
+
+            continue;
+        }
+
+        len = 0;
+
+        /* Calculate the length */
+        len += sizeof("1970/09/28 12:00:00");   /* log time */
+        len += NGX_INT64_LEN + 2;               /* [ngx_pid] */
+        len += c->addr_text.len + 1;            /* client address */
+        len += s->addr_text->len + 1;           /* this session address */
+        len += sizeof("1970/09/28 12:00:00");   /* accept time */
+        len += sizeof("255.255.255.255:65536"); /* upstream address */
+        len += NGX_OFF_T_LEN + 1;               /* read bytes from client */
+        len += NGX_OFF_T_LEN + 1;               /* write bytes to client */
+        len += NGX_LINEFEED_SIZE;
+
+        file = log[l].file;
+
+#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000
+        if (file && file->data) {
+
+            buffer = file->data;
+
+            if (len > (size_t) (buffer->last - buffer->pos)) {
+
+                ngx_tcp_log_write(s, &log[l], buffer->start,
+                                  buffer->pos - buffer->start);
+
+                buffer->pos = buffer->start;
+            }
+
+            if (len <= (size_t) (buffer->last - buffer->pos)) {
+
+                p = buffer->pos;
+
+                p = ngx_tcp_log_fill(s, p);
+
+                buffer->pos = p;
+
+                continue;
+            }
+        }
+#else
+        if (file && file->buffer) {
+
+            if (len > (size_t) (file->last - file->pos)) {
+
+                ngx_tcp_log_write(s, &log[l], file->buffer,
+                                  file->pos - file->buffer);
+
+                file->pos = file->buffer;
+            }
+
+            if (len <= (size_t) (file->last - file->pos)) {
+
+                p = file->pos;
+
+                p = ngx_tcp_log_fill(s, p);
+
+                file->pos = p;
+
+                continue;
+            }
+        }
+#endif
+
+        line = ngx_pnalloc(s->pool, len);
+        if (line == NULL) {
+            return NGX_ERROR;
+        }
+
+        p = line;
+
+        p = ngx_tcp_log_fill(s, p);
+
+        ngx_tcp_log_write(s, &log[l], line, p - line);
+    }
+
+    return NGX_OK;
+}
+
+
+static u_char *
+ngx_tcp_time(u_char *buf, time_t t)
+{
+    ngx_tm_t    tm;
+
+    ngx_localtime(t, &tm);
+
+    return ngx_sprintf(buf, "%4d/%02d/%02d %02d:%02d:%02d",
+                       tm.ngx_tm_year, tm.ngx_tm_mon,
+                       tm.ngx_tm_mday, tm.ngx_tm_hour,
+                       tm.ngx_tm_min, tm.ngx_tm_sec);
+}
+
+
+static u_char *
+ngx_tcp_log_fill(ngx_tcp_session_t *s, u_char *buf) 
+{
+    u_char              *last;
+    ngx_str_t           *name;
+    ngx_connection_t    *c;
+    ngx_tcp_upstream_t  *u;
+
+    c = s->connection;
+
+    last = ngx_cpymem(buf, ngx_cached_err_log_time.data,
+            ngx_cached_err_log_time.len);
+
+    last = ngx_sprintf(last, " [%P]", ngx_pid);
+    last = ngx_sprintf(last, " %V", &c->addr_text);
+    last = ngx_sprintf(last, " %V ", s->addr_text);
+    last = ngx_tcp_time(last, s->start_sec);
+    
+    name = NULL;
+    if (s->upstream) {
+        u = s->upstream;
+        if (u->peer.connection) {
+            name = u->peer.name;
+        }
+    }
+
+    if (name) {
+        last = ngx_sprintf(last, " %V", name);
+    }
+    else {
+        last = ngx_sprintf(last, " -");
+    }
+
+    last = ngx_sprintf(last, " %O", s->bytes_read);
+    last = ngx_sprintf(last, " %O", s->bytes_write);
+
+    ngx_linefeed(last);
+
+    return last;
+}
+
+
+static void
+ngx_tcp_log_write(ngx_tcp_session_t *s, ngx_tcp_log_t *log, u_char *buf,
+    size_t len)
+{
+    u_char     *name;
+    time_t      now;
+    ssize_t     n;
+    ngx_err_t   err;
+
+    if(len == 0) return;
+
+    name = log->file->name.data;
+    n = ngx_write_fd(log->file->fd, buf, len);
+
+    if (n == (ssize_t) len) {
+        return;
+    }
+
+    now = ngx_time();
+
+    if (n == -1) {
+        err = ngx_errno;
+
+        if (err == NGX_ENOSPC) {
+            log->disk_full_time = now;
+        }
+
+        if (now - log->error_log_time > 59) {
+            ngx_log_error(NGX_LOG_ALERT, s->connection->log, err,
+                          ngx_write_fd_n " to \"%s\" failed", name);
+
+            log->error_log_time = now;
+        }
+
+        return;
+    }
+
+    if (now - log->error_log_time > 59) {
+        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,
+                      ngx_write_fd_n " to \"%s\" was incomplete: %z of %uz",
+                      name, n, len);
+
+        log->error_log_time = now;
+    }
+}
diff --git a/src/tcp/ngx_tcp_session.c b/src/tcp/ngx_tcp_session.c
new file mode 100755
index 0000000..7a96d51
--- /dev/null
+++ b/src/tcp/ngx_tcp_session.c
@@ -0,0 +1,523 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_tcp.h>
+
+
+static void ngx_tcp_init_session(ngx_connection_t *c);
+static void ngx_tcp_set_session_socket(ngx_tcp_session_t *s);
+static void ngx_tcp_process_session(ngx_connection_t *c);
+
+#if (NGX_TCP_SSL)
+static void ngx_tcp_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);
+static void ngx_tcp_ssl_handshake_handler(ngx_connection_t *c);
+#endif
+
+
+void
+ngx_tcp_init_connection(ngx_connection_t *c)
+{
+    ngx_uint_t            i;
+    ngx_tcp_port_t       *port;
+    struct sockaddr      *sa;
+    struct sockaddr_in   *sin;
+    ngx_tcp_log_ctx_t    *ctx;
+    ngx_tcp_in_addr_t    *addr;
+    ngx_tcp_session_t    *s;
+    ngx_tcp_addr_conf_t  *addr_conf;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6  *sin6;
+    ngx_tcp_in6_addr_t   *addr6;
+#endif
+
+
+    /* find the server configuration for the address:port */
+
+    /* AF_INET only */
+
+    port = c->listening->servers;
+
+    if (port->naddrs > 1) {
+
+        /*
+         * There are several addresses on this port and one of them
+         * is the "*:port" wildcard so getsockname() is needed to determine
+         * the server address.
+         *
+         * AcceptEx() already gave this address.
+         */
+
+        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {
+            ngx_tcp_close_connection(c);
+            return;
+        }
+
+        sa = c->local_sockaddr;
+
+        switch (sa->sa_family) {
+
+#if (NGX_HAVE_INET6)
+        case AF_INET6:
+            sin6 = (struct sockaddr_in6 *) sa;
+
+            addr6 = port->addrs;
+
+            /* the last address is "*" */
+
+            for (i = 0; i < port->naddrs - 1; i++) {
+                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {
+                    break;
+                }
+            }
+
+            addr_conf = &addr6[i].conf;
+
+            break;
+#endif
+
+        default: /* AF_INET */
+            sin = (struct sockaddr_in *) sa;
+
+            addr = port->addrs;
+
+            /* the last address is "*" */
+
+            for (i = 0; i < port->naddrs - 1; i++) {
+                if (addr[i].addr == sin->sin_addr.s_addr) {
+                    break;
+                }
+            }
+
+            addr_conf = &addr[i].conf;
+
+            break;
+        }
+
+    } else {
+        switch (c->local_sockaddr->sa_family) {
+
+#if (NGX_HAVE_INET6)
+        case AF_INET6:
+            addr6 = port->addrs;
+            addr_conf = &addr6[0].conf;
+            break;
+#endif
+
+        default: /* AF_INET */
+            addr = port->addrs;
+            addr_conf = &addr[0].conf;
+            break;
+        }
+    }
+
+    s = ngx_pcalloc(c->pool, sizeof(ngx_tcp_session_t));
+    if (s == NULL) {
+        ngx_tcp_close_connection(c);
+        return;
+    }
+
+    if (addr_conf->default_ctx) {
+        s->main_conf = addr_conf->default_ctx->main_conf;
+        s->srv_conf = addr_conf->default_ctx->srv_conf;
+    }
+    else {
+        s->main_conf = addr_conf->ctx->main_conf;
+        s->srv_conf = addr_conf->ctx->srv_conf;
+    }
+
+    s->addr_text = &addr_conf->addr_text;
+
+    c->data = s;
+    s->connection = c;
+
+    ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%ui client %V connected to %V",
+                  c->number, &c->addr_text, s->addr_text);
+
+    ctx = ngx_palloc(c->pool, sizeof(ngx_tcp_log_ctx_t));
+    if (ctx == NULL) {
+        ngx_tcp_close_connection(c);
+        return;
+    }
+
+    ctx->client = &c->addr_text;
+    ctx->session = s;
+
+    c->log->connection = c->number;
+    c->log->handler = ngx_tcp_log_error;
+    c->log->data = ctx;
+    c->log->action = "nginx tcp module init connection";
+
+    c->log_error = NGX_ERROR_INFO;
+
+#if (NGX_TCP_SSL)
+
+    {
+    ngx_tcp_ssl_srv_conf_t  *sscf;
+
+    sscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_ssl_module);
+    if (sscf->enable || addr_conf->ssl) {
+
+        if (c->ssl == NULL) {
+
+            c->log->action = "SSL handshaking";
+
+            if (addr_conf->ssl && sscf->ssl.ctx == NULL) {
+                ngx_log_error(NGX_LOG_ERR, c->log, 0,
+                              "no \"ssl_certificate\" is defined "
+                              "in server listening on SSL port");
+                ngx_tcp_close_connection(c);
+                return;
+            }
+
+            ngx_tcp_ssl_init_connection(&sscf->ssl, c);
+            return;
+        }
+    }
+    }
+
+#endif
+
+    ngx_tcp_init_session(c);
+}
+
+
+#if (NGX_TCP_SSL)
+
+static void
+ngx_tcp_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)
+{
+    ngx_tcp_session_t        *s;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    if (ngx_ssl_create_connection(ssl, c, NGX_SSL_BUFFER) == NGX_ERROR) {
+        ngx_tcp_close_connection(c);
+        return;
+    }
+
+    if (ngx_ssl_handshake(c) == NGX_AGAIN) {
+
+        s = c->data;
+
+        cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+        ngx_add_timer(c->read, cscf->timeout);
+
+        c->ssl->handler = ngx_tcp_ssl_handshake_handler;
+
+        return;
+    }
+
+    ngx_tcp_ssl_handshake_handler(c);
+}
+
+
+static void
+ngx_tcp_ssl_handshake_handler(ngx_connection_t *c)
+{
+    if (c->ssl->handshaked) {
+
+        c->read->ready = 0;
+
+        ngx_tcp_init_session(c);
+        return;
+    }
+
+    ngx_tcp_close_connection(c);
+}
+
+#endif
+
+
+static void
+ngx_tcp_init_session(ngx_connection_t *c)
+{
+    ngx_time_t               *tp;
+    ngx_tcp_session_t        *s;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    s = c->data;
+
+    s->signature = NGX_TCP_MODULE;
+    s->pool = c->pool;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+    if (cscf == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    s->ctx = ngx_pcalloc(s->pool, sizeof(void *) * ngx_tcp_max_module);
+    if (s->ctx == NULL) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    tp = ngx_timeofday();
+    s->start_sec = tp->sec;
+    s->start_msec = tp->msec;
+
+    s->bytes_read = 0;
+    s->bytes_write = 0;
+
+    ngx_tcp_set_session_socket(s);
+
+    ngx_tcp_process_session(c);
+}
+
+
+static void 
+ngx_tcp_set_session_socket(ngx_tcp_session_t *s) 
+{
+    int                       keepalive;
+    int                       tcp_nodelay;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    if (cscf->so_keepalive) {
+        keepalive = 1;
+
+        if (setsockopt(s->connection->fd, SOL_SOCKET, SO_KEEPALIVE,
+                       (const void *) &keepalive, sizeof(int)) == -1)
+        {
+            ngx_log_error(NGX_LOG_ALERT, s->connection->log, ngx_socket_errno,
+                          "setsockopt(SO_KEEPALIVE) failed");
+        }
+    }
+
+    if (cscf->tcp_nodelay) {
+        tcp_nodelay = 1;
+        if (setsockopt(s->connection->fd, IPPROTO_TCP, TCP_NODELAY,
+                       (const void *) &tcp_nodelay, sizeof(int))
+            == -1)
+        {
+            ngx_log_error(NGX_LOG_ALERT, s->connection->log, ngx_socket_errno,
+                          "setsockopt(TCP_NODELAY) failed");
+        }
+
+        s->connection->tcp_nodelay = NGX_TCP_NODELAY_SET;
+    }
+}
+
+
+static void
+ngx_tcp_process_session(ngx_connection_t *c)
+{
+    ngx_tcp_session_t         *s;
+    ngx_tcp_core_srv_conf_t   *cscf;
+
+    s = c->data;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    /* process the ACL */
+    if (ngx_tcp_access_handler(s) == NGX_ERROR) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    cscf->protocol->init_session(s);
+}
+
+
+void
+ngx_tcp_send(ngx_event_t *wev)
+{
+    ngx_int_t                  n;
+    ngx_connection_t          *c;
+    ngx_tcp_session_t         *s;
+    ngx_tcp_core_srv_conf_t   *cscf;
+
+    c = wev->data;
+    s = c->data;
+
+    if (wev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
+        c->timedout = 1;
+        ngx_tcp_close_connection(c);
+        return;
+    }
+
+    if (s->out.len == 0) {
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            ngx_tcp_close_connection(c);
+        }
+
+        return;
+    }
+
+    n = c->send(c, s->out.data, s->out.len);
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, wev->log, 0, "nginx tcp send:%d", n);
+
+    if (n > 0) {
+        s->out.len -= n;
+
+        if (wev->timer_set) {
+            ngx_del_timer(wev);
+        }
+
+        if (s->quit) {
+            ngx_tcp_close_connection(c);
+            return;
+        }
+
+        return;
+    }
+
+    if (n == NGX_ERROR) {
+        ngx_tcp_close_connection(c);
+        return;
+    }
+
+    /* n == NGX_AGAIN */
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    ngx_add_timer(c->write, cscf->timeout);
+
+    if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+        ngx_tcp_close_connection(c);
+        return;
+    }
+}
+
+
+void
+ngx_tcp_session_internal_server_error(ngx_tcp_session_t *s)
+{
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    s->out = cscf->protocol->internal_server_error;
+    s->quit = 1;
+
+    ngx_tcp_send(s->connection->write);
+}
+
+
+void 
+ngx_tcp_finalize_session(ngx_tcp_session_t *s)
+{
+    ngx_connection_t *c;
+    ngx_tcp_cleanup_t *cln;
+
+    c = s->connection;
+
+    ngx_tcp_log_handler(s);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,
+                   "close tcp session: %d", c->fd);
+
+    for (cln = s->cleanup; cln; cln = cln->next) {
+        if (cln->handler) {
+            cln->handler(cln->data);
+            cln->handler = NULL;
+        }
+    }
+
+    ngx_tcp_close_connection(c);
+
+    return;
+}
+
+
+void
+ngx_tcp_close_connection(ngx_connection_t *c)
+{
+    ngx_pool_t  *pool;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,
+                   "close tcp connection: %d", c->fd);
+
+#if (NGX_TCP_SSL)
+
+    if (c->ssl) {
+        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
+            c->ssl->handler = ngx_tcp_close_connection;
+            return;
+        }
+    }
+
+#endif
+
+#if (NGX_STAT_STUB)
+    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
+#endif
+
+    c->destroyed = 1;
+
+    pool = c->pool;
+
+    ngx_close_connection(c);
+
+    ngx_destroy_pool(pool);
+}
+
+
+u_char *
+ngx_tcp_log_error(ngx_log_t *log, u_char *buf, size_t len)
+{
+    u_char              *p;
+    ngx_tcp_session_t   *s;
+    ngx_tcp_log_ctx_t   *ctx;
+
+    p = buf;
+
+    if (log->action) {
+        p = ngx_snprintf(p, len + (buf - p), " while %s", log->action);
+    }
+
+    ctx = log->data;
+
+    p = ngx_snprintf(p, len + (buf - p), ", client: %V", ctx->client);
+
+    s = ctx->session;
+
+    if (s == NULL) {
+        return p;
+    }
+
+    p = ngx_snprintf(p, len + (buf - p), ", server: %V", s->addr_text);
+
+    if (s->upstream) {
+        if (s->upstream->peer.connection) {
+            p = ngx_snprintf(p, len + (buf - p), ", upstream: %V", s->upstream->peer.name);
+        }
+    }
+
+    return p;
+}
+
+
+ngx_tcp_cleanup_t *
+ngx_tcp_cleanup_add(ngx_tcp_session_t *s, size_t size)
+{
+    ngx_tcp_cleanup_t  *cln;
+
+    cln = ngx_palloc(s->pool, sizeof(ngx_tcp_cleanup_t));
+    if (cln == NULL) {
+        return NULL;
+    }
+
+    if (size) {
+        cln->data = ngx_palloc(s->pool, size);
+        if (cln->data == NULL) {
+            return NULL;
+        }
+
+    } else {
+        cln->data = NULL;
+    }
+
+    cln->handler = NULL;
+    cln->next = s->cleanup;
+
+    s->cleanup = cln;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "tcp cleanup add: %p", cln);
+
+    return cln;
+}
diff --git a/src/tcp/ngx_tcp_session.h b/src/tcp/ngx_tcp_session.h
new file mode 100755
index 0000000..8dce358
--- /dev/null
+++ b/src/tcp/ngx_tcp_session.h
@@ -0,0 +1,71 @@
+
+#ifndef _NGX_TCP_SESSION_H_INCLUDED_
+#define _NGX_TCP_SESSION_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+#include <ngx_tcp.h>
+
+
+typedef struct ngx_tcp_session_s {
+    uint32_t                signature;         /* "TCP" */
+
+    ngx_pool_t             *pool;
+
+    ngx_connection_t       *connection;
+    ngx_tcp_upstream_t     *upstream;
+
+    ngx_str_t               out;
+    ngx_buf_t              *buffer;
+
+    void                  **ctx;
+    void                  **main_conf;
+    void                  **srv_conf;
+
+    ngx_resolver_ctx_t     *resolver_ctx;
+
+    ngx_tcp_cleanup_t      *cleanup;
+
+    time_t                  start_sec;
+    ngx_msec_t              start_msec;
+
+    off_t                   bytes_read;
+    off_t                   bytes_write;
+
+    unsigned                quit:1;
+    ngx_str_t              *addr_text;
+    ngx_str_t               host;
+
+} ngx_tcp_session_t;
+
+
+typedef void (*ngx_tcp_cleanup_pt)(void *data);
+
+
+struct ngx_tcp_cleanup_s {
+    ngx_tcp_cleanup_pt      handler;
+    void                   *data;
+    ngx_tcp_cleanup_t      *next;
+};
+
+void ngx_tcp_init_connection(ngx_connection_t *c);
+
+void ngx_tcp_send(ngx_event_t *wev);
+ngx_int_t ngx_tcp_read_command(ngx_tcp_session_t *s, ngx_connection_t *c);
+void ngx_tcp_auth(ngx_tcp_session_t *s, ngx_connection_t *c);
+void ngx_tcp_close_connection(ngx_connection_t *c);
+void ngx_tcp_session_internal_server_error(ngx_tcp_session_t *s);
+
+u_char *ngx_tcp_log_error(ngx_log_t *log, u_char *buf, size_t len);
+
+void ngx_tcp_finalize_session(ngx_tcp_session_t *s);
+
+ngx_tcp_cleanup_t * ngx_tcp_cleanup_add(ngx_tcp_session_t *s, size_t size);
+
+ngx_int_t ngx_tcp_access_handler(ngx_tcp_session_t *s);
+ngx_int_t ngx_tcp_log_handler(ngx_tcp_session_t *s);
+
+#endif
diff --git a/src/tcp/ngx_tcp_upstream.c b/src/tcp/ngx_tcp_upstream.c
new file mode 100755
index 0000000..6f60de2
--- /dev/null
+++ b/src/tcp/ngx_tcp_upstream.c
@@ -0,0 +1,1224 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+#include <ngx_tcp_upstream.h>
+
+
+static void ngx_tcp_upstream_cleanup(void *data);
+
+static void ngx_tcp_upstream_handler(ngx_event_t *ev); 
+static void ngx_tcp_upstream_connect(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_t *u);
+static void ngx_tcp_upstream_resolve_handler(ngx_resolver_ctx_t *ctx);
+static void ngx_tcp_upstream_finalize_session(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_t *u, ngx_int_t rc);
+
+static char *ngx_tcp_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy);
+static char *ngx_tcp_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_tcp_upstream_check(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+static void *ngx_tcp_upstream_create_main_conf(ngx_conf_t *cf);
+static char *ngx_tcp_upstream_init_main_conf(ngx_conf_t *cf, void *conf);
+
+
+static ngx_conf_bitmask_t  ngx_check_http_expect_alive_masks[] = {
+    { ngx_string("http_2xx"), NGX_CHECK_HTTP_2XX },
+    { ngx_string("http_3xx"), NGX_CHECK_HTTP_3XX },
+    { ngx_string("http_4xx"), NGX_CHECK_HTTP_4XX },
+    { ngx_string("http_5xx"), NGX_CHECK_HTTP_5XX },
+    { ngx_null_string, 0 }
+};
+
+static ngx_conf_bitmask_t  ngx_check_smtp_expect_alive_masks[] = {
+    { ngx_string("smtp_2xx"), NGX_CHECK_SMTP_2XX },
+    { ngx_string("smtp_3xx"), NGX_CHECK_SMTP_3XX },
+    { ngx_string("smtp_4xx"), NGX_CHECK_SMTP_4XX },
+    { ngx_string("smtp_5xx"), NGX_CHECK_SMTP_5XX },
+    { ngx_null_string, 0 }
+};
+
+static ngx_command_t  ngx_tcp_upstream_commands[] = {
+
+    { ngx_string("upstream"),
+      NGX_TCP_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE1,
+      ngx_tcp_upstream,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("server"),
+      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,
+      ngx_tcp_upstream_server,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("check"),
+      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,
+      ngx_tcp_upstream_check,
+      NGX_TCP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("check_http_send"),
+      NGX_TCP_UPS_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_upstream_srv_conf_t, send),
+      NULL },
+
+    { ngx_string("check_smtp_send"),
+      NGX_TCP_UPS_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_upstream_srv_conf_t, send),
+      NULL },
+
+    { ngx_string("check_http_expect_alive"),
+      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_upstream_srv_conf_t, code.status_alive),
+      &ngx_check_http_expect_alive_masks },
+
+    { ngx_string("check_smtp_expect_alive"),
+      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_TCP_SRV_CONF_OFFSET,
+      offsetof(ngx_tcp_upstream_srv_conf_t, code.status_alive),
+      &ngx_check_smtp_expect_alive_masks },
+
+    { ngx_string("check_shm_size"),
+      NGX_TCP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_TCP_MAIN_CONF_OFFSET,
+      offsetof(ngx_tcp_upstream_main_conf_t, check_shm_size),
+      NULL },
+
+    ngx_null_command
+};
+
+
+static ngx_tcp_module_t  ngx_tcp_upstream_module_ctx = {
+    NULL,
+
+    ngx_tcp_upstream_create_main_conf,     /* create main configuration */
+    ngx_tcp_upstream_init_main_conf,       /* init main configuration */
+
+    NULL,                                  /* create server configuration */
+    NULL,                                  /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_tcp_upstream_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_upstream_module_ctx,          /* module context */
+    ngx_tcp_upstream_commands,             /* module directives */
+    NGX_TCP_MODULE,                        /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+ngx_int_t
+ngx_tcp_upstream_create(ngx_tcp_session_t *s) 
+{
+    ngx_tcp_upstream_t  *u;
+
+    u = s->upstream;
+
+    if (u && u->cleanup) {
+        ngx_tcp_upstream_cleanup(s);
+    }
+
+    u = ngx_pcalloc(s->pool, sizeof(ngx_tcp_upstream_t));
+    if (u == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->upstream = u;
+
+    u->peer.log = s->connection->log;
+    u->peer.log_error = NGX_ERROR_ERR;
+
+    return NGX_OK;
+}
+
+
+void
+ngx_tcp_upstream_init(ngx_tcp_session_t *s)
+{
+    ngx_str_t                      *host;
+    ngx_uint_t                      i;
+    ngx_connection_t               *c;
+    ngx_tcp_cleanup_t              *cln;
+    ngx_resolver_ctx_t             *ctx, temp;
+    ngx_tcp_upstream_t             *u;
+    ngx_tcp_core_srv_conf_t        *cscf;
+    ngx_tcp_upstream_srv_conf_t    *uscf, **uscfp;
+    ngx_tcp_upstream_main_conf_t   *umcf;
+
+    c = s->connection;
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,
+                   "tcp init upstream, client timer: %d", c->read->timer_set);
+
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    u = s->upstream;
+
+    cln = ngx_tcp_cleanup_add(s, 0);
+
+    cln->handler = ngx_tcp_upstream_cleanup;
+    cln->data = s;
+    u->cleanup = &cln->handler;
+
+
+	if(u->conf->upstream->flags & NGX_TCP_UPSTREAM_TPROXY){
+		if (ngx_tcp_upstream_create_tproxy_peer(s, u->resolved)
+			!= NGX_OK)
+		{
+			ngx_tcp_finalize_session(s);
+			return;
+		}
+		
+		ngx_tcp_upstream_connect(s, u);
+		return;	
+	}
+
+    if (u->resolved == NULL) {
+        uscf = u->conf->upstream;
+    } else {
+
+        /*TODO: support variable in the proxy_pass*/
+        if (u->resolved->sockaddr) {
+
+            if (ngx_tcp_upstream_create_round_robin_peer(s, u->resolved)
+                != NGX_OK)
+            {
+                ngx_tcp_finalize_session(s);
+                return;
+            }
+
+            ngx_tcp_upstream_connect(s, u);
+
+            return;
+        }
+		
+
+        host = &u->resolved->host;
+
+        umcf = ngx_tcp_get_module_main_conf(s, ngx_tcp_upstream_module);
+
+        uscfp = umcf->upstreams.elts;
+
+        for (i = 0; i < umcf->upstreams.nelts; i++) {
+
+            uscf = uscfp[i];
+
+            if (uscf->host.len == host->len
+                && ((uscf->port == 0 && u->resolved->no_port)
+                    || uscf->port == u->resolved->port)
+                && ngx_memcmp(uscf->host.data, host->data, host->len) == 0)
+            {
+                goto found;
+            }
+        }
+
+        temp.name = *host;
+
+        ctx = ngx_resolve_start(cscf->resolver, &temp);
+        if (ctx == NULL) {
+            ngx_tcp_finalize_session(s);
+            return;
+        }
+
+        if (ctx == NGX_NO_RESOLVER) {
+            ngx_log_error(NGX_LOG_ERR, c->log, 0,
+                         "no resolver defined to resolve %V", host);
+            ngx_tcp_finalize_session(s);
+            return;
+        }
+
+        ctx->name = *host;
+        ctx->type = NGX_RESOLVE_A;
+        ctx->handler = ngx_tcp_upstream_resolve_handler;
+        ctx->data = s;
+        ctx->timeout = cscf->resolver_timeout;
+
+        u->resolved->ctx = ctx;
+
+        if (ngx_resolve_name(ctx) != NGX_OK) {
+            u->resolved->ctx = NULL;
+            ngx_tcp_finalize_session(s);
+            return;
+        }
+
+        return;
+    }
+
+found:
+
+    if (uscf->peer.init(s, uscf) != NGX_OK) {
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ngx_tcp_upstream_connect(s, u);
+}
+
+
+static void
+ngx_tcp_upstream_resolve_handler(ngx_resolver_ctx_t *ctx) 
+{
+    ngx_tcp_session_t            *s;
+    ngx_tcp_upstream_resolved_t  *ur;
+
+    s = ctx->data;
+
+    s->upstream->resolved->ctx = NULL;
+
+    if (ctx->state) {
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                      "%V could not be resolved (%i: %s)",
+                      &ctx->name, ctx->state,
+                      ngx_resolver_strerror(ctx->state));
+
+        ngx_resolve_name_done(ctx);
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ur = s->upstream->resolved;
+    ur->naddrs = ctx->naddrs;
+    ur->addrs = ctx->addrs;
+
+#if (NGX_DEBUG)
+    {
+        in_addr_t   addr;
+        ngx_uint_t  i;
+
+        for (i = 0; i < ctx->naddrs; i++) {
+            addr = ntohl(ur->addrs[i]);
+
+            ngx_log_debug4(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                           "name was resolved to %ud.%ud.%ud.%ud",
+                           (addr >> 24) & 0xff, (addr >> 16) & 0xff,
+                           (addr >> 8) & 0xff, addr & 0xff);
+        }
+    }
+#endif
+
+    if (ngx_tcp_upstream_create_round_robin_peer(s, ur) != NGX_OK) {
+        ngx_resolve_name_done(ctx);
+        ngx_tcp_finalize_session(s);
+        return;
+    }
+
+    ngx_resolve_name_done(ctx);
+
+    ngx_tcp_upstream_connect(s, s->upstream);
+}
+
+
+static void
+ngx_tcp_upstream_connect(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u) 
+{
+    int                       tcp_nodelay;
+    ngx_int_t                 rc;
+    ngx_connection_t         *c;
+    ngx_tcp_core_srv_conf_t  *cscf;
+
+    s->connection->log->action = "connecting to upstream";
+
+    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);
+
+    rc = ngx_event_connect_peer(&u->peer);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "tcp upstream connect: %d", rc);
+
+    if (rc != NGX_OK && rc != NGX_AGAIN) {
+
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0, 
+                      "upstream servers are busy or encounter error!");
+
+        /* TODO: check this function */
+        ngx_tcp_upstream_finalize_session(s, u, 0);
+
+        return;
+    }
+
+    /* rc == NGX_OK or rc == NGX_AGAIN */
+
+    if (u->peer.check_index != NGX_INVALID_CHECK_INDEX) {
+        ngx_tcp_check_get_peer(u->peer.check_index);
+    }
+
+    c = u->peer.connection;
+
+    c->data = s;
+    c->pool = s->connection->pool;
+    c->log = s->connection->log;
+    c->read->log = c->log;
+    c->write->log = c->log;
+
+    c->write->handler = ngx_tcp_upstream_handler;
+    c->read->handler = ngx_tcp_upstream_handler;
+
+    if (cscf->tcp_nodelay) {
+        tcp_nodelay = 1;
+
+        if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,
+                       (const void *) &tcp_nodelay, sizeof(int)) == -1)
+        {
+            ngx_connection_error(c, ngx_socket_errno,
+                                 "setsockopt(TCP_NODELAY) failed");
+            ngx_tcp_upstream_finalize_session(s, u, 0);
+            return;
+        }
+
+        c->tcp_nodelay = NGX_TCP_NODELAY_SET;
+    }
+
+    if (rc == NGX_AGAIN) {
+        ngx_add_timer(c->write, u->conf->connect_timeout);
+        return;
+    }
+    else {
+        ngx_add_timer(c->read, u->conf->read_timeout);
+        ngx_add_timer(c->write, u->conf->send_timeout);
+
+        c->write->handler(c->write);
+    }
+}
+
+
+static void
+ngx_tcp_upstream_handler(ngx_event_t *ev) 
+{
+    ngx_connection_t     *c;
+    ngx_tcp_session_t    *s;
+    ngx_tcp_upstream_t   *u;
+
+    c = ev->data;
+    s = c->data;
+
+    u = s->upstream;
+    c = s->connection;
+
+    if (ev->write) {
+        if (u->write_event_handler) {
+            u->write_event_handler(s, u);
+        }
+
+    } else {
+
+        if (u->read_event_handler) {
+            u->read_event_handler(s, u);
+        }
+    }
+}
+
+
+ngx_int_t 
+ngx_tcp_upstream_check_broken_connection(ngx_tcp_session_t *s) 
+{
+    int                  n;
+    char                 buf[1];
+    ngx_err_t            err;
+    ngx_connection_t    *c;
+    ngx_tcp_upstream_t  *u;
+
+    u = s->upstream;
+    c = u->peer.connection;
+
+    if (u->peer.connection == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,
+                   "tcp upstream check upstream, fd: %d", c->fd);
+
+    n = recv(c->fd, buf, 1, MSG_PEEK);
+
+    err = ngx_socket_errno;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, err,
+                   "tcp check upstream recv(): %d", n);
+
+    if (n >= 0 || err == NGX_EAGAIN) {
+        return NGX_OK;
+    }
+
+    c->error = 1;
+
+    return NGX_ERROR;
+}
+
+
+
+
+void
+ngx_tcp_upstream_next(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u,
+    ngx_uint_t ft_type) 
+{
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "tcp next upstream, fail_type: %xi", ft_type);
+
+    if ((ft_type != NGX_TCP_UPSTREAM_FT_NOLIVE) && u->peer.free) {
+        u->peer.free(&u->peer, u->peer.data, NGX_PEER_FAILED);
+    }
+
+    if (ft_type == NGX_TCP_UPSTREAM_FT_TIMEOUT) {
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, NGX_ETIMEDOUT,
+                      "upstream timed out");
+    }
+
+    if (s->connection->error) {
+        ngx_tcp_upstream_finalize_session(s, u, 0);
+        return;
+    }
+
+    if (u->peer.tries == 0) {
+        ngx_tcp_upstream_finalize_session(s, u, 0);
+        return;
+    }
+
+    if (u->peer.connection) {
+        ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                       "close tcp upstream connection: %d",
+                       u->peer.connection->fd);
+#if (NGX_TCP_SSL)
+
+        if (u->peer.connection->ssl) {
+            u->peer.connection->ssl->no_wait_shutdown = 1;
+            u->peer.connection->ssl->no_send_shutdown = 1;
+
+            (void) ngx_ssl_shutdown(u->peer.connection);
+        }
+#endif
+        
+        if (u->peer.check_index != NGX_INVALID_CHECK_INDEX) {
+            ngx_tcp_check_free_peer(u->peer.check_index);
+            u->peer.check_index = NGX_INVALID_CHECK_INDEX;
+        }
+
+        ngx_close_connection(u->peer.connection);
+    }
+
+    ngx_tcp_upstream_connect(s, u);
+}
+
+
+static void
+ngx_tcp_upstream_cleanup(void *data) 
+{
+    ngx_tcp_session_t *s = data;
+
+    ngx_tcp_upstream_t  *u;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "cleanup tcp upstream session: fd: %d", s->connection->fd);
+
+    u = s->upstream;
+
+    if (u->resolved && u->resolved->ctx) {
+        ngx_resolve_name_done(u->resolved->ctx);
+    }
+
+    ngx_tcp_upstream_finalize_session(s, u, NGX_DONE);
+}
+
+
+static void
+ngx_tcp_upstream_finalize_session(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_t *u, ngx_int_t rc) 
+{
+    ngx_time_t  *tp;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                   "finalize tcp upstream session: %i", rc);
+
+    if (u->cleanup) {
+        *u->cleanup = NULL;
+        u->cleanup = NULL;
+    }
+
+    if (u->state && u->state->response_sec) {
+        tp = ngx_timeofday();
+        u->state->response_sec = tp->sec - u->state->response_sec;
+        u->state->response_msec = tp->msec - u->state->response_msec;
+    }
+
+    if (u->peer.free) {
+        u->peer.free(&u->peer, u->peer.data, 0);
+    }
+
+    if (u->peer.check_index != NGX_INVALID_CHECK_INDEX) {
+        ngx_tcp_check_free_peer(u->peer.check_index);
+        u->peer.check_index = NGX_INVALID_CHECK_INDEX;
+    }
+
+    if (u->peer.connection) {
+
+        ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,
+                       "close tcp upstream connection: %d",
+                       u->peer.connection->fd);
+
+        ngx_close_connection(u->peer.connection);
+    }
+
+    u->peer.connection = NULL;
+
+    if (rc == NGX_DECLINED || rc == NGX_DONE) {
+        return;
+    }
+
+    s->connection->log->action = "sending to client";
+
+    ngx_tcp_finalize_session(s);
+}
+
+
+ngx_tcp_upstream_srv_conf_t *
+ngx_tcp_upstream_add(ngx_conf_t *cf, ngx_url_t *u, ngx_uint_t flags) 
+{
+    ngx_uint_t                     i;
+    ngx_tcp_upstream_server_t     *us;
+    ngx_tcp_upstream_srv_conf_t   *uscf, **uscfp;
+    ngx_tcp_upstream_main_conf_t  *umcf;
+
+	umcf = ngx_tcp_conf_get_module_main_conf(cf, ngx_tcp_upstream_module);
+	uscfp = umcf->upstreams.elts;
+	
+#if (NGX_HAVE_TPROXY)
+
+	if (ngx_strncasecmp(u->url.data, (u_char *) "tproxy", 6) == 0) {
+		
+		uscf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_srv_conf_t));
+		if (uscf == NULL) {
+			return NULL;
+		}
+		uscf->flags = NGX_TCP_UPSTREAM_TPROXY;
+		uscf->peer.init_upstream = ngx_tcp_upstream_init_tproxy;
+		
+		uscfp = ngx_array_push(&umcf->upstreams);
+		if (uscfp == NULL) {
+			return NULL;
+		}
+		
+		*uscfp = uscf;
+		
+		return uscf;
+
+		
+	}
+	else
+#endif
+    if (!(flags & NGX_TCP_UPSTREAM_CREATE)) {
+
+        if (ngx_parse_url(cf->pool, u) != NGX_OK) {
+            if (u->err) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "%s in upstream \"%V\"", u->err, &u->url);
+            }
+
+            return NULL;
+        }
+    }
+
+
+
+    for (i = 0; i < umcf->upstreams.nelts; i++) {
+
+        if (uscfp[i]->host.len != u->host.len || 
+                ngx_strncasecmp(uscfp[i]->host.data,
+                                u->host.data, u->host.len) != 0)
+        {
+            continue;
+        }
+
+        if ((flags & NGX_TCP_UPSTREAM_CREATE)
+             && (uscfp[i]->flags & NGX_TCP_UPSTREAM_CREATE))
+        {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "duplicate upstream \"%V\"", &u->host);
+            return NULL;
+        }
+
+#if (nginx_version) >= 1003011
+        if ((uscfp[i]->flags & NGX_TCP_UPSTREAM_CREATE) && !u->no_port) {
+#else
+        if ((uscfp[i]->flags & NGX_TCP_UPSTREAM_CREATE) && u->port) {
+#endif
+            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                               "upstream \"%V\" may not have port %d",
+                               &u->host, u->port);
+            return NULL;
+        }
+
+#if (nginx_version) >= 1003011
+        if ((flags & NGX_TCP_UPSTREAM_CREATE) && !uscfp[i]->no_port) {
+#else
+        if ((flags & NGX_TCP_UPSTREAM_CREATE) && uscfp[i]->port) {
+#endif
+            ngx_log_error(NGX_LOG_WARN, cf->log, 0,
+                          "upstream \"%V\" may not have port %d in %s:%ui",
+                          &u->host, uscfp[i]->port,
+                          uscfp[i]->file_name, uscfp[i]->line);
+            return NULL;
+        }
+
+#if (nginx_version) >= 1003011
+        if (uscfp[i]->port && u->port && uscfp[i]->port != u->port) {
+#else
+        if (uscfp[i]->port != u->port) {
+#endif
+            continue;
+        }
+
+        if (uscfp[i]->default_port && u->default_port
+            && uscfp[i]->default_port != u->default_port)
+        {
+            continue;
+        }
+
+        return uscfp[i];
+    }
+
+    uscf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_srv_conf_t));
+    if (uscf == NULL) {
+        return NULL;
+    }
+
+    uscf->flags = flags;
+    uscf->host = u->host;
+    uscf->file_name = cf->conf_file->file.name.data;
+    uscf->line = cf->conf_file->line;
+    uscf->port = u->port;
+    uscf->default_port = u->default_port;
+#if (nginx_version) >= 1003011
+    uscf->no_port = u->no_port;
+#endif
+    uscf->code.status_alive = 0;
+
+    if (u->naddrs == 1) {
+        uscf->servers = ngx_array_create(cf->pool, 1,
+                                         sizeof(ngx_tcp_upstream_server_t));
+        if (uscf->servers == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        us = ngx_array_push(uscf->servers);
+        if (us == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        ngx_memzero(us, sizeof(ngx_tcp_upstream_server_t));
+
+        us->addrs = u->addrs;
+        us->naddrs = u->naddrs;
+    }
+
+    uscfp = ngx_array_push(&umcf->upstreams);
+    if (uscfp == NULL) {
+        return NULL;
+    }
+
+    *uscfp = uscf;
+
+    return uscf;
+}
+
+
+static char *
+ngx_tcp_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy) 
+{
+    char                          *rv;
+    void                          *mconf;
+    ngx_str_t                     *value;
+    ngx_url_t                      u;
+    ngx_uint_t                     m;
+    ngx_conf_t                     pcf;
+    ngx_tcp_module_t              *module;
+    ngx_tcp_conf_ctx_t            *ctx, *tcp_ctx;
+    ngx_tcp_upstream_srv_conf_t   *uscf;
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    value = cf->args->elts;
+    u.host = value[1];
+    u.no_resolve = 1;
+    u.no_port = 1;
+
+    uscf = ngx_tcp_upstream_add(cf, &u, 
+                                NGX_TCP_UPSTREAM_CREATE
+                               |NGX_TCP_UPSTREAM_WEIGHT
+                               |NGX_TCP_UPSTREAM_MAX_FAILS
+                               |NGX_TCP_UPSTREAM_FAIL_TIMEOUT
+                               |NGX_TCP_UPSTREAM_MAX_BUSY
+                               |NGX_TCP_UPSTREAM_DOWN
+                               |NGX_TCP_UPSTREAM_BACKUP);
+    if (uscf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_conf_ctx_t));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    tcp_ctx = cf->ctx;
+    ctx->main_conf = tcp_ctx->main_conf;
+
+    /* the upstream{}'s srv_conf */
+
+    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_tcp_max_module);
+    if (ctx->srv_conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ctx->srv_conf[ngx_tcp_upstream_module.ctx_index] = uscf;
+
+    uscf->srv_conf = ctx->srv_conf;
+
+
+    for (m = 0; ngx_modules[m]; m++) {
+        if (ngx_modules[m]->type != NGX_TCP_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[m]->ctx;
+
+        if (module->create_srv_conf) {
+            mconf = module->create_srv_conf(cf);
+            if (mconf == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;
+        }
+
+    }
+
+    /* parse inside upstream{} */
+
+    pcf = *cf;
+    cf->ctx = ctx;
+    cf->cmd_type = NGX_TCP_UPS_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    if (uscf->servers == NULL) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "no servers are inside upstream");
+        return NGX_CONF_ERROR;
+    }
+
+    return rv;
+}
+
+
+static char *
+ngx_tcp_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    ngx_tcp_upstream_srv_conf_t  *uscf = conf;
+
+    time_t                       fail_timeout;
+    ngx_str_t                   *value, s;
+    ngx_url_t                    u;
+    ngx_int_t                    weight, max_fails, max_busy;
+    ngx_uint_t                   i;
+    ngx_tcp_upstream_server_t   *us;
+
+    if (uscf->servers == NULL) {
+        uscf->servers = ngx_array_create(cf->pool, 4,
+                                         sizeof(ngx_tcp_upstream_server_t));
+        if (uscf->servers == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    us = ngx_array_push(uscf->servers);
+    if (us == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memzero(us, sizeof(ngx_tcp_upstream_server_t));
+
+    value = cf->args->elts;
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    u.url = value[1];
+    u.default_port = 80;
+
+    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+        if (u.err) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "%s in upstream \"%V\"", u.err, &u.url);
+        }
+
+        return NGX_CONF_ERROR;
+    }
+
+    weight = 1;
+    max_fails = 1;
+    max_busy = (ngx_uint_t)-1;
+    fail_timeout = 10;
+
+    for (i = 2; i < cf->args->nelts; i++) {
+
+        if (ngx_strncmp(value[i].data, "weight=", 7) == 0) {
+
+            if (!(uscf->flags & NGX_TCP_UPSTREAM_WEIGHT)) {
+                goto invalid;
+            }
+
+            weight = ngx_atoi(&value[i].data[7], value[i].len - 7);
+
+            if (weight == NGX_ERROR || weight == 0) {
+                goto invalid;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "max_fails=", 10) == 0) {
+
+            if (!(uscf->flags & NGX_TCP_UPSTREAM_MAX_FAILS)) {
+                goto invalid;
+            }
+
+            max_fails = ngx_atoi(&value[i].data[10], value[i].len - 10);
+
+            if (max_fails == NGX_ERROR) {
+                goto invalid;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "max_busy=", 9) == 0) {
+
+            if (!(uscf->flags & NGX_TCP_UPSTREAM_MAX_BUSY)) {
+                goto invalid;
+            }
+
+            max_busy = ngx_atoi(&value[i].data[9], value[i].len - 9);
+
+            if (max_busy == NGX_ERROR) {
+                goto invalid;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "fail_timeout=", 13) == 0) {
+
+            if (!(uscf->flags & NGX_TCP_UPSTREAM_FAIL_TIMEOUT)) {
+                goto invalid;
+            }
+
+            s.len = value[i].len - 13;
+            s.data = &value[i].data[13];
+
+            fail_timeout = ngx_parse_time(&s, 1);
+
+            if (fail_timeout == NGX_ERROR) {
+                goto invalid;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "backup", 6) == 0) {
+
+            if (!(uscf->flags & NGX_TCP_UPSTREAM_BACKUP)) {
+                goto invalid;
+            }
+
+            us->backup = 1;
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "down", 4) == 0) {
+
+            if (!(uscf->flags & NGX_TCP_UPSTREAM_DOWN)) {
+                goto invalid;
+            }
+
+            us->down = 1;
+
+            continue;
+        }
+
+        goto invalid;
+    }
+
+    us->addrs = u.addrs;
+    us->naddrs = u.naddrs;
+    us->weight = weight;
+    us->max_fails = max_fails;
+    us->max_busy = max_busy;
+    us->fail_timeout = fail_timeout;
+
+    return NGX_CONF_OK;
+
+invalid:
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid parameter \"%V\"", &value[i]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static char *
+ngx_tcp_upstream_check(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) 
+{
+    ngx_tcp_upstream_srv_conf_t  *uscf = conf;
+
+    ngx_str_t   *value, s;
+    ngx_uint_t   i, rise, fall;
+    ngx_msec_t   interval, timeout;
+
+    /*set default*/
+    rise = 2;
+    fall = 5;
+    interval = 30000;
+    timeout = 1000;
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+
+        if (ngx_strncmp(value[i].data, "type=", 5) == 0) {
+            s.len = value[i].len - 5;
+            s.data = value[i].data + 5;
+
+            uscf->check_type_conf = ngx_tcp_get_check_type_conf(&s);
+
+            if ( uscf->check_type_conf == NULL) {
+                goto invalid_check_parameter;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "interval=", 9) == 0) {
+            s.len = value[i].len - 9;
+            s.data = value[i].data + 9;
+
+            interval = ngx_atoi(s.data, s.len);
+            if (interval == (ngx_msec_t) NGX_ERROR) {
+                goto invalid_check_parameter;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "timeout=", 8) == 0) {
+            s.len = value[i].len - 8;
+            s.data = value[i].data + 8;
+
+            timeout = ngx_atoi(s.data, s.len);
+            if (timeout == (ngx_msec_t) NGX_ERROR) {
+                goto invalid_check_parameter;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "rise=", 5) == 0) {
+            s.len = value[i].len - 5;
+            s.data = value[i].data + 5;
+
+            rise = ngx_atoi(s.data, s.len);
+            if (rise == (ngx_uint_t) NGX_ERROR) {
+                goto invalid_check_parameter;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "fall=", 5) == 0) {
+            s.len = value[i].len - 5;
+            s.data = value[i].data + 5;
+
+            fall = ngx_atoi(s.data, s.len);
+            if (fall == (ngx_uint_t) NGX_ERROR) {
+                goto invalid_check_parameter;
+            }
+
+            continue;
+        }
+
+        goto invalid_check_parameter;
+    }
+
+    uscf->check_interval = interval;
+    uscf->check_timeout = timeout;
+    uscf->fall_count = fall;
+    uscf->rise_count = rise;
+
+    if (uscf->check_type_conf == NULL) {
+        s.len = sizeof("tcp") - 1;
+        s.data =(u_char *) "tcp";
+
+        uscf->check_type_conf = ngx_tcp_get_check_type_conf(&s);
+    }
+
+    return NGX_CONF_OK;
+
+invalid_check_parameter:
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid parameter \"%V\"", &value[i]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static void *
+ngx_tcp_upstream_create_main_conf(ngx_conf_t *cf) 
+{
+    ngx_tcp_upstream_main_conf_t  *umcf;
+
+    umcf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_main_conf_t));
+    if (umcf == NULL) {
+        return NULL;
+    }
+
+    umcf->peers_conf = ngx_pcalloc(cf->pool,
+                                   sizeof(ngx_tcp_check_peers_conf_t));
+    if (umcf->peers_conf == NULL) {
+        return NULL;
+    }
+
+    if (ngx_array_init(&umcf->upstreams, cf->pool, 4,
+                       sizeof(ngx_tcp_upstream_srv_conf_t *)) != NGX_OK)
+    {
+        return NULL;
+    }
+
+    if (ngx_array_init(&umcf->peers_conf->peers, cf->pool, 16,
+                       sizeof(ngx_tcp_check_peer_conf_t)) != NGX_OK)
+    {
+        return NULL;
+    }
+
+    return umcf;
+}
+
+
+static char *
+ngx_tcp_upstream_init_main_conf(ngx_conf_t *cf, void *conf) 
+{
+    ngx_tcp_upstream_main_conf_t   *umcf = conf;
+
+    ngx_uint_t                      i;
+    ngx_tcp_upstream_init_pt        init;
+    ngx_tcp_upstream_srv_conf_t   **uscfp;
+
+    uscfp = umcf->upstreams.elts;
+
+    if (ngx_tcp_upstream_init_main_check_conf(cf, conf) != NGX_OK) {
+            return NGX_CONF_ERROR;
+    }
+
+    for (i = 0; i < umcf->upstreams.nelts; i++) {
+
+        init = uscfp[i]->peer.init_upstream ? uscfp[i]->peer.init_upstream:
+                                              ngx_tcp_upstream_init_round_robin;
+
+        if (init(cf, uscfp[i]) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+// ======================= ngx_tcp_upstream_tproxy
+
+#if (NGX_HAVE_TPROXY)
+ngx_int_t
+ngx_tcp_upstream_init_tproxy(ngx_conf_t *cf,
+    ngx_tcp_upstream_srv_conf_t *us)
+{
+	return NGX_OK;
+}
+
+ngx_int_t ngx_tcp_upstream_create_tproxy_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_resolved_t *ur)
+{
+	ngx_peer_connection_t *pc;
+
+	pc = &s->upstream->peer;
+
+	pc->name = ngx_palloc(s->pool, sizeof(ngx_str_t));
+	if(pc->name == NULL)
+		return NGX_ERROR;
+	
+	pc->name->data = ngx_palloc(s->pool, NGX_SOCKADDR_STRLEN);
+	if(pc->name->data == NULL)
+		return NGX_ERROR;
+	
+	pc->name->len = ngx_sock_ntop(s->connection->dst_sockaddr, pc->name->data,
+											 NGX_SOCKADDR_STRLEN, 1);
+	if(pc->name->len == 0)
+		return NGX_ERROR;
+	
+	
+	pc->sockaddr = s->connection->dst_sockaddr;
+	pc->socklen = s->connection->socklen;
+
+	
+    //s->upstream->peer.sockaddr = s->connection->dst_sockaddr;
+    //s->upstream->peer.socklen = s->connection->socklen;
+    pc->get = ngx_tcp_upstream_get_tproxy_peer;	
+    pc->tries = 0;
+    pc->check_index = NGX_INVALID_CHECK_INDEX;
+	pc->connection = NULL;
+    return NGX_OK;
+}
+
+ngx_int_t ngx_tcp_upstream_get_tproxy_peer(ngx_peer_connection_t *pc,
+    void *data)
+{
+
+
+
+
+
+
+	return NGX_OK;
+}
+
+
+
+#endif
+
diff --git a/src/tcp/ngx_tcp_upstream.h b/src/tcp/ngx_tcp_upstream.h
new file mode 100755
index 0000000..f6e3e65
--- /dev/null
+++ b/src/tcp/ngx_tcp_upstream.h
@@ -0,0 +1,203 @@
+
+#ifndef _NGX_TCP_UPSTREAM_H_INCLUDED_
+#define _NGX_TCP_UPSTREAM_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+#include <ngx_event_pipe.h>
+#include <ngx_tcp.h>
+
+
+#define NGX_TCP_UPSTREAM_FT_ERROR           0x00000002
+#define NGX_TCP_UPSTREAM_FT_TIMEOUT         0x00000004
+#define NGX_TCP_UPSTREAM_FT_INVALID_HEADER  0x00000008
+#define NGX_TCP_UPSTREAM_FT_TCP_500         0x00000010
+#define NGX_TCP_UPSTREAM_FT_TCP_502         0x00000020
+#define NGX_TCP_UPSTREAM_FT_TCP_503         0x00000040
+#define NGX_TCP_UPSTREAM_FT_TCP_504         0x00000080
+#define NGX_TCP_UPSTREAM_FT_TCP_404         0x00000100
+#define NGX_TCP_UPSTREAM_FT_UPDATING        0x00000200
+#define NGX_TCP_UPSTREAM_FT_BUSY_LOCK       0x00000400
+#define NGX_TCP_UPSTREAM_FT_MAX_WAITING     0x00000800
+#define NGX_TCP_UPSTREAM_FT_NOLIVE          0x40000000
+#define NGX_TCP_UPSTREAM_FT_OFF             0x80000000
+
+#define NGX_TCP_UPSTREAM_FT_STATUS          (NGX_TCP_UPSTREAM_FT_TCP_500  \
+                                             |NGX_TCP_UPSTREAM_FT_TCP_502  \
+                                             |NGX_TCP_UPSTREAM_FT_TCP_503  \
+                                             |NGX_TCP_UPSTREAM_FT_TCP_504  \
+                                             |NGX_TCP_UPSTREAM_FT_TCP_404)
+
+#define NGX_TCP_UPSTREAM_INVALID_HEADER     40
+
+
+#define NGX_TCP_UPSTREAM_IGN_XA_REDIRECT    0x00000002
+#define NGX_TCP_UPSTREAM_IGN_XA_EXPIRES     0x00000004
+#define NGX_TCP_UPSTREAM_IGN_EXPIRES        0x00000008
+#define NGX_TCP_UPSTREAM_IGN_CACHE_CONTROL  0x00000010
+
+typedef struct {
+    ngx_msec_t                       bl_time;
+    ngx_uint_t                       bl_state;
+
+    ngx_uint_t                       status;
+    time_t                           response_sec;
+    ngx_uint_t                       response_msec;
+
+    ngx_str_t                       *peer;
+} ngx_tcp_upstream_state_t;
+
+
+typedef struct {
+    ngx_uint_t                       check_shm_size;
+    ngx_tcp_check_peers_conf_t      *peers_conf;
+    ngx_array_t                      upstreams; /* ngx_tcp_upstream_srv_conf_t */
+} ngx_tcp_upstream_main_conf_t;
+
+
+typedef ngx_int_t (*ngx_tcp_upstream_init_pt)(ngx_conf_t *cf,
+        ngx_tcp_upstream_srv_conf_t *us);
+typedef ngx_int_t (*ngx_tcp_upstream_init_peer_pt)(ngx_tcp_session_t *s,
+        ngx_tcp_upstream_srv_conf_t *us);
+
+typedef struct {
+    ngx_tcp_upstream_init_pt         init_upstream;
+    ngx_tcp_upstream_init_peer_pt    init;
+    void                            *data;
+} ngx_tcp_upstream_peer_t;
+
+typedef struct {
+    ngx_peer_addr_t                 *addrs;
+    ngx_uint_t                       naddrs;
+    ngx_uint_t                       weight;
+    ngx_uint_t                       max_fails;
+    time_t                           fail_timeout;
+    ngx_uint_t                       max_busy;
+
+    unsigned                         down:1;
+    unsigned                         backup:1;
+} ngx_tcp_upstream_server_t;
+
+
+#define NGX_TCP_UPSTREAM_CREATE        0x0001
+#define NGX_TCP_UPSTREAM_WEIGHT        0x0002
+#define NGX_TCP_UPSTREAM_MAX_FAILS     0x0004
+#define NGX_TCP_UPSTREAM_FAIL_TIMEOUT  0x0008
+#define NGX_TCP_UPSTREAM_DOWN          0x0010
+#define NGX_TCP_UPSTREAM_BACKUP        0x0020
+#define NGX_TCP_UPSTREAM_SRUN_ID       0x0040
+#define NGX_TCP_UPSTREAM_MAX_BUSY      0x0080
+#define NGX_TCP_UPSTREAM_TPROXY        0x0100
+
+struct ngx_tcp_upstream_srv_conf_s {
+
+    ngx_tcp_upstream_peer_t          peer;
+    void                           **srv_conf;
+
+    ngx_array_t                     *servers;  /* ngx_tcp_upstream_server_t */
+
+    ngx_uint_t                       flags;
+    ngx_str_t                        host;
+    u_char                          *file_name;
+    ngx_uint_t                       line;
+    in_port_t                        port;
+    in_port_t                        default_port;
+#if (nginx_version) >= 1003011
+    ngx_uint_t                       no_port;  /* unsigned no_port:1 */
+#endif
+
+    ngx_uint_t                       fall_count;
+    ngx_uint_t                       rise_count;
+    ngx_msec_t                       check_interval;
+    ngx_msec_t                       check_timeout;
+
+    check_conf_t                    *check_type_conf;
+    ngx_str_t                        send;
+
+    union {
+        ngx_uint_t                   return_code;
+        ngx_uint_t                   status_alive;
+    } code;
+};
+
+
+typedef struct {
+    ngx_tcp_upstream_srv_conf_t     *upstream;
+
+    ngx_msec_t                       connect_timeout;
+    ngx_msec_t                       send_timeout;
+    ngx_msec_t                       read_timeout;
+    ngx_msec_t                       timeout;
+} ngx_tcp_upstream_conf_t;
+
+
+struct ngx_tcp_upstream_resolved_s {
+    ngx_str_t                        host;
+    in_port_t                        port;
+    ngx_uint_t                       no_port; /* unsigned no_port:1 */
+
+    ngx_uint_t                       naddrs;
+    in_addr_t                       *addrs;
+
+    struct sockaddr                 *sockaddr;
+    socklen_t                        socklen;
+
+    ngx_resolver_ctx_t              *ctx;
+};
+
+
+typedef void (*ngx_tcp_upstream_handler_pt)(ngx_tcp_session_t *s,
+        ngx_tcp_upstream_t *u);
+
+struct ngx_tcp_upstream_s {
+    ngx_tcp_upstream_handler_pt      read_event_handler;
+    ngx_tcp_upstream_handler_pt      write_event_handler;
+
+    ngx_peer_connection_t            peer;
+    ngx_tcp_upstream_conf_t         *conf;
+    ngx_tcp_upstream_resolved_t     *resolved;
+    ngx_tcp_upstream_state_t        *state;
+    ngx_tcp_cleanup_pt              *cleanup;
+};
+
+
+typedef struct {
+    ngx_uint_t                       status;
+    ngx_uint_t                       mask;
+} ngx_tcp_upstream_next_t;
+
+
+ngx_int_t ngx_tcp_upstream_create(ngx_tcp_session_t *s);
+void ngx_tcp_upstream_init(ngx_tcp_session_t *s);
+ngx_tcp_upstream_srv_conf_t *ngx_tcp_upstream_add(ngx_conf_t *cf,
+    ngx_url_t *u, ngx_uint_t flags);
+
+ngx_int_t ngx_tcp_upstream_check_broken_connection(ngx_tcp_session_t *s);
+void ngx_tcp_upstream_next(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u,
+     ngx_uint_t ft_type);
+
+
+#if (NGX_HAVE_TPROXY)
+ngx_int_t ngx_tcp_upstream_init_tproxy(ngx_conf_t *cf,
+    ngx_tcp_upstream_srv_conf_t *us);
+ngx_int_t ngx_tcp_upstream_create_tproxy_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_resolved_t *ur);
+ngx_int_t ngx_tcp_upstream_get_tproxy_peer(ngx_peer_connection_t *pc,
+    void *data);
+
+#endif
+
+
+#define ngx_tcp_conf_upstream_srv_conf(uscf, module)                         \
+    uscf->srv_conf[module.ctx_index]
+
+
+
+
+extern ngx_module_t        ngx_tcp_upstream_module;
+
+
+#endif /* _NGX_TCP_UPSTREAM_H_INCLUDED_ */
diff --git a/src/tcp/ngx_tcp_upstream_check.c b/src/tcp/ngx_tcp_upstream_check.c
new file mode 100755
index 0000000..a15b6fb
--- /dev/null
+++ b/src/tcp/ngx_tcp_upstream_check.c
@@ -0,0 +1,1954 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+#include <ngx_http.h>
+
+
+/* ngx_spinlock is defined without a matching unlock primitive */
+#define ngx_spinlock_unlock(lock)      \
+    (void) ngx_atomic_cmp_set(lock, ngx_pid, 0)
+
+static ngx_int_t ngx_tcp_check_get_shm_name(ngx_str_t *shm_name,
+    ngx_pool_t *pool);
+static ngx_int_t ngx_tcp_upstream_check_init_shm_zone(ngx_shm_zone_t *shm_zone,
+    void *data);
+static ngx_int_t ngx_tcp_check_init_process(ngx_cycle_t *cycle);
+
+static void ngx_tcp_check_peek_handler(ngx_event_t *event);
+
+static void ngx_tcp_check_send_handler(ngx_event_t *event);
+static void ngx_tcp_check_recv_handler(ngx_event_t *event);
+
+static ngx_int_t ngx_tcp_check_http_init(ngx_tcp_check_peer_conf_t *peer_conf);
+static ngx_int_t ngx_tcp_check_http_parse(ngx_tcp_check_peer_conf_t *peer_conf);
+static void ngx_tcp_check_http_reinit(ngx_tcp_check_peer_conf_t *peer_conf);
+
+static ngx_int_t ngx_tcp_check_ssl_hello_init(ngx_tcp_check_peer_conf_t *peer_conf);
+static ngx_int_t ngx_tcp_check_ssl_hello_parse(ngx_tcp_check_peer_conf_t *peer_conf);
+static void ngx_tcp_check_ssl_hello_reinit(ngx_tcp_check_peer_conf_t *peer_conf);
+
+static ngx_int_t ngx_tcp_check_smtp_init(ngx_tcp_check_peer_conf_t *peer_conf);
+static ngx_int_t ngx_tcp_check_smtp_parse(ngx_tcp_check_peer_conf_t *peer_conf);
+static void ngx_tcp_check_smtp_reinit(ngx_tcp_check_peer_conf_t *peer_conf);
+
+static ngx_int_t ngx_tcp_check_mysql_init(ngx_tcp_check_peer_conf_t *peer_conf);
+static ngx_int_t ngx_tcp_check_mysql_parse(ngx_tcp_check_peer_conf_t *peer_conf);
+static void ngx_tcp_check_mysql_reinit(ngx_tcp_check_peer_conf_t *peer_conf);
+
+static ngx_int_t ngx_tcp_check_pop3_init(ngx_tcp_check_peer_conf_t *peer_conf);
+static ngx_int_t ngx_tcp_check_pop3_parse(ngx_tcp_check_peer_conf_t *peer_conf);
+static void ngx_tcp_check_pop3_reinit(ngx_tcp_check_peer_conf_t *peer_conf);
+
+static ngx_int_t ngx_tcp_check_imap_init(ngx_tcp_check_peer_conf_t *peer_conf);
+static ngx_int_t ngx_tcp_check_imap_parse(ngx_tcp_check_peer_conf_t *peer_conf);
+static void ngx_tcp_check_imap_reinit(ngx_tcp_check_peer_conf_t *peer_conf);
+
+static char * ngx_tcp_upstream_check_status_set_status(ngx_conf_t *cf, 
+        ngx_command_t *cmd, void *conf);
+static char * ngx_tcp_upstream_check_status(ngx_conf_t *cf, 
+        ngx_command_t *cmd, void *conf);
+
+
+#define RANDOM "NGX_TCP_CHECK_SSL_HELLO\n\n\n\n\n"
+
+/* This is the SSLv3 CLIENT HELLO packet used in conjunction with the
+ * check type of ssl_hello to ensure that the remote server speaks SSL.
+ *
+ * Check RFC 2246 (TLSv1.0) sections A.3 and A.4 for details.
+ *
+ * Some codes copy from HAProxy 1.4.1
+ */
+static const char sslv3_client_hello_pkt[] = {
+	"\x16"                /* ContentType         : 0x16 = Hanshake           */
+	"\x03\x00"            /* ProtocolVersion     : 0x0300 = SSLv3            */
+	"\x00\x79"            /* ContentLength       : 0x79 bytes after this one */
+	"\x01"                /* HanshakeType        : 0x01 = CLIENT HELLO       */
+	"\x00\x00\x75"        /* HandshakeLength     : 0x75 bytes after this one */
+	"\x03\x00"            /* Hello Version       : 0x0300 = v3               */
+	"\x00\x00\x00\x00"    /* Unix GMT Time (s)   : filled with <now> (@0x0B) */
+	RANDOM                /* Random   : must be exactly 28 bytes  */
+	"\x00"                /* Session ID length   : empty (no session ID)     */
+	"\x00\x4E"            /* Cipher Suite Length : 78 bytes after this one   */
+	"\x00\x01" "\x00\x02" "\x00\x03" "\x00\x04" /* 39 most common ciphers :  */
+	"\x00\x05" "\x00\x06" "\x00\x07" "\x00\x08" /* 0x01...0x1B, 0x2F...0x3A  */
+	"\x00\x09" "\x00\x0A" "\x00\x0B" "\x00\x0C" /* This covers RSA/DH,       */
+	"\x00\x0D" "\x00\x0E" "\x00\x0F" "\x00\x10" /* various bit lengths,      */
+	"\x00\x11" "\x00\x12" "\x00\x13" "\x00\x14" /* SHA1/MD5, DES/3DES/AES... */
+	"\x00\x15" "\x00\x16" "\x00\x17" "\x00\x18"
+	"\x00\x19" "\x00\x1A" "\x00\x1B" "\x00\x2F"
+	"\x00\x30" "\x00\x31" "\x00\x32" "\x00\x33"
+	"\x00\x34" "\x00\x35" "\x00\x36" "\x00\x37"
+	"\x00\x38" "\x00\x39" "\x00\x3A"
+	"\x01"                /* Compression Length  : 0x01 = 1 byte for types   */
+	"\x00"                /* Compression Type    : 0x00 = NULL compression   */
+};
+
+
+#define HANDSHAKE    0x16
+#define SERVER_HELLO 0x02
+
+static check_conf_t  ngx_check_types[] = {
+
+    { NGX_TCP_CHECK_TCP,
+      "tcp",
+      ngx_null_string,
+      0,
+      ngx_tcp_check_peek_handler,
+      ngx_tcp_check_peek_handler,
+      NULL,
+      NULL,
+      NULL,
+      0 },
+
+    { NGX_TCP_CHECK_HTTP,
+      "http",
+      ngx_string("GET / HTTP/1.0\r\n\r\n"),
+      NGX_CONF_BITMASK_SET | NGX_CHECK_HTTP_2XX | NGX_CHECK_HTTP_3XX,
+      ngx_tcp_check_send_handler,
+      ngx_tcp_check_recv_handler,
+      ngx_tcp_check_http_init,
+      ngx_tcp_check_http_parse,
+      ngx_tcp_check_http_reinit,
+      1 },
+
+    { NGX_TCP_CHECK_SSL_HELLO,
+      "ssl_hello",
+      ngx_string(sslv3_client_hello_pkt),
+      0,
+      ngx_tcp_check_send_handler,
+      ngx_tcp_check_recv_handler,
+      ngx_tcp_check_ssl_hello_init,
+      ngx_tcp_check_ssl_hello_parse,
+      ngx_tcp_check_ssl_hello_reinit,
+      1 },
+
+    { NGX_TCP_CHECK_SMTP,
+      "smtp",
+      ngx_string("HELO smtp.localdomain\r\n"),
+      NGX_CONF_BITMASK_SET | NGX_CHECK_SMTP_2XX,
+      ngx_tcp_check_send_handler,
+      ngx_tcp_check_recv_handler,
+      ngx_tcp_check_smtp_init,
+      ngx_tcp_check_smtp_parse,
+      ngx_tcp_check_smtp_reinit,
+      1 },
+
+    { NGX_TCP_CHECK_MYSQL,
+      "mysql",
+      ngx_null_string,
+      0,
+      ngx_tcp_check_send_handler,
+      ngx_tcp_check_recv_handler,
+      ngx_tcp_check_mysql_init,
+      ngx_tcp_check_mysql_parse,
+      ngx_tcp_check_mysql_reinit,
+      1 },
+
+    { NGX_TCP_CHECK_POP3,
+      "pop3",
+      ngx_null_string,
+      0,
+      ngx_tcp_check_send_handler,
+      ngx_tcp_check_recv_handler,
+      ngx_tcp_check_pop3_init,
+      ngx_tcp_check_pop3_parse,
+      ngx_tcp_check_pop3_reinit,
+      1 },
+
+    { NGX_TCP_CHECK_IMAP,
+      "imap",
+      ngx_null_string,
+      0,
+      ngx_tcp_check_send_handler,
+      ngx_tcp_check_recv_handler,
+      ngx_tcp_check_imap_init,
+      ngx_tcp_check_imap_parse,
+      ngx_tcp_check_imap_reinit,
+      1 },
+
+    {0, "", ngx_null_string, 0, NULL, NULL, NULL, NULL, NULL, 0}
+};
+
+
+static ngx_conf_deprecated_t  ngx_conf_deprecated_check_status = {
+    ngx_conf_deprecated, "check_status", "tcp_check_status"
+};
+
+static ngx_command_t  ngx_tcp_upstream_check_status_commands[] = {
+
+    { ngx_string("check_status"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
+      ngx_tcp_upstream_check_status_set_status,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("tcp_check_status"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
+      ngx_tcp_upstream_check_status,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_http_module_t  ngx_tcp_upstream_check_status_module_ctx = {
+    NULL,                                  /* preconfiguration */
+    NULL,                                  /* postconfiguration */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    NULL,                                  /* create server configuration */
+    NULL,                                  /* merge server configuration */
+
+    NULL,                                  /* create location configuration */
+    NULL                                   /* merge location configuration */
+};
+
+
+ngx_module_t  ngx_tcp_upstream_check_status_module = {
+    NGX_MODULE_V1,
+    &ngx_tcp_upstream_check_status_module_ctx, /* module context */
+    ngx_tcp_upstream_check_status_commands,    /* module directives */
+    NGX_HTTP_MODULE,                           /* module type */
+    NULL,                                      /* init master */
+    NULL,                                      /* init module */
+    ngx_tcp_check_init_process,                /* init process */
+    NULL,                                      /* init thread */
+    NULL,                                      /* exit thread */
+    NULL,                                      /* exit process */
+    NULL,                                      /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_uint_t ngx_tcp_check_shm_generation = 0;
+static ngx_tcp_check_peers_conf_t *check_peers_ctx = NULL;
+
+
+check_conf_t *
+ngx_tcp_get_check_type_conf(ngx_str_t *str) 
+{
+    ngx_uint_t i;
+
+    for (i = 0; ;i++) {
+
+        if (ngx_check_types[i].type == 0) {
+            break;
+        }
+
+        if (ngx_strncmp(str->data, (u_char *)ngx_check_types[i].name,
+                        str->len) == 0) {
+            return &ngx_check_types[i];
+        }
+    }
+
+    return NULL;
+}
+
+
+ngx_uint_t
+ngx_tcp_check_add_peer(ngx_conf_t *cf, ngx_tcp_upstream_srv_conf_t *uscf,
+    ngx_peer_addr_t *peer, ngx_uint_t max_busy) 
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_check_peers_conf_t    *peers_conf;
+    ngx_tcp_upstream_main_conf_t  *umcf; 
+
+    umcf = ngx_tcp_conf_get_module_main_conf(cf, ngx_tcp_upstream_module);
+
+    peers_conf = umcf->peers_conf;
+
+    peer_conf = ngx_array_push(&peers_conf->peers);
+    if (peer_conf == NULL) {
+        return NGX_INVALID_CHECK_INDEX;
+    }
+
+    ngx_memzero(peer_conf, sizeof(ngx_tcp_check_peer_conf_t));
+
+    peer_conf->index = peers_conf->peers.nelts - 1;
+    peer_conf->max_busy = max_busy;
+    peer_conf->conf = uscf;
+    peer_conf->peer = peer;
+
+    return peer_conf->index;
+}
+
+
+ngx_uint_t 
+ngx_tcp_check_peer_down(ngx_uint_t index)
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+
+    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {
+        return 0;
+    }
+
+    peer_conf = check_peers_ctx->peers.elts;
+
+    return (peer_conf[index].shm->down || 
+            (peer_conf[index].shm->busyness > peer_conf[index].max_busy));
+}
+
+
+ngx_uint_t 
+ngx_tcp_check_get_peer_busyness(ngx_uint_t index)
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+
+    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {
+        return (ngx_uint_t) (-1);
+    }
+
+    peer_conf = check_peers_ctx->peers.elts;
+
+    return peer_conf[index].shm->busyness;
+}
+
+
+void 
+ngx_tcp_check_get_peer(ngx_uint_t index) 
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+
+    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {
+        return;
+    }
+
+    peer_conf = check_peers_ctx->peers.elts;
+
+    ngx_spinlock(&peer_conf[index].shm->lock, ngx_pid, 1024);
+
+    peer_conf[index].shm->busyness++;
+    peer_conf[index].shm->access_count++;
+
+    ngx_spinlock_unlock(&peer_conf[index].shm->lock);
+}
+
+
+void 
+ngx_tcp_check_free_peer(ngx_uint_t index) 
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+
+    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {
+        return;
+    }
+
+    peer_conf = check_peers_ctx->peers.elts;
+
+    ngx_spinlock(&peer_conf[index].shm->lock, ngx_pid, 1024);
+
+    if (peer_conf[index].shm->busyness > 0) {
+        peer_conf[index].shm->busyness--;
+    }
+
+    ngx_spinlock_unlock(&peer_conf[index].shm->lock);
+}
+
+
+#define SHM_NAME_LEN 256
+
+static ngx_int_t
+ngx_tcp_upstream_check_init_shm_zone(ngx_shm_zone_t *shm_zone, void *data) 
+{
+    ngx_uint_t                      i;
+    ngx_slab_pool_t                *shpool;
+    ngx_tcp_check_peer_shm_t       *peer_shm;
+    ngx_tcp_check_peers_shm_t      *peers_shm;
+    ngx_tcp_check_peers_conf_t     *peers_conf;
+
+    peers_conf = shm_zone->data;
+
+    if (peers_conf == NULL || peers_conf->peers.nelts == 0) {
+        return NGX_OK;
+    }
+
+    if (data) {
+        peers_shm = data;
+    } else {
+        shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
+
+        peers_shm = ngx_slab_alloc(shpool, sizeof(*peers_shm) +
+            (peers_conf->peers.nelts - 1) * sizeof(ngx_tcp_check_peer_shm_t));
+
+        if (peers_shm == NULL) {
+            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
+                          "tcp upstream check_shm_size is too small, "
+                          "you should set a larger size.");
+            return NGX_ERROR;
+        }
+    }
+
+    peers_shm->generation = ngx_tcp_check_shm_generation;
+
+    for (i = 0; i < peers_conf->peers.nelts; i++) {
+        peer_shm = &peers_shm->peers[i];
+
+        peer_shm->owner = NGX_INVALID_PID;
+
+        peer_shm->access_time = 0;
+        peer_shm->access_count = 0;
+
+        peer_shm->fall_count = 0;
+        peer_shm->rise_count = 0;
+
+        peer_shm->busyness = 0;
+        peer_shm->down = 1;
+    }
+
+    peers_conf->peers_shm = peers_shm;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_get_shm_name(ngx_str_t *shm_name, ngx_pool_t *pool) 
+{
+    u_char    *last;
+
+    shm_name->data = ngx_palloc(pool, SHM_NAME_LEN);
+    if (shm_name->data == NULL) {
+        return NGX_ERROR;
+    }
+
+    last = ngx_snprintf(shm_name->data, SHM_NAME_LEN, "%s#%ui",
+                        "ngx_tcp_upstream", ngx_tcp_check_shm_generation);
+
+    shm_name->len = last - shm_name->data;
+
+    return NGX_OK;
+}
+
+
+static ngx_shm_zone_t *
+ngx_shared_memory_find(ngx_cycle_t *cycle, ngx_str_t *name, void *tag)
+{
+    ngx_uint_t        i;
+    ngx_shm_zone_t   *shm_zone;
+    ngx_list_part_t  *part;
+
+    part = (ngx_list_part_t *) & (cycle->shared_memory.part);
+    shm_zone = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            shm_zone = part->elts;
+            i = 0;
+        }
+
+        if (name->len != shm_zone[i].shm.name.len) {
+            continue;
+        }
+
+        if (ngx_strncmp(name->data, shm_zone[i].shm.name.data, name->len)
+            != 0)
+        {
+            continue;
+        }
+
+        if (tag != shm_zone[i].tag) {
+            continue;
+        }
+
+        return &shm_zone[i];
+    }
+
+    return NULL;
+}
+
+
+static void 
+ngx_tcp_check_clean_event(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_connection_t            *c;
+
+    c = peer_conf->pc.connection;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, 0, 
+                   "tcp check clean event: index:%d, fd: %d", 
+                   peer_conf->index, c->fd);
+
+    ngx_close_connection(c);
+
+    if (peer_conf->check_timeout_ev.timer_set) {
+        ngx_del_timer(&peer_conf->check_timeout_ev);
+    }
+
+    peer_conf->state = NGX_TCP_CHECK_ALL_DONE;
+
+    if (peer_conf->check_data != NULL && peer_conf->reinit) {
+        peer_conf->reinit(peer_conf);
+    }
+
+    ngx_spinlock(&peer_conf->shm->lock, ngx_pid, 1024);
+
+    peer_conf->shm->owner = NGX_INVALID_PID;
+
+    ngx_spinlock_unlock(&peer_conf->shm->lock);
+}
+
+
+static void 
+ngx_tcp_check_clear_all_events() 
+{
+    ngx_uint_t                     i;
+    static ngx_flag_t              has_cleared = 0;
+    ngx_tcp_check_peer_shm_t      *peer_shm;
+    ngx_tcp_check_peers_shm_t     *peers_shm;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_check_peers_conf_t    *peers_conf;
+
+    if (has_cleared || check_peers_ctx == NULL) {
+        return;
+    }
+
+    has_cleared = 1;
+
+    peers_conf = check_peers_ctx;
+    peers_shm = peers_conf->peers_shm;
+
+    peer_conf = peers_conf->peers.elts;
+    peer_shm = peers_shm->peers;
+    for (i = 0; i < peers_conf->peers.nelts; i++) {
+        if (peer_conf[i].check_ev.timer_set) {
+            ngx_del_timer(&peer_conf[i].check_ev);
+        }
+        if (peer_shm[i].owner == ngx_pid) {
+            ngx_tcp_check_clean_event(&peer_conf[i]);
+        }
+        if (peer_conf[i].pool != NULL) {
+            ngx_destroy_pool(peer_conf[i].pool);
+        }
+    }
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_need_exit() 
+{
+    if (ngx_terminate || ngx_exiting || ngx_quit) {
+        ngx_tcp_check_clear_all_events();
+        return 1;
+    }
+
+    return 0;
+}
+
+
+static void 
+ngx_tcp_check_finish_handler(ngx_event_t *event) 
+{
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+}
+
+
+static void 
+ngx_tcp_check_status_update(ngx_tcp_check_peer_conf_t *peer_conf,
+    ngx_int_t result) 
+{
+    ngx_tcp_upstream_srv_conf_t   *uscf;
+
+    uscf = peer_conf->conf;
+
+    if (result) {
+        peer_conf->shm->rise_count++; 
+        peer_conf->shm->fall_count = 0; 
+        if (peer_conf->shm->down
+            && (peer_conf->shm->rise_count >= uscf->rise_count)) {
+
+            peer_conf->shm->down = 0; 
+        } 
+    } else {
+        peer_conf->shm->rise_count = 0; 
+        peer_conf->shm->fall_count++; 
+        if (!peer_conf->shm->down
+             && (peer_conf->shm->fall_count >= uscf->fall_count)) {
+            peer_conf->shm->down = 1; 
+        }
+    }
+
+    peer_conf->shm->access_time = ngx_current_msec; 
+}
+
+
+static void 
+ngx_tcp_check_timeout_handler(ngx_event_t *event) 
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+
+    peer_conf = event->data;
+
+    ngx_log_error(NGX_LOG_ERR, event->log, 0,
+                  "check time out with peer: %V ", &peer_conf->peer->name);
+
+    ngx_tcp_check_status_update(peer_conf, 0);
+    ngx_tcp_check_clean_event(peer_conf);
+}
+
+
+static void 
+ngx_tcp_check_peek_handler(ngx_event_t *event) 
+{
+    char                           buf[1];
+    ngx_int_t                      n;
+    ngx_err_t                      err;
+    ngx_connection_t              *c;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+
+    c = event->data;
+    peer_conf = c->data;
+
+    n = recv(c->fd, buf, 1, MSG_PEEK);
+
+    err = ngx_socket_errno;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err, 
+                   "tcp check upstream recv(): %d, fd: %d",
+                   n, c->fd);
+
+    if (n >= 0 || err == NGX_EAGAIN) {
+        ngx_tcp_check_status_update(peer_conf, 1);
+    } else {
+        c->error = 1;
+        ngx_tcp_check_status_update(peer_conf, 0);
+    }
+
+    ngx_tcp_check_clean_event(peer_conf);
+
+    /* dummy */
+    ngx_tcp_check_finish_handler(event);
+}
+
+
+void
+http_field(void *data, const signed char *field, 
+    size_t flen, const signed char *value, size_t vlen)
+{
+#if (NGX_DEBUG)
+    ngx_str_t str_field, str_value;
+
+    str_field.data = (u_char *) field;
+    str_field.len = flen;
+
+    str_value.data = (u_char *) value;
+    str_value.len = vlen;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "%V: %V", &str_field, &str_value);
+#endif
+}
+
+
+void
+http_version(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "VERSION: \"%V\"", &str);
+#endif
+}
+
+
+void
+status_code(void *data, const signed char *at, size_t length)
+{
+    int                        code;
+    ngx_tcp_check_ctx         *ctx;
+    http_response_parser      *hp;
+    ngx_tcp_check_peer_conf_t *peer_conf = data;
+
+#if (NGX_DEBUG)
+    ngx_str_t                  str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "STATUS_CODE: \"%V\"", &str);
+#endif
+
+    ctx = peer_conf->check_data;
+    hp = ctx->parser;
+
+    code = ngx_atoi((u_char*)at, length);
+
+    if (code >= 200 && code < 300) {
+        hp->status_code_n = NGX_CHECK_HTTP_2XX;
+
+    } else if (code >= 300 && code < 400) {
+        hp->status_code_n = NGX_CHECK_HTTP_3XX;
+
+    } else if (code >= 400 && code < 500) {
+        hp->status_code_n = NGX_CHECK_HTTP_4XX;
+
+    } else if (code >= 500 && code < 600) {
+        hp->status_code_n = NGX_CHECK_HTTP_5XX;
+
+    } else {
+        hp->status_code_n = NGX_CHECK_HTTP_ERR;
+    }
+}
+
+
+void
+reason_phrase(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "REASON_PHRASE: \"%V\"", &str);
+#endif
+}
+
+
+void
+header_done(void *data, const signed char *at, size_t length)
+{
+
+}
+
+
+static void
+check_http_response_parser_init(http_response_parser *hp, 
+    void *data) 
+{
+    hp->data = data;
+    hp->http_field = http_field;
+    hp->http_version = http_version;
+    hp->status_code = status_code;
+    hp->status_code_n = 0;
+    hp->reason_phrase = reason_phrase;
+    hp->header_done = header_done;
+    
+    http_response_parser_init(hp);
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_http_init(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+    
+    ctx = peer_conf->check_data;
+    uscf = peer_conf->conf;
+
+    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;
+    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;
+
+    ctx->recv.start = ctx->recv.pos = NULL;
+    ctx->recv.end = ctx->recv.last = NULL;
+
+    ctx->parser = ngx_pcalloc(peer_conf->pool, sizeof(http_response_parser));
+    if (ctx->parser == NULL) {
+        return NGX_ERROR;
+    }
+
+    check_http_response_parser_init(ctx->parser, peer_conf);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_http_parse(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ssize_t                       n, offset, length;
+    ngx_tcp_check_ctx            *ctx;
+    http_response_parser         *hp;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+
+    uscf = peer_conf->conf;
+    ctx = peer_conf->check_data;
+    hp = ctx->parser;
+
+    if ((ctx->recv.last - ctx->recv.pos) > 0) {
+        offset = ctx->recv.pos - ctx->recv.start;
+        length = ctx->recv.last - ctx->recv.start;
+
+        n = http_response_parser_execute(hp, (signed char *)ctx->recv.start,
+                                         length, offset);
+        ctx->recv.pos = ctx->recv.start + n;
+
+        if (http_response_parser_finish(hp) == -1) {
+            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,
+                          "http parse error with peer: %V, recv data: %s", 
+                          &peer_conf->peer->name, ctx->recv.start);
+            return NGX_ERROR;
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                       "http_parse: hp->status_code_n: %d, conf: %d",
+                       hp->status_code_n, uscf->code.status_alive);
+
+        if (hp->status_code_n == 0) {
+            return NGX_AGAIN;
+
+        } else if (hp->status_code_n & uscf->code.status_alive) {
+            return NGX_OK;
+
+        } else {
+            return NGX_ERROR;
+        }
+
+    } else {
+        return NGX_AGAIN;
+    }
+
+    return NGX_OK;
+}
+
+
+static void 
+ngx_tcp_check_http_reinit(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx *ctx;
+
+    ctx = peer_conf->check_data;
+
+    ctx->send.pos = ctx->send.start;
+    ctx->send.last = ctx->send.end;
+
+    ctx->recv.pos = ctx->recv.last = ctx->recv.start;
+
+    check_http_response_parser_init(ctx->parser, peer_conf);
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_ssl_hello_init(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+    
+    ctx = peer_conf->check_data;
+    uscf = peer_conf->conf;
+
+    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;
+    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;
+
+    ctx->recv.start = ctx->recv.pos = NULL;
+    ctx->recv.end = ctx->recv.last = NULL;
+
+    return NGX_OK;
+}
+
+
+/* a rough check of server ssl_hello responses */
+static ngx_int_t 
+ngx_tcp_check_ssl_hello_parse(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    size_t                        size;
+    server_ssl_hello_t           *resp;
+    ngx_tcp_check_ctx            *ctx;
+
+    ctx = peer_conf->check_data;
+
+    size = ctx->recv.last - ctx->recv.pos;
+    if (size < sizeof(server_ssl_hello_t)) {
+        return NGX_AGAIN;
+    } 
+
+    resp = (server_ssl_hello_t *) ctx->recv.pos;
+
+    ngx_log_debug7(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "tcp check ssl_parse, type: %d, version: %d.%d, "
+                   "length: %d, handshanke_type: %d, "
+                   "hello_version: %d.%d", 
+                   resp->msg_type, resp->version.major, resp->version.minor, 
+                   ntohs(resp->length), resp->handshake_type, 
+                   resp->hello_version.major, resp->hello_version.minor);
+
+    if (resp->msg_type != HANDSHAKE) {
+        return NGX_ERROR;
+    }
+
+    if (resp->handshake_type != SERVER_HELLO) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void 
+ngx_tcp_check_ssl_hello_reinit(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx *ctx;
+
+    ctx = peer_conf->check_data;
+
+    ctx->send.pos = ctx->send.start;
+    ctx->send.last = ctx->send.end;
+
+    ctx->recv.pos = ctx->recv.last = ctx->recv.start;
+}
+
+
+static void 
+domain(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "DOMAIN: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+greeting_text(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "GREETING_TEXT: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+reply_code(void *data, const signed char *at, size_t length)
+{
+    int                        code;
+    smtp_parser               *sp;
+    ngx_tcp_check_ctx         *ctx;
+    ngx_tcp_check_peer_conf_t *peer_conf = data;
+
+#if (NGX_DEBUG)
+    ngx_str_t                  str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "REPLY_CODE: \"%V\"", &str);
+#endif
+
+    ctx = peer_conf->check_data;
+    sp = ctx->parser;
+
+    code = ngx_atoi((u_char*)at, length);
+
+    if (code >= 200 && code < 300) {
+        sp->hello_reply_code = NGX_CHECK_SMTP_2XX;
+
+    } else if (code >= 300 && code < 400) {
+        sp->hello_reply_code = NGX_CHECK_SMTP_3XX;
+
+    } else if (code >= 400 && code < 500) {
+        sp->hello_reply_code = NGX_CHECK_SMTP_4XX;
+
+    } else if (code >= 500 && code < 600) {
+        sp->hello_reply_code = NGX_CHECK_SMTP_5XX;
+
+    } else {
+        sp->hello_reply_code = NGX_CHECK_SMTP_ERR;
+    }
+}
+
+
+static void 
+reply_text(void *data, const signed char *at, size_t length)
+{
+#if (NGX_DEBUG)
+    ngx_str_t str;
+
+    str.data = (u_char *) at;
+    str.len = length;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "REPLY_TEXT: \"%V\"", &str);
+#endif
+}
+
+
+static void 
+smtp_done(void *data, const signed char *at, size_t length)
+{
+
+}
+
+
+static void 
+check_smtp_parser_init(smtp_parser *sp, void *data) 
+{
+    sp->data = data;
+    sp->hello_reply_code = 0;
+
+    sp->domain = domain;
+    sp->greeting_text = greeting_text;
+    sp->reply_code = reply_code;
+    sp->reply_text = reply_text;
+    sp->smtp_done = smtp_done;
+
+    smtp_parser_init(sp);
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_smtp_init(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+    
+    ctx = peer_conf->check_data;
+    uscf = peer_conf->conf;
+
+    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;
+    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;
+
+    ctx->recv.start = ctx->recv.pos = NULL;
+    ctx->recv.end = ctx->recv.last = NULL;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "smtp_init: send:%V", &uscf->send);
+
+    ctx->parser = ngx_pcalloc(peer_conf->pool, sizeof(smtp_parser));
+    if (ctx->parser == NULL) {
+        return NGX_ERROR;
+    }
+
+    check_smtp_parser_init(ctx->parser, peer_conf);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_smtp_parse(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ssize_t                       n, offset, length;
+    smtp_parser                  *sp;
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+
+    uscf = peer_conf->conf;
+    ctx = peer_conf->check_data;
+    sp = ctx->parser;
+
+    if (ctx->recv.last - ctx->recv.pos <= 0 ) {
+        return NGX_AGAIN;
+    }
+
+    offset = ctx->recv.pos - ctx->recv.start;
+    length = ctx->recv.last - ctx->recv.start;
+
+    n = smtp_parser_execute(sp, (signed char *)ctx->recv.start, length, offset);
+    ctx->recv.pos = ctx->recv.start + n;
+
+    if (smtp_parser_finish(sp) == -1) {
+        ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,
+                      "smtp parse error with peer: %V, recv data: %s", 
+                      &peer_conf->peer->name, ctx->recv.pos);
+
+        /* 
+         * Some SMTP servers are not strictly designed with the RFC2821, 
+         * but it does work
+         * */
+        if (*ctx->recv.start == '2') {
+            return NGX_OK;
+        }
+
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "smtp_parse: sp->hello_reply_code: %d, conf: %d",
+                   sp->hello_reply_code, uscf->code.status_alive);
+
+    if (sp->hello_reply_code == 0) {
+        return NGX_AGAIN;
+
+    } else if (sp->hello_reply_code & uscf->code.status_alive) {
+        return NGX_OK;
+
+    } else {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_tcp_check_smtp_reinit(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx *ctx;
+
+    ctx = peer_conf->check_data;
+
+    ctx->send.pos = ctx->send.start;
+    ctx->send.last = ctx->send.end;
+
+    ctx->recv.pos = ctx->recv.last = ctx->recv.start;
+
+    check_smtp_parser_init(ctx->parser, peer_conf);
+}
+   
+
+static ngx_int_t 
+ngx_tcp_check_mysql_init(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+    
+    ctx = peer_conf->check_data;
+    uscf = peer_conf->conf;
+
+    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;
+    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;
+
+    ctx->recv.start = ctx->recv.pos = NULL;
+    ctx->recv.end = ctx->recv.last = NULL;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_mysql_parse(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    mysql_handshake_init_t       *handshake;
+
+    ctx = peer_conf->check_data;
+
+    if (ctx->recv.last - ctx->recv.pos <= 0 ) {
+        return NGX_AGAIN;
+    }
+
+    handshake = (mysql_handshake_init_t *) ctx->recv.pos;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "mysql_parse: packet_number=%d, protocol=%d, server=%s", 
+                   handshake->packet_number,
+                   handshake->protocol_version,
+                   handshake->others);
+
+    /* The mysql greeting packet's serial number always begin with 0. */
+    if (handshake->packet_number != 0x00) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_tcp_check_mysql_reinit(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx *ctx;
+
+    ctx = peer_conf->check_data;
+
+    ctx->send.pos = ctx->send.start;
+    ctx->send.last = ctx->send.end;
+
+    ctx->recv.pos = ctx->recv.last = ctx->recv.start;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_pop3_init(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+    
+    ctx = peer_conf->check_data;
+    uscf = peer_conf->conf;
+
+    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;
+    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;
+
+    ctx->recv.start = ctx->recv.pos = NULL;
+    ctx->recv.end = ctx->recv.last = NULL;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_pop3_parse(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    u_char                        ch;
+    ngx_tcp_check_ctx            *ctx;
+
+    ctx = peer_conf->check_data;
+
+    if (ctx->recv.last - ctx->recv.pos <= 0 ) {
+        return NGX_AGAIN;
+    }
+
+    ch = *(ctx->recv.start);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "pop3_parse: packet_greeting \"%s\"", ctx->recv.start);
+
+    /*
+     * RFC 1939
+     * There are currently two status indicators: positive ("+OK") and 
+     * negative ("-ERR").  Servers MUST send the "+OK" and "-ERR" in upper case.
+     */
+    if (ch != '+') {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_tcp_check_pop3_reinit(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx *ctx;
+
+    ctx = peer_conf->check_data;
+
+    ctx->send.pos = ctx->send.start;
+    ctx->send.last = ctx->send.end;
+
+    ctx->recv.pos = ctx->recv.last = ctx->recv.start;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_imap_init(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx            *ctx;
+    ngx_tcp_upstream_srv_conf_t  *uscf;
+    
+    ctx = peer_conf->check_data;
+    uscf = peer_conf->conf;
+
+    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;
+    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;
+
+    ctx->recv.start = ctx->recv.pos = NULL;
+    ctx->recv.end = ctx->recv.last = NULL;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_imap_parse(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    u_char                       *p;
+    ngx_tcp_check_ctx            *ctx;
+
+    ctx = peer_conf->check_data;
+
+    if (ctx->recv.last - ctx->recv.pos <= 0 ) {
+        return NGX_AGAIN;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, 
+                   "imap_parse: packet_greeting \"%s\"", ctx->recv.start);
+
+    /* RFC 3501
+     * command         = tag SP (command-any / command-auth / command-nonauth /
+     * command-select) CRLF
+     */
+
+    p = ctx->recv.start;
+    while (p < ctx->recv.last) {
+
+        if (*p == ' ') {
+            if ((p + 2) >= ctx->recv.last) {
+                return NGX_AGAIN;
+            }
+            else if (*(p + 1) == 'O' && *(p + 2) == 'K') {
+                return NGX_OK;
+            }
+            else {
+                return NGX_ERROR;
+            }
+        }
+
+        p++;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static void
+ngx_tcp_check_imap_reinit(ngx_tcp_check_peer_conf_t *peer_conf) 
+{
+    ngx_tcp_check_ctx *ctx;
+
+    ctx = peer_conf->check_data;
+
+    ctx->send.pos = ctx->send.start;
+    ctx->send.last = ctx->send.end;
+
+    ctx->recv.pos = ctx->recv.last = ctx->recv.start;
+}
+
+
+static void 
+ngx_tcp_check_send_handler(ngx_event_t *event) 
+{
+    ssize_t                        size;
+    ngx_connection_t              *c;
+    ngx_tcp_check_ctx             *ctx;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+
+    c = event->data;
+    peer_conf = c->data;
+
+    if (c->pool == NULL) {
+        ngx_log_error(NGX_LOG_ERR, event->log, 0,
+                      "check pool NULL with peer: %V ", &peer_conf->peer->name);
+
+        goto check_send_fail;
+    }
+
+    if (peer_conf->state != NGX_TCP_CHECK_CONNECT_DONE) {
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+                goto check_send_fail;
+        }
+
+        return;
+    }
+
+    if (peer_conf->check_data == NULL) {
+
+        peer_conf->check_data = ngx_pcalloc(c->pool, sizeof(ngx_tcp_check_ctx));
+        if (peer_conf->check_data == NULL) {
+            goto check_send_fail;
+        }
+
+        if (peer_conf->init == NULL || peer_conf->init(peer_conf) != NGX_OK) {
+
+            ngx_log_error(NGX_LOG_ERR, event->log, 0,
+                          "check init error with peer: %V ",
+                          &peer_conf->peer->name);
+
+            goto check_send_fail;
+        }
+    }
+
+    ctx = peer_conf->check_data;
+
+    while (ctx->send.pos < ctx->send.last) {
+
+        size = c->send(c, ctx->send.pos, ctx->send.last - ctx->send.pos);
+
+#if (NGX_DEBUG)
+        ngx_err_t                      err;
+
+        err = (size >=0) ? 0 : ngx_socket_errno;
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err, 
+                       "tcp check send size: %d, total: %d",
+                       size, ctx->send.last - ctx->send.pos);
+#endif
+
+        if (size >= 0) {
+            ctx->send.pos += size;
+
+        } else if (size == NGX_AGAIN) {
+            return;
+
+        } else {
+            c->error = 1;
+            goto check_send_fail;
+        }
+    }
+
+    if (ctx->send.pos == ctx->send.last) {
+        ngx_log_debug0(NGX_LOG_DEBUG_TCP, c->log, 0, "tcp check send done.");
+        peer_conf->state = NGX_TCP_CHECK_SEND_DONE;
+    }
+
+    return;
+
+check_send_fail:
+    ngx_tcp_check_status_update(peer_conf, 0);
+    ngx_tcp_check_clean_event(peer_conf);
+    return;
+}
+
+
+static void 
+ngx_tcp_check_recv_handler(ngx_event_t *event) 
+{
+    ssize_t                        size, n, rc;
+    u_char                        *new_buf;
+    ngx_connection_t              *c;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_check_ctx             *ctx;
+
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+
+    c = event->data;
+    peer_conf = c->data;
+
+    if (peer_conf->state != NGX_TCP_CHECK_SEND_DONE) {
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            goto check_recv_fail;
+        }
+
+        return;
+    }
+
+    ctx = peer_conf->check_data;
+
+    if (ctx->recv.start == NULL) {
+        /* 2048, is it enough? */
+        ctx->recv.start = ngx_palloc(c->pool, ngx_pagesize/2);
+        if (ctx->recv.start == NULL) {
+            goto check_recv_fail;
+        }
+
+        ctx->recv.last = ctx->recv.pos = ctx->recv.start;
+        ctx->recv.end = ctx->recv.start + ngx_pagesize/2;
+    }
+
+    while (1) {
+        n = ctx->recv.end - ctx->recv.last;
+        /* Not enough buffer? Enlarge twice */
+        if (n == 0) {
+            size = ctx->recv.end - ctx->recv.start;
+            new_buf = ngx_palloc(c->pool, size * 2);
+            if (new_buf == NULL) {
+                goto check_recv_fail;
+            }
+
+            ngx_memcpy(new_buf, ctx->recv.start, size);
+
+            ctx->recv.pos = ctx->recv.start = new_buf;
+            ctx->recv.last = new_buf + size;
+            ctx->recv.end = new_buf + size * 2;
+
+            n = ctx->recv.end - ctx->recv.last;
+        }
+
+        size = c->recv(c, ctx->recv.last, n);
+
+#if (NGX_DEBUG)
+        ngx_err_t                      err;
+
+        err = (size >= 0) ? 0 : ngx_socket_errno;
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err, 
+                       "tcp check recv size: %d, peer: %V",
+                       size, &peer_conf->peer->name);
+#endif
+
+        if (size > 0) {
+            ctx->recv.last += size;
+            continue;
+
+        } else if (size == 0 || size == NGX_AGAIN) {
+            break;
+
+        } else {
+            c->error = 1;
+            goto check_recv_fail;
+        }
+    }
+
+    rc = peer_conf->parse(peer_conf); 
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, 0, 
+                   "tcp check parse rc: %d, peer: %V",
+                   rc, &peer_conf->peer->name);
+
+    switch (rc) {
+
+    case NGX_AGAIN:
+        return;
+
+    case NGX_ERROR:
+        ngx_log_error(NGX_LOG_ERR, event->log, 0,
+                      "check protocol %s error with peer: %V ", 
+                      peer_conf->conf->check_type_conf->name,
+                      &peer_conf->peer->name);
+
+        ngx_tcp_check_status_update(peer_conf, 0);
+        break;
+
+    case NGX_OK:
+        /* pass throught */
+
+    default:
+        ngx_tcp_check_status_update(peer_conf, 1);
+    }
+
+    peer_conf->state = NGX_TCP_CHECK_RECV_DONE;
+    ngx_tcp_check_clean_event(peer_conf);
+
+    return;
+
+check_recv_fail:
+
+    ngx_tcp_check_status_update(peer_conf, 0);
+    ngx_tcp_check_clean_event(peer_conf);
+
+    return;
+}
+
+
+static void 
+ngx_tcp_check_connect_handler(ngx_event_t *event) 
+{
+    ngx_int_t                      rc;
+    ngx_connection_t              *c;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_upstream_srv_conf_t   *uscf;
+
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+
+    peer_conf = event->data;
+    uscf = peer_conf->conf;
+
+    ngx_memzero(&peer_conf->pc, sizeof(ngx_peer_connection_t));
+
+    peer_conf->pc.sockaddr = peer_conf->peer->sockaddr;
+    peer_conf->pc.socklen = peer_conf->peer->socklen;
+    peer_conf->pc.name = &peer_conf->peer->name;
+
+    peer_conf->pc.get = ngx_event_get_peer;
+    peer_conf->pc.log = event->log;
+    peer_conf->pc.log_error = NGX_ERROR_ERR; 
+
+    peer_conf->pc.cached = 0;
+    peer_conf->pc.connection = NULL;
+
+    rc = ngx_event_connect_peer(&peer_conf->pc);
+
+    if (rc == NGX_ERROR || rc == NGX_DECLINED) {
+        ngx_tcp_check_status_update(peer_conf, 0);
+        return;
+    }
+
+    /* NGX_OK or NGX_AGAIN */
+    c = peer_conf->pc.connection;
+    c->data = peer_conf;
+    c->log = peer_conf->pc.log;
+    c->sendfile = 0;
+    c->read->log = c->log;
+    c->write->log = c->log;
+    c->pool = peer_conf->pool;
+
+    peer_conf->state = NGX_TCP_CHECK_CONNECT_DONE;
+
+    c->write->handler = peer_conf->send_handler;
+    c->read->handler = peer_conf->recv_handler;
+
+    ngx_add_timer(&peer_conf->check_timeout_ev, uscf->check_timeout);
+
+    /* The kqueue's loop interface need it. */
+    if (rc == NGX_OK) {
+        c->write->handler(c->write);
+    }
+}
+
+
+static void 
+ngx_tcp_check_begin_handler(ngx_event_t *event) 
+{
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_upstream_srv_conf_t   *uscf;
+
+    if (ngx_tcp_check_need_exit()) {
+        return;
+    }
+
+    peer_conf = event->data;
+    uscf = peer_conf->conf;
+
+    ngx_add_timer(event, uscf->check_interval/2);
+
+    /* This process are processing the event now. */
+    if (peer_conf->shm->owner == ngx_pid) {
+        return;
+    }
+
+    ngx_log_debug4(NGX_LOG_DEBUG_TCP, event->log, 0, 
+                   "tcp check begin handler index:%ud, owner: %d, "
+                   "ngx_pid: %ud, time:%d", 
+                   peer_conf->index, peer_conf->shm->owner, ngx_pid, 
+                   (ngx_current_msec - peer_conf->shm->access_time));
+
+    ngx_spinlock(&peer_conf->shm->lock, ngx_pid, 1024);
+
+    if (((ngx_current_msec - peer_conf->shm->access_time) >= uscf->check_interval) && 
+            peer_conf->shm->owner == NGX_INVALID_PID)
+    {
+        peer_conf->shm->owner = ngx_pid;
+    }
+
+    ngx_spinlock_unlock(&peer_conf->shm->lock);
+
+    if (peer_conf->shm->owner == ngx_pid) {
+        ngx_tcp_check_connect_handler(event);
+    }
+}
+
+
+static void 
+ngx_tcp_upstream_init_check_conf(ngx_tcp_upstream_srv_conf_t *uscf) 
+{
+    check_conf_t *cf;
+
+    cf = uscf->check_type_conf;
+
+    if (uscf->send.len == 0) {
+        uscf->send.data = cf->default_send.data;
+        uscf->send.len = cf->default_send.len;
+    }
+
+    if (uscf->code.status_alive == 0) { 
+        uscf->code.status_alive = cf->default_status_alive;
+    }
+}
+
+
+ngx_int_t 
+ngx_tcp_upstream_init_main_check_conf(ngx_conf_t *cf, void*conf) 
+{
+    ngx_tcp_upstream_main_conf_t   *umcf = conf;
+
+    ngx_uint_t                      i, shm_size, need_check;
+    ngx_str_t                      *shm_name;
+    ngx_shm_zone_t                 *shm_zone;
+    ngx_tcp_upstream_srv_conf_t   **uscfp;
+
+    uscfp = umcf->upstreams.elts;
+
+    need_check = 0;
+    for (i = 0; i < umcf->upstreams.nelts; i++) {
+        if (uscfp[i]->check_interval) {
+
+            ngx_tcp_upstream_init_check_conf(uscfp[i]);
+            
+            need_check = 1;
+        }
+    }
+
+    if (need_check) {
+        ngx_tcp_check_shm_generation++;
+
+        shm_name = &umcf->peers_conf->check_shm_name;
+
+        if (ngx_tcp_check_get_shm_name(shm_name, cf->pool) == NGX_ERROR) {
+            return NGX_ERROR;
+        }
+
+        /*the default check shmare memory size*/
+        shm_size = (umcf->upstreams.nelts + 1 )* ngx_pagesize;
+
+        shm_size = shm_size < umcf->check_shm_size 
+                   ? umcf->check_shm_size : shm_size;
+
+        shm_zone = ngx_shared_memory_add(cf, shm_name, shm_size,
+                                         &ngx_tcp_upstream_module);
+
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, cf->log, 0,
+                       "[tcp_upstream] upsteam:%V, shm_zone size:%ui",
+                       shm_name, shm_size);
+
+        shm_zone->data = umcf->peers_conf;
+        check_peers_ctx = umcf->peers_conf;
+
+        shm_zone->init = ngx_tcp_upstream_check_init_shm_zone;
+
+    } else {
+        check_peers_ctx = NULL;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_check_init_process(ngx_cycle_t *cycle) 
+{
+    ngx_str_t                      shm_name;
+    ngx_uint_t                     i;
+    ngx_msec_t                     t, delay;
+    check_conf_t                  *cf;
+    ngx_shm_zone_t                *shm_zone;
+    ngx_tcp_check_peer_shm_t      *peer_shm;
+    ngx_tcp_check_peers_shm_t     *peers_shm;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_check_peers_conf_t    *peers_conf;
+    ngx_tcp_upstream_srv_conf_t   *uscf;
+
+    if (ngx_tcp_check_get_shm_name(&shm_name, cycle->pool) == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    shm_zone = ngx_shared_memory_find(cycle, &shm_name, 
+                                      &ngx_tcp_upstream_module);
+
+    if (shm_zone == NULL || shm_zone->data == NULL) {
+        return NGX_OK;
+    }
+
+    peers_conf = shm_zone->data;
+    peers_shm = peers_conf->peers_shm;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, cycle->log, 0, 
+                   "tcp check upstream init_process, shm_name: %V, "
+                   "peer number: %ud",
+                   &shm_name, peers_conf->peers.nelts);
+
+    srandom(ngx_pid);
+
+    peer_conf = peers_conf->peers.elts;
+    peer_shm = peers_shm->peers;
+
+    for (i = 0; i < peers_conf->peers.nelts; i++) {
+        peer_conf[i].shm = &peer_shm[i];
+
+        peer_conf[i].check_ev.handler = ngx_tcp_check_begin_handler;
+        peer_conf[i].check_ev.log = cycle->log;
+        peer_conf[i].check_ev.data = &peer_conf[i];
+        peer_conf[i].check_ev.timer_set = 0;
+
+        peer_conf[i].check_timeout_ev.handler = ngx_tcp_check_timeout_handler;
+        peer_conf[i].check_timeout_ev.log = cycle->log;
+        peer_conf[i].check_timeout_ev.data = &peer_conf[i];
+        peer_conf[i].check_timeout_ev.timer_set = 0;
+
+        uscf = peer_conf[i].conf;
+        cf = uscf->check_type_conf;
+
+        if (cf->need_pool) {
+            peer_conf[i].pool = ngx_create_pool(ngx_pagesize, cycle->log);
+            if (peer_conf[i].pool == NULL) {
+                return NGX_ERROR;
+            }
+        }
+
+        peer_conf[i].send_handler = cf->send_handler;
+        peer_conf[i].recv_handler = cf->recv_handler;
+
+        peer_conf[i].init = cf->init;
+        peer_conf[i].parse = cf->parse;
+        peer_conf[i].reinit = cf->reinit;
+
+        /* Default delay interval is 1 second. 
+           I don't want to trigger the check event too close. */
+        delay = uscf->check_interval > 1000 ? uscf->check_interval : 1000;
+        t = ngx_random() % delay;
+
+        ngx_add_timer(&peer_conf[i].check_ev, t);
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t 
+ngx_tcp_upstream_check_status_handler(ngx_http_request_t *r) 
+{
+    ngx_buf_t                     *b;
+    ngx_str_t                      shm_name;
+    ngx_int_t                      rc;
+    ngx_uint_t                     i;
+    ngx_chain_t                    out;
+    ngx_shm_zone_t                *shm_zone;
+    ngx_tcp_check_peer_shm_t      *peer_shm;
+    ngx_tcp_check_peers_shm_t     *peers_shm;
+    ngx_tcp_check_peer_conf_t     *peer_conf;
+    ngx_tcp_check_peers_conf_t    *peers_conf;
+
+
+    if (r->method != NGX_HTTP_GET && r->method != NGX_HTTP_HEAD) {
+        return NGX_HTTP_NOT_ALLOWED;
+    }
+
+    rc = ngx_http_discard_request_body(r);
+
+    if (rc != NGX_OK) {
+        return rc;
+    }
+
+    r->headers_out.content_type.len = sizeof("text/html; charset=utf-8") - 1;
+    r->headers_out.content_type.data = (u_char *) "text/html; charset=utf-8";
+
+    if (r->method == NGX_HTTP_HEAD) {
+        r->headers_out.status = NGX_HTTP_OK;
+
+        rc = ngx_http_send_header(r);
+
+        if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
+            return rc;
+        }
+    }
+
+    if (ngx_tcp_check_get_shm_name(&shm_name, r->pool) == NGX_ERROR) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    shm_zone = ngx_shared_memory_find((ngx_cycle_t *)ngx_cycle, &shm_name, 
+            &ngx_tcp_upstream_module);
+
+    if (shm_zone == NULL || shm_zone->data == NULL) {
+
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "[tcp upstream check] can not find the "
+                      "shared memory zone \"%V\" ", &shm_name);
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    peers_conf = shm_zone->data;
+    peers_shm = peers_conf->peers_shm;
+
+    peer_conf = peers_conf->peers.elts;
+    peer_shm = peers_shm->peers;
+
+    b = ngx_create_temp_buf(r->pool, ngx_pagesize);
+    if (b == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    out.buf = b;
+    out.next = NULL;
+
+    b->last = ngx_sprintf(b->last, 
+            "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\n"
+            "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n"
+            "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
+            "<head>\n"
+            "  <title>Nginx tcp upstream check status</title>\n"
+            "</head>\n"
+            "<body>\n"
+            "<h1>Nginx tcp upstream check status</h1>\n"
+            "<h2>Check upstream server number: %ui, shm_name: %V</h2>\n"
+            "<table style=\"background-color:white\" cellspacing=\"0\" cellpadding=\"3\" border=\"1\">\n"
+            "  <tr bgcolor=\"#C0C0C0\">\n"
+            "    <th>Index</th>\n"
+            "    <th>Name</th>\n"
+            "    <th>Status</th>\n"
+            "    <th>Busyness</th>\n"
+            "    <th>Rise counts</th>\n"
+            "    <th>Fall counts</th>\n"
+            "    <th>Access counts</th>\n"
+            "    <th>Check type</th>\n"
+            "  </tr>\n",
+            peers_conf->peers.nelts, &shm_name);
+
+    for (i = 0; i < peers_conf->peers.nelts; i++) {
+        b->last = ngx_sprintf(b->last, 
+                "  <tr%s>\n"
+                "    <td>%ui</td>\n" 
+                "    <td>%V</td>\n" 
+                "    <td>%s</td>\n" 
+                "    <td>%ui</td>\n" 
+                "    <td>%ui</td>\n" 
+                "    <td>%ui</td>\n" 
+                "    <td>%ui</td>\n" 
+                "    <td>%s</td>\n" 
+                "  </tr>\n",
+                peer_shm[i].down ? " bgcolor=\"#FF0000\"" : "",
+                i, 
+                &peer_conf[i].peer->name, 
+                peer_shm[i].down ? "down" : "up",
+                peer_shm[i].busyness,
+                peer_shm[i].rise_count, 
+                peer_shm[i].fall_count, 
+                peer_shm[i].access_count, 
+                peer_conf[i].conf->check_type_conf->name);
+    }
+
+    b->last = ngx_sprintf(b->last, 
+            "</table>\n"
+            "</body>\n"
+            "</html>\n");
+
+    r->headers_out.status = NGX_HTTP_OK;
+    r->headers_out.content_length_n = b->last - b->pos;
+
+    b->last_buf = 1;
+
+    rc = ngx_http_send_header(r);
+
+    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
+        return rc;
+    }
+
+    return ngx_http_output_filter(r, &out);
+}
+
+
+static char *
+ngx_tcp_upstream_check_status_set_status(ngx_conf_t *cf, 
+    ngx_command_t *cmd, void *conf) 
+{
+    ngx_http_core_loc_conf_t                *clcf;
+
+    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
+
+    ngx_conf_deprecated(cf, &ngx_conf_deprecated_check_status, NULL);
+
+    clcf->handler = ngx_tcp_upstream_check_status_handler;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_tcp_upstream_check_status(ngx_conf_t *cf, 
+    ngx_command_t *cmd, void *conf) 
+{
+    ngx_http_core_loc_conf_t                *clcf;
+
+    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
+
+    clcf->handler = ngx_tcp_upstream_check_status_handler;
+
+    return NGX_CONF_OK;
+}
diff --git a/src/tcp/ngx_tcp_upstream_check.h b/src/tcp/ngx_tcp_upstream_check.h
new file mode 100755
index 0000000..686394e
--- /dev/null
+++ b/src/tcp/ngx_tcp_upstream_check.h
@@ -0,0 +1,180 @@
+#ifndef _NGX_TCP_UPSTREAM_CHECK_H_INCLUDED_
+#define _NGX_TCP_UPSTREAM_CHECK_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+#include <ngx_event_pipe.h>
+#include <ngx_tcp.h>
+
+#include <http_request_parser.h>
+#include <http_response_parser.h>
+#include <smtp_response_parser.h>
+
+
+typedef struct {
+    u_char                 major;
+    u_char                 minor;
+} ssl_protocol_version_t;
+
+typedef struct {
+    u_char                 msg_type;
+    ssl_protocol_version_t version;
+    uint16_t               length;
+
+    u_char                 handshake_type;
+    u_char                 handshake_length[3];
+    ssl_protocol_version_t hello_version;
+
+    time_t                 time;
+    u_char                 random[28];
+
+    u_char                 others[0];
+} __attribute__((packed)) server_ssl_hello_t;
+
+typedef struct {
+    u_char                 packet_length[3];
+    u_char                 packet_number;
+
+    u_char                 protocol_version;
+    u_char                 others[0];
+} __attribute__((packed)) mysql_handshake_init_t;
+
+typedef struct {
+    ngx_buf_t              send;
+    ngx_buf_t              recv;
+
+    void                  *parser;
+} ngx_tcp_check_ctx;
+
+/*state*/
+#define NGX_TCP_CHECK_CONNECT_DONE     0x0001
+#define NGX_TCP_CHECK_SEND_DONE        0x0002
+#define NGX_TCP_CHECK_RECV_DONE        0x0004
+#define NGX_TCP_CHECK_ALL_DONE         0x0008
+
+typedef struct {
+    ngx_pid_t              owner;
+
+    ngx_msec_t             access_time;
+
+    ngx_uint_t             fall_count;
+    ngx_uint_t             rise_count;
+
+    ngx_atomic_t           lock;
+    ngx_atomic_t           busyness;
+    ngx_atomic_t           down;
+
+    ngx_uint_t             access_count;
+} ngx_tcp_check_peer_shm_t;
+
+typedef struct {
+    ngx_uint_t             generation;
+
+    ngx_uint_t             state;
+    ngx_atomic_t           lock;
+
+    /*store the ngx_tcp_check_status_peer_t*/
+    ngx_tcp_check_peer_shm_t peers[1];
+} ngx_tcp_check_peers_shm_t;
+
+typedef ngx_int_t (*ngx_tcp_check_packet_init_pt)
+    (ngx_tcp_check_peer_conf_t *peer_conf); 
+typedef ngx_int_t (*ngx_tcp_check_packet_parse_pt)
+    (ngx_tcp_check_peer_conf_t *peer_conf); 
+typedef void (*ngx_tcp_check_packet_clean_pt)
+    (ngx_tcp_check_peer_conf_t *peer_conf); 
+
+#define NGX_TCP_CHECK_TCP              0x0001
+#define NGX_TCP_CHECK_HTTP             0x0002
+#define NGX_TCP_CHECK_SSL_HELLO        0x0004
+#define NGX_TCP_CHECK_SMTP             0x0008
+#define NGX_TCP_CHECK_MYSQL            0x0010
+#define NGX_TCP_CHECK_POP3             0x0020
+#define NGX_TCP_CHECK_IMAP             0x0040
+
+#define NGX_CHECK_HTTP_2XX             0x0002
+#define NGX_CHECK_HTTP_3XX             0x0004
+#define NGX_CHECK_HTTP_4XX             0x0008
+#define NGX_CHECK_HTTP_5XX             0x0010
+#define NGX_CHECK_HTTP_6XX             0x0020
+#define NGX_CHECK_HTTP_ERR             0x8000
+
+#define NGX_CHECK_SMTP_2XX             0x0002
+#define NGX_CHECK_SMTP_3XX             0x0004
+#define NGX_CHECK_SMTP_4XX             0x0008
+#define NGX_CHECK_SMTP_5XX             0x0010
+#define NGX_CHECK_SMTP_6XX             0x0020
+#define NGX_CHECK_SMTP_ERR             0x8000
+
+
+struct check_conf_s {
+    ngx_uint_t                      type;
+
+    char                            *name;
+
+    ngx_str_t                        default_send;
+    
+    /* HTTP */
+    ngx_uint_t                       default_status_alive;
+
+    ngx_event_handler_pt             send_handler;
+    ngx_event_handler_pt             recv_handler;
+
+    ngx_tcp_check_packet_init_pt     init;
+    ngx_tcp_check_packet_parse_pt    parse;
+    ngx_tcp_check_packet_clean_pt    reinit;
+
+    unsigned need_pool;
+};
+
+struct ngx_tcp_check_peer_conf_s {
+
+    ngx_flag_t                       state;
+    ngx_pool_t                      *pool;
+    ngx_uint_t                       index;
+    ngx_uint_t                       max_busy;
+    ngx_tcp_upstream_srv_conf_t     *conf;
+    ngx_peer_addr_t                 *peer;
+    ngx_event_t                      check_ev;
+    ngx_event_t                      check_timeout_ev;
+    ngx_peer_connection_t            pc;
+
+    void *                           check_data;
+    ngx_event_handler_pt             send_handler;
+    ngx_event_handler_pt             recv_handler;
+
+    ngx_tcp_check_packet_init_pt     init;
+    ngx_tcp_check_packet_parse_pt    parse;
+    ngx_tcp_check_packet_clean_pt    reinit;
+
+    ngx_tcp_check_peer_shm_t         *shm;
+};
+
+struct ngx_tcp_check_peers_conf_s {
+    ngx_str_t                        check_shm_name;
+    ngx_array_t                      peers;
+
+    ngx_tcp_check_peers_shm_t       *peers_shm;
+};
+
+
+ngx_int_t ngx_tcp_upstream_init_main_check_conf(ngx_conf_t *cf, void*conf);
+
+ngx_uint_t ngx_tcp_check_add_peer(ngx_conf_t *cf,
+    ngx_tcp_upstream_srv_conf_t *uscf,
+    ngx_peer_addr_t *peer, ngx_uint_t max_busy);
+
+ngx_uint_t ngx_tcp_check_peer_down(ngx_uint_t index);
+
+ngx_uint_t ngx_tcp_check_get_peer_busyness(ngx_uint_t index);
+
+void ngx_tcp_check_get_peer(ngx_uint_t index);
+void ngx_tcp_check_free_peer(ngx_uint_t index);
+
+check_conf_t *ngx_tcp_get_check_type_conf(ngx_str_t *str);
+
+#endif //_NGX_TCP_UPSTREAM_CHECK_H_INCLUDED_
+
diff --git a/src/tcp/ngx_tcp_upstream_round_robin.c b/src/tcp/ngx_tcp_upstream_round_robin.c
new file mode 100755
index 0000000..734ea74
--- /dev/null
+++ b/src/tcp/ngx_tcp_upstream_round_robin.c
@@ -0,0 +1,812 @@
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+static ngx_int_t ngx_tcp_upstream_cmp_servers(const void *one, const void *two);
+static ngx_uint_t ngx_tcp_upstream_get_peer(ngx_tcp_upstream_rr_peers_t *peers);
+
+ngx_int_t
+ngx_tcp_upstream_init_round_robin(ngx_conf_t *cf,
+    ngx_tcp_upstream_srv_conf_t *us)
+{
+    ngx_url_t                      u;
+    ngx_uint_t                     i, j, n;
+    ngx_tcp_upstream_server_t     *server;
+    ngx_tcp_upstream_rr_peers_t   *peers, *backup;
+
+    us->peer.init = ngx_tcp_upstream_init_round_robin_peer;
+
+    if (us->servers) {
+        server = us->servers->elts;
+
+        n = 0;
+
+        for (i = 0; i < us->servers->nelts; i++) {
+            if (server[i].backup) {
+                continue;
+            }
+
+            n += server[i].naddrs;
+        }
+
+        peers = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_rr_peers_t)
+                              + sizeof(ngx_tcp_upstream_rr_peer_t) * (n - 1));
+        if (peers == NULL) {
+            return NGX_ERROR;
+        }
+
+        peers->single = (n == 1);
+        peers->number = n;
+        peers->name = &us->host;
+
+        n = 0;
+
+        for (i = 0; i < us->servers->nelts; i++) {
+            for (j = 0; j < server[i].naddrs; j++) {
+                if (server[i].backup) {
+                    continue;
+                }
+
+                peers->peer[n].sockaddr = server[i].addrs[j].sockaddr;
+                peers->peer[n].socklen = server[i].addrs[j].socklen;
+                peers->peer[n].name = server[i].addrs[j].name;
+                peers->peer[n].max_fails = server[i].max_fails;
+                peers->peer[n].fail_timeout = server[i].fail_timeout;
+                peers->peer[n].down = server[i].down;
+                peers->peer[n].weight = server[i].down ? 0 : server[i].weight;
+                peers->peer[n].current_weight = peers->peer[n].weight;
+
+                if (!server[i].down && us->check_interval) {
+                    peers->peer[n].check_index = 
+                        ngx_tcp_check_add_peer(cf, us, &server[i].addrs[j],
+                                               server[i].max_busy);
+
+                    if (peers->peer[n].check_index
+                                     == (ngx_uint_t) NGX_INVALID_CHECK_INDEX) {
+                        return NGX_ERROR;
+                    }
+                }
+                else {
+                    peers->peer[n].check_index
+                                       = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;
+                }
+
+                n++;
+            }
+        }
+
+        us->peer.data = peers;
+
+        ngx_sort(&peers->peer[0], (size_t) n,
+                 sizeof(ngx_tcp_upstream_rr_peer_t),
+                 ngx_tcp_upstream_cmp_servers);
+
+        /* backup servers */
+
+        n = 0;
+
+        for (i = 0; i < us->servers->nelts; i++) {
+            if (!server[i].backup) {
+                continue;
+            }
+
+            n += server[i].naddrs;
+        }
+
+        if (n == 0) {
+            return NGX_OK;
+        }
+
+        backup = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_rr_peers_t)
+                              + sizeof(ngx_tcp_upstream_rr_peer_t) * (n - 1));
+        if (backup == NULL) {
+            return NGX_ERROR;
+        }
+
+        peers->single = 0;
+        backup->single = 0;
+        backup->number = n;
+        backup->name = &us->host;
+
+        n = 0;
+
+        for (i = 0; i < us->servers->nelts; i++) {
+            for (j = 0; j < server[i].naddrs; j++) {
+                if (!server[i].backup) {
+                    continue;
+                }
+
+                backup->peer[n].sockaddr = server[i].addrs[j].sockaddr;
+                backup->peer[n].socklen = server[i].addrs[j].socklen;
+                backup->peer[n].name = server[i].addrs[j].name;
+                backup->peer[n].weight = server[i].weight;
+                backup->peer[n].current_weight = server[i].weight;
+                backup->peer[n].max_fails = server[i].max_fails;
+                backup->peer[n].fail_timeout = server[i].fail_timeout;
+                backup->peer[n].down = server[i].down;
+                if (!server[i].down && us->check_interval) {
+                    backup->peer[n].check_index = 
+                        ngx_tcp_check_add_peer(cf, us, &server[i].addrs[j],
+                                               server[i].max_busy);
+
+                    if (backup->peer[n].check_index
+                                     == (ngx_uint_t) NGX_INVALID_CHECK_INDEX) {
+                        return NGX_ERROR;
+                    }
+                }
+                else {
+                    backup->peer[n].check_index
+                                     = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;
+                }
+
+                n++;
+            }
+        }
+
+        peers->next = backup;
+
+        ngx_sort(&backup->peer[0], (size_t) n,
+                 sizeof(ngx_tcp_upstream_rr_peer_t),
+                 ngx_tcp_upstream_cmp_servers);
+
+        return NGX_OK;
+    }
+
+
+    /* an upstream implicitly defined by proxy_pass, etc. */
+ 
+#if (nginx_version) >= 1003011
+    if (us->port == 0) {
+#else
+    if (us->port == 0 && us->default_port == 0) {
+#endif
+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                      "no port in upstream \"%V\" in %s:%ui",
+                      &us->host, us->file_name, us->line);
+        return NGX_ERROR;
+    }
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    u.host = us->host;
+#if (nginx_version) >= 1003011
+    u.port = us->port;
+#else
+    u.port = (in_port_t) (us->port ? us->port : us->default_port);
+#endif
+
+    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {
+        if (u.err) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "%s in upstream \"%V\" in %s:%ui",
+                          u.err, &us->host, us->file_name, us->line);
+        }
+
+        return NGX_ERROR;
+    }
+
+    n = u.naddrs;
+
+    peers = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_rr_peers_t)
+                              + sizeof(ngx_tcp_upstream_rr_peer_t) * (n - 1));
+    if (peers == NULL) {
+        return NGX_ERROR;
+    }
+
+    peers->single = (n == 1);
+    peers->number = n;
+    peers->name = &us->host;
+
+    for (i = 0; i < u.naddrs; i++) {
+        peers->peer[i].sockaddr = u.addrs[i].sockaddr;
+        peers->peer[i].socklen = u.addrs[i].socklen;
+        peers->peer[i].name = u.addrs[i].name;
+        peers->peer[i].weight = 1;
+        peers->peer[i].current_weight = 1;
+        peers->peer[i].max_fails = 1;
+        peers->peer[i].fail_timeout = 10;
+        peers->peer[i].check_index = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;
+    }
+
+    us->peer.data = peers;
+
+    /* implicitly defined upstream has no backup servers */
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_tcp_upstream_cmp_servers(const void *one, const void *two)
+{
+    ngx_tcp_upstream_rr_peer_t  *first, *second;
+
+    first = (ngx_tcp_upstream_rr_peer_t *) one;
+    second = (ngx_tcp_upstream_rr_peer_t *) two;
+
+    return (first->weight < second->weight);
+}
+
+
+ngx_int_t
+ngx_tcp_upstream_init_round_robin_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_srv_conf_t *us)
+{
+    ngx_uint_t                         n;
+    ngx_tcp_upstream_rr_peer_data_t  *rrp;
+
+    rrp = s->upstream->peer.data;
+
+    if (rrp == NULL) {
+        rrp = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_rr_peer_data_t));
+        if (rrp == NULL) {
+            return NGX_ERROR;
+        }
+
+        s->upstream->peer.data = rrp;
+    }
+
+    rrp->peers = us->peer.data;
+    rrp->current = 0;
+
+    if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {
+        rrp->tried = &rrp->data;
+        rrp->data = 0;
+
+    } else {
+        n = (rrp->peers->number + (8 * sizeof(uintptr_t) - 1))
+                / (8 * sizeof(uintptr_t));
+
+        rrp->tried = ngx_pcalloc(s->pool, n * sizeof(uintptr_t));
+        if (rrp->tried == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    s->upstream->peer.get = ngx_tcp_upstream_get_round_robin_peer;
+    s->upstream->peer.free = ngx_tcp_upstream_free_round_robin_peer;
+    s->upstream->peer.tries = rrp->peers->number;
+    s->upstream->peer.check_index = NGX_INVALID_CHECK_INDEX;
+    s->upstream->peer.name = NULL;
+#if (NGX_TCP_SSL)
+    s->upstream->peer.set_session =
+                               ngx_tcp_upstream_set_round_robin_peer_session;
+    s->upstream->peer.save_session =
+                               ngx_tcp_upstream_save_round_robin_peer_session;
+#endif
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_tcp_upstream_create_round_robin_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_resolved_t *ur)
+{
+    u_char                            *p;
+    size_t                             len;
+    ngx_uint_t                         i, n;
+    struct sockaddr_in                *sin;
+    ngx_tcp_upstream_rr_peers_t       *peers;
+    ngx_tcp_upstream_rr_peer_data_t   *rrp;
+
+    rrp = s->upstream->peer.data;
+
+    if (rrp == NULL) {
+        rrp = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_rr_peer_data_t));
+        if (rrp == NULL) {
+            return NGX_ERROR;
+        }
+
+        s->upstream->peer.data = rrp;
+    }
+
+    peers = ngx_pcalloc(s->pool, sizeof(ngx_tcp_upstream_rr_peers_t)
+                     + sizeof(ngx_tcp_upstream_rr_peer_t) * (ur->naddrs - 1));
+    if (peers == NULL) {
+        return NGX_ERROR;
+    }
+
+    peers->single = (ur->naddrs == 1);
+    peers->number = ur->naddrs;
+    peers->name = &ur->host;
+
+    if (ur->sockaddr) {
+        peers->peer[0].sockaddr = ur->sockaddr;
+        peers->peer[0].socklen = ur->socklen;
+        peers->peer[0].name = ur->host;
+        peers->peer[0].weight = 1;
+        peers->peer[0].current_weight = 1;
+        peers->peer[0].max_fails = 1;
+        peers->peer[0].fail_timeout = 10;
+        peers->peer[0].check_index = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;
+
+    } else {
+
+        for (i = 0; i < ur->naddrs; i++) {
+
+            len = NGX_INET_ADDRSTRLEN + sizeof(":65536") - 1;
+
+            p = ngx_pnalloc(s->pool, len);
+            if (p == NULL) {
+                return NGX_ERROR;
+            }
+
+            len = ngx_inet_ntop(AF_INET, &ur->addrs[i], p, NGX_INET_ADDRSTRLEN);
+            len = ngx_sprintf(&p[len], ":%d", ur->port) - p;
+
+            sin = ngx_pcalloc(s->pool, sizeof(struct sockaddr_in));
+            if (sin == NULL) {
+                return NGX_ERROR;
+            }
+
+            sin->sin_family = AF_INET;
+            sin->sin_port = htons(ur->port);
+            sin->sin_addr.s_addr = ur->addrs[i];
+
+            peers->peer[i].sockaddr = (struct sockaddr *) sin;
+            peers->peer[i].socklen = sizeof(struct sockaddr_in);
+            peers->peer[i].name.len = len;
+            peers->peer[i].name.data = p;
+            peers->peer[i].weight = 1;
+            peers->peer[i].current_weight = 1;
+            peers->peer[i].max_fails = 1;
+            peers->peer[i].fail_timeout = 10;
+            peers->peer[i].check_index = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;
+        }
+    }
+
+    rrp->peers = peers;
+    rrp->current = 0;
+
+    if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {
+        rrp->tried = &rrp->data;
+        rrp->data = 0;
+
+    } else {
+        n = (rrp->peers->number + (8 * sizeof(uintptr_t) - 1))
+                / (8 * sizeof(uintptr_t));
+
+        rrp->tried = ngx_pcalloc(s->pool, n * sizeof(uintptr_t));
+        if (rrp->tried == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    s->upstream->peer.get = ngx_tcp_upstream_get_round_robin_peer;
+    s->upstream->peer.free = ngx_tcp_upstream_free_round_robin_peer;
+    s->upstream->peer.tries = rrp->peers->number;
+#if (NGX_TCP_SSL)
+    s->upstream->peer.set_session =
+                               ngx_tcp_upstream_set_round_robin_peer_session;
+    s->upstream->peer.save_session =
+                               ngx_tcp_upstream_save_round_robin_peer_session;
+#endif
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_tcp_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
+{
+    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;
+
+    time_t                         now;
+    uintptr_t                      m;
+    ngx_int_t                      rc;
+    ngx_uint_t                     i, n;
+    ngx_connection_t              *c;
+    ngx_tcp_upstream_rr_peer_t    *peer;
+    ngx_tcp_upstream_rr_peers_t   *peers;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                   "get rr peer, try: %ui", pc->tries);
+
+    now = ngx_time();
+
+    /* ngx_lock_mutex(rrp->peers->mutex); */
+
+    if (rrp->peers->last_cached) {
+
+        /* cached connection */
+
+        c = rrp->peers->cached[rrp->peers->last_cached];
+        rrp->peers->last_cached--;
+
+        /* ngx_unlock_mutex(ppr->peers->mutex); */
+
+#if (NGX_THREADS)
+        c->read->lock = c->read->own_lock;
+        c->write->lock = c->write->own_lock;
+#endif
+
+        pc->connection = c;
+        pc->cached = 1;
+
+        return NGX_OK;
+    }
+
+    pc->cached = 0;
+    pc->connection = NULL;
+
+    if (rrp->peers->single) {
+        peer = &rrp->peers->peer[0];
+        if (ngx_tcp_check_peer_down(peer->check_index)) {
+            return NGX_BUSY;
+        }
+    } else {
+
+        /* there are several peers */
+
+        if (pc->tries == rrp->peers->number) {
+
+            /* it's a first try - get a current peer */
+
+            i = pc->tries;
+
+            for ( ;; ) {
+                rrp->current = ngx_tcp_upstream_get_peer(rrp->peers);
+
+                ngx_log_debug3(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                               "get rr peer, current: %ui %i, tries: %ui",
+                               rrp->current,
+                               rrp->peers->peer[rrp->current].current_weight,
+                               pc->tries);
+
+                n = rrp->current / (8 * sizeof(uintptr_t));
+                m = (uintptr_t) 1 << rrp->current % (8 * sizeof(uintptr_t));
+
+                if (!(rrp->tried[n] & m)) {
+                    peer = &rrp->peers->peer[rrp->current];
+
+                    if (!peer->down) {
+
+                        ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                                "get rr peer, down: %ui", 
+                                ngx_tcp_check_peer_down(peer->check_index));
+
+                        if (!ngx_tcp_check_peer_down(peer->check_index)) {
+                            if (peer->max_fails == 0
+                                    || peer->fails < peer->max_fails)
+                            {
+                                break;
+                            }
+
+                            if (now - peer->accessed > peer->fail_timeout) {
+                                peer->fails = 0;
+                                break;
+                            }
+                        }
+
+                        peer->current_weight = 0;
+
+                    } else {
+                        rrp->tried[n] |= m;
+                    }
+
+                    pc->tries--;
+                }
+
+                if (pc->tries == 0) {
+                    goto failed;
+                }
+
+                if (--i == 0) {
+                    ngx_log_error(NGX_LOG_ALERT, pc->log, 0,
+                                  "round robin upstream stuck on %ui tries",
+                                  pc->tries);
+                    goto failed;
+                }
+            }
+
+            peer->current_weight--;
+
+        } else {
+
+            i = pc->tries;
+
+            for ( ;; ) {
+                n = rrp->current / (8 * sizeof(uintptr_t));
+                m = (uintptr_t) 1 << rrp->current % (8 * sizeof(uintptr_t));
+
+                if (!(rrp->tried[n] & m)) {
+
+                    peer = &rrp->peers->peer[rrp->current];
+
+                    if (!peer->down) {
+
+                        if (!ngx_tcp_check_peer_down(peer->check_index)) {
+                            
+                            if (peer->max_fails == 0
+                                    || peer->fails < peer->max_fails)
+                            {
+                                break;
+                            }
+
+                            if (now - peer->accessed > peer->fail_timeout) {
+                                peer->fails = 0;
+                                break;
+                            }
+                        }
+
+                        peer->current_weight = 0;
+
+                    } else {
+                        rrp->tried[n] |= m;
+                    }
+
+                    pc->tries--;
+                }
+
+                rrp->current++;
+
+                if (rrp->current >= rrp->peers->number) {
+                    rrp->current = 0;
+                }
+
+                if (pc->tries == 0) {
+                    goto failed;
+                }
+
+                if (--i == 0) {
+                    ngx_log_error(NGX_LOG_ALERT, pc->log, 0,
+                                  "round robin upstream stuck on %ui tries",
+                                  pc->tries);
+                    goto failed;
+                }
+            }
+
+            peer->current_weight--;
+        }
+
+        rrp->tried[n] |= m;
+    }
+
+    pc->sockaddr = peer->sockaddr;
+    pc->socklen = peer->socklen;
+    pc->name = &peer->name;
+    pc->check_index = peer->check_index;
+
+    /* ngx_unlock_mutex(rrp->peers->mutex); */
+
+    if (pc->tries == 1 && rrp->peers->next) {
+        pc->tries += rrp->peers->next->number;
+
+        n = rrp->peers->next->number / (8 * sizeof(uintptr_t)) + 1;
+        for (i = 0; i < n; i++) {
+             rrp->tried[i] = 0;
+        }
+    }
+
+    return NGX_OK;
+
+failed:
+
+    peers = rrp->peers;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, pc->log, 0, "backup servers1");
+
+    if (peers->next) {
+
+        /* ngx_unlock_mutex(peers->mutex); */
+
+        ngx_log_debug0(NGX_LOG_DEBUG_TCP, pc->log, 0, "backup servers");
+
+        rrp->peers = peers->next;
+        pc->tries = rrp->peers->number;
+
+        n = rrp->peers->number / (8 * sizeof(uintptr_t)) + 1;
+        for (i = 0; i < n; i++) {
+             rrp->tried[i] = 0;
+        }
+
+        rc = ngx_tcp_upstream_get_round_robin_peer(pc, rrp);
+
+        if (rc != NGX_BUSY) {
+            return rc;
+        }
+
+        /* ngx_lock_mutex(peers->mutex); */
+    }
+
+    /* all peers failed, mark them as live for quick recovery */
+
+    for (i = 0; i < peers->number; i++) {
+        peers->peer[i].fails = 0;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_TCP, pc->log, 0, "backup servers2");
+
+    /* ngx_unlock_mutex(peers->mutex); */
+
+    pc->name = peers->name;
+
+    return NGX_BUSY;
+}
+
+
+static ngx_uint_t
+ngx_tcp_upstream_get_peer(ngx_tcp_upstream_rr_peers_t *peers)
+{
+    ngx_uint_t                    i, n;
+    ngx_tcp_upstream_rr_peer_t   *peer;
+
+    peer = &peers->peer[0];
+
+    for ( ;; ) {
+
+        for (i = 0; i < peers->number; i++) {
+
+            if (peer[i].current_weight <= 0) {
+                continue;
+            }
+
+            n = i;
+
+            while (i < peers->number - 1) {
+
+                i++;
+
+                if (peer[i].current_weight <= 0) {
+                    continue;
+                }
+
+                if (peer[n].current_weight * 1000 / peer[i].current_weight
+                    > peer[n].weight * 1000 / peer[i].weight)
+                {
+                    return n;
+                }
+
+                n = i;
+            }
+
+            if (peer[i].current_weight > 0) {
+                n = i;
+            }
+
+            return n;
+        }
+
+        for (i = 0; i < peers->number; i++) {
+            peer[i].current_weight = peer[i].weight;
+        }
+    }
+}
+
+
+void
+ngx_tcp_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,
+    ngx_uint_t state)
+{
+    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;
+
+    time_t                       now;
+    ngx_tcp_upstream_rr_peer_t  *peer;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                   "free rr peer %ui %ui", pc->tries, state);
+
+    if (state == 0 && pc->tries == 0) {
+        return;
+    }
+
+    /* TODO: NGX_PEER_KEEPALIVE */
+
+    if (rrp->peers->single) {
+        pc->tries = 0;
+        return;
+    }
+
+    if (state & NGX_PEER_FAILED) {
+        now = ngx_time();
+
+        /* ngx_lock_mutex(rrp->peers->mutex); */
+        peer = &rrp->peers->peer[rrp->current];
+
+        peer->fails++;
+        peer->accessed = now;
+
+        if (peer->max_fails) {
+            peer->current_weight -= peer->weight / peer->max_fails;
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                       "free rr peer failed: %ui %i",
+                       rrp->current, peer->current_weight);
+
+        if (peer->current_weight < 0) {
+            peer->current_weight = 0;
+        }
+
+        /* ngx_unlock_mutex(rrp->peers->mutex); */
+    }
+
+    rrp->current++;
+
+    if (rrp->current >= rrp->peers->number) {
+        rrp->current = 0;
+    }
+
+    if (pc->tries) {
+        pc->tries--;
+    }
+
+    /* ngx_unlock_mutex(rrp->peers->mutex); */
+}
+
+
+#if (NGX_TCP_SSL)
+
+ngx_int_t
+ngx_tcp_upstream_set_round_robin_peer_session(ngx_peer_connection_t *pc,
+    void *data)
+{
+    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;
+
+    ngx_int_t                     rc;
+    ngx_ssl_session_t            *ssl_session;
+    ngx_tcp_upstream_rr_peer_t   *peer;
+
+    peer = &rrp->peers->peer[rrp->current];
+
+    /* TODO: threads only mutex */
+    /* ngx_lock_mutex(rrp->peers->mutex); */
+
+    ssl_session = peer->ssl_session;
+
+    rc = ngx_ssl_set_session(pc->connection, ssl_session);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                   "set session: %p:%d",
+                   ssl_session, ssl_session ? ssl_session->references : 0);
+
+    /* ngx_unlock_mutex(rrp->peers->mutex); */
+
+    return rc;
+}
+
+
+void
+ngx_tcp_upstream_save_round_robin_peer_session(ngx_peer_connection_t *pc,
+    void *data)
+{
+    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;
+
+    ngx_ssl_session_t            *old_ssl_session, *ssl_session;
+    ngx_tcp_upstream_rr_peer_t  *peer;
+
+    ssl_session = ngx_ssl_get_session(pc->connection);
+
+    if (ssl_session == NULL) {
+        return;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                   "save session: %p:%d", ssl_session, ssl_session->references);
+
+    peer = &rrp->peers->peer[rrp->current];
+
+    /* TODO: threads only mutex */
+    /* ngx_lock_mutex(rrp->peers->mutex); */
+
+    old_ssl_session = peer->ssl_session;
+    peer->ssl_session = ssl_session;
+
+    /* ngx_unlock_mutex(rrp->peers->mutex); */
+
+    if (old_ssl_session) {
+
+        ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,
+                       "old session: %p:%d",
+                       old_ssl_session, old_ssl_session->references);
+
+        /* TODO: may block */
+
+        ngx_ssl_free_session(old_ssl_session);
+    }
+}
+
+#endif
diff --git a/src/tcp/ngx_tcp_upstream_round_robin.h b/src/tcp/ngx_tcp_upstream_round_robin.h
new file mode 100755
index 0000000..9383b12
--- /dev/null
+++ b/src/tcp/ngx_tcp_upstream_round_robin.h
@@ -0,0 +1,79 @@
+
+#ifndef _NGX_TCP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_
+#define _NGX_TCP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_tcp.h>
+
+
+typedef struct {
+    struct sockaddr                *sockaddr;
+    socklen_t                       socklen;
+    ngx_str_t                       name;
+
+    ngx_int_t                       current_weight;
+    ngx_int_t                       weight;
+
+    ngx_uint_t                      fails;
+    time_t                          accessed;
+
+    ngx_uint_t                      max_fails;
+    time_t                          fail_timeout;
+
+    ngx_uint_t                      check_index;
+
+    ngx_uint_t                      down;          /* unsigned  down:1; */
+
+#if (NGX_TCP_SSL)
+    ngx_ssl_session_t              *ssl_session;   /* local to a process */
+#endif
+} ngx_tcp_upstream_rr_peer_t;
+
+
+typedef struct ngx_tcp_upstream_rr_peers_s  ngx_tcp_upstream_rr_peers_t;
+
+struct ngx_tcp_upstream_rr_peers_s {
+    ngx_uint_t                      single;        /* unsigned  single:1; */
+    ngx_uint_t                      number;
+    ngx_uint_t                      last_cached;
+
+ /* ngx_mutex_t                    *mutex; */
+    ngx_connection_t              **cached;
+
+    ngx_str_t                      *name;
+
+    ngx_tcp_upstream_rr_peers_t    *next;
+
+    ngx_tcp_upstream_rr_peer_t     peer[1];
+};
+
+
+typedef struct {
+    ngx_tcp_upstream_rr_peers_t    *peers;
+    ngx_uint_t                      current;
+    uintptr_t                      *tried;
+    uintptr_t                       data;
+} ngx_tcp_upstream_rr_peer_data_t;
+
+ngx_int_t ngx_tcp_upstream_init_round_robin(ngx_conf_t *cf,
+    ngx_tcp_upstream_srv_conf_t *us);
+ngx_int_t ngx_tcp_upstream_init_round_robin_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_srv_conf_t *us);
+ngx_int_t ngx_tcp_upstream_create_round_robin_peer(ngx_tcp_session_t *s,
+    ngx_tcp_upstream_resolved_t *ur);
+ngx_int_t ngx_tcp_upstream_get_round_robin_peer(ngx_peer_connection_t *pc,
+    void *data);
+void ngx_tcp_upstream_free_round_robin_peer(ngx_peer_connection_t *pc,
+    void *data, ngx_uint_t state);
+
+#if (NGX_TCP_SSL)
+ngx_int_t ngx_tcp_upstream_set_round_robin_peer_session(
+    ngx_peer_connection_t *pc, void *data);
+void ngx_tcp_upstream_save_round_robin_peer_session(ngx_peer_connection_t *pc,
+     void *data);
+#endif
+
+
+#endif /* _NGX_TCP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_ */
diff --git a/src/tcp/parsers/gen.shell b/src/tcp/parsers/gen.shell
new file mode 100755
index 0000000..82d5652
--- /dev/null
+++ b/src/tcp/parsers/gen.shell
@@ -0,0 +1,4 @@
+
+ragel -G2 http_request_parser.rl
+ragel -G2 http_response_parser.rl
+ragel -G2 smtp_response_parser.rl
diff --git a/src/tcp/parsers/http_request_parser.c b/src/tcp/parsers/http_request_parser.c
new file mode 100755
index 0000000..2bc32e0
--- /dev/null
+++ b/src/tcp/parsers/http_request_parser.c
@@ -0,0 +1,1231 @@
+
+#line 1 "http_request_parser.rl"
+
+/**
+ * Copyright (c) 2005 Zed A. Shaw
+ * You can redistribute it and/or modify it under the same terms as Ruby.
+ */
+
+#include <http_request_parser.h> 
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+
+#line 126 "http_request_parser.rl"
+
+
+/** Data **/
+
+#line 31 "http_request_parser.c"
+static const int http_request_parser_start = 1;
+static const int http_request_parser_first_final = 57;
+static const int http_request_parser_error = 0;
+
+static const int http_request_parser_en_main = 1;
+
+
+#line 130 "http_request_parser.rl"
+
+int http_request_parser_init(http_request_parser *parser)  {
+  int cs = 0;
+  
+#line 44 "http_request_parser.c"
+	{
+	cs = http_request_parser_start;
+	}
+
+#line 134 "http_request_parser.rl"
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_request_parser_execute(http_request_parser *parser, const signed char *buffer, size_t len, size_t off)  {
+  const signed char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer + off;
+  pe = buffer + len;
+
+  
+#line 73 "http_request_parser.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	switch( (*p) ) {
+		case 36: goto tr0;
+		case 95: goto tr0;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto tr0;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto tr0;
+	} else
+		goto tr0;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+tr0:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st2;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+#line 104 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st38;
+		case 95: goto st38;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st38;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st38;
+	} else
+		goto st38;
+	goto st0;
+tr2:
+#line 40 "http_request_parser.rl"
+	{ 
+    if(parser->request_method != NULL) 
+      parser->request_method(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st3;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+#line 130 "http_request_parser.c"
+	switch( (*p) ) {
+		case 42: goto tr4;
+		case 43: goto tr5;
+		case 47: goto tr6;
+		case 58: goto tr7;
+	}
+	if ( (*p) < 65 ) {
+		if ( 45 <= (*p) && (*p) <= 57 )
+			goto tr5;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr5;
+	} else
+		goto tr5;
+	goto st0;
+tr4:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st4;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+#line 154 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr8;
+		case 35: goto tr9;
+	}
+	goto st0;
+tr8:
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr31:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+#line 48 "http_request_parser.rl"
+	{
+    if(parser->fragment != NULL)
+      parser->fragment(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr34:
+#line 48 "http_request_parser.rl"
+	{
+    if(parser->fragment != NULL)
+      parser->fragment(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr42:
+#line 64 "http_request_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr53:
+#line 53 "http_request_parser.rl"
+	{MARK(query_start, p); }
+#line 54 "http_request_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr57:
+#line 54 "http_request_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+#line 225 "http_request_parser.c"
+	if ( (*p) == 72 )
+		goto tr10;
+	goto st0;
+tr10:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st6;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+#line 237 "http_request_parser.c"
+	if ( (*p) == 84 )
+		goto st7;
+	goto st0;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+	if ( (*p) == 84 )
+		goto st8;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	if ( (*p) == 80 )
+		goto st9;
+	goto st0;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+	if ( (*p) == 47 )
+		goto st10;
+	goto st0;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st11;
+	goto st0;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+	if ( (*p) == 46 )
+		goto st12;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st11;
+	goto st0;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st13;
+	goto st0;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+	if ( (*p) == 13 )
+		goto tr18;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st13;
+	goto st0;
+tr18:
+#line 59 "http_request_parser.rl"
+	{	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st14;
+tr26:
+#line 34 "http_request_parser.rl"
+	{ MARK(mark, p); }
+#line 35 "http_request_parser.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+tr29:
+#line 35 "http_request_parser.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+#line 323 "http_request_parser.c"
+	if ( (*p) == 10 )
+		goto st15;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	switch( (*p) ) {
+		case 13: goto st16;
+		case 33: goto tr21;
+		case 124: goto tr21;
+		case 126: goto tr21;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto tr21;
+		} else if ( (*p) >= 35 )
+			goto tr21;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto tr21;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto tr21;
+		} else
+			goto tr21;
+	} else
+		goto tr21;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 10 )
+		goto tr22;
+	goto st0;
+tr22:
+#line 69 "http_request_parser.rl"
+	{ 
+    parser->body_start = p - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, p + 1, pe - p - 1);
+    {p++; cs = 57; goto _out;}
+  }
+	goto st57;
+st57:
+	if ( ++p == pe )
+		goto _test_eof57;
+case 57:
+#line 375 "http_request_parser.c"
+	goto st0;
+tr21:
+#line 29 "http_request_parser.rl"
+	{ MARK(field_start, p); }
+	goto st17;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+#line 385 "http_request_parser.c"
+	switch( (*p) ) {
+		case 33: goto st17;
+		case 58: goto tr24;
+		case 124: goto st17;
+		case 126: goto st17;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto st17;
+		} else if ( (*p) >= 35 )
+			goto st17;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto st17;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto st17;
+		} else
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+tr24:
+#line 30 "http_request_parser.rl"
+	{ 
+    parser->field_len = LEN(field_start, p);
+  }
+	goto st18;
+tr27:
+#line 34 "http_request_parser.rl"
+	{ MARK(mark, p); }
+	goto st18;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+#line 424 "http_request_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr26;
+		case 32: goto tr27;
+	}
+	goto tr25;
+tr25:
+#line 34 "http_request_parser.rl"
+	{ MARK(mark, p); }
+	goto st19;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+#line 438 "http_request_parser.c"
+	if ( (*p) == 13 )
+		goto tr29;
+	goto st19;
+tr9:
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+tr43:
+#line 64 "http_request_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+tr54:
+#line 53 "http_request_parser.rl"
+	{MARK(query_start, p); }
+#line 54 "http_request_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+tr58:
+#line 54 "http_request_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 44 "http_request_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+#line 491 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr31;
+		case 37: goto tr32;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( (*p) > 31 ) {
+		if ( 34 <= (*p) && (*p) <= 35 )
+			goto st0;
+	} else if ( (*p) >= 0 )
+		goto st0;
+	goto tr30;
+tr30:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st21;
+st21:
+	if ( ++p == pe )
+		goto _test_eof21;
+case 21:
+#line 513 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr34;
+		case 37: goto st22;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( (*p) > 31 ) {
+		if ( 34 <= (*p) && (*p) <= 35 )
+			goto st0;
+	} else if ( (*p) >= 0 )
+		goto st0;
+	goto st21;
+tr32:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st22;
+st22:
+	if ( ++p == pe )
+		goto _test_eof22;
+case 22:
+#line 535 "http_request_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st23;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st23;
+	} else
+		goto st23;
+	goto st0;
+st23:
+	if ( ++p == pe )
+		goto _test_eof23;
+case 23:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st21;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st21;
+	} else
+		goto st21;
+	goto st0;
+tr5:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st24;
+st24:
+	if ( ++p == pe )
+		goto _test_eof24;
+case 24:
+#line 566 "http_request_parser.c"
+	switch( (*p) ) {
+		case 43: goto st24;
+		case 58: goto st25;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st24;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 90 ) {
+			if ( 97 <= (*p) && (*p) <= 122 )
+				goto st24;
+		} else if ( (*p) >= 65 )
+			goto st24;
+	} else
+		goto st24;
+	goto st0;
+tr7:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st25;
+st25:
+	if ( ++p == pe )
+		goto _test_eof25;
+case 25:
+#line 591 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr8;
+		case 34: goto st0;
+		case 35: goto tr9;
+		case 37: goto st26;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st25;
+st26:
+	if ( ++p == pe )
+		goto _test_eof26;
+case 26:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st27;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st27;
+	} else
+		goto st27;
+	goto st0;
+st27:
+	if ( ++p == pe )
+		goto _test_eof27;
+case 27:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st25;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st25;
+	} else
+		goto st25;
+	goto st0;
+tr6:
+#line 26 "http_request_parser.rl"
+	{MARK(mark, p); }
+	goto st28;
+st28:
+	if ( ++p == pe )
+		goto _test_eof28;
+case 28:
+#line 638 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr42;
+		case 34: goto st0;
+		case 35: goto tr43;
+		case 37: goto st29;
+		case 59: goto tr45;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 63: goto tr46;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st28;
+st29:
+	if ( ++p == pe )
+		goto _test_eof29;
+case 29:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st30;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st30;
+	} else
+		goto st30;
+	goto st0;
+st30:
+	if ( ++p == pe )
+		goto _test_eof30;
+case 30:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st28;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st28;
+	} else
+		goto st28;
+	goto st0;
+tr45:
+#line 64 "http_request_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st31;
+st31:
+	if ( ++p == pe )
+		goto _test_eof31;
+case 31:
+#line 690 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr8;
+		case 34: goto st0;
+		case 35: goto tr9;
+		case 37: goto st32;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 63: goto st34;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st31;
+st32:
+	if ( ++p == pe )
+		goto _test_eof32;
+case 32:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st33;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st33;
+	} else
+		goto st33;
+	goto st0;
+st33:
+	if ( ++p == pe )
+		goto _test_eof33;
+case 33:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st31;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st31;
+	} else
+		goto st31;
+	goto st0;
+tr46:
+#line 64 "http_request_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st34;
+st34:
+	if ( ++p == pe )
+		goto _test_eof34;
+case 34:
+#line 741 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr53;
+		case 34: goto st0;
+		case 35: goto tr54;
+		case 37: goto tr55;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto tr52;
+tr52:
+#line 53 "http_request_parser.rl"
+	{MARK(query_start, p); }
+	goto st35;
+st35:
+	if ( ++p == pe )
+		goto _test_eof35;
+case 35:
+#line 762 "http_request_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr57;
+		case 34: goto st0;
+		case 35: goto tr58;
+		case 37: goto st36;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st35;
+tr55:
+#line 53 "http_request_parser.rl"
+	{MARK(query_start, p); }
+	goto st36;
+st36:
+	if ( ++p == pe )
+		goto _test_eof36;
+case 36:
+#line 783 "http_request_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st37;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st37;
+	} else
+		goto st37;
+	goto st0;
+st37:
+	if ( ++p == pe )
+		goto _test_eof37;
+case 37:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st35;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st35;
+	} else
+		goto st35;
+	goto st0;
+st38:
+	if ( ++p == pe )
+		goto _test_eof38;
+case 38:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st39;
+		case 95: goto st39;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st39;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st39;
+	} else
+		goto st39;
+	goto st0;
+st39:
+	if ( ++p == pe )
+		goto _test_eof39;
+case 39:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st40;
+		case 95: goto st40;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st40;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st40;
+	} else
+		goto st40;
+	goto st0;
+st40:
+	if ( ++p == pe )
+		goto _test_eof40;
+case 40:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st41;
+		case 95: goto st41;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st41;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st41;
+	} else
+		goto st41;
+	goto st0;
+st41:
+	if ( ++p == pe )
+		goto _test_eof41;
+case 41:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st42;
+		case 95: goto st42;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st42;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st42;
+	} else
+		goto st42;
+	goto st0;
+st42:
+	if ( ++p == pe )
+		goto _test_eof42;
+case 42:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st43;
+		case 95: goto st43;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st43;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st43;
+	} else
+		goto st43;
+	goto st0;
+st43:
+	if ( ++p == pe )
+		goto _test_eof43;
+case 43:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st44;
+		case 95: goto st44;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st44;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st44;
+	} else
+		goto st44;
+	goto st0;
+st44:
+	if ( ++p == pe )
+		goto _test_eof44;
+case 44:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st45;
+		case 95: goto st45;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st45;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st45;
+	} else
+		goto st45;
+	goto st0;
+st45:
+	if ( ++p == pe )
+		goto _test_eof45;
+case 45:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st46;
+		case 95: goto st46;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st46;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st46;
+	} else
+		goto st46;
+	goto st0;
+st46:
+	if ( ++p == pe )
+		goto _test_eof46;
+case 46:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st47;
+		case 95: goto st47;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st47;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st47;
+	} else
+		goto st47;
+	goto st0;
+st47:
+	if ( ++p == pe )
+		goto _test_eof47;
+case 47:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st48;
+		case 95: goto st48;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st48;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st48;
+	} else
+		goto st48;
+	goto st0;
+st48:
+	if ( ++p == pe )
+		goto _test_eof48;
+case 48:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st49;
+		case 95: goto st49;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st49;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st49;
+	} else
+		goto st49;
+	goto st0;
+st49:
+	if ( ++p == pe )
+		goto _test_eof49;
+case 49:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st50;
+		case 95: goto st50;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st50;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st50;
+	} else
+		goto st50;
+	goto st0;
+st50:
+	if ( ++p == pe )
+		goto _test_eof50;
+case 50:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st51;
+		case 95: goto st51;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st51;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st51;
+	} else
+		goto st51;
+	goto st0;
+st51:
+	if ( ++p == pe )
+		goto _test_eof51;
+case 51:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st52;
+		case 95: goto st52;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st52;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st52;
+	} else
+		goto st52;
+	goto st0;
+st52:
+	if ( ++p == pe )
+		goto _test_eof52;
+case 52:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st53;
+		case 95: goto st53;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st53;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st53;
+	} else
+		goto st53;
+	goto st0;
+st53:
+	if ( ++p == pe )
+		goto _test_eof53;
+case 53:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st54;
+		case 95: goto st54;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st54;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st54;
+	} else
+		goto st54;
+	goto st0;
+st54:
+	if ( ++p == pe )
+		goto _test_eof54;
+case 54:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st55;
+		case 95: goto st55;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st55;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st55;
+	} else
+		goto st55;
+	goto st0;
+st55:
+	if ( ++p == pe )
+		goto _test_eof55;
+case 55:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st56;
+		case 95: goto st56;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st56;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st56;
+	} else
+		goto st56;
+	goto st0;
+st56:
+	if ( ++p == pe )
+		goto _test_eof56;
+case 56:
+	if ( (*p) == 32 )
+		goto tr2;
+	goto st0;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof57: cs = 57; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof21: cs = 21; goto _test_eof; 
+	_test_eof22: cs = 22; goto _test_eof; 
+	_test_eof23: cs = 23; goto _test_eof; 
+	_test_eof24: cs = 24; goto _test_eof; 
+	_test_eof25: cs = 25; goto _test_eof; 
+	_test_eof26: cs = 26; goto _test_eof; 
+	_test_eof27: cs = 27; goto _test_eof; 
+	_test_eof28: cs = 28; goto _test_eof; 
+	_test_eof29: cs = 29; goto _test_eof; 
+	_test_eof30: cs = 30; goto _test_eof; 
+	_test_eof31: cs = 31; goto _test_eof; 
+	_test_eof32: cs = 32; goto _test_eof; 
+	_test_eof33: cs = 33; goto _test_eof; 
+	_test_eof34: cs = 34; goto _test_eof; 
+	_test_eof35: cs = 35; goto _test_eof; 
+	_test_eof36: cs = 36; goto _test_eof; 
+	_test_eof37: cs = 37; goto _test_eof; 
+	_test_eof38: cs = 38; goto _test_eof; 
+	_test_eof39: cs = 39; goto _test_eof; 
+	_test_eof40: cs = 40; goto _test_eof; 
+	_test_eof41: cs = 41; goto _test_eof; 
+	_test_eof42: cs = 42; goto _test_eof; 
+	_test_eof43: cs = 43; goto _test_eof; 
+	_test_eof44: cs = 44; goto _test_eof; 
+	_test_eof45: cs = 45; goto _test_eof; 
+	_test_eof46: cs = 46; goto _test_eof; 
+	_test_eof47: cs = 47; goto _test_eof; 
+	_test_eof48: cs = 48; goto _test_eof; 
+	_test_eof49: cs = 49; goto _test_eof; 
+	_test_eof50: cs = 50; goto _test_eof; 
+	_test_eof51: cs = 51; goto _test_eof; 
+	_test_eof52: cs = 52; goto _test_eof; 
+	_test_eof53: cs = 53; goto _test_eof; 
+	_test_eof54: cs = 54; goto _test_eof; 
+	_test_eof55: cs = 55; goto _test_eof; 
+	_test_eof56: cs = 56; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 157 "http_request_parser.rl"
+
+  if (!http_request_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_request_parser_finish(http_request_parser *parser)
+{
+  if (http_request_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_request_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_request_parser_has_error(http_request_parser *parser) {
+  return parser->cs == http_request_parser_error;
+}
+
+int http_request_parser_is_finished(http_request_parser *parser) {
+  return parser->cs >= http_request_parser_first_final;
+}
diff --git a/src/tcp/parsers/http_request_parser.h b/src/tcp/parsers/http_request_parser.h
new file mode 100755
index 0000000..b895c8f
--- /dev/null
+++ b/src/tcp/parsers/http_request_parser.h
@@ -0,0 +1,41 @@
+
+#ifndef _NGX_TCP_HTTP_REQUEST_PARSER_H_INCLUDED_
+#define _NGX_TCP_HTTP_REQUEST_PARSER_H_INCLUDED_
+
+#include <parser.h>
+
+
+typedef struct http_request_parser { 
+  int cs;
+  size_t body_start;
+  int content_len;
+  size_t nread;
+  size_t mark;
+  size_t field_start;
+  size_t field_len;
+  size_t query_start;
+
+  void *data;
+
+  field_cb http_field;
+  element_cb request_method;
+  element_cb request_uri;
+  element_cb fragment;
+  element_cb request_path;
+  element_cb query_string;
+  element_cb http_version;
+  element_cb header_done;
+  
+} http_request_parser;
+
+int http_request_parser_init(http_request_parser *parser);
+int http_request_parser_finish(http_request_parser *parser);
+size_t http_request_parser_execute(http_request_parser *parser, 
+        const signed char *data, size_t len, size_t off);
+int http_request_parser_has_error(http_request_parser *parser);
+int http_request_parser_is_finished(http_request_parser *parser);
+
+#define http_request_parser_nread(parser) (parser)->nread 
+
+
+#endif //_NGX_TCP_HTTP_REQUEST_PARSER_H_INCLUDED_
diff --git a/src/tcp/parsers/http_request_parser.rl b/src/tcp/parsers/http_request_parser.rl
new file mode 100755
index 0000000..e78ae4f
--- /dev/null
+++ b/src/tcp/parsers/http_request_parser.rl
@@ -0,0 +1,189 @@
+
+/**
+ * Copyright (c) 2005 Zed A. Shaw
+ * You can redistribute it and/or modify it under the same terms as Ruby.
+ */
+
+#include <http_request_parser.h> 
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+%%{
+  
+  machine http_request_parser;
+
+  action mark {MARK(mark, fpc); }
+
+
+  action start_field { MARK(field_start, fpc); }
+  action write_field { 
+    parser->field_len = LEN(field_start, fpc);
+  }
+
+  action start_value { MARK(mark, fpc); }
+  action write_value {
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, fpc));
+    }
+  }
+  action request_method { 
+    if(parser->request_method != NULL) 
+      parser->request_method(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+  action request_uri { 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+  action fragment {
+    if(parser->fragment != NULL)
+      parser->fragment(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action start_query {MARK(query_start, fpc); }
+  action query_string { 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, fpc));
+  }
+
+  action http_version {	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action request_path {
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action done { 
+    parser->body_start = fpc - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, fpc + 1, pe - fpc - 1);
+    fbreak;
+  }
+
+#### HTTP PROTOCOL GRAMMAR
+# line endings
+  CRLF = "\r\n";
+
+# character types
+  CTL = (cntrl | 127);
+  safe = ("$" | "-" | "_" | ".");
+  extra = ("!" | "*" | "'" | "(" | ")" | ",");
+  reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+");
+  unsafe = (CTL | " " | "\"" | "#" | "%" | "<" | ">");
+  national = any -- (alpha | digit | reserved | extra | safe | unsafe);
+  unreserved = (alpha | digit | safe | extra | national);
+  escape = ("%" xdigit xdigit);
+  uchar = (unreserved | escape);
+  pchar = (uchar | ":" | "@" | "&" | "=" | "+");
+  tspecials = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" | "\"" | "/" | "[" | "]" | "?" | "=" | "{" | "}" | " " | "\t");
+
+# elements
+  token = (ascii -- (CTL | tspecials));
+
+# URI schemes and absolute paths
+  scheme = ( alpha | digit | "+" | "-" | "." )* ;
+  absolute_uri = (scheme ":" (uchar | reserved )*);
+
+  path = ( pchar+ ( "/" pchar* )* ) ;
+  query = ( uchar | reserved )* %query_string ;
+  param = ( pchar | "/" )* ;
+  params = ( param ( ";" param )* ) ;
+  rel_path = ( path? %request_path (";" params)? ) ("?" %start_query query)?;
+  absolute_path = ( "/"+ rel_path );
+
+  Request_URI = ( "*" | absolute_uri | absolute_path ) >mark %request_uri;
+  Fragment = ( uchar | reserved )* >mark %fragment;
+  Method = ( upper | digit | safe ){1,20} >mark %request_method;
+
+  http_number = ( digit+ "." digit+ ) ;
+  HTTP_Version = ( "HTTP/" http_number ) >mark %http_version ;
+  Request_Line = ( Method " " Request_URI ("#" Fragment){0,1} " " HTTP_Version CRLF ) ;
+
+#field_name = ( token -- ":" )+ >start_field $snake_upcase_field %write_field;
+  field_name = ( token -- ":" )+ >start_field %write_field;
+
+  field_value = any* >start_value %write_value;
+
+  message_header = field_name ":" " "* field_value :> CRLF;
+
+  Request = Request_Line ( message_header )* ( CRLF @done );
+
+main := Request;
+
+}%%
+
+/** Data **/
+%% write data;
+
+int http_request_parser_init(http_request_parser *parser)  {
+  int cs = 0;
+  %% write init;
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_request_parser_execute(http_request_parser *parser, const signed char *buffer, size_t len, size_t off)  {
+  const signed char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer + off;
+  pe = buffer + len;
+
+  %% write exec;
+
+  if (!http_request_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_request_parser_finish(http_request_parser *parser)
+{
+  if (http_request_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_request_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_request_parser_has_error(http_request_parser *parser) {
+  return parser->cs == http_request_parser_error;
+}
+
+int http_request_parser_is_finished(http_request_parser *parser) {
+  return parser->cs >= http_request_parser_first_final;
+}
diff --git a/src/tcp/parsers/http_response_parser.c b/src/tcp/parsers/http_response_parser.c
new file mode 100755
index 0000000..76d4c20
--- /dev/null
+++ b/src/tcp/parsers/http_response_parser.c
@@ -0,0 +1,418 @@
+
+#line 1 "http_response_parser.rl"
+
+#include <http_response_parser.h>
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+
+#line 88 "http_response_parser.rl"
+
+
+/** Data **/
+
+#line 26 "http_response_parser.c"
+static const int http_response_parser_start = 1;
+static const int http_response_parser_first_final = 20;
+static const int http_response_parser_error = 0;
+
+static const int http_response_parser_en_main = 1;
+
+
+#line 92 "http_response_parser.rl"
+
+int http_response_parser_init(http_response_parser *parser)  {
+  int cs = 0;
+  
+#line 39 "http_response_parser.c"
+	{
+	cs = http_response_parser_start;
+	}
+
+#line 96 "http_response_parser.rl"
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_response_parser_execute(http_response_parser *parser, const signed char *buffer, size_t len, size_t off)  {
+  const signed char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer + off;
+  pe = buffer + len;
+
+  
+#line 68 "http_response_parser.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	if ( (*p) == 72 )
+		goto tr0;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+tr0:
+#line 21 "http_response_parser.rl"
+	{MARK(mark, p); }
+	goto st2;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+#line 89 "http_response_parser.c"
+	if ( (*p) == 84 )
+		goto st3;
+	goto st0;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+	if ( (*p) == 84 )
+		goto st4;
+	goto st0;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+	if ( (*p) == 80 )
+		goto st5;
+	goto st0;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+	if ( (*p) == 47 )
+		goto st6;
+	goto st0;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st7;
+	goto st0;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+	if ( (*p) == 46 )
+		goto st8;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st7;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+	if ( (*p) == 32 )
+		goto tr9;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+tr9:
+#line 36 "http_response_parser.rl"
+	{	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st10;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+#line 157 "http_response_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr10;
+	goto st0;
+tr10:
+#line 21 "http_response_parser.rl"
+	{MARK(mark, p); }
+	goto st11;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+#line 169 "http_response_parser.c"
+	if ( (*p) == 32 )
+		goto tr11;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st11;
+	goto st0;
+tr11:
+#line 41 "http_response_parser.rl"
+	{
+    if(parser->status_code != NULL)
+      parser->status_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st12;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+#line 186 "http_response_parser.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr13;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr13;
+	} else
+		goto tr13;
+	goto st0;
+tr13:
+#line 21 "http_response_parser.rl"
+	{MARK(mark, p); }
+	goto st13;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+#line 204 "http_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr15;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st13;
+	} else if ( (*p) >= 0 )
+		goto st13;
+	goto st0;
+tr15:
+#line 46 "http_response_parser.rl"
+	{
+    if(parser->reason_phrase != NULL)
+      parser->reason_phrase(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st14;
+tr23:
+#line 28 "http_response_parser.rl"
+	{ MARK(mark, p); }
+#line 30 "http_response_parser.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+tr26:
+#line 30 "http_response_parser.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+#line 242 "http_response_parser.c"
+	if ( (*p) == 10 )
+		goto st15;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	switch( (*p) ) {
+		case 13: goto st16;
+		case 33: goto tr18;
+		case 124: goto tr18;
+		case 126: goto tr18;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto tr18;
+		} else if ( (*p) >= 35 )
+			goto tr18;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto tr18;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto tr18;
+		} else
+			goto tr18;
+	} else
+		goto tr18;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 10 )
+		goto tr19;
+	goto st0;
+tr19:
+#line 51 "http_response_parser.rl"
+	{ 
+    parser->body_start = p - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, p + 1, pe - p - 1);
+    {p++; cs = 20; goto _out;}
+  }
+	goto st20;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+#line 294 "http_response_parser.c"
+	goto st0;
+tr18:
+#line 23 "http_response_parser.rl"
+	{ MARK(field_start, p); }
+	goto st17;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+#line 304 "http_response_parser.c"
+	switch( (*p) ) {
+		case 33: goto st17;
+		case 58: goto tr21;
+		case 124: goto st17;
+		case 126: goto st17;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto st17;
+		} else if ( (*p) >= 35 )
+			goto st17;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto st17;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto st17;
+		} else
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+tr21:
+#line 24 "http_response_parser.rl"
+	{ 
+    parser->field_len = LEN(field_start, p);
+  }
+	goto st18;
+tr24:
+#line 28 "http_response_parser.rl"
+	{ MARK(mark, p); }
+	goto st18;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+#line 343 "http_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr23;
+		case 32: goto tr24;
+	}
+	goto tr22;
+tr22:
+#line 28 "http_response_parser.rl"
+	{ MARK(mark, p); }
+	goto st19;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+#line 357 "http_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr26;
+	goto st19;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 119 "http_response_parser.rl"
+
+  if (!http_response_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_response_parser_finish(http_response_parser *parser)
+{
+  if (http_response_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_response_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_response_parser_has_error(http_response_parser *parser) {
+  return parser->cs == http_response_parser_error;
+}
+
+int http_response_parser_is_finished(http_response_parser *parser) {
+  return parser->cs >= http_response_parser_first_final;
+}
diff --git a/src/tcp/parsers/http_response_parser.h b/src/tcp/parsers/http_response_parser.h
new file mode 100755
index 0000000..9ed05dd
--- /dev/null
+++ b/src/tcp/parsers/http_response_parser.h
@@ -0,0 +1,39 @@
+
+#ifndef _NGX_TCP_HTTP_RESPONSE_PARSER_H_INCLUDED_
+#define _NGX_TCP_HTTP_RESPONSE_PARSER_H_INCLUDED_
+
+#include <parser.h>
+
+typedef struct http_response_parser { 
+  int cs;
+  size_t body_start;
+  int content_len;
+  int status_code_n;
+  size_t nread;
+  size_t mark;
+  size_t field_start;
+  size_t field_len;
+
+  void *data;
+
+  field_cb http_field;
+
+  element_cb http_version;
+  element_cb status_code;
+  element_cb reason_phrase;
+  element_cb header_done;
+  
+} http_response_parser;
+
+
+int http_response_parser_init(http_response_parser *parser);
+int http_response_parser_finish(http_response_parser *parser);
+size_t http_response_parser_execute(http_response_parser *parser,
+        const signed char *data, size_t len, size_t off);
+int http_response_parser_has_error(http_response_parser *parser);
+int http_response_parser_is_finished(http_response_parser *parser);
+
+#define http_response_parser_nread(parser) (parser)->nread 
+
+
+#endif //_NGX_TCP_HTTP_RESPONSE_PARSER_H_INCLUDED_
diff --git a/src/tcp/parsers/http_response_parser.rl b/src/tcp/parsers/http_response_parser.rl
new file mode 100755
index 0000000..d25beb1
--- /dev/null
+++ b/src/tcp/parsers/http_response_parser.rl
@@ -0,0 +1,151 @@
+
+#include <http_response_parser.h>
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+%%{
+  
+  machine http_response_parser;
+
+  action mark {MARK(mark, fpc); }
+
+  action start_field { MARK(field_start, fpc); }
+  action write_field { 
+    parser->field_len = LEN(field_start, fpc);
+  }
+
+  action start_value { MARK(mark, fpc); }
+
+  action write_value {
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, fpc));
+    }
+  }
+
+  action http_version {	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action status_code {
+    if(parser->status_code != NULL)
+      parser->status_code(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action reason_phrase {
+    if(parser->reason_phrase != NULL)
+      parser->reason_phrase(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action done { 
+    parser->body_start = fpc - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, fpc + 1, pe - fpc - 1);
+    fbreak;
+  }
+
+#### HTTP PROTOCOL GRAMMAR
+# line endings
+  CRLF = "\r\n";
+
+# character types
+  CTL = (cntrl | 127);
+  tspecials = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" | "\"" | "/" | "[" | "]" | "?" | "=" | "{" | "}" | " " | "\t");
+
+# elements
+  token = (ascii -- (CTL | tspecials));
+
+  Reason_Phrase = ( ascii -- ("\r" | "\n") )+ >mark %reason_phrase;
+
+  Status_Code = ( digit+ ) >mark %status_code ;
+
+  http_number = ( digit+ "." digit+ ) ;
+  HTTP_Version = ( "HTTP/" http_number ) >mark %http_version ;
+
+  Response_Line = ( HTTP_Version " " Status_Code " " Reason_Phrase CRLF ) ;
+
+  field_name = ( token -- ":" )+ >start_field %write_field;
+
+  field_value = any* >start_value %write_value;
+
+  message_header = field_name ":" " "* field_value :> CRLF;
+
+  Response = Response_Line ( message_header )* ( CRLF @done );
+
+main := Response;
+
+}%%
+
+/** Data **/
+%% write data;
+
+int http_response_parser_init(http_response_parser *parser)  {
+  int cs = 0;
+  %% write init;
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_response_parser_execute(http_response_parser *parser, const signed char *buffer, size_t len, size_t off)  {
+  const signed char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer + off;
+  pe = buffer + len;
+
+  %% write exec;
+
+  if (!http_response_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_response_parser_finish(http_response_parser *parser)
+{
+  if (http_response_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_response_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_response_parser_has_error(http_response_parser *parser) {
+  return parser->cs == http_response_parser_error;
+}
+
+int http_response_parser_is_finished(http_response_parser *parser) {
+  return parser->cs >= http_response_parser_first_final;
+}
diff --git a/src/tcp/parsers/parser.h b/src/tcp/parsers/parser.h
new file mode 100755
index 0000000..5783464
--- /dev/null
+++ b/src/tcp/parsers/parser.h
@@ -0,0 +1,13 @@
+
+#ifndef _NGX_TCP_PARSER_H_INCLUDED_
+#define _NGX_TCP_PARSER_H_INCLUDED_
+
+#include <sys/types.h>
+
+/*HTTP parser*/
+typedef void (*element_cb)(void *data, const signed char *at, size_t length);
+typedef void (*field_cb)(void *data, const signed char *field, 
+        size_t flen, const signed char *value, size_t vlen);
+
+
+#endif //_NGX_TCP_PARSER_H_INCLUDED_
diff --git a/src/tcp/parsers/smtp_response_parser.c b/src/tcp/parsers/smtp_response_parser.c
new file mode 100755
index 0000000..c3d2016
--- /dev/null
+++ b/src/tcp/parsers/smtp_response_parser.c
@@ -0,0 +1,6550 @@
+
+#line 1 "smtp_response_parser.rl"
+
+#include "../ngx_tcp_upstream_check.h"
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+
+#line 108 "smtp_response_parser.rl"
+
+
+/** Data **/
+
+#line 25 "smtp_response_parser.c"
+static const int smtp_parser_start = 1;
+static const int smtp_parser_first_final = 429;
+static const int smtp_parser_error = 0;
+
+static const int smtp_parser_en_main = 1;
+
+
+#line 112 "smtp_response_parser.rl"
+
+int smtp_parser_init(smtp_parser *parser)  {
+
+  int cs = 0;
+  
+#line 39 "smtp_response_parser.c"
+	{
+	cs = smtp_parser_start;
+	}
+
+#line 117 "smtp_response_parser.rl"
+  parser->cs = cs;
+  parser->mark = 0;
+  parser->nread = 0;
+
+  return(1);
+}
+
+
+/** exec **/
+size_t smtp_parser_execute(smtp_parser *parser, const signed char *buffer, size_t len, size_t off)  {
+
+  const signed char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer + off;
+  pe = buffer + len;
+
+  
+#line 65 "smtp_response_parser.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	if ( (*p) == 50 )
+		goto st2;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+	if ( (*p) == 50 )
+		goto st3;
+	goto st0;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+	if ( (*p) == 48 )
+		goto st4;
+	goto st0;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+	if ( (*p) == 32 )
+		goto st5;
+	goto st0;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+	if ( (*p) == 91 )
+		goto tr6;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr5;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr5;
+	} else
+		goto tr5;
+	goto st0;
+tr5:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st6;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+#line 122 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr7;
+		case 32: goto tr8;
+		case 45: goto st300;
+		case 46: goto st301;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st6;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st6;
+	} else
+		goto st6;
+	goto st0;
+tr7:
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st7;
+tr323:
+#line 28 "smtp_response_parser.rl"
+	{	
+    if(parser->greeting_text != NULL)
+      parser->greeting_text(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st7;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+#line 157 "smtp_response_parser.c"
+	if ( (*p) == 10 )
+		goto st8;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	if ( (*p) == 50 )
+		goto tr14;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr13;
+	goto st0;
+tr13:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st9;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+#line 178 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr15;
+		case 32: goto tr16;
+	}
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+tr190:
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st10;
+tr15:
+#line 33 "smtp_response_parser.rl"
+	{
+    if(parser->reply_code != NULL)
+      parser->reply_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st10;
+tr21:
+#line 38 "smtp_response_parser.rl"
+	{
+    if(parser->reply_text != NULL)
+      parser->reply_text(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st10;
+tr194:
+#line 28 "smtp_response_parser.rl"
+	{	
+    if(parser->greeting_text != NULL)
+      parser->greeting_text(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st10;
+tr181:
+#line 33 "smtp_response_parser.rl"
+	{
+    if(parser->reply_code != NULL)
+      parser->reply_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st10;
+tr189:
+#line 38 "smtp_response_parser.rl"
+	{
+    if(parser->reply_text != NULL)
+      parser->reply_text(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 28 "smtp_response_parser.rl"
+	{	
+    if(parser->greeting_text != NULL)
+      parser->greeting_text(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st10;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+#line 244 "smtp_response_parser.c"
+	if ( (*p) == 10 )
+		goto tr18;
+	goto st0;
+tr18:
+#line 43 "smtp_response_parser.rl"
+	{ 
+    if(parser->smtp_done != NULL)
+      parser->smtp_done(parser->data, p + 1, pe - p - 1);
+    {p++; cs = 429; goto _out;}
+  }
+	goto st429;
+st429:
+	if ( ++p == pe )
+		goto _test_eof429;
+case 429:
+#line 260 "smtp_response_parser.c"
+	goto st0;
+tr16:
+#line 33 "smtp_response_parser.rl"
+	{
+    if(parser->reply_code != NULL)
+      parser->reply_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st11;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+#line 273 "smtp_response_parser.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr19;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr19;
+	} else
+		goto tr19;
+	goto st0;
+tr19:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st12;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+#line 291 "smtp_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr21;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st12;
+	} else if ( (*p) >= 0 )
+		goto st12;
+	goto st0;
+tr14:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st13;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+#line 308 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr15;
+		case 32: goto tr16;
+		case 53: goto st14;
+	}
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+	switch( (*p) ) {
+		case 13: goto tr15;
+		case 32: goto tr16;
+		case 48: goto st15;
+	}
+	if ( 49 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	switch( (*p) ) {
+		case 13: goto tr15;
+		case 32: goto tr16;
+		case 45: goto st16;
+		case 91: goto tr27;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr25;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr26;
+	} else
+		goto tr26;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 91 )
+		goto tr29;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr28;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr28;
+	} else
+		goto tr28;
+	goto st0;
+tr28:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st17;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+#line 371 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr30;
+		case 32: goto tr31;
+		case 45: goto st34;
+		case 46: goto st35;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st17;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+tr30:
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st18;
+tr48:
+#line 38 "smtp_response_parser.rl"
+	{
+    if(parser->reply_text != NULL)
+      parser->reply_text(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st18;
+tr54:
+#line 28 "smtp_response_parser.rl"
+	{	
+    if(parser->greeting_text != NULL)
+      parser->greeting_text(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st18;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+#line 413 "smtp_response_parser.c"
+	if ( (*p) == 10 )
+		goto st19;
+	goto st0;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+	if ( (*p) == 50 )
+		goto tr37;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr36;
+	goto st0;
+tr36:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st20;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+#line 434 "smtp_response_parser.c"
+	if ( (*p) == 32 )
+		goto tr38;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st20;
+	goto st0;
+tr38:
+#line 33 "smtp_response_parser.rl"
+	{
+    if(parser->reply_code != NULL)
+      parser->reply_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st21;
+st21:
+	if ( ++p == pe )
+		goto _test_eof21;
+case 21:
+#line 451 "smtp_response_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr40;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr40;
+	} else
+		goto tr40;
+	goto st0;
+tr40:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st22;
+st22:
+	if ( ++p == pe )
+		goto _test_eof22;
+case 22:
+#line 469 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr21;
+		case 32: goto st23;
+		case 45: goto st22;
+		case 61: goto st23;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st22;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st22;
+	} else
+		goto st22;
+	goto st0;
+st23:
+	if ( ++p == pe )
+		goto _test_eof23;
+case 23:
+	if ( 33 <= (*p) && (*p) <= 126 )
+		goto st24;
+	goto st0;
+st24:
+	if ( ++p == pe )
+		goto _test_eof24;
+case 24:
+	switch( (*p) ) {
+		case 13: goto tr21;
+		case 32: goto st23;
+	}
+	if ( 33 <= (*p) && (*p) <= 126 )
+		goto st24;
+	goto st0;
+tr37:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st25;
+st25:
+	if ( ++p == pe )
+		goto _test_eof25;
+case 25:
+#line 511 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr38;
+		case 53: goto st26;
+	}
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st20;
+	goto st0;
+st26:
+	if ( ++p == pe )
+		goto _test_eof26;
+case 26:
+	switch( (*p) ) {
+		case 32: goto tr38;
+		case 48: goto st27;
+	}
+	if ( 49 <= (*p) && (*p) <= 57 )
+		goto st20;
+	goto st0;
+st27:
+	if ( ++p == pe )
+		goto _test_eof27;
+case 27:
+	switch( (*p) ) {
+		case 32: goto tr38;
+		case 45: goto st28;
+	}
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st20;
+	goto st0;
+st28:
+	if ( ++p == pe )
+		goto _test_eof28;
+case 28:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr47;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr47;
+	} else
+		goto tr47;
+	goto st0;
+tr47:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st29;
+st29:
+	if ( ++p == pe )
+		goto _test_eof29;
+case 29:
+#line 562 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr48;
+		case 32: goto st30;
+		case 45: goto st29;
+		case 61: goto st30;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st29;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st29;
+	} else
+		goto st29;
+	goto st0;
+st30:
+	if ( ++p == pe )
+		goto _test_eof30;
+case 30:
+	if ( 33 <= (*p) && (*p) <= 126 )
+		goto st31;
+	goto st0;
+st31:
+	if ( ++p == pe )
+		goto _test_eof31;
+case 31:
+	switch( (*p) ) {
+		case 13: goto tr48;
+		case 32: goto st30;
+	}
+	if ( 33 <= (*p) && (*p) <= 126 )
+		goto st31;
+	goto st0;
+tr31:
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st32;
+st32:
+	if ( ++p == pe )
+		goto _test_eof32;
+case 32:
+#line 608 "smtp_response_parser.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr52;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr52;
+	} else
+		goto tr52;
+	goto st0;
+tr52:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st33;
+st33:
+	if ( ++p == pe )
+		goto _test_eof33;
+case 33:
+#line 626 "smtp_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr54;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st33;
+	} else if ( (*p) >= 0 )
+		goto st33;
+	goto st0;
+st34:
+	if ( ++p == pe )
+		goto _test_eof34;
+case 34:
+	if ( (*p) == 45 )
+		goto st34;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st17;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+st35:
+	if ( ++p == pe )
+		goto _test_eof35;
+case 35:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st36;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st36;
+	} else
+		goto st36;
+	goto st0;
+st36:
+	if ( ++p == pe )
+		goto _test_eof36;
+case 36:
+	switch( (*p) ) {
+		case 13: goto tr30;
+		case 32: goto tr31;
+		case 45: goto st37;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st36;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st36;
+	} else
+		goto st36;
+	goto st0;
+st37:
+	if ( ++p == pe )
+		goto _test_eof37;
+case 37:
+	if ( (*p) == 45 )
+		goto st37;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st36;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st36;
+	} else
+		goto st36;
+	goto st0;
+tr29:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st38;
+st38:
+	if ( ++p == pe )
+		goto _test_eof38;
+case 38:
+#line 704 "smtp_response_parser.c"
+	if ( (*p) == 73 )
+		goto st55;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st39;
+	goto st0;
+st39:
+	if ( ++p == pe )
+		goto _test_eof39;
+case 39:
+	if ( (*p) == 46 )
+		goto st40;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st53;
+	goto st0;
+st40:
+	if ( ++p == pe )
+		goto _test_eof40;
+case 40:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st41;
+	goto st0;
+st41:
+	if ( ++p == pe )
+		goto _test_eof41;
+case 41:
+	if ( (*p) == 46 )
+		goto st42;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st51;
+	goto st0;
+st42:
+	if ( ++p == pe )
+		goto _test_eof42;
+case 42:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st43;
+	goto st0;
+st43:
+	if ( ++p == pe )
+		goto _test_eof43;
+case 43:
+	if ( (*p) == 46 )
+		goto st44;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st49;
+	goto st0;
+st44:
+	if ( ++p == pe )
+		goto _test_eof44;
+case 44:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st45;
+	goto st0;
+st45:
+	if ( ++p == pe )
+		goto _test_eof45;
+case 45:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st46;
+	goto st0;
+st46:
+	if ( ++p == pe )
+		goto _test_eof46;
+case 46:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st47;
+	goto st0;
+st47:
+	if ( ++p == pe )
+		goto _test_eof47;
+case 47:
+	if ( (*p) == 93 )
+		goto st48;
+	goto st0;
+st48:
+	if ( ++p == pe )
+		goto _test_eof48;
+case 48:
+	switch( (*p) ) {
+		case 13: goto tr30;
+		case 32: goto tr31;
+	}
+	goto st0;
+st49:
+	if ( ++p == pe )
+		goto _test_eof49;
+case 49:
+	if ( (*p) == 46 )
+		goto st44;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st50;
+	goto st0;
+st50:
+	if ( ++p == pe )
+		goto _test_eof50;
+case 50:
+	if ( (*p) == 46 )
+		goto st44;
+	goto st0;
+st51:
+	if ( ++p == pe )
+		goto _test_eof51;
+case 51:
+	if ( (*p) == 46 )
+		goto st42;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st52;
+	goto st0;
+st52:
+	if ( ++p == pe )
+		goto _test_eof52;
+case 52:
+	if ( (*p) == 46 )
+		goto st42;
+	goto st0;
+st53:
+	if ( ++p == pe )
+		goto _test_eof53;
+case 53:
+	if ( (*p) == 46 )
+		goto st40;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st54;
+	goto st0;
+st54:
+	if ( ++p == pe )
+		goto _test_eof54;
+case 54:
+	if ( (*p) == 46 )
+		goto st40;
+	goto st0;
+st55:
+	if ( ++p == pe )
+		goto _test_eof55;
+case 55:
+	if ( (*p) == 80 )
+		goto st56;
+	goto st0;
+st56:
+	if ( ++p == pe )
+		goto _test_eof56;
+case 56:
+	if ( (*p) == 118 )
+		goto st57;
+	goto st0;
+st57:
+	if ( ++p == pe )
+		goto _test_eof57;
+case 57:
+	if ( (*p) == 54 )
+		goto st58;
+	goto st0;
+st58:
+	if ( ++p == pe )
+		goto _test_eof58;
+case 58:
+	if ( (*p) == 58 )
+		goto st59;
+	goto st0;
+st59:
+	if ( ++p == pe )
+		goto _test_eof59;
+case 59:
+	if ( (*p) == 58 )
+		goto st162;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st60;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st60;
+	} else
+		goto st60;
+	goto st0;
+st60:
+	if ( ++p == pe )
+		goto _test_eof60;
+case 60:
+	if ( (*p) == 58 )
+		goto st64;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st61;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st61;
+	} else
+		goto st61;
+	goto st0;
+st61:
+	if ( ++p == pe )
+		goto _test_eof61;
+case 61:
+	if ( (*p) == 58 )
+		goto st64;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st62;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st62;
+	} else
+		goto st62;
+	goto st0;
+st62:
+	if ( ++p == pe )
+		goto _test_eof62;
+case 62:
+	if ( (*p) == 58 )
+		goto st64;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st63;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st63;
+	} else
+		goto st63;
+	goto st0;
+st63:
+	if ( ++p == pe )
+		goto _test_eof63;
+case 63:
+	if ( (*p) == 58 )
+		goto st64;
+	goto st0;
+st64:
+	if ( ++p == pe )
+		goto _test_eof64;
+case 64:
+	if ( (*p) == 58 )
+		goto st126;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st65;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st65;
+	} else
+		goto st65;
+	goto st0;
+st65:
+	if ( ++p == pe )
+		goto _test_eof65;
+case 65:
+	if ( (*p) == 58 )
+		goto st69;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st66;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st66;
+	} else
+		goto st66;
+	goto st0;
+st66:
+	if ( ++p == pe )
+		goto _test_eof66;
+case 66:
+	if ( (*p) == 58 )
+		goto st69;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st67;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st67;
+	} else
+		goto st67;
+	goto st0;
+st67:
+	if ( ++p == pe )
+		goto _test_eof67;
+case 67:
+	if ( (*p) == 58 )
+		goto st69;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st68;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st68;
+	} else
+		goto st68;
+	goto st0;
+st68:
+	if ( ++p == pe )
+		goto _test_eof68;
+case 68:
+	if ( (*p) == 58 )
+		goto st69;
+	goto st0;
+st69:
+	if ( ++p == pe )
+		goto _test_eof69;
+case 69:
+	if ( (*p) == 58 )
+		goto st126;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st70;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st70;
+	} else
+		goto st70;
+	goto st0;
+st70:
+	if ( ++p == pe )
+		goto _test_eof70;
+case 70:
+	if ( (*p) == 58 )
+		goto st74;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st71;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st71;
+	} else
+		goto st71;
+	goto st0;
+st71:
+	if ( ++p == pe )
+		goto _test_eof71;
+case 71:
+	if ( (*p) == 58 )
+		goto st74;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st72;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st72;
+	} else
+		goto st72;
+	goto st0;
+st72:
+	if ( ++p == pe )
+		goto _test_eof72;
+case 72:
+	if ( (*p) == 58 )
+		goto st74;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st73;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st73;
+	} else
+		goto st73;
+	goto st0;
+st73:
+	if ( ++p == pe )
+		goto _test_eof73;
+case 73:
+	if ( (*p) == 58 )
+		goto st74;
+	goto st0;
+st74:
+	if ( ++p == pe )
+		goto _test_eof74;
+case 74:
+	if ( (*p) == 58 )
+		goto st126;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st75;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st75;
+	} else
+		goto st75;
+	goto st0;
+st75:
+	if ( ++p == pe )
+		goto _test_eof75;
+case 75:
+	if ( (*p) == 58 )
+		goto st79;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st76;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st76;
+	} else
+		goto st76;
+	goto st0;
+st76:
+	if ( ++p == pe )
+		goto _test_eof76;
+case 76:
+	if ( (*p) == 58 )
+		goto st79;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st77;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st77;
+	} else
+		goto st77;
+	goto st0;
+st77:
+	if ( ++p == pe )
+		goto _test_eof77;
+case 77:
+	if ( (*p) == 58 )
+		goto st79;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st78;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st78;
+	} else
+		goto st78;
+	goto st0;
+st78:
+	if ( ++p == pe )
+		goto _test_eof78;
+case 78:
+	if ( (*p) == 58 )
+		goto st79;
+	goto st0;
+st79:
+	if ( ++p == pe )
+		goto _test_eof79;
+case 79:
+	if ( (*p) == 58 )
+		goto st126;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st80;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st80;
+	} else
+		goto st80;
+	goto st0;
+st80:
+	if ( ++p == pe )
+		goto _test_eof80;
+case 80:
+	if ( (*p) == 58 )
+		goto st84;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st81;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st81;
+	} else
+		goto st81;
+	goto st0;
+st81:
+	if ( ++p == pe )
+		goto _test_eof81;
+case 81:
+	if ( (*p) == 58 )
+		goto st84;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st82;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st82;
+	} else
+		goto st82;
+	goto st0;
+st82:
+	if ( ++p == pe )
+		goto _test_eof82;
+case 82:
+	if ( (*p) == 58 )
+		goto st84;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st83;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st83;
+	} else
+		goto st83;
+	goto st0;
+st83:
+	if ( ++p == pe )
+		goto _test_eof83;
+case 83:
+	if ( (*p) == 58 )
+		goto st84;
+	goto st0;
+st84:
+	if ( ++p == pe )
+		goto _test_eof84;
+case 84:
+	if ( (*p) == 58 )
+		goto st100;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st85;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st85;
+	} else
+		goto st85;
+	goto st0;
+st85:
+	if ( ++p == pe )
+		goto _test_eof85;
+case 85:
+	if ( (*p) == 58 )
+		goto st89;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st86;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st86;
+	} else
+		goto st86;
+	goto st0;
+st86:
+	if ( ++p == pe )
+		goto _test_eof86;
+case 86:
+	if ( (*p) == 58 )
+		goto st89;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st87;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st87;
+	} else
+		goto st87;
+	goto st0;
+st87:
+	if ( ++p == pe )
+		goto _test_eof87;
+case 87:
+	if ( (*p) == 58 )
+		goto st89;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st88;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st88;
+	} else
+		goto st88;
+	goto st0;
+st88:
+	if ( ++p == pe )
+		goto _test_eof88;
+case 88:
+	if ( (*p) == 58 )
+		goto st89;
+	goto st0;
+st89:
+	if ( ++p == pe )
+		goto _test_eof89;
+case 89:
+	if ( (*p) == 58 )
+		goto st100;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st90;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st125;
+	} else
+		goto st125;
+	goto st0;
+st90:
+	if ( ++p == pe )
+		goto _test_eof90;
+case 90:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st94;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st91;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st99;
+	} else
+		goto st99;
+	goto st0;
+st91:
+	if ( ++p == pe )
+		goto _test_eof91;
+case 91:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st94;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st92;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st98;
+	} else
+		goto st98;
+	goto st0;
+st92:
+	if ( ++p == pe )
+		goto _test_eof92;
+case 92:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st94;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st93;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st93;
+	} else
+		goto st93;
+	goto st0;
+st93:
+	if ( ++p == pe )
+		goto _test_eof93;
+case 93:
+	if ( (*p) == 58 )
+		goto st94;
+	goto st0;
+st94:
+	if ( ++p == pe )
+		goto _test_eof94;
+case 94:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st95;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st95;
+	} else
+		goto st95;
+	goto st0;
+st95:
+	if ( ++p == pe )
+		goto _test_eof95;
+case 95:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st96;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st96;
+	} else
+		goto st96;
+	goto st0;
+st96:
+	if ( ++p == pe )
+		goto _test_eof96;
+case 96:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st97;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st97;
+	} else
+		goto st97;
+	goto st0;
+st97:
+	if ( ++p == pe )
+		goto _test_eof97;
+case 97:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st47;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st47;
+	} else
+		goto st47;
+	goto st0;
+st98:
+	if ( ++p == pe )
+		goto _test_eof98;
+case 98:
+	if ( (*p) == 58 )
+		goto st94;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st93;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st93;
+	} else
+		goto st93;
+	goto st0;
+st99:
+	if ( ++p == pe )
+		goto _test_eof99;
+case 99:
+	if ( (*p) == 58 )
+		goto st94;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st98;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st98;
+	} else
+		goto st98;
+	goto st0;
+st100:
+	if ( ++p == pe )
+		goto _test_eof100;
+case 100:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st101;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st101;
+	} else
+		goto st101;
+	goto st0;
+st101:
+	if ( ++p == pe )
+		goto _test_eof101;
+case 101:
+	switch( (*p) ) {
+		case 58: goto st105;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st102;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st102;
+	} else
+		goto st102;
+	goto st0;
+st102:
+	if ( ++p == pe )
+		goto _test_eof102;
+case 102:
+	switch( (*p) ) {
+		case 58: goto st105;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st103;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st103;
+	} else
+		goto st103;
+	goto st0;
+st103:
+	if ( ++p == pe )
+		goto _test_eof103;
+case 103:
+	switch( (*p) ) {
+		case 58: goto st105;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st104;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st104;
+	} else
+		goto st104;
+	goto st0;
+st104:
+	if ( ++p == pe )
+		goto _test_eof104;
+case 104:
+	switch( (*p) ) {
+		case 58: goto st105;
+		case 93: goto st48;
+	}
+	goto st0;
+st105:
+	if ( ++p == pe )
+		goto _test_eof105;
+case 105:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st106;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st106;
+	} else
+		goto st106;
+	goto st0;
+st106:
+	if ( ++p == pe )
+		goto _test_eof106;
+case 106:
+	switch( (*p) ) {
+		case 58: goto st110;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st107;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st107;
+	} else
+		goto st107;
+	goto st0;
+st107:
+	if ( ++p == pe )
+		goto _test_eof107;
+case 107:
+	switch( (*p) ) {
+		case 58: goto st110;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st108;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st108;
+	} else
+		goto st108;
+	goto st0;
+st108:
+	if ( ++p == pe )
+		goto _test_eof108;
+case 108:
+	switch( (*p) ) {
+		case 58: goto st110;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st109;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st109;
+	} else
+		goto st109;
+	goto st0;
+st109:
+	if ( ++p == pe )
+		goto _test_eof109;
+case 109:
+	switch( (*p) ) {
+		case 58: goto st110;
+		case 93: goto st48;
+	}
+	goto st0;
+st110:
+	if ( ++p == pe )
+		goto _test_eof110;
+case 110:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st111;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st111;
+	} else
+		goto st111;
+	goto st0;
+st111:
+	if ( ++p == pe )
+		goto _test_eof111;
+case 111:
+	switch( (*p) ) {
+		case 58: goto st115;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st112;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st112;
+	} else
+		goto st112;
+	goto st0;
+st112:
+	if ( ++p == pe )
+		goto _test_eof112;
+case 112:
+	switch( (*p) ) {
+		case 58: goto st115;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st113;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st113;
+	} else
+		goto st113;
+	goto st0;
+st113:
+	if ( ++p == pe )
+		goto _test_eof113;
+case 113:
+	switch( (*p) ) {
+		case 58: goto st115;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st114;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st114;
+	} else
+		goto st114;
+	goto st0;
+st114:
+	if ( ++p == pe )
+		goto _test_eof114;
+case 114:
+	switch( (*p) ) {
+		case 58: goto st115;
+		case 93: goto st48;
+	}
+	goto st0;
+st115:
+	if ( ++p == pe )
+		goto _test_eof115;
+case 115:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st116;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st116;
+	} else
+		goto st116;
+	goto st0;
+st116:
+	if ( ++p == pe )
+		goto _test_eof116;
+case 116:
+	switch( (*p) ) {
+		case 58: goto st120;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st117;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st117;
+	} else
+		goto st117;
+	goto st0;
+st117:
+	if ( ++p == pe )
+		goto _test_eof117;
+case 117:
+	switch( (*p) ) {
+		case 58: goto st120;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st118;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st118;
+	} else
+		goto st118;
+	goto st0;
+st118:
+	if ( ++p == pe )
+		goto _test_eof118;
+case 118:
+	switch( (*p) ) {
+		case 58: goto st120;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st119;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st119;
+	} else
+		goto st119;
+	goto st0;
+st119:
+	if ( ++p == pe )
+		goto _test_eof119;
+case 119:
+	switch( (*p) ) {
+		case 58: goto st120;
+		case 93: goto st48;
+	}
+	goto st0;
+st120:
+	if ( ++p == pe )
+		goto _test_eof120;
+case 120:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st121;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st121;
+	} else
+		goto st121;
+	goto st0;
+st121:
+	if ( ++p == pe )
+		goto _test_eof121;
+case 121:
+	switch( (*p) ) {
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st122;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st122;
+	} else
+		goto st122;
+	goto st0;
+st122:
+	if ( ++p == pe )
+		goto _test_eof122;
+case 122:
+	switch( (*p) ) {
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st123;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st123;
+	} else
+		goto st123;
+	goto st0;
+st123:
+	if ( ++p == pe )
+		goto _test_eof123;
+case 123:
+	switch( (*p) ) {
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st124;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st124;
+	} else
+		goto st124;
+	goto st0;
+st124:
+	if ( ++p == pe )
+		goto _test_eof124;
+case 124:
+	switch( (*p) ) {
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	goto st0;
+st125:
+	if ( ++p == pe )
+		goto _test_eof125;
+case 125:
+	if ( (*p) == 58 )
+		goto st94;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st99;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st99;
+	} else
+		goto st99;
+	goto st0;
+st126:
+	if ( ++p == pe )
+		goto _test_eof126;
+case 126:
+	if ( (*p) == 93 )
+		goto st48;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st127;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st161;
+	} else
+		goto st161;
+	goto st0;
+st127:
+	if ( ++p == pe )
+		goto _test_eof127;
+case 127:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st128;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st160;
+	} else
+		goto st160;
+	goto st0;
+st128:
+	if ( ++p == pe )
+		goto _test_eof128;
+case 128:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st129;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st159;
+	} else
+		goto st159;
+	goto st0;
+st129:
+	if ( ++p == pe )
+		goto _test_eof129;
+case 129:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st130;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st130;
+	} else
+		goto st130;
+	goto st0;
+st130:
+	if ( ++p == pe )
+		goto _test_eof130;
+case 130:
+	switch( (*p) ) {
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	goto st0;
+st131:
+	if ( ++p == pe )
+		goto _test_eof131;
+case 131:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st132;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st158;
+	} else
+		goto st158;
+	goto st0;
+st132:
+	if ( ++p == pe )
+		goto _test_eof132;
+case 132:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st133;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st157;
+	} else
+		goto st157;
+	goto st0;
+st133:
+	if ( ++p == pe )
+		goto _test_eof133;
+case 133:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st134;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st156;
+	} else
+		goto st156;
+	goto st0;
+st134:
+	if ( ++p == pe )
+		goto _test_eof134;
+case 134:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st135;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st135;
+	} else
+		goto st135;
+	goto st0;
+st135:
+	if ( ++p == pe )
+		goto _test_eof135;
+case 135:
+	switch( (*p) ) {
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	goto st0;
+st136:
+	if ( ++p == pe )
+		goto _test_eof136;
+case 136:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st137;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st155;
+	} else
+		goto st155;
+	goto st0;
+st137:
+	if ( ++p == pe )
+		goto _test_eof137;
+case 137:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st138;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st154;
+	} else
+		goto st154;
+	goto st0;
+st138:
+	if ( ++p == pe )
+		goto _test_eof138;
+case 138:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st139;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st153;
+	} else
+		goto st153;
+	goto st0;
+st139:
+	if ( ++p == pe )
+		goto _test_eof139;
+case 139:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st140;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st140;
+	} else
+		goto st140;
+	goto st0;
+st140:
+	if ( ++p == pe )
+		goto _test_eof140;
+case 140:
+	switch( (*p) ) {
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	goto st0;
+st141:
+	if ( ++p == pe )
+		goto _test_eof141;
+case 141:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st142;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st152;
+	} else
+		goto st152;
+	goto st0;
+st142:
+	if ( ++p == pe )
+		goto _test_eof142;
+case 142:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st143;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st151;
+	} else
+		goto st151;
+	goto st0;
+st143:
+	if ( ++p == pe )
+		goto _test_eof143;
+case 143:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st144;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st150;
+	} else
+		goto st150;
+	goto st0;
+st144:
+	if ( ++p == pe )
+		goto _test_eof144;
+case 144:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st145;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st145;
+	} else
+		goto st145;
+	goto st0;
+st145:
+	if ( ++p == pe )
+		goto _test_eof145;
+case 145:
+	switch( (*p) ) {
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	goto st0;
+st146:
+	if ( ++p == pe )
+		goto _test_eof146;
+case 146:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st147;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st121;
+	} else
+		goto st121;
+	goto st0;
+st147:
+	if ( ++p == pe )
+		goto _test_eof147;
+case 147:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st148;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st122;
+	} else
+		goto st122;
+	goto st0;
+st148:
+	if ( ++p == pe )
+		goto _test_eof148;
+case 148:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st149;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st123;
+	} else
+		goto st123;
+	goto st0;
+st149:
+	if ( ++p == pe )
+		goto _test_eof149;
+case 149:
+	switch( (*p) ) {
+		case 46: goto st40;
+		case 58: goto st94;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st124;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st124;
+	} else
+		goto st124;
+	goto st0;
+st150:
+	if ( ++p == pe )
+		goto _test_eof150;
+case 150:
+	switch( (*p) ) {
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st145;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st145;
+	} else
+		goto st145;
+	goto st0;
+st151:
+	if ( ++p == pe )
+		goto _test_eof151;
+case 151:
+	switch( (*p) ) {
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st150;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st150;
+	} else
+		goto st150;
+	goto st0;
+st152:
+	if ( ++p == pe )
+		goto _test_eof152;
+case 152:
+	switch( (*p) ) {
+		case 58: goto st146;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st151;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st151;
+	} else
+		goto st151;
+	goto st0;
+st153:
+	if ( ++p == pe )
+		goto _test_eof153;
+case 153:
+	switch( (*p) ) {
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st140;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st140;
+	} else
+		goto st140;
+	goto st0;
+st154:
+	if ( ++p == pe )
+		goto _test_eof154;
+case 154:
+	switch( (*p) ) {
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st153;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st153;
+	} else
+		goto st153;
+	goto st0;
+st155:
+	if ( ++p == pe )
+		goto _test_eof155;
+case 155:
+	switch( (*p) ) {
+		case 58: goto st141;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st154;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st154;
+	} else
+		goto st154;
+	goto st0;
+st156:
+	if ( ++p == pe )
+		goto _test_eof156;
+case 156:
+	switch( (*p) ) {
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st135;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st135;
+	} else
+		goto st135;
+	goto st0;
+st157:
+	if ( ++p == pe )
+		goto _test_eof157;
+case 157:
+	switch( (*p) ) {
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st156;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st156;
+	} else
+		goto st156;
+	goto st0;
+st158:
+	if ( ++p == pe )
+		goto _test_eof158;
+case 158:
+	switch( (*p) ) {
+		case 58: goto st136;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st157;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st157;
+	} else
+		goto st157;
+	goto st0;
+st159:
+	if ( ++p == pe )
+		goto _test_eof159;
+case 159:
+	switch( (*p) ) {
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st130;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st130;
+	} else
+		goto st130;
+	goto st0;
+st160:
+	if ( ++p == pe )
+		goto _test_eof160;
+case 160:
+	switch( (*p) ) {
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st159;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st159;
+	} else
+		goto st159;
+	goto st0;
+st161:
+	if ( ++p == pe )
+		goto _test_eof161;
+case 161:
+	switch( (*p) ) {
+		case 58: goto st131;
+		case 93: goto st48;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st160;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st160;
+	} else
+		goto st160;
+	goto st0;
+st162:
+	if ( ++p == pe )
+		goto _test_eof162;
+case 162:
+	if ( (*p) == 58 )
+		goto st126;
+	goto st0;
+tr25:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st163;
+st163:
+	if ( ++p == pe )
+		goto _test_eof163;
+case 163:
+#line 2405 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr181;
+		case 32: goto tr182;
+		case 45: goto st166;
+		case 46: goto st170;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st163;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st167;
+	} else
+		goto st167;
+	goto st0;
+tr182:
+#line 33 "smtp_response_parser.rl"
+	{
+    if(parser->reply_code != NULL)
+      parser->reply_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st164;
+st164:
+	if ( ++p == pe )
+		goto _test_eof164;
+case 164:
+#line 2438 "smtp_response_parser.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr187;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr187;
+	} else
+		goto tr187;
+	goto st0;
+tr187:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st165;
+st165:
+	if ( ++p == pe )
+		goto _test_eof165;
+case 165:
+#line 2456 "smtp_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr189;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st165;
+	} else if ( (*p) >= 0 )
+		goto st165;
+	goto st0;
+st166:
+	if ( ++p == pe )
+		goto _test_eof166;
+case 166:
+	if ( (*p) == 45 )
+		goto st166;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st167;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st167;
+	} else
+		goto st167;
+	goto st0;
+tr26:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st167;
+st167:
+	if ( ++p == pe )
+		goto _test_eof167;
+case 167:
+#line 2488 "smtp_response_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr190;
+		case 32: goto tr191;
+		case 45: goto st166;
+		case 46: goto st170;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st167;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st167;
+	} else
+		goto st167;
+	goto st0;
+tr191:
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st168;
+st168:
+	if ( ++p == pe )
+		goto _test_eof168;
+case 168:
+#line 2516 "smtp_response_parser.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr192;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr192;
+	} else
+		goto tr192;
+	goto st0;
+tr192:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st169;
+st169:
+	if ( ++p == pe )
+		goto _test_eof169;
+case 169:
+#line 2534 "smtp_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr194;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st169;
+	} else if ( (*p) >= 0 )
+		goto st169;
+	goto st0;
+st170:
+	if ( ++p == pe )
+		goto _test_eof170;
+case 170:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st171;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st171;
+	} else
+		goto st171;
+	goto st0;
+st171:
+	if ( ++p == pe )
+		goto _test_eof171;
+case 171:
+	switch( (*p) ) {
+		case 13: goto tr190;
+		case 32: goto tr191;
+		case 45: goto st172;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st171;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st171;
+	} else
+		goto st171;
+	goto st0;
+st172:
+	if ( ++p == pe )
+		goto _test_eof172;
+case 172:
+	if ( (*p) == 45 )
+		goto st172;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st171;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st171;
+	} else
+		goto st171;
+	goto st0;
+tr27:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st173;
+st173:
+	if ( ++p == pe )
+		goto _test_eof173;
+case 173:
+#line 2597 "smtp_response_parser.c"
+	if ( (*p) == 73 )
+		goto st190;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st174;
+	goto st0;
+st174:
+	if ( ++p == pe )
+		goto _test_eof174;
+case 174:
+	if ( (*p) == 46 )
+		goto st175;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st188;
+	goto st0;
+st175:
+	if ( ++p == pe )
+		goto _test_eof175;
+case 175:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st176;
+	goto st0;
+st176:
+	if ( ++p == pe )
+		goto _test_eof176;
+case 176:
+	if ( (*p) == 46 )
+		goto st177;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st186;
+	goto st0;
+st177:
+	if ( ++p == pe )
+		goto _test_eof177;
+case 177:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st178;
+	goto st0;
+st178:
+	if ( ++p == pe )
+		goto _test_eof178;
+case 178:
+	if ( (*p) == 46 )
+		goto st179;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st184;
+	goto st0;
+st179:
+	if ( ++p == pe )
+		goto _test_eof179;
+case 179:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st180;
+	goto st0;
+st180:
+	if ( ++p == pe )
+		goto _test_eof180;
+case 180:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st181;
+	goto st0;
+st181:
+	if ( ++p == pe )
+		goto _test_eof181;
+case 181:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st182;
+	goto st0;
+st182:
+	if ( ++p == pe )
+		goto _test_eof182;
+case 182:
+	if ( (*p) == 93 )
+		goto st183;
+	goto st0;
+st183:
+	if ( ++p == pe )
+		goto _test_eof183;
+case 183:
+	switch( (*p) ) {
+		case 13: goto tr190;
+		case 32: goto tr191;
+	}
+	goto st0;
+st184:
+	if ( ++p == pe )
+		goto _test_eof184;
+case 184:
+	if ( (*p) == 46 )
+		goto st179;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st185;
+	goto st0;
+st185:
+	if ( ++p == pe )
+		goto _test_eof185;
+case 185:
+	if ( (*p) == 46 )
+		goto st179;
+	goto st0;
+st186:
+	if ( ++p == pe )
+		goto _test_eof186;
+case 186:
+	if ( (*p) == 46 )
+		goto st177;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st187;
+	goto st0;
+st187:
+	if ( ++p == pe )
+		goto _test_eof187;
+case 187:
+	if ( (*p) == 46 )
+		goto st177;
+	goto st0;
+st188:
+	if ( ++p == pe )
+		goto _test_eof188;
+case 188:
+	if ( (*p) == 46 )
+		goto st175;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st189;
+	goto st0;
+st189:
+	if ( ++p == pe )
+		goto _test_eof189;
+case 189:
+	if ( (*p) == 46 )
+		goto st175;
+	goto st0;
+st190:
+	if ( ++p == pe )
+		goto _test_eof190;
+case 190:
+	if ( (*p) == 80 )
+		goto st191;
+	goto st0;
+st191:
+	if ( ++p == pe )
+		goto _test_eof191;
+case 191:
+	if ( (*p) == 118 )
+		goto st192;
+	goto st0;
+st192:
+	if ( ++p == pe )
+		goto _test_eof192;
+case 192:
+	if ( (*p) == 54 )
+		goto st193;
+	goto st0;
+st193:
+	if ( ++p == pe )
+		goto _test_eof193;
+case 193:
+	if ( (*p) == 58 )
+		goto st194;
+	goto st0;
+st194:
+	if ( ++p == pe )
+		goto _test_eof194;
+case 194:
+	if ( (*p) == 58 )
+		goto st297;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st195;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st195;
+	} else
+		goto st195;
+	goto st0;
+st195:
+	if ( ++p == pe )
+		goto _test_eof195;
+case 195:
+	if ( (*p) == 58 )
+		goto st199;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st196;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st196;
+	} else
+		goto st196;
+	goto st0;
+st196:
+	if ( ++p == pe )
+		goto _test_eof196;
+case 196:
+	if ( (*p) == 58 )
+		goto st199;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st197;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st197;
+	} else
+		goto st197;
+	goto st0;
+st197:
+	if ( ++p == pe )
+		goto _test_eof197;
+case 197:
+	if ( (*p) == 58 )
+		goto st199;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st198;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st198;
+	} else
+		goto st198;
+	goto st0;
+st198:
+	if ( ++p == pe )
+		goto _test_eof198;
+case 198:
+	if ( (*p) == 58 )
+		goto st199;
+	goto st0;
+st199:
+	if ( ++p == pe )
+		goto _test_eof199;
+case 199:
+	if ( (*p) == 58 )
+		goto st261;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st200;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st200;
+	} else
+		goto st200;
+	goto st0;
+st200:
+	if ( ++p == pe )
+		goto _test_eof200;
+case 200:
+	if ( (*p) == 58 )
+		goto st204;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st201;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st201;
+	} else
+		goto st201;
+	goto st0;
+st201:
+	if ( ++p == pe )
+		goto _test_eof201;
+case 201:
+	if ( (*p) == 58 )
+		goto st204;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st202;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st202;
+	} else
+		goto st202;
+	goto st0;
+st202:
+	if ( ++p == pe )
+		goto _test_eof202;
+case 202:
+	if ( (*p) == 58 )
+		goto st204;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st203;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st203;
+	} else
+		goto st203;
+	goto st0;
+st203:
+	if ( ++p == pe )
+		goto _test_eof203;
+case 203:
+	if ( (*p) == 58 )
+		goto st204;
+	goto st0;
+st204:
+	if ( ++p == pe )
+		goto _test_eof204;
+case 204:
+	if ( (*p) == 58 )
+		goto st261;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st205;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st205;
+	} else
+		goto st205;
+	goto st0;
+st205:
+	if ( ++p == pe )
+		goto _test_eof205;
+case 205:
+	if ( (*p) == 58 )
+		goto st209;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st206;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st206;
+	} else
+		goto st206;
+	goto st0;
+st206:
+	if ( ++p == pe )
+		goto _test_eof206;
+case 206:
+	if ( (*p) == 58 )
+		goto st209;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st207;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st207;
+	} else
+		goto st207;
+	goto st0;
+st207:
+	if ( ++p == pe )
+		goto _test_eof207;
+case 207:
+	if ( (*p) == 58 )
+		goto st209;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st208;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st208;
+	} else
+		goto st208;
+	goto st0;
+st208:
+	if ( ++p == pe )
+		goto _test_eof208;
+case 208:
+	if ( (*p) == 58 )
+		goto st209;
+	goto st0;
+st209:
+	if ( ++p == pe )
+		goto _test_eof209;
+case 209:
+	if ( (*p) == 58 )
+		goto st261;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st210;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st210;
+	} else
+		goto st210;
+	goto st0;
+st210:
+	if ( ++p == pe )
+		goto _test_eof210;
+case 210:
+	if ( (*p) == 58 )
+		goto st214;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st211;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st211;
+	} else
+		goto st211;
+	goto st0;
+st211:
+	if ( ++p == pe )
+		goto _test_eof211;
+case 211:
+	if ( (*p) == 58 )
+		goto st214;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st212;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st212;
+	} else
+		goto st212;
+	goto st0;
+st212:
+	if ( ++p == pe )
+		goto _test_eof212;
+case 212:
+	if ( (*p) == 58 )
+		goto st214;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st213;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st213;
+	} else
+		goto st213;
+	goto st0;
+st213:
+	if ( ++p == pe )
+		goto _test_eof213;
+case 213:
+	if ( (*p) == 58 )
+		goto st214;
+	goto st0;
+st214:
+	if ( ++p == pe )
+		goto _test_eof214;
+case 214:
+	if ( (*p) == 58 )
+		goto st261;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st215;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st215;
+	} else
+		goto st215;
+	goto st0;
+st215:
+	if ( ++p == pe )
+		goto _test_eof215;
+case 215:
+	if ( (*p) == 58 )
+		goto st219;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st216;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st216;
+	} else
+		goto st216;
+	goto st0;
+st216:
+	if ( ++p == pe )
+		goto _test_eof216;
+case 216:
+	if ( (*p) == 58 )
+		goto st219;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st217;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st217;
+	} else
+		goto st217;
+	goto st0;
+st217:
+	if ( ++p == pe )
+		goto _test_eof217;
+case 217:
+	if ( (*p) == 58 )
+		goto st219;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st218;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st218;
+	} else
+		goto st218;
+	goto st0;
+st218:
+	if ( ++p == pe )
+		goto _test_eof218;
+case 218:
+	if ( (*p) == 58 )
+		goto st219;
+	goto st0;
+st219:
+	if ( ++p == pe )
+		goto _test_eof219;
+case 219:
+	if ( (*p) == 58 )
+		goto st235;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st220;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st220;
+	} else
+		goto st220;
+	goto st0;
+st220:
+	if ( ++p == pe )
+		goto _test_eof220;
+case 220:
+	if ( (*p) == 58 )
+		goto st224;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st221;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st221;
+	} else
+		goto st221;
+	goto st0;
+st221:
+	if ( ++p == pe )
+		goto _test_eof221;
+case 221:
+	if ( (*p) == 58 )
+		goto st224;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st222;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st222;
+	} else
+		goto st222;
+	goto st0;
+st222:
+	if ( ++p == pe )
+		goto _test_eof222;
+case 222:
+	if ( (*p) == 58 )
+		goto st224;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st223;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st223;
+	} else
+		goto st223;
+	goto st0;
+st223:
+	if ( ++p == pe )
+		goto _test_eof223;
+case 223:
+	if ( (*p) == 58 )
+		goto st224;
+	goto st0;
+st224:
+	if ( ++p == pe )
+		goto _test_eof224;
+case 224:
+	if ( (*p) == 58 )
+		goto st235;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st225;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st260;
+	} else
+		goto st260;
+	goto st0;
+st225:
+	if ( ++p == pe )
+		goto _test_eof225;
+case 225:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st229;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st226;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st234;
+	} else
+		goto st234;
+	goto st0;
+st226:
+	if ( ++p == pe )
+		goto _test_eof226;
+case 226:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st229;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st227;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st233;
+	} else
+		goto st233;
+	goto st0;
+st227:
+	if ( ++p == pe )
+		goto _test_eof227;
+case 227:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st229;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st228;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st228;
+	} else
+		goto st228;
+	goto st0;
+st228:
+	if ( ++p == pe )
+		goto _test_eof228;
+case 228:
+	if ( (*p) == 58 )
+		goto st229;
+	goto st0;
+st229:
+	if ( ++p == pe )
+		goto _test_eof229;
+case 229:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st230;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st230;
+	} else
+		goto st230;
+	goto st0;
+st230:
+	if ( ++p == pe )
+		goto _test_eof230;
+case 230:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st231;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st231;
+	} else
+		goto st231;
+	goto st0;
+st231:
+	if ( ++p == pe )
+		goto _test_eof231;
+case 231:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st232;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st232;
+	} else
+		goto st232;
+	goto st0;
+st232:
+	if ( ++p == pe )
+		goto _test_eof232;
+case 232:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st182;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st182;
+	} else
+		goto st182;
+	goto st0;
+st233:
+	if ( ++p == pe )
+		goto _test_eof233;
+case 233:
+	if ( (*p) == 58 )
+		goto st229;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st228;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st228;
+	} else
+		goto st228;
+	goto st0;
+st234:
+	if ( ++p == pe )
+		goto _test_eof234;
+case 234:
+	if ( (*p) == 58 )
+		goto st229;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st233;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st233;
+	} else
+		goto st233;
+	goto st0;
+st235:
+	if ( ++p == pe )
+		goto _test_eof235;
+case 235:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st236;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st236;
+	} else
+		goto st236;
+	goto st0;
+st236:
+	if ( ++p == pe )
+		goto _test_eof236;
+case 236:
+	switch( (*p) ) {
+		case 58: goto st240;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st237;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st237;
+	} else
+		goto st237;
+	goto st0;
+st237:
+	if ( ++p == pe )
+		goto _test_eof237;
+case 237:
+	switch( (*p) ) {
+		case 58: goto st240;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st238;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st238;
+	} else
+		goto st238;
+	goto st0;
+st238:
+	if ( ++p == pe )
+		goto _test_eof238;
+case 238:
+	switch( (*p) ) {
+		case 58: goto st240;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st239;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st239;
+	} else
+		goto st239;
+	goto st0;
+st239:
+	if ( ++p == pe )
+		goto _test_eof239;
+case 239:
+	switch( (*p) ) {
+		case 58: goto st240;
+		case 93: goto st183;
+	}
+	goto st0;
+st240:
+	if ( ++p == pe )
+		goto _test_eof240;
+case 240:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st241;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st241;
+	} else
+		goto st241;
+	goto st0;
+st241:
+	if ( ++p == pe )
+		goto _test_eof241;
+case 241:
+	switch( (*p) ) {
+		case 58: goto st245;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st242;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st242;
+	} else
+		goto st242;
+	goto st0;
+st242:
+	if ( ++p == pe )
+		goto _test_eof242;
+case 242:
+	switch( (*p) ) {
+		case 58: goto st245;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st243;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st243;
+	} else
+		goto st243;
+	goto st0;
+st243:
+	if ( ++p == pe )
+		goto _test_eof243;
+case 243:
+	switch( (*p) ) {
+		case 58: goto st245;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st244;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st244;
+	} else
+		goto st244;
+	goto st0;
+st244:
+	if ( ++p == pe )
+		goto _test_eof244;
+case 244:
+	switch( (*p) ) {
+		case 58: goto st245;
+		case 93: goto st183;
+	}
+	goto st0;
+st245:
+	if ( ++p == pe )
+		goto _test_eof245;
+case 245:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st246;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st246;
+	} else
+		goto st246;
+	goto st0;
+st246:
+	if ( ++p == pe )
+		goto _test_eof246;
+case 246:
+	switch( (*p) ) {
+		case 58: goto st250;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st247;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st247;
+	} else
+		goto st247;
+	goto st0;
+st247:
+	if ( ++p == pe )
+		goto _test_eof247;
+case 247:
+	switch( (*p) ) {
+		case 58: goto st250;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st248;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st248;
+	} else
+		goto st248;
+	goto st0;
+st248:
+	if ( ++p == pe )
+		goto _test_eof248;
+case 248:
+	switch( (*p) ) {
+		case 58: goto st250;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st249;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st249;
+	} else
+		goto st249;
+	goto st0;
+st249:
+	if ( ++p == pe )
+		goto _test_eof249;
+case 249:
+	switch( (*p) ) {
+		case 58: goto st250;
+		case 93: goto st183;
+	}
+	goto st0;
+st250:
+	if ( ++p == pe )
+		goto _test_eof250;
+case 250:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st251;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st251;
+	} else
+		goto st251;
+	goto st0;
+st251:
+	if ( ++p == pe )
+		goto _test_eof251;
+case 251:
+	switch( (*p) ) {
+		case 58: goto st255;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st252;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st252;
+	} else
+		goto st252;
+	goto st0;
+st252:
+	if ( ++p == pe )
+		goto _test_eof252;
+case 252:
+	switch( (*p) ) {
+		case 58: goto st255;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st253;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st253;
+	} else
+		goto st253;
+	goto st0;
+st253:
+	if ( ++p == pe )
+		goto _test_eof253;
+case 253:
+	switch( (*p) ) {
+		case 58: goto st255;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st254;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st254;
+	} else
+		goto st254;
+	goto st0;
+st254:
+	if ( ++p == pe )
+		goto _test_eof254;
+case 254:
+	switch( (*p) ) {
+		case 58: goto st255;
+		case 93: goto st183;
+	}
+	goto st0;
+st255:
+	if ( ++p == pe )
+		goto _test_eof255;
+case 255:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st256;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st256;
+	} else
+		goto st256;
+	goto st0;
+st256:
+	if ( ++p == pe )
+		goto _test_eof256;
+case 256:
+	switch( (*p) ) {
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st257;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st257;
+	} else
+		goto st257;
+	goto st0;
+st257:
+	if ( ++p == pe )
+		goto _test_eof257;
+case 257:
+	switch( (*p) ) {
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st258;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st258;
+	} else
+		goto st258;
+	goto st0;
+st258:
+	if ( ++p == pe )
+		goto _test_eof258;
+case 258:
+	switch( (*p) ) {
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st259;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st259;
+	} else
+		goto st259;
+	goto st0;
+st259:
+	if ( ++p == pe )
+		goto _test_eof259;
+case 259:
+	switch( (*p) ) {
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	goto st0;
+st260:
+	if ( ++p == pe )
+		goto _test_eof260;
+case 260:
+	if ( (*p) == 58 )
+		goto st229;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st234;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st234;
+	} else
+		goto st234;
+	goto st0;
+st261:
+	if ( ++p == pe )
+		goto _test_eof261;
+case 261:
+	if ( (*p) == 93 )
+		goto st183;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st262;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st296;
+	} else
+		goto st296;
+	goto st0;
+st262:
+	if ( ++p == pe )
+		goto _test_eof262;
+case 262:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st263;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st295;
+	} else
+		goto st295;
+	goto st0;
+st263:
+	if ( ++p == pe )
+		goto _test_eof263;
+case 263:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st264;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st294;
+	} else
+		goto st294;
+	goto st0;
+st264:
+	if ( ++p == pe )
+		goto _test_eof264;
+case 264:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st265;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st265;
+	} else
+		goto st265;
+	goto st0;
+st265:
+	if ( ++p == pe )
+		goto _test_eof265;
+case 265:
+	switch( (*p) ) {
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	goto st0;
+st266:
+	if ( ++p == pe )
+		goto _test_eof266;
+case 266:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st267;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st293;
+	} else
+		goto st293;
+	goto st0;
+st267:
+	if ( ++p == pe )
+		goto _test_eof267;
+case 267:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st268;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st292;
+	} else
+		goto st292;
+	goto st0;
+st268:
+	if ( ++p == pe )
+		goto _test_eof268;
+case 268:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st269;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st291;
+	} else
+		goto st291;
+	goto st0;
+st269:
+	if ( ++p == pe )
+		goto _test_eof269;
+case 269:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st270;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st270;
+	} else
+		goto st270;
+	goto st0;
+st270:
+	if ( ++p == pe )
+		goto _test_eof270;
+case 270:
+	switch( (*p) ) {
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	goto st0;
+st271:
+	if ( ++p == pe )
+		goto _test_eof271;
+case 271:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st272;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st290;
+	} else
+		goto st290;
+	goto st0;
+st272:
+	if ( ++p == pe )
+		goto _test_eof272;
+case 272:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st273;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st289;
+	} else
+		goto st289;
+	goto st0;
+st273:
+	if ( ++p == pe )
+		goto _test_eof273;
+case 273:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st274;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st288;
+	} else
+		goto st288;
+	goto st0;
+st274:
+	if ( ++p == pe )
+		goto _test_eof274;
+case 274:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st275;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st275;
+	} else
+		goto st275;
+	goto st0;
+st275:
+	if ( ++p == pe )
+		goto _test_eof275;
+case 275:
+	switch( (*p) ) {
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	goto st0;
+st276:
+	if ( ++p == pe )
+		goto _test_eof276;
+case 276:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st277;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st287;
+	} else
+		goto st287;
+	goto st0;
+st277:
+	if ( ++p == pe )
+		goto _test_eof277;
+case 277:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st278;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st286;
+	} else
+		goto st286;
+	goto st0;
+st278:
+	if ( ++p == pe )
+		goto _test_eof278;
+case 278:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st279;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st285;
+	} else
+		goto st285;
+	goto st0;
+st279:
+	if ( ++p == pe )
+		goto _test_eof279;
+case 279:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st280;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st280;
+	} else
+		goto st280;
+	goto st0;
+st280:
+	if ( ++p == pe )
+		goto _test_eof280;
+case 280:
+	switch( (*p) ) {
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	goto st0;
+st281:
+	if ( ++p == pe )
+		goto _test_eof281;
+case 281:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st282;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st256;
+	} else
+		goto st256;
+	goto st0;
+st282:
+	if ( ++p == pe )
+		goto _test_eof282;
+case 282:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st283;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st257;
+	} else
+		goto st257;
+	goto st0;
+st283:
+	if ( ++p == pe )
+		goto _test_eof283;
+case 283:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st284;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st258;
+	} else
+		goto st258;
+	goto st0;
+st284:
+	if ( ++p == pe )
+		goto _test_eof284;
+case 284:
+	switch( (*p) ) {
+		case 46: goto st175;
+		case 58: goto st229;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st259;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st259;
+	} else
+		goto st259;
+	goto st0;
+st285:
+	if ( ++p == pe )
+		goto _test_eof285;
+case 285:
+	switch( (*p) ) {
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st280;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st280;
+	} else
+		goto st280;
+	goto st0;
+st286:
+	if ( ++p == pe )
+		goto _test_eof286;
+case 286:
+	switch( (*p) ) {
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st285;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st285;
+	} else
+		goto st285;
+	goto st0;
+st287:
+	if ( ++p == pe )
+		goto _test_eof287;
+case 287:
+	switch( (*p) ) {
+		case 58: goto st281;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st286;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st286;
+	} else
+		goto st286;
+	goto st0;
+st288:
+	if ( ++p == pe )
+		goto _test_eof288;
+case 288:
+	switch( (*p) ) {
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st275;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st275;
+	} else
+		goto st275;
+	goto st0;
+st289:
+	if ( ++p == pe )
+		goto _test_eof289;
+case 289:
+	switch( (*p) ) {
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st288;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st288;
+	} else
+		goto st288;
+	goto st0;
+st290:
+	if ( ++p == pe )
+		goto _test_eof290;
+case 290:
+	switch( (*p) ) {
+		case 58: goto st276;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st289;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st289;
+	} else
+		goto st289;
+	goto st0;
+st291:
+	if ( ++p == pe )
+		goto _test_eof291;
+case 291:
+	switch( (*p) ) {
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st270;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st270;
+	} else
+		goto st270;
+	goto st0;
+st292:
+	if ( ++p == pe )
+		goto _test_eof292;
+case 292:
+	switch( (*p) ) {
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st291;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st291;
+	} else
+		goto st291;
+	goto st0;
+st293:
+	if ( ++p == pe )
+		goto _test_eof293;
+case 293:
+	switch( (*p) ) {
+		case 58: goto st271;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st292;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st292;
+	} else
+		goto st292;
+	goto st0;
+st294:
+	if ( ++p == pe )
+		goto _test_eof294;
+case 294:
+	switch( (*p) ) {
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st265;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st265;
+	} else
+		goto st265;
+	goto st0;
+st295:
+	if ( ++p == pe )
+		goto _test_eof295;
+case 295:
+	switch( (*p) ) {
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st294;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st294;
+	} else
+		goto st294;
+	goto st0;
+st296:
+	if ( ++p == pe )
+		goto _test_eof296;
+case 296:
+	switch( (*p) ) {
+		case 58: goto st266;
+		case 93: goto st183;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st295;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st295;
+	} else
+		goto st295;
+	goto st0;
+st297:
+	if ( ++p == pe )
+		goto _test_eof297;
+case 297:
+	if ( (*p) == 58 )
+		goto st261;
+	goto st0;
+tr8:
+#line 22 "smtp_response_parser.rl"
+	{
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st298;
+st298:
+	if ( ++p == pe )
+		goto _test_eof298;
+case 298:
+#line 4302 "smtp_response_parser.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr321;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr321;
+	} else
+		goto tr321;
+	goto st0;
+tr321:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st299;
+st299:
+	if ( ++p == pe )
+		goto _test_eof299;
+case 299:
+#line 4320 "smtp_response_parser.c"
+	if ( (*p) == 13 )
+		goto tr323;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st299;
+	} else if ( (*p) >= 0 )
+		goto st299;
+	goto st0;
+st300:
+	if ( ++p == pe )
+		goto _test_eof300;
+case 300:
+	if ( (*p) == 45 )
+		goto st300;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st6;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st6;
+	} else
+		goto st6;
+	goto st0;
+st301:
+	if ( ++p == pe )
+		goto _test_eof301;
+case 301:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st302;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st302;
+	} else
+		goto st302;
+	goto st0;
+st302:
+	if ( ++p == pe )
+		goto _test_eof302;
+case 302:
+	switch( (*p) ) {
+		case 13: goto tr7;
+		case 32: goto tr8;
+		case 45: goto st303;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st302;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st302;
+	} else
+		goto st302;
+	goto st0;
+st303:
+	if ( ++p == pe )
+		goto _test_eof303;
+case 303:
+	if ( (*p) == 45 )
+		goto st303;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st302;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto st302;
+	} else
+		goto st302;
+	goto st0;
+tr6:
+#line 20 "smtp_response_parser.rl"
+	{MARK(mark, p);}
+	goto st304;
+st304:
+	if ( ++p == pe )
+		goto _test_eof304;
+case 304:
+#line 4398 "smtp_response_parser.c"
+	if ( (*p) == 73 )
+		goto st321;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st305;
+	goto st0;
+st305:
+	if ( ++p == pe )
+		goto _test_eof305;
+case 305:
+	if ( (*p) == 46 )
+		goto st306;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st319;
+	goto st0;
+st306:
+	if ( ++p == pe )
+		goto _test_eof306;
+case 306:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st307;
+	goto st0;
+st307:
+	if ( ++p == pe )
+		goto _test_eof307;
+case 307:
+	if ( (*p) == 46 )
+		goto st308;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st317;
+	goto st0;
+st308:
+	if ( ++p == pe )
+		goto _test_eof308;
+case 308:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st309;
+	goto st0;
+st309:
+	if ( ++p == pe )
+		goto _test_eof309;
+case 309:
+	if ( (*p) == 46 )
+		goto st310;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st315;
+	goto st0;
+st310:
+	if ( ++p == pe )
+		goto _test_eof310;
+case 310:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st311;
+	goto st0;
+st311:
+	if ( ++p == pe )
+		goto _test_eof311;
+case 311:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st312;
+	goto st0;
+st312:
+	if ( ++p == pe )
+		goto _test_eof312;
+case 312:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st313;
+	goto st0;
+st313:
+	if ( ++p == pe )
+		goto _test_eof313;
+case 313:
+	if ( (*p) == 93 )
+		goto st314;
+	goto st0;
+st314:
+	if ( ++p == pe )
+		goto _test_eof314;
+case 314:
+	switch( (*p) ) {
+		case 13: goto tr7;
+		case 32: goto tr8;
+	}
+	goto st0;
+st315:
+	if ( ++p == pe )
+		goto _test_eof315;
+case 315:
+	if ( (*p) == 46 )
+		goto st310;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st316;
+	goto st0;
+st316:
+	if ( ++p == pe )
+		goto _test_eof316;
+case 316:
+	if ( (*p) == 46 )
+		goto st310;
+	goto st0;
+st317:
+	if ( ++p == pe )
+		goto _test_eof317;
+case 317:
+	if ( (*p) == 46 )
+		goto st308;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st318;
+	goto st0;
+st318:
+	if ( ++p == pe )
+		goto _test_eof318;
+case 318:
+	if ( (*p) == 46 )
+		goto st308;
+	goto st0;
+st319:
+	if ( ++p == pe )
+		goto _test_eof319;
+case 319:
+	if ( (*p) == 46 )
+		goto st306;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st320;
+	goto st0;
+st320:
+	if ( ++p == pe )
+		goto _test_eof320;
+case 320:
+	if ( (*p) == 46 )
+		goto st306;
+	goto st0;
+st321:
+	if ( ++p == pe )
+		goto _test_eof321;
+case 321:
+	if ( (*p) == 80 )
+		goto st322;
+	goto st0;
+st322:
+	if ( ++p == pe )
+		goto _test_eof322;
+case 322:
+	if ( (*p) == 118 )
+		goto st323;
+	goto st0;
+st323:
+	if ( ++p == pe )
+		goto _test_eof323;
+case 323:
+	if ( (*p) == 54 )
+		goto st324;
+	goto st0;
+st324:
+	if ( ++p == pe )
+		goto _test_eof324;
+case 324:
+	if ( (*p) == 58 )
+		goto st325;
+	goto st0;
+st325:
+	if ( ++p == pe )
+		goto _test_eof325;
+case 325:
+	if ( (*p) == 58 )
+		goto st428;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st326;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st326;
+	} else
+		goto st326;
+	goto st0;
+st326:
+	if ( ++p == pe )
+		goto _test_eof326;
+case 326:
+	if ( (*p) == 58 )
+		goto st330;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st327;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st327;
+	} else
+		goto st327;
+	goto st0;
+st327:
+	if ( ++p == pe )
+		goto _test_eof327;
+case 327:
+	if ( (*p) == 58 )
+		goto st330;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st328;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st328;
+	} else
+		goto st328;
+	goto st0;
+st328:
+	if ( ++p == pe )
+		goto _test_eof328;
+case 328:
+	if ( (*p) == 58 )
+		goto st330;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st329;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st329;
+	} else
+		goto st329;
+	goto st0;
+st329:
+	if ( ++p == pe )
+		goto _test_eof329;
+case 329:
+	if ( (*p) == 58 )
+		goto st330;
+	goto st0;
+st330:
+	if ( ++p == pe )
+		goto _test_eof330;
+case 330:
+	if ( (*p) == 58 )
+		goto st392;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st331;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st331;
+	} else
+		goto st331;
+	goto st0;
+st331:
+	if ( ++p == pe )
+		goto _test_eof331;
+case 331:
+	if ( (*p) == 58 )
+		goto st335;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st332;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st332;
+	} else
+		goto st332;
+	goto st0;
+st332:
+	if ( ++p == pe )
+		goto _test_eof332;
+case 332:
+	if ( (*p) == 58 )
+		goto st335;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st333;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st333;
+	} else
+		goto st333;
+	goto st0;
+st333:
+	if ( ++p == pe )
+		goto _test_eof333;
+case 333:
+	if ( (*p) == 58 )
+		goto st335;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st334;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st334;
+	} else
+		goto st334;
+	goto st0;
+st334:
+	if ( ++p == pe )
+		goto _test_eof334;
+case 334:
+	if ( (*p) == 58 )
+		goto st335;
+	goto st0;
+st335:
+	if ( ++p == pe )
+		goto _test_eof335;
+case 335:
+	if ( (*p) == 58 )
+		goto st392;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st336;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st336;
+	} else
+		goto st336;
+	goto st0;
+st336:
+	if ( ++p == pe )
+		goto _test_eof336;
+case 336:
+	if ( (*p) == 58 )
+		goto st340;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st337;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st337;
+	} else
+		goto st337;
+	goto st0;
+st337:
+	if ( ++p == pe )
+		goto _test_eof337;
+case 337:
+	if ( (*p) == 58 )
+		goto st340;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st338;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st338;
+	} else
+		goto st338;
+	goto st0;
+st338:
+	if ( ++p == pe )
+		goto _test_eof338;
+case 338:
+	if ( (*p) == 58 )
+		goto st340;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st339;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st339;
+	} else
+		goto st339;
+	goto st0;
+st339:
+	if ( ++p == pe )
+		goto _test_eof339;
+case 339:
+	if ( (*p) == 58 )
+		goto st340;
+	goto st0;
+st340:
+	if ( ++p == pe )
+		goto _test_eof340;
+case 340:
+	if ( (*p) == 58 )
+		goto st392;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st341;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st341;
+	} else
+		goto st341;
+	goto st0;
+st341:
+	if ( ++p == pe )
+		goto _test_eof341;
+case 341:
+	if ( (*p) == 58 )
+		goto st345;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st342;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st342;
+	} else
+		goto st342;
+	goto st0;
+st342:
+	if ( ++p == pe )
+		goto _test_eof342;
+case 342:
+	if ( (*p) == 58 )
+		goto st345;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st343;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st343;
+	} else
+		goto st343;
+	goto st0;
+st343:
+	if ( ++p == pe )
+		goto _test_eof343;
+case 343:
+	if ( (*p) == 58 )
+		goto st345;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st344;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st344;
+	} else
+		goto st344;
+	goto st0;
+st344:
+	if ( ++p == pe )
+		goto _test_eof344;
+case 344:
+	if ( (*p) == 58 )
+		goto st345;
+	goto st0;
+st345:
+	if ( ++p == pe )
+		goto _test_eof345;
+case 345:
+	if ( (*p) == 58 )
+		goto st392;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st346;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st346;
+	} else
+		goto st346;
+	goto st0;
+st346:
+	if ( ++p == pe )
+		goto _test_eof346;
+case 346:
+	if ( (*p) == 58 )
+		goto st350;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st347;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st347;
+	} else
+		goto st347;
+	goto st0;
+st347:
+	if ( ++p == pe )
+		goto _test_eof347;
+case 347:
+	if ( (*p) == 58 )
+		goto st350;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st348;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st348;
+	} else
+		goto st348;
+	goto st0;
+st348:
+	if ( ++p == pe )
+		goto _test_eof348;
+case 348:
+	if ( (*p) == 58 )
+		goto st350;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st349;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st349;
+	} else
+		goto st349;
+	goto st0;
+st349:
+	if ( ++p == pe )
+		goto _test_eof349;
+case 349:
+	if ( (*p) == 58 )
+		goto st350;
+	goto st0;
+st350:
+	if ( ++p == pe )
+		goto _test_eof350;
+case 350:
+	if ( (*p) == 58 )
+		goto st366;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st351;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st351;
+	} else
+		goto st351;
+	goto st0;
+st351:
+	if ( ++p == pe )
+		goto _test_eof351;
+case 351:
+	if ( (*p) == 58 )
+		goto st355;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st352;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st352;
+	} else
+		goto st352;
+	goto st0;
+st352:
+	if ( ++p == pe )
+		goto _test_eof352;
+case 352:
+	if ( (*p) == 58 )
+		goto st355;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st353;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st353;
+	} else
+		goto st353;
+	goto st0;
+st353:
+	if ( ++p == pe )
+		goto _test_eof353;
+case 353:
+	if ( (*p) == 58 )
+		goto st355;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st354;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st354;
+	} else
+		goto st354;
+	goto st0;
+st354:
+	if ( ++p == pe )
+		goto _test_eof354;
+case 354:
+	if ( (*p) == 58 )
+		goto st355;
+	goto st0;
+st355:
+	if ( ++p == pe )
+		goto _test_eof355;
+case 355:
+	if ( (*p) == 58 )
+		goto st366;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st356;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st391;
+	} else
+		goto st391;
+	goto st0;
+st356:
+	if ( ++p == pe )
+		goto _test_eof356;
+case 356:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st360;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st357;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st365;
+	} else
+		goto st365;
+	goto st0;
+st357:
+	if ( ++p == pe )
+		goto _test_eof357;
+case 357:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st360;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st358;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st364;
+	} else
+		goto st364;
+	goto st0;
+st358:
+	if ( ++p == pe )
+		goto _test_eof358;
+case 358:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st360;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st359;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st359;
+	} else
+		goto st359;
+	goto st0;
+st359:
+	if ( ++p == pe )
+		goto _test_eof359;
+case 359:
+	if ( (*p) == 58 )
+		goto st360;
+	goto st0;
+st360:
+	if ( ++p == pe )
+		goto _test_eof360;
+case 360:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st361;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st361;
+	} else
+		goto st361;
+	goto st0;
+st361:
+	if ( ++p == pe )
+		goto _test_eof361;
+case 361:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st362;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st362;
+	} else
+		goto st362;
+	goto st0;
+st362:
+	if ( ++p == pe )
+		goto _test_eof362;
+case 362:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st363;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st363;
+	} else
+		goto st363;
+	goto st0;
+st363:
+	if ( ++p == pe )
+		goto _test_eof363;
+case 363:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st313;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st313;
+	} else
+		goto st313;
+	goto st0;
+st364:
+	if ( ++p == pe )
+		goto _test_eof364;
+case 364:
+	if ( (*p) == 58 )
+		goto st360;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st359;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st359;
+	} else
+		goto st359;
+	goto st0;
+st365:
+	if ( ++p == pe )
+		goto _test_eof365;
+case 365:
+	if ( (*p) == 58 )
+		goto st360;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st364;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st364;
+	} else
+		goto st364;
+	goto st0;
+st366:
+	if ( ++p == pe )
+		goto _test_eof366;
+case 366:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st367;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st367;
+	} else
+		goto st367;
+	goto st0;
+st367:
+	if ( ++p == pe )
+		goto _test_eof367;
+case 367:
+	switch( (*p) ) {
+		case 58: goto st371;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st368;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st368;
+	} else
+		goto st368;
+	goto st0;
+st368:
+	if ( ++p == pe )
+		goto _test_eof368;
+case 368:
+	switch( (*p) ) {
+		case 58: goto st371;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st369;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st369;
+	} else
+		goto st369;
+	goto st0;
+st369:
+	if ( ++p == pe )
+		goto _test_eof369;
+case 369:
+	switch( (*p) ) {
+		case 58: goto st371;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st370;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st370;
+	} else
+		goto st370;
+	goto st0;
+st370:
+	if ( ++p == pe )
+		goto _test_eof370;
+case 370:
+	switch( (*p) ) {
+		case 58: goto st371;
+		case 93: goto st314;
+	}
+	goto st0;
+st371:
+	if ( ++p == pe )
+		goto _test_eof371;
+case 371:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st372;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st372;
+	} else
+		goto st372;
+	goto st0;
+st372:
+	if ( ++p == pe )
+		goto _test_eof372;
+case 372:
+	switch( (*p) ) {
+		case 58: goto st376;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st373;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st373;
+	} else
+		goto st373;
+	goto st0;
+st373:
+	if ( ++p == pe )
+		goto _test_eof373;
+case 373:
+	switch( (*p) ) {
+		case 58: goto st376;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st374;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st374;
+	} else
+		goto st374;
+	goto st0;
+st374:
+	if ( ++p == pe )
+		goto _test_eof374;
+case 374:
+	switch( (*p) ) {
+		case 58: goto st376;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st375;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st375;
+	} else
+		goto st375;
+	goto st0;
+st375:
+	if ( ++p == pe )
+		goto _test_eof375;
+case 375:
+	switch( (*p) ) {
+		case 58: goto st376;
+		case 93: goto st314;
+	}
+	goto st0;
+st376:
+	if ( ++p == pe )
+		goto _test_eof376;
+case 376:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st377;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st377;
+	} else
+		goto st377;
+	goto st0;
+st377:
+	if ( ++p == pe )
+		goto _test_eof377;
+case 377:
+	switch( (*p) ) {
+		case 58: goto st381;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st378;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st378;
+	} else
+		goto st378;
+	goto st0;
+st378:
+	if ( ++p == pe )
+		goto _test_eof378;
+case 378:
+	switch( (*p) ) {
+		case 58: goto st381;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st379;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st379;
+	} else
+		goto st379;
+	goto st0;
+st379:
+	if ( ++p == pe )
+		goto _test_eof379;
+case 379:
+	switch( (*p) ) {
+		case 58: goto st381;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st380;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st380;
+	} else
+		goto st380;
+	goto st0;
+st380:
+	if ( ++p == pe )
+		goto _test_eof380;
+case 380:
+	switch( (*p) ) {
+		case 58: goto st381;
+		case 93: goto st314;
+	}
+	goto st0;
+st381:
+	if ( ++p == pe )
+		goto _test_eof381;
+case 381:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st382;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st382;
+	} else
+		goto st382;
+	goto st0;
+st382:
+	if ( ++p == pe )
+		goto _test_eof382;
+case 382:
+	switch( (*p) ) {
+		case 58: goto st386;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st383;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st383;
+	} else
+		goto st383;
+	goto st0;
+st383:
+	if ( ++p == pe )
+		goto _test_eof383;
+case 383:
+	switch( (*p) ) {
+		case 58: goto st386;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st384;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st384;
+	} else
+		goto st384;
+	goto st0;
+st384:
+	if ( ++p == pe )
+		goto _test_eof384;
+case 384:
+	switch( (*p) ) {
+		case 58: goto st386;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st385;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st385;
+	} else
+		goto st385;
+	goto st0;
+st385:
+	if ( ++p == pe )
+		goto _test_eof385;
+case 385:
+	switch( (*p) ) {
+		case 58: goto st386;
+		case 93: goto st314;
+	}
+	goto st0;
+st386:
+	if ( ++p == pe )
+		goto _test_eof386;
+case 386:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st387;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st387;
+	} else
+		goto st387;
+	goto st0;
+st387:
+	if ( ++p == pe )
+		goto _test_eof387;
+case 387:
+	switch( (*p) ) {
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st388;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st388;
+	} else
+		goto st388;
+	goto st0;
+st388:
+	if ( ++p == pe )
+		goto _test_eof388;
+case 388:
+	switch( (*p) ) {
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st389;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st389;
+	} else
+		goto st389;
+	goto st0;
+st389:
+	if ( ++p == pe )
+		goto _test_eof389;
+case 389:
+	switch( (*p) ) {
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st390;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st390;
+	} else
+		goto st390;
+	goto st0;
+st390:
+	if ( ++p == pe )
+		goto _test_eof390;
+case 390:
+	switch( (*p) ) {
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	goto st0;
+st391:
+	if ( ++p == pe )
+		goto _test_eof391;
+case 391:
+	if ( (*p) == 58 )
+		goto st360;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st365;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st365;
+	} else
+		goto st365;
+	goto st0;
+st392:
+	if ( ++p == pe )
+		goto _test_eof392;
+case 392:
+	if ( (*p) == 93 )
+		goto st314;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st393;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st427;
+	} else
+		goto st427;
+	goto st0;
+st393:
+	if ( ++p == pe )
+		goto _test_eof393;
+case 393:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st394;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st426;
+	} else
+		goto st426;
+	goto st0;
+st394:
+	if ( ++p == pe )
+		goto _test_eof394;
+case 394:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st395;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st425;
+	} else
+		goto st425;
+	goto st0;
+st395:
+	if ( ++p == pe )
+		goto _test_eof395;
+case 395:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st396;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st396;
+	} else
+		goto st396;
+	goto st0;
+st396:
+	if ( ++p == pe )
+		goto _test_eof396;
+case 396:
+	switch( (*p) ) {
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	goto st0;
+st397:
+	if ( ++p == pe )
+		goto _test_eof397;
+case 397:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st398;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st424;
+	} else
+		goto st424;
+	goto st0;
+st398:
+	if ( ++p == pe )
+		goto _test_eof398;
+case 398:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st399;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st423;
+	} else
+		goto st423;
+	goto st0;
+st399:
+	if ( ++p == pe )
+		goto _test_eof399;
+case 399:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st400;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st422;
+	} else
+		goto st422;
+	goto st0;
+st400:
+	if ( ++p == pe )
+		goto _test_eof400;
+case 400:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st401;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st401;
+	} else
+		goto st401;
+	goto st0;
+st401:
+	if ( ++p == pe )
+		goto _test_eof401;
+case 401:
+	switch( (*p) ) {
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	goto st0;
+st402:
+	if ( ++p == pe )
+		goto _test_eof402;
+case 402:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st403;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st421;
+	} else
+		goto st421;
+	goto st0;
+st403:
+	if ( ++p == pe )
+		goto _test_eof403;
+case 403:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st404;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st420;
+	} else
+		goto st420;
+	goto st0;
+st404:
+	if ( ++p == pe )
+		goto _test_eof404;
+case 404:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st405;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st419;
+	} else
+		goto st419;
+	goto st0;
+st405:
+	if ( ++p == pe )
+		goto _test_eof405;
+case 405:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st406;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st406;
+	} else
+		goto st406;
+	goto st0;
+st406:
+	if ( ++p == pe )
+		goto _test_eof406;
+case 406:
+	switch( (*p) ) {
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	goto st0;
+st407:
+	if ( ++p == pe )
+		goto _test_eof407;
+case 407:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st408;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st418;
+	} else
+		goto st418;
+	goto st0;
+st408:
+	if ( ++p == pe )
+		goto _test_eof408;
+case 408:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st409;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st417;
+	} else
+		goto st417;
+	goto st0;
+st409:
+	if ( ++p == pe )
+		goto _test_eof409;
+case 409:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st410;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st416;
+	} else
+		goto st416;
+	goto st0;
+st410:
+	if ( ++p == pe )
+		goto _test_eof410;
+case 410:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st411;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st411;
+	} else
+		goto st411;
+	goto st0;
+st411:
+	if ( ++p == pe )
+		goto _test_eof411;
+case 411:
+	switch( (*p) ) {
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	goto st0;
+st412:
+	if ( ++p == pe )
+		goto _test_eof412;
+case 412:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st413;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st387;
+	} else
+		goto st387;
+	goto st0;
+st413:
+	if ( ++p == pe )
+		goto _test_eof413;
+case 413:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st414;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st388;
+	} else
+		goto st388;
+	goto st0;
+st414:
+	if ( ++p == pe )
+		goto _test_eof414;
+case 414:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st415;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st389;
+	} else
+		goto st389;
+	goto st0;
+st415:
+	if ( ++p == pe )
+		goto _test_eof415;
+case 415:
+	switch( (*p) ) {
+		case 46: goto st306;
+		case 58: goto st360;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st390;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st390;
+	} else
+		goto st390;
+	goto st0;
+st416:
+	if ( ++p == pe )
+		goto _test_eof416;
+case 416:
+	switch( (*p) ) {
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st411;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st411;
+	} else
+		goto st411;
+	goto st0;
+st417:
+	if ( ++p == pe )
+		goto _test_eof417;
+case 417:
+	switch( (*p) ) {
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st416;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st416;
+	} else
+		goto st416;
+	goto st0;
+st418:
+	if ( ++p == pe )
+		goto _test_eof418;
+case 418:
+	switch( (*p) ) {
+		case 58: goto st412;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st417;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st417;
+	} else
+		goto st417;
+	goto st0;
+st419:
+	if ( ++p == pe )
+		goto _test_eof419;
+case 419:
+	switch( (*p) ) {
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st406;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st406;
+	} else
+		goto st406;
+	goto st0;
+st420:
+	if ( ++p == pe )
+		goto _test_eof420;
+case 420:
+	switch( (*p) ) {
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st419;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st419;
+	} else
+		goto st419;
+	goto st0;
+st421:
+	if ( ++p == pe )
+		goto _test_eof421;
+case 421:
+	switch( (*p) ) {
+		case 58: goto st407;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st420;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st420;
+	} else
+		goto st420;
+	goto st0;
+st422:
+	if ( ++p == pe )
+		goto _test_eof422;
+case 422:
+	switch( (*p) ) {
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st401;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st401;
+	} else
+		goto st401;
+	goto st0;
+st423:
+	if ( ++p == pe )
+		goto _test_eof423;
+case 423:
+	switch( (*p) ) {
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st422;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st422;
+	} else
+		goto st422;
+	goto st0;
+st424:
+	if ( ++p == pe )
+		goto _test_eof424;
+case 424:
+	switch( (*p) ) {
+		case 58: goto st402;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st423;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st423;
+	} else
+		goto st423;
+	goto st0;
+st425:
+	if ( ++p == pe )
+		goto _test_eof425;
+case 425:
+	switch( (*p) ) {
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st396;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st396;
+	} else
+		goto st396;
+	goto st0;
+st426:
+	if ( ++p == pe )
+		goto _test_eof426;
+case 426:
+	switch( (*p) ) {
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st425;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st425;
+	} else
+		goto st425;
+	goto st0;
+st427:
+	if ( ++p == pe )
+		goto _test_eof427;
+case 427:
+	switch( (*p) ) {
+		case 58: goto st397;
+		case 93: goto st314;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st426;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st426;
+	} else
+		goto st426;
+	goto st0;
+st428:
+	if ( ++p == pe )
+		goto _test_eof428;
+case 428:
+	if ( (*p) == 58 )
+		goto st392;
+	goto st0;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof429: cs = 429; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof21: cs = 21; goto _test_eof; 
+	_test_eof22: cs = 22; goto _test_eof; 
+	_test_eof23: cs = 23; goto _test_eof; 
+	_test_eof24: cs = 24; goto _test_eof; 
+	_test_eof25: cs = 25; goto _test_eof; 
+	_test_eof26: cs = 26; goto _test_eof; 
+	_test_eof27: cs = 27; goto _test_eof; 
+	_test_eof28: cs = 28; goto _test_eof; 
+	_test_eof29: cs = 29; goto _test_eof; 
+	_test_eof30: cs = 30; goto _test_eof; 
+	_test_eof31: cs = 31; goto _test_eof; 
+	_test_eof32: cs = 32; goto _test_eof; 
+	_test_eof33: cs = 33; goto _test_eof; 
+	_test_eof34: cs = 34; goto _test_eof; 
+	_test_eof35: cs = 35; goto _test_eof; 
+	_test_eof36: cs = 36; goto _test_eof; 
+	_test_eof37: cs = 37; goto _test_eof; 
+	_test_eof38: cs = 38; goto _test_eof; 
+	_test_eof39: cs = 39; goto _test_eof; 
+	_test_eof40: cs = 40; goto _test_eof; 
+	_test_eof41: cs = 41; goto _test_eof; 
+	_test_eof42: cs = 42; goto _test_eof; 
+	_test_eof43: cs = 43; goto _test_eof; 
+	_test_eof44: cs = 44; goto _test_eof; 
+	_test_eof45: cs = 45; goto _test_eof; 
+	_test_eof46: cs = 46; goto _test_eof; 
+	_test_eof47: cs = 47; goto _test_eof; 
+	_test_eof48: cs = 48; goto _test_eof; 
+	_test_eof49: cs = 49; goto _test_eof; 
+	_test_eof50: cs = 50; goto _test_eof; 
+	_test_eof51: cs = 51; goto _test_eof; 
+	_test_eof52: cs = 52; goto _test_eof; 
+	_test_eof53: cs = 53; goto _test_eof; 
+	_test_eof54: cs = 54; goto _test_eof; 
+	_test_eof55: cs = 55; goto _test_eof; 
+	_test_eof56: cs = 56; goto _test_eof; 
+	_test_eof57: cs = 57; goto _test_eof; 
+	_test_eof58: cs = 58; goto _test_eof; 
+	_test_eof59: cs = 59; goto _test_eof; 
+	_test_eof60: cs = 60; goto _test_eof; 
+	_test_eof61: cs = 61; goto _test_eof; 
+	_test_eof62: cs = 62; goto _test_eof; 
+	_test_eof63: cs = 63; goto _test_eof; 
+	_test_eof64: cs = 64; goto _test_eof; 
+	_test_eof65: cs = 65; goto _test_eof; 
+	_test_eof66: cs = 66; goto _test_eof; 
+	_test_eof67: cs = 67; goto _test_eof; 
+	_test_eof68: cs = 68; goto _test_eof; 
+	_test_eof69: cs = 69; goto _test_eof; 
+	_test_eof70: cs = 70; goto _test_eof; 
+	_test_eof71: cs = 71; goto _test_eof; 
+	_test_eof72: cs = 72; goto _test_eof; 
+	_test_eof73: cs = 73; goto _test_eof; 
+	_test_eof74: cs = 74; goto _test_eof; 
+	_test_eof75: cs = 75; goto _test_eof; 
+	_test_eof76: cs = 76; goto _test_eof; 
+	_test_eof77: cs = 77; goto _test_eof; 
+	_test_eof78: cs = 78; goto _test_eof; 
+	_test_eof79: cs = 79; goto _test_eof; 
+	_test_eof80: cs = 80; goto _test_eof; 
+	_test_eof81: cs = 81; goto _test_eof; 
+	_test_eof82: cs = 82; goto _test_eof; 
+	_test_eof83: cs = 83; goto _test_eof; 
+	_test_eof84: cs = 84; goto _test_eof; 
+	_test_eof85: cs = 85; goto _test_eof; 
+	_test_eof86: cs = 86; goto _test_eof; 
+	_test_eof87: cs = 87; goto _test_eof; 
+	_test_eof88: cs = 88; goto _test_eof; 
+	_test_eof89: cs = 89; goto _test_eof; 
+	_test_eof90: cs = 90; goto _test_eof; 
+	_test_eof91: cs = 91; goto _test_eof; 
+	_test_eof92: cs = 92; goto _test_eof; 
+	_test_eof93: cs = 93; goto _test_eof; 
+	_test_eof94: cs = 94; goto _test_eof; 
+	_test_eof95: cs = 95; goto _test_eof; 
+	_test_eof96: cs = 96; goto _test_eof; 
+	_test_eof97: cs = 97; goto _test_eof; 
+	_test_eof98: cs = 98; goto _test_eof; 
+	_test_eof99: cs = 99; goto _test_eof; 
+	_test_eof100: cs = 100; goto _test_eof; 
+	_test_eof101: cs = 101; goto _test_eof; 
+	_test_eof102: cs = 102; goto _test_eof; 
+	_test_eof103: cs = 103; goto _test_eof; 
+	_test_eof104: cs = 104; goto _test_eof; 
+	_test_eof105: cs = 105; goto _test_eof; 
+	_test_eof106: cs = 106; goto _test_eof; 
+	_test_eof107: cs = 107; goto _test_eof; 
+	_test_eof108: cs = 108; goto _test_eof; 
+	_test_eof109: cs = 109; goto _test_eof; 
+	_test_eof110: cs = 110; goto _test_eof; 
+	_test_eof111: cs = 111; goto _test_eof; 
+	_test_eof112: cs = 112; goto _test_eof; 
+	_test_eof113: cs = 113; goto _test_eof; 
+	_test_eof114: cs = 114; goto _test_eof; 
+	_test_eof115: cs = 115; goto _test_eof; 
+	_test_eof116: cs = 116; goto _test_eof; 
+	_test_eof117: cs = 117; goto _test_eof; 
+	_test_eof118: cs = 118; goto _test_eof; 
+	_test_eof119: cs = 119; goto _test_eof; 
+	_test_eof120: cs = 120; goto _test_eof; 
+	_test_eof121: cs = 121; goto _test_eof; 
+	_test_eof122: cs = 122; goto _test_eof; 
+	_test_eof123: cs = 123; goto _test_eof; 
+	_test_eof124: cs = 124; goto _test_eof; 
+	_test_eof125: cs = 125; goto _test_eof; 
+	_test_eof126: cs = 126; goto _test_eof; 
+	_test_eof127: cs = 127; goto _test_eof; 
+	_test_eof128: cs = 128; goto _test_eof; 
+	_test_eof129: cs = 129; goto _test_eof; 
+	_test_eof130: cs = 130; goto _test_eof; 
+	_test_eof131: cs = 131; goto _test_eof; 
+	_test_eof132: cs = 132; goto _test_eof; 
+	_test_eof133: cs = 133; goto _test_eof; 
+	_test_eof134: cs = 134; goto _test_eof; 
+	_test_eof135: cs = 135; goto _test_eof; 
+	_test_eof136: cs = 136; goto _test_eof; 
+	_test_eof137: cs = 137; goto _test_eof; 
+	_test_eof138: cs = 138; goto _test_eof; 
+	_test_eof139: cs = 139; goto _test_eof; 
+	_test_eof140: cs = 140; goto _test_eof; 
+	_test_eof141: cs = 141; goto _test_eof; 
+	_test_eof142: cs = 142; goto _test_eof; 
+	_test_eof143: cs = 143; goto _test_eof; 
+	_test_eof144: cs = 144; goto _test_eof; 
+	_test_eof145: cs = 145; goto _test_eof; 
+	_test_eof146: cs = 146; goto _test_eof; 
+	_test_eof147: cs = 147; goto _test_eof; 
+	_test_eof148: cs = 148; goto _test_eof; 
+	_test_eof149: cs = 149; goto _test_eof; 
+	_test_eof150: cs = 150; goto _test_eof; 
+	_test_eof151: cs = 151; goto _test_eof; 
+	_test_eof152: cs = 152; goto _test_eof; 
+	_test_eof153: cs = 153; goto _test_eof; 
+	_test_eof154: cs = 154; goto _test_eof; 
+	_test_eof155: cs = 155; goto _test_eof; 
+	_test_eof156: cs = 156; goto _test_eof; 
+	_test_eof157: cs = 157; goto _test_eof; 
+	_test_eof158: cs = 158; goto _test_eof; 
+	_test_eof159: cs = 159; goto _test_eof; 
+	_test_eof160: cs = 160; goto _test_eof; 
+	_test_eof161: cs = 161; goto _test_eof; 
+	_test_eof162: cs = 162; goto _test_eof; 
+	_test_eof163: cs = 163; goto _test_eof; 
+	_test_eof164: cs = 164; goto _test_eof; 
+	_test_eof165: cs = 165; goto _test_eof; 
+	_test_eof166: cs = 166; goto _test_eof; 
+	_test_eof167: cs = 167; goto _test_eof; 
+	_test_eof168: cs = 168; goto _test_eof; 
+	_test_eof169: cs = 169; goto _test_eof; 
+	_test_eof170: cs = 170; goto _test_eof; 
+	_test_eof171: cs = 171; goto _test_eof; 
+	_test_eof172: cs = 172; goto _test_eof; 
+	_test_eof173: cs = 173; goto _test_eof; 
+	_test_eof174: cs = 174; goto _test_eof; 
+	_test_eof175: cs = 175; goto _test_eof; 
+	_test_eof176: cs = 176; goto _test_eof; 
+	_test_eof177: cs = 177; goto _test_eof; 
+	_test_eof178: cs = 178; goto _test_eof; 
+	_test_eof179: cs = 179; goto _test_eof; 
+	_test_eof180: cs = 180; goto _test_eof; 
+	_test_eof181: cs = 181; goto _test_eof; 
+	_test_eof182: cs = 182; goto _test_eof; 
+	_test_eof183: cs = 183; goto _test_eof; 
+	_test_eof184: cs = 184; goto _test_eof; 
+	_test_eof185: cs = 185; goto _test_eof; 
+	_test_eof186: cs = 186; goto _test_eof; 
+	_test_eof187: cs = 187; goto _test_eof; 
+	_test_eof188: cs = 188; goto _test_eof; 
+	_test_eof189: cs = 189; goto _test_eof; 
+	_test_eof190: cs = 190; goto _test_eof; 
+	_test_eof191: cs = 191; goto _test_eof; 
+	_test_eof192: cs = 192; goto _test_eof; 
+	_test_eof193: cs = 193; goto _test_eof; 
+	_test_eof194: cs = 194; goto _test_eof; 
+	_test_eof195: cs = 195; goto _test_eof; 
+	_test_eof196: cs = 196; goto _test_eof; 
+	_test_eof197: cs = 197; goto _test_eof; 
+	_test_eof198: cs = 198; goto _test_eof; 
+	_test_eof199: cs = 199; goto _test_eof; 
+	_test_eof200: cs = 200; goto _test_eof; 
+	_test_eof201: cs = 201; goto _test_eof; 
+	_test_eof202: cs = 202; goto _test_eof; 
+	_test_eof203: cs = 203; goto _test_eof; 
+	_test_eof204: cs = 204; goto _test_eof; 
+	_test_eof205: cs = 205; goto _test_eof; 
+	_test_eof206: cs = 206; goto _test_eof; 
+	_test_eof207: cs = 207; goto _test_eof; 
+	_test_eof208: cs = 208; goto _test_eof; 
+	_test_eof209: cs = 209; goto _test_eof; 
+	_test_eof210: cs = 210; goto _test_eof; 
+	_test_eof211: cs = 211; goto _test_eof; 
+	_test_eof212: cs = 212; goto _test_eof; 
+	_test_eof213: cs = 213; goto _test_eof; 
+	_test_eof214: cs = 214; goto _test_eof; 
+	_test_eof215: cs = 215; goto _test_eof; 
+	_test_eof216: cs = 216; goto _test_eof; 
+	_test_eof217: cs = 217; goto _test_eof; 
+	_test_eof218: cs = 218; goto _test_eof; 
+	_test_eof219: cs = 219; goto _test_eof; 
+	_test_eof220: cs = 220; goto _test_eof; 
+	_test_eof221: cs = 221; goto _test_eof; 
+	_test_eof222: cs = 222; goto _test_eof; 
+	_test_eof223: cs = 223; goto _test_eof; 
+	_test_eof224: cs = 224; goto _test_eof; 
+	_test_eof225: cs = 225; goto _test_eof; 
+	_test_eof226: cs = 226; goto _test_eof; 
+	_test_eof227: cs = 227; goto _test_eof; 
+	_test_eof228: cs = 228; goto _test_eof; 
+	_test_eof229: cs = 229; goto _test_eof; 
+	_test_eof230: cs = 230; goto _test_eof; 
+	_test_eof231: cs = 231; goto _test_eof; 
+	_test_eof232: cs = 232; goto _test_eof; 
+	_test_eof233: cs = 233; goto _test_eof; 
+	_test_eof234: cs = 234; goto _test_eof; 
+	_test_eof235: cs = 235; goto _test_eof; 
+	_test_eof236: cs = 236; goto _test_eof; 
+	_test_eof237: cs = 237; goto _test_eof; 
+	_test_eof238: cs = 238; goto _test_eof; 
+	_test_eof239: cs = 239; goto _test_eof; 
+	_test_eof240: cs = 240; goto _test_eof; 
+	_test_eof241: cs = 241; goto _test_eof; 
+	_test_eof242: cs = 242; goto _test_eof; 
+	_test_eof243: cs = 243; goto _test_eof; 
+	_test_eof244: cs = 244; goto _test_eof; 
+	_test_eof245: cs = 245; goto _test_eof; 
+	_test_eof246: cs = 246; goto _test_eof; 
+	_test_eof247: cs = 247; goto _test_eof; 
+	_test_eof248: cs = 248; goto _test_eof; 
+	_test_eof249: cs = 249; goto _test_eof; 
+	_test_eof250: cs = 250; goto _test_eof; 
+	_test_eof251: cs = 251; goto _test_eof; 
+	_test_eof252: cs = 252; goto _test_eof; 
+	_test_eof253: cs = 253; goto _test_eof; 
+	_test_eof254: cs = 254; goto _test_eof; 
+	_test_eof255: cs = 255; goto _test_eof; 
+	_test_eof256: cs = 256; goto _test_eof; 
+	_test_eof257: cs = 257; goto _test_eof; 
+	_test_eof258: cs = 258; goto _test_eof; 
+	_test_eof259: cs = 259; goto _test_eof; 
+	_test_eof260: cs = 260; goto _test_eof; 
+	_test_eof261: cs = 261; goto _test_eof; 
+	_test_eof262: cs = 262; goto _test_eof; 
+	_test_eof263: cs = 263; goto _test_eof; 
+	_test_eof264: cs = 264; goto _test_eof; 
+	_test_eof265: cs = 265; goto _test_eof; 
+	_test_eof266: cs = 266; goto _test_eof; 
+	_test_eof267: cs = 267; goto _test_eof; 
+	_test_eof268: cs = 268; goto _test_eof; 
+	_test_eof269: cs = 269; goto _test_eof; 
+	_test_eof270: cs = 270; goto _test_eof; 
+	_test_eof271: cs = 271; goto _test_eof; 
+	_test_eof272: cs = 272; goto _test_eof; 
+	_test_eof273: cs = 273; goto _test_eof; 
+	_test_eof274: cs = 274; goto _test_eof; 
+	_test_eof275: cs = 275; goto _test_eof; 
+	_test_eof276: cs = 276; goto _test_eof; 
+	_test_eof277: cs = 277; goto _test_eof; 
+	_test_eof278: cs = 278; goto _test_eof; 
+	_test_eof279: cs = 279; goto _test_eof; 
+	_test_eof280: cs = 280; goto _test_eof; 
+	_test_eof281: cs = 281; goto _test_eof; 
+	_test_eof282: cs = 282; goto _test_eof; 
+	_test_eof283: cs = 283; goto _test_eof; 
+	_test_eof284: cs = 284; goto _test_eof; 
+	_test_eof285: cs = 285; goto _test_eof; 
+	_test_eof286: cs = 286; goto _test_eof; 
+	_test_eof287: cs = 287; goto _test_eof; 
+	_test_eof288: cs = 288; goto _test_eof; 
+	_test_eof289: cs = 289; goto _test_eof; 
+	_test_eof290: cs = 290; goto _test_eof; 
+	_test_eof291: cs = 291; goto _test_eof; 
+	_test_eof292: cs = 292; goto _test_eof; 
+	_test_eof293: cs = 293; goto _test_eof; 
+	_test_eof294: cs = 294; goto _test_eof; 
+	_test_eof295: cs = 295; goto _test_eof; 
+	_test_eof296: cs = 296; goto _test_eof; 
+	_test_eof297: cs = 297; goto _test_eof; 
+	_test_eof298: cs = 298; goto _test_eof; 
+	_test_eof299: cs = 299; goto _test_eof; 
+	_test_eof300: cs = 300; goto _test_eof; 
+	_test_eof301: cs = 301; goto _test_eof; 
+	_test_eof302: cs = 302; goto _test_eof; 
+	_test_eof303: cs = 303; goto _test_eof; 
+	_test_eof304: cs = 304; goto _test_eof; 
+	_test_eof305: cs = 305; goto _test_eof; 
+	_test_eof306: cs = 306; goto _test_eof; 
+	_test_eof307: cs = 307; goto _test_eof; 
+	_test_eof308: cs = 308; goto _test_eof; 
+	_test_eof309: cs = 309; goto _test_eof; 
+	_test_eof310: cs = 310; goto _test_eof; 
+	_test_eof311: cs = 311; goto _test_eof; 
+	_test_eof312: cs = 312; goto _test_eof; 
+	_test_eof313: cs = 313; goto _test_eof; 
+	_test_eof314: cs = 314; goto _test_eof; 
+	_test_eof315: cs = 315; goto _test_eof; 
+	_test_eof316: cs = 316; goto _test_eof; 
+	_test_eof317: cs = 317; goto _test_eof; 
+	_test_eof318: cs = 318; goto _test_eof; 
+	_test_eof319: cs = 319; goto _test_eof; 
+	_test_eof320: cs = 320; goto _test_eof; 
+	_test_eof321: cs = 321; goto _test_eof; 
+	_test_eof322: cs = 322; goto _test_eof; 
+	_test_eof323: cs = 323; goto _test_eof; 
+	_test_eof324: cs = 324; goto _test_eof; 
+	_test_eof325: cs = 325; goto _test_eof; 
+	_test_eof326: cs = 326; goto _test_eof; 
+	_test_eof327: cs = 327; goto _test_eof; 
+	_test_eof328: cs = 328; goto _test_eof; 
+	_test_eof329: cs = 329; goto _test_eof; 
+	_test_eof330: cs = 330; goto _test_eof; 
+	_test_eof331: cs = 331; goto _test_eof; 
+	_test_eof332: cs = 332; goto _test_eof; 
+	_test_eof333: cs = 333; goto _test_eof; 
+	_test_eof334: cs = 334; goto _test_eof; 
+	_test_eof335: cs = 335; goto _test_eof; 
+	_test_eof336: cs = 336; goto _test_eof; 
+	_test_eof337: cs = 337; goto _test_eof; 
+	_test_eof338: cs = 338; goto _test_eof; 
+	_test_eof339: cs = 339; goto _test_eof; 
+	_test_eof340: cs = 340; goto _test_eof; 
+	_test_eof341: cs = 341; goto _test_eof; 
+	_test_eof342: cs = 342; goto _test_eof; 
+	_test_eof343: cs = 343; goto _test_eof; 
+	_test_eof344: cs = 344; goto _test_eof; 
+	_test_eof345: cs = 345; goto _test_eof; 
+	_test_eof346: cs = 346; goto _test_eof; 
+	_test_eof347: cs = 347; goto _test_eof; 
+	_test_eof348: cs = 348; goto _test_eof; 
+	_test_eof349: cs = 349; goto _test_eof; 
+	_test_eof350: cs = 350; goto _test_eof; 
+	_test_eof351: cs = 351; goto _test_eof; 
+	_test_eof352: cs = 352; goto _test_eof; 
+	_test_eof353: cs = 353; goto _test_eof; 
+	_test_eof354: cs = 354; goto _test_eof; 
+	_test_eof355: cs = 355; goto _test_eof; 
+	_test_eof356: cs = 356; goto _test_eof; 
+	_test_eof357: cs = 357; goto _test_eof; 
+	_test_eof358: cs = 358; goto _test_eof; 
+	_test_eof359: cs = 359; goto _test_eof; 
+	_test_eof360: cs = 360; goto _test_eof; 
+	_test_eof361: cs = 361; goto _test_eof; 
+	_test_eof362: cs = 362; goto _test_eof; 
+	_test_eof363: cs = 363; goto _test_eof; 
+	_test_eof364: cs = 364; goto _test_eof; 
+	_test_eof365: cs = 365; goto _test_eof; 
+	_test_eof366: cs = 366; goto _test_eof; 
+	_test_eof367: cs = 367; goto _test_eof; 
+	_test_eof368: cs = 368; goto _test_eof; 
+	_test_eof369: cs = 369; goto _test_eof; 
+	_test_eof370: cs = 370; goto _test_eof; 
+	_test_eof371: cs = 371; goto _test_eof; 
+	_test_eof372: cs = 372; goto _test_eof; 
+	_test_eof373: cs = 373; goto _test_eof; 
+	_test_eof374: cs = 374; goto _test_eof; 
+	_test_eof375: cs = 375; goto _test_eof; 
+	_test_eof376: cs = 376; goto _test_eof; 
+	_test_eof377: cs = 377; goto _test_eof; 
+	_test_eof378: cs = 378; goto _test_eof; 
+	_test_eof379: cs = 379; goto _test_eof; 
+	_test_eof380: cs = 380; goto _test_eof; 
+	_test_eof381: cs = 381; goto _test_eof; 
+	_test_eof382: cs = 382; goto _test_eof; 
+	_test_eof383: cs = 383; goto _test_eof; 
+	_test_eof384: cs = 384; goto _test_eof; 
+	_test_eof385: cs = 385; goto _test_eof; 
+	_test_eof386: cs = 386; goto _test_eof; 
+	_test_eof387: cs = 387; goto _test_eof; 
+	_test_eof388: cs = 388; goto _test_eof; 
+	_test_eof389: cs = 389; goto _test_eof; 
+	_test_eof390: cs = 390; goto _test_eof; 
+	_test_eof391: cs = 391; goto _test_eof; 
+	_test_eof392: cs = 392; goto _test_eof; 
+	_test_eof393: cs = 393; goto _test_eof; 
+	_test_eof394: cs = 394; goto _test_eof; 
+	_test_eof395: cs = 395; goto _test_eof; 
+	_test_eof396: cs = 396; goto _test_eof; 
+	_test_eof397: cs = 397; goto _test_eof; 
+	_test_eof398: cs = 398; goto _test_eof; 
+	_test_eof399: cs = 399; goto _test_eof; 
+	_test_eof400: cs = 400; goto _test_eof; 
+	_test_eof401: cs = 401; goto _test_eof; 
+	_test_eof402: cs = 402; goto _test_eof; 
+	_test_eof403: cs = 403; goto _test_eof; 
+	_test_eof404: cs = 404; goto _test_eof; 
+	_test_eof405: cs = 405; goto _test_eof; 
+	_test_eof406: cs = 406; goto _test_eof; 
+	_test_eof407: cs = 407; goto _test_eof; 
+	_test_eof408: cs = 408; goto _test_eof; 
+	_test_eof409: cs = 409; goto _test_eof; 
+	_test_eof410: cs = 410; goto _test_eof; 
+	_test_eof411: cs = 411; goto _test_eof; 
+	_test_eof412: cs = 412; goto _test_eof; 
+	_test_eof413: cs = 413; goto _test_eof; 
+	_test_eof414: cs = 414; goto _test_eof; 
+	_test_eof415: cs = 415; goto _test_eof; 
+	_test_eof416: cs = 416; goto _test_eof; 
+	_test_eof417: cs = 417; goto _test_eof; 
+	_test_eof418: cs = 418; goto _test_eof; 
+	_test_eof419: cs = 419; goto _test_eof; 
+	_test_eof420: cs = 420; goto _test_eof; 
+	_test_eof421: cs = 421; goto _test_eof; 
+	_test_eof422: cs = 422; goto _test_eof; 
+	_test_eof423: cs = 423; goto _test_eof; 
+	_test_eof424: cs = 424; goto _test_eof; 
+	_test_eof425: cs = 425; goto _test_eof; 
+	_test_eof426: cs = 426; goto _test_eof; 
+	_test_eof427: cs = 427; goto _test_eof; 
+	_test_eof428: cs = 428; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 137 "smtp_response_parser.rl"
+
+  if (!smtp_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  return(parser->nread);
+}
+
+int smtp_parser_finish(smtp_parser *parser)
+{
+  if (smtp_parser_has_error(parser) ) {
+    return -1;
+  } else if (smtp_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int smtp_parser_has_error(smtp_parser *parser) {
+  return parser->cs == smtp_parser_error;
+}
+
+int smtp_parser_is_finished(smtp_parser *parser) {
+  return parser->cs >= smtp_parser_first_final;
+}
diff --git a/src/tcp/parsers/smtp_response_parser.h b/src/tcp/parsers/smtp_response_parser.h
new file mode 100755
index 0000000..58e6ccf
--- /dev/null
+++ b/src/tcp/parsers/smtp_response_parser.h
@@ -0,0 +1,31 @@
+
+#ifndef _NGX_TCP_SMTP_RESPONSE_PARSER_H_INCLUDED_
+#define _NGX_TCP_SMTP_RESPONSE_PARSER_H_INCLUDED_
+
+#include <parser.h>
+
+typedef struct smtp_parser {
+
+  int cs;
+  size_t nread;
+  size_t mark;
+
+  int hello_reply_code;
+
+  void *data;
+
+  element_cb domain;
+  element_cb greeting_text;
+  element_cb reply_code;
+  element_cb reply_text;
+  element_cb smtp_done;
+    
+} smtp_parser;
+
+int smtp_parser_init(smtp_parser *parser);
+int smtp_parser_finish(smtp_parser *parser);
+size_t smtp_parser_execute(smtp_parser *parser, const signed char *data, size_t len, size_t off);
+int smtp_parser_has_error(smtp_parser *parser);
+int smtp_parser_is_finished(smtp_parser *parser);
+
+#endif //_NGX_TCP_SMTP_RESPONSE_PARSER_H_INCLUDED_
diff --git a/src/tcp/parsers/smtp_response_parser.rl b/src/tcp/parsers/smtp_response_parser.rl
new file mode 100755
index 0000000..9f61210
--- /dev/null
+++ b/src/tcp/parsers/smtp_response_parser.rl
@@ -0,0 +1,162 @@
+
+#include "../ngx_tcp_upstream_check.h"
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+%%{
+  
+  machine smtp_parser;
+
+  action mark {MARK(mark, fpc);}
+
+  action domain {
+    if(parser->domain != NULL) {
+      parser->domain(parser->data, PTR_TO(mark), LEN(mark, fpc));
+    }
+  }
+
+  action greeting_text {	
+    if(parser->greeting_text != NULL)
+      parser->greeting_text(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action reply_code {
+    if(parser->reply_code != NULL)
+      parser->reply_code(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action reply_text {
+    if(parser->reply_text != NULL)
+      parser->reply_text(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action done { 
+    if(parser->smtp_done != NULL)
+      parser->smtp_done(parser->data, fpc + 1, pe - fpc - 1);
+    fbreak;
+  }
+
+#### SMTP PROTOCOL GRAMMAR
+  CRLF = "\r\n";
+  SP = " ";
+
+  Let_dig = alnum;
+  Ldh_str = ( alnum | "-" )* alnum;
+  Snum = digit{1,3};
+#Standardized_tag = Ldh_str;
+#Not supported yet
+#General_address_literal = Standardized_tag ":" content{1,d};
+
+  IPv4_address_literal = Snum ("." Snum){3};
+
+  IPv6_hex  = xdigit{1,4};
+  IPv6_full = IPv6_hex ( ":" IPv6_hex ){7};
+  IPv6_comp = (IPv6_hex (":" IPv6_hex){0,5})? "::" (IPv6_hex (":" IPv6_hex){0,5})?;
+  IPv6v4_full = IPv6_hex (":" IPv6_hex){5} ":" IPv4_address_literal;
+  IPv6v4_comp = (IPv6_hex (":" IPv6_hex){0,3})? "::" (IPv6_hex (":" IPv6_hex){0,3} ":")? IPv4_address_literal;
+
+  IPv6_addr = ( IPv6_full | IPv6_comp | IPv6v4_full | IPv6v4_comp );
+
+  IPv6_address_literal = "IPv6:" IPv6_addr;
+  
+  Sub_domain = Let_dig Ldh_str?;
+#Address_literal = "[" ( Pv4_address_literal | IPv6_address_literal | General_address_literal ) "]";
+  Address_literal = "[" ( IPv4_address_literal | IPv6_address_literal ) "]";
+
+#It should be '+', but smtp.163.com is sucks.
+#Domain = (( Sub_domain ( '.' Sub_domain )+ ) | Address_literal ) >mark %domain;
+  Domain = (( Sub_domain ( '.' Sub_domain )? ) | Address_literal ) >mark %domain;
+
+  Greeting_text = ( ascii -- ("\r" | "\n") )+ >mark %greeting_text;
+
+  Greeting_line = "220 " Domain ( SP Greeting_text )? CRLF;
+
+
+  
+  Reply_code = ( digit+ ) >mark %reply_code;
+
+  Ehlo_keyword = Let_dig ( Let_dig | "-" )*;
+  Ehlo_param   = ( ascii -- ( cntrl | SP ) )+;
+
+#the "=" is not in the RFC, the reason see also: http://www.linuxquestions.org/questions/linux-networking-3/qmail-auth-login-auth%3Dlogin-arghhhhhhhh-226524/
+  Ehlo_line = ( Ehlo_keyword ( ( SP | "=" ) Ehlo_param )* ) >mark %reply_text;
+
+Ehlo_reply_ok = ( ( "250" Domain ( SP Greeting_text )? CRLF ) 
+        | ("250-" Domain ( SP Greeting_text)? CRLF ( "250-" Ehlo_line CRLF )* Reply_code SP Ehlo_line CRLF) ); 
+
+  Reply_text = ( ascii -- ("\r" | "\n") )+ >mark %reply_text;
+
+  General_reply_line = Reply_code ( SP Reply_text )? CRLF;
+
+  Reply_line = ( General_reply_line | Ehlo_reply_ok );
+
+
+  Response = Greeting_line Reply_line @done;
+
+main := Response;
+
+}%%
+
+/** Data **/
+%% write data;
+
+int smtp_parser_init(smtp_parser *parser)  {
+
+  int cs = 0;
+  %% write init;
+  parser->cs = cs;
+  parser->mark = 0;
+  parser->nread = 0;
+
+  return(1);
+}
+
+
+/** exec **/
+size_t smtp_parser_execute(smtp_parser *parser, const signed char *buffer, size_t len, size_t off)  {
+
+  const signed char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer + off;
+  pe = buffer + len;
+
+  %% write exec;
+
+  if (!smtp_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  return(parser->nread);
+}
+
+int smtp_parser_finish(smtp_parser *parser)
+{
+  if (smtp_parser_has_error(parser) ) {
+    return -1;
+  } else if (smtp_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int smtp_parser_has_error(smtp_parser *parser) {
+  return parser->cs == smtp_parser_error;
+}
+
+int smtp_parser_is_finished(smtp_parser *parser) {
+  return parser->cs >= smtp_parser_first_final;
+}
diff --git a/src/tcp/test/README b/src/tcp/test/README
new file mode 100755
index 0000000..5c3c158
--- /dev/null
+++ b/src/tcp/test/README
@@ -0,0 +1,61 @@
+NAME
+    Test::Nginx - Testing modules for Nginx C module development
+
+DESCRIPTION
+    This distribution provides two testing modules for Nginx C module
+    development:
+
+    *   Test::Nginx::LWP
+
+    *   Test::Nginx::Socket
+
+    All of them are based on Test::Base.
+
+SOURCE REPOSITORY
+    This module has a Git repository on Github, which has access for all.
+
+        http://github.com/agentzh/test-nginx
+
+    If you want a commit bit, feel free to drop me a line.
+
+AUTHOR
+    agentzh (章亦春) "<agentzh@gmail.com>"
+
+COPYRIGHT & LICENSE
+    Copyright (c) 2009, Taobao Inc., Alibaba Group
+    (<http://www.taobao.com>).
+
+    Copyright (c) 2009, agentzh "<agentzh@gmail.com>".
+
+    This module is licensed under the terms of the BSD license.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+    *   Redistributions of source code must retain the above copyright
+        notice, this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of the Taobao Inc. nor the names of its
+        contributors may be used to endorse or promote products derived from
+        this software without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+SEE ALSO
+    Test::Nginx::LWP, Test::Nginx::Socket, Test::Base.
+
diff --git a/src/tcp/test/inc/Module/AutoInstall.pm b/src/tcp/test/inc/Module/AutoInstall.pm
new file mode 100755
index 0000000..dfb8ef7
--- /dev/null
+++ b/src/tcp/test/inc/Module/AutoInstall.pm
@@ -0,0 +1,805 @@
+#line 1
+package Module::AutoInstall;
+
+use strict;
+use Cwd                 ();
+use ExtUtils::MakeMaker ();
+
+use vars qw{$VERSION};
+BEGIN {
+	$VERSION = '1.03';
+}
+
+# special map on pre-defined feature sets
+my %FeatureMap = (
+    ''      => 'Core Features',    # XXX: deprecated
+    '-core' => 'Core Features',
+);
+
+# various lexical flags
+my ( @Missing, @Existing,  %DisabledTests, $UnderCPAN,     $HasCPANPLUS );
+my (
+    $Config, $CheckOnly, $SkipInstall, $AcceptDefault, $TestOnly, $AllDeps
+);
+my ( $PostambleActions, $PostambleUsed );
+
+# See if it's a testing or non-interactive session
+_accept_default( $ENV{AUTOMATED_TESTING} or ! -t STDIN ); 
+_init();
+
+sub _accept_default {
+    $AcceptDefault = shift;
+}
+
+sub missing_modules {
+    return @Missing;
+}
+
+sub do_install {
+    __PACKAGE__->install(
+        [
+            $Config
+            ? ( UNIVERSAL::isa( $Config, 'HASH' ) ? %{$Config} : @{$Config} )
+            : ()
+        ],
+        @Missing,
+    );
+}
+
+# initialize various flags, and/or perform install
+sub _init {
+    foreach my $arg (
+        @ARGV,
+        split(
+            /[\s\t]+/,
+            $ENV{PERL_AUTOINSTALL} || $ENV{PERL_EXTUTILS_AUTOINSTALL} || ''
+        )
+      )
+    {
+        if ( $arg =~ /^--config=(.*)$/ ) {
+            $Config = [ split( ',', $1 ) ];
+        }
+        elsif ( $arg =~ /^--installdeps=(.*)$/ ) {
+            __PACKAGE__->install( $Config, @Missing = split( /,/, $1 ) );
+            exit 0;
+        }
+        elsif ( $arg =~ /^--default(?:deps)?$/ ) {
+            $AcceptDefault = 1;
+        }
+        elsif ( $arg =~ /^--check(?:deps)?$/ ) {
+            $CheckOnly = 1;
+        }
+        elsif ( $arg =~ /^--skip(?:deps)?$/ ) {
+            $SkipInstall = 1;
+        }
+        elsif ( $arg =~ /^--test(?:only)?$/ ) {
+            $TestOnly = 1;
+        }
+        elsif ( $arg =~ /^--all(?:deps)?$/ ) {
+            $AllDeps = 1;
+        }
+    }
+}
+
+# overrides MakeMaker's prompt() to automatically accept the default choice
+sub _prompt {
+    goto &ExtUtils::MakeMaker::prompt unless $AcceptDefault;
+
+    my ( $prompt, $default ) = @_;
+    my $y = ( $default =~ /^[Yy]/ );
+
+    print $prompt, ' [', ( $y ? 'Y' : 'y' ), '/', ( $y ? 'n' : 'N' ), '] ';
+    print "$default\n";
+    return $default;
+}
+
+# the workhorse
+sub import {
+    my $class = shift;
+    my @args  = @_ or return;
+    my $core_all;
+
+    print "*** $class version " . $class->VERSION . "\n";
+    print "*** Checking for Perl dependencies...\n";
+
+    my $cwd = Cwd::cwd();
+
+    $Config = [];
+
+    my $maxlen = length(
+        (
+            sort   { length($b) <=> length($a) }
+              grep { /^[^\-]/ }
+              map  {
+                ref($_)
+                  ? ( ( ref($_) eq 'HASH' ) ? keys(%$_) : @{$_} )
+                  : ''
+              }
+              map { +{@args}->{$_} }
+              grep { /^[^\-]/ or /^-core$/i } keys %{ +{@args} }
+        )[0]
+    );
+
+    # We want to know if we're under CPAN early to avoid prompting, but
+    # if we aren't going to try and install anything anyway then skip the
+    # check entirely since we don't want to have to load (and configure)
+    # an old CPAN just for a cosmetic message
+
+    $UnderCPAN = _check_lock(1) unless $SkipInstall;
+
+    while ( my ( $feature, $modules ) = splice( @args, 0, 2 ) ) {
+        my ( @required, @tests, @skiptests );
+        my $default  = 1;
+        my $conflict = 0;
+
+        if ( $feature =~ m/^-(\w+)$/ ) {
+            my $option = lc($1);
+
+            # check for a newer version of myself
+            _update_to( $modules, @_ ) and return if $option eq 'version';
+
+            # sets CPAN configuration options
+            $Config = $modules if $option eq 'config';
+
+            # promote every features to core status
+            $core_all = ( $modules =~ /^all$/i ) and next
+              if $option eq 'core';
+
+            next unless $option eq 'core';
+        }
+
+        print "[" . ( $FeatureMap{ lc($feature) } || $feature ) . "]\n";
+
+        $modules = [ %{$modules} ] if UNIVERSAL::isa( $modules, 'HASH' );
+
+        unshift @$modules, -default => &{ shift(@$modules) }
+          if ( ref( $modules->[0] ) eq 'CODE' );    # XXX: bugward combatability
+
+        while ( my ( $mod, $arg ) = splice( @$modules, 0, 2 ) ) {
+            if ( $mod =~ m/^-(\w+)$/ ) {
+                my $option = lc($1);
+
+                $default   = $arg    if ( $option eq 'default' );
+                $conflict  = $arg    if ( $option eq 'conflict' );
+                @tests     = @{$arg} if ( $option eq 'tests' );
+                @skiptests = @{$arg} if ( $option eq 'skiptests' );
+
+                next;
+            }
+
+            printf( "- %-${maxlen}s ...", $mod );
+
+            if ( $arg and $arg =~ /^\D/ ) {
+                unshift @$modules, $arg;
+                $arg = 0;
+            }
+
+            # XXX: check for conflicts and uninstalls(!) them.
+            my $cur = _load($mod);
+            if (_version_cmp ($cur, $arg) >= 0)
+            {
+                print "loaded. ($cur" . ( $arg ? " >= $arg" : '' ) . ")\n";
+                push @Existing, $mod => $arg;
+                $DisabledTests{$_} = 1 for map { glob($_) } @skiptests;
+            }
+            else {
+                if (not defined $cur)   # indeed missing
+                {
+                    print "missing." . ( $arg ? " (would need $arg)" : '' ) . "\n";
+                }
+                else
+                {
+                    # no need to check $arg as _version_cmp ($cur, undef) would satisfy >= above
+                    print "too old. ($cur < $arg)\n";
+                }
+
+                push @required, $mod => $arg;
+            }
+        }
+
+        next unless @required;
+
+        my $mandatory = ( $feature eq '-core' or $core_all );
+
+        if (
+            !$SkipInstall
+            and (
+                $CheckOnly
+                or ($mandatory and $UnderCPAN)
+                or $AllDeps
+                or _prompt(
+                    qq{==> Auto-install the }
+                      . ( @required / 2 )
+                      . ( $mandatory ? ' mandatory' : ' optional' )
+                      . qq{ module(s) from CPAN?},
+                    $default ? 'y' : 'n',
+                ) =~ /^[Yy]/
+            )
+          )
+        {
+            push( @Missing, @required );
+            $DisabledTests{$_} = 1 for map { glob($_) } @skiptests;
+        }
+
+        elsif ( !$SkipInstall
+            and $default
+            and $mandatory
+            and
+            _prompt( qq{==> The module(s) are mandatory! Really skip?}, 'n', )
+            =~ /^[Nn]/ )
+        {
+            push( @Missing, @required );
+            $DisabledTests{$_} = 1 for map { glob($_) } @skiptests;
+        }
+
+        else {
+            $DisabledTests{$_} = 1 for map { glob($_) } @tests;
+        }
+    }
+
+    if ( @Missing and not( $CheckOnly or $UnderCPAN ) ) {
+        require Config;
+        print
+"*** Dependencies will be installed the next time you type '$Config::Config{make}'.\n";
+
+        # make an educated guess of whether we'll need root permission.
+        print "    (You may need to do that as the 'root' user.)\n"
+          if eval '$>';
+    }
+    print "*** $class configuration finished.\n";
+
+    chdir $cwd;
+
+    # import to main::
+    no strict 'refs';
+    *{'main::WriteMakefile'} = \&Write if caller(0) eq 'main';
+}
+
+sub _running_under {
+    my $thing = shift;
+    print <<"END_MESSAGE";
+*** Since we're running under ${thing}, I'll just let it take care
+    of the dependency's installation later.
+END_MESSAGE
+    return 1;
+}
+
+# Check to see if we are currently running under CPAN.pm and/or CPANPLUS;
+# if we are, then we simply let it taking care of our dependencies
+sub _check_lock {
+    return unless @Missing or @_;
+
+    my $cpan_env = $ENV{PERL5_CPAN_IS_RUNNING};
+
+    if ($ENV{PERL5_CPANPLUS_IS_RUNNING}) {
+        return _running_under($cpan_env ? 'CPAN' : 'CPANPLUS');
+    }
+
+    require CPAN;
+
+    if ($CPAN::VERSION > '1.89') {
+        if ($cpan_env) {
+            return _running_under('CPAN');
+        }
+        return; # CPAN.pm new enough, don't need to check further
+    }
+
+    # last ditch attempt, this -will- configure CPAN, very sorry
+
+    _load_cpan(1); # force initialize even though it's already loaded
+
+    # Find the CPAN lock-file
+    my $lock = MM->catfile( $CPAN::Config->{cpan_home}, ".lock" );
+    return unless -f $lock;
+
+    # Check the lock
+    local *LOCK;
+    return unless open(LOCK, $lock);
+
+    if (
+            ( $^O eq 'MSWin32' ? _under_cpan() : <LOCK> == getppid() )
+        and ( $CPAN::Config->{prerequisites_policy} || '' ) ne 'ignore'
+    ) {
+        print <<'END_MESSAGE';
+
+*** Since we're running under CPAN, I'll just let it take care
+    of the dependency's installation later.
+END_MESSAGE
+        return 1;
+    }
+
+    close LOCK;
+    return;
+}
+
+sub install {
+    my $class = shift;
+
+    my $i;    # used below to strip leading '-' from config keys
+    my @config = ( map { s/^-// if ++$i; $_ } @{ +shift } );
+
+    my ( @modules, @installed );
+    while ( my ( $pkg, $ver ) = splice( @_, 0, 2 ) ) {
+
+        # grep out those already installed
+        if ( _version_cmp( _load($pkg), $ver ) >= 0 ) {
+            push @installed, $pkg;
+        }
+        else {
+            push @modules, $pkg, $ver;
+        }
+    }
+
+    return @installed unless @modules;  # nothing to do
+    return @installed if _check_lock(); # defer to the CPAN shell
+
+    print "*** Installing dependencies...\n";
+
+    return unless _connected_to('cpan.org');
+
+    my %args = @config;
+    my %failed;
+    local *FAILED;
+    if ( $args{do_once} and open( FAILED, '.#autoinstall.failed' ) ) {
+        while (<FAILED>) { chomp; $failed{$_}++ }
+        close FAILED;
+
+        my @newmod;
+        while ( my ( $k, $v ) = splice( @modules, 0, 2 ) ) {
+            push @newmod, ( $k => $v ) unless $failed{$k};
+        }
+        @modules = @newmod;
+    }
+
+    if ( _has_cpanplus() and not $ENV{PERL_AUTOINSTALL_PREFER_CPAN} ) {
+        _install_cpanplus( \@modules, \@config );
+    } else {
+        _install_cpan( \@modules, \@config );
+    }
+
+    print "*** $class installation finished.\n";
+
+    # see if we have successfully installed them
+    while ( my ( $pkg, $ver ) = splice( @modules, 0, 2 ) ) {
+        if ( _version_cmp( _load($pkg), $ver ) >= 0 ) {
+            push @installed, $pkg;
+        }
+        elsif ( $args{do_once} and open( FAILED, '>> .#autoinstall.failed' ) ) {
+            print FAILED "$pkg\n";
+        }
+    }
+
+    close FAILED if $args{do_once};
+
+    return @installed;
+}
+
+sub _install_cpanplus {
+    my @modules   = @{ +shift };
+    my @config    = _cpanplus_config( @{ +shift } );
+    my $installed = 0;
+
+    require CPANPLUS::Backend;
+    my $cp   = CPANPLUS::Backend->new;
+    my $conf = $cp->configure_object;
+
+    return unless $conf->can('conf') # 0.05x+ with "sudo" support
+               or _can_write($conf->_get_build('base'));  # 0.04x
+
+    # if we're root, set UNINST=1 to avoid trouble unless user asked for it.
+    my $makeflags = $conf->get_conf('makeflags') || '';
+    if ( UNIVERSAL::isa( $makeflags, 'HASH' ) ) {
+        # 0.03+ uses a hashref here
+        $makeflags->{UNINST} = 1 unless exists $makeflags->{UNINST};
+
+    } else {
+        # 0.02 and below uses a scalar
+        $makeflags = join( ' ', split( ' ', $makeflags ), 'UNINST=1' )
+          if ( $makeflags !~ /\bUNINST\b/ and eval qq{ $> eq '0' } );
+
+    }
+    $conf->set_conf( makeflags => $makeflags );
+    $conf->set_conf( prereqs   => 1 );
+
+    
+
+    while ( my ( $key, $val ) = splice( @config, 0, 2 ) ) {
+        $conf->set_conf( $key, $val );
+    }
+
+    my $modtree = $cp->module_tree;
+    while ( my ( $pkg, $ver ) = splice( @modules, 0, 2 ) ) {
+        print "*** Installing $pkg...\n";
+
+        MY::preinstall( $pkg, $ver ) or next if defined &MY::preinstall;
+
+        my $success;
+        my $obj = $modtree->{$pkg};
+
+        if ( $obj and _version_cmp( $obj->{version}, $ver ) >= 0 ) {
+            my $pathname = $pkg;
+            $pathname =~ s/::/\\W/;
+
+            foreach my $inc ( grep { m/$pathname.pm/i } keys(%INC) ) {
+                delete $INC{$inc};
+            }
+
+            my $rv = $cp->install( modules => [ $obj->{module} ] );
+
+            if ( $rv and ( $rv->{ $obj->{module} } or $rv->{ok} ) ) {
+                print "*** $pkg successfully installed.\n";
+                $success = 1;
+            } else {
+                print "*** $pkg installation cancelled.\n";
+                $success = 0;
+            }
+
+            $installed += $success;
+        } else {
+            print << ".";
+*** Could not find a version $ver or above for $pkg; skipping.
+.
+        }
+
+        MY::postinstall( $pkg, $ver, $success ) if defined &MY::postinstall;
+    }
+
+    return $installed;
+}
+
+sub _cpanplus_config {
+	my @config = ();
+	while ( @_ ) {
+		my ($key, $value) = (shift(), shift());
+		if ( $key eq 'prerequisites_policy' ) {
+			if ( $value eq 'follow' ) {
+				$value = CPANPLUS::Internals::Constants::PREREQ_INSTALL();
+			} elsif ( $value eq 'ask' ) {
+				$value = CPANPLUS::Internals::Constants::PREREQ_ASK();
+			} elsif ( $value eq 'ignore' ) {
+				$value = CPANPLUS::Internals::Constants::PREREQ_IGNORE();
+			} else {
+				die "*** Cannot convert option $key = '$value' to CPANPLUS version.\n";
+			}
+		} else {
+			die "*** Cannot convert option $key to CPANPLUS version.\n";
+		}
+	}
+	return @config;
+}
+
+sub _install_cpan {
+    my @modules   = @{ +shift };
+    my @config    = @{ +shift };
+    my $installed = 0;
+    my %args;
+
+    _load_cpan();
+    require Config;
+
+    if (CPAN->VERSION < 1.80) {
+        # no "sudo" support, probe for writableness
+        return unless _can_write( MM->catfile( $CPAN::Config->{cpan_home}, 'sources' ) )
+                  and _can_write( $Config::Config{sitelib} );
+    }
+
+    # if we're root, set UNINST=1 to avoid trouble unless user asked for it.
+    my $makeflags = $CPAN::Config->{make_install_arg} || '';
+    $CPAN::Config->{make_install_arg} =
+      join( ' ', split( ' ', $makeflags ), 'UNINST=1' )
+      if ( $makeflags !~ /\bUNINST\b/ and eval qq{ $> eq '0' } );
+
+    # don't show start-up info
+    $CPAN::Config->{inhibit_startup_message} = 1;
+
+    # set additional options
+    while ( my ( $opt, $arg ) = splice( @config, 0, 2 ) ) {
+        ( $args{$opt} = $arg, next )
+          if $opt =~ /^force$/;    # pseudo-option
+        $CPAN::Config->{$opt} = $arg;
+    }
+
+    local $CPAN::Config->{prerequisites_policy} = 'follow';
+
+    while ( my ( $pkg, $ver ) = splice( @modules, 0, 2 ) ) {
+        MY::preinstall( $pkg, $ver ) or next if defined &MY::preinstall;
+
+        print "*** Installing $pkg...\n";
+
+        my $obj     = CPAN::Shell->expand( Module => $pkg );
+        my $success = 0;
+
+        if ( $obj and _version_cmp( $obj->cpan_version, $ver ) >= 0 ) {
+            my $pathname = $pkg;
+            $pathname =~ s/::/\\W/;
+
+            foreach my $inc ( grep { m/$pathname.pm/i } keys(%INC) ) {
+                delete $INC{$inc};
+            }
+
+            my $rv = $args{force} ? CPAN::Shell->force( install => $pkg )
+                                  : CPAN::Shell->install($pkg);
+            $rv ||= eval {
+                $CPAN::META->instance( 'CPAN::Distribution', $obj->cpan_file, )
+                  ->{install}
+                  if $CPAN::META;
+            };
+
+            if ( $rv eq 'YES' ) {
+                print "*** $pkg successfully installed.\n";
+                $success = 1;
+            }
+            else {
+                print "*** $pkg installation failed.\n";
+                $success = 0;
+            }
+
+            $installed += $success;
+        }
+        else {
+            print << ".";
+*** Could not find a version $ver or above for $pkg; skipping.
+.
+        }
+
+        MY::postinstall( $pkg, $ver, $success ) if defined &MY::postinstall;
+    }
+
+    return $installed;
+}
+
+sub _has_cpanplus {
+    return (
+        $HasCPANPLUS = (
+            $INC{'CPANPLUS/Config.pm'}
+              or _load('CPANPLUS::Shell::Default')
+        )
+    );
+}
+
+# make guesses on whether we're under the CPAN installation directory
+sub _under_cpan {
+    require Cwd;
+    require File::Spec;
+
+    my $cwd  = File::Spec->canonpath( Cwd::cwd() );
+    my $cpan = File::Spec->canonpath( $CPAN::Config->{cpan_home} );
+
+    return ( index( $cwd, $cpan ) > -1 );
+}
+
+sub _update_to {
+    my $class = __PACKAGE__;
+    my $ver   = shift;
+
+    return
+      if _version_cmp( _load($class), $ver ) >= 0;  # no need to upgrade
+
+    if (
+        _prompt( "==> A newer version of $class ($ver) is required. Install?",
+            'y' ) =~ /^[Nn]/
+      )
+    {
+        die "*** Please install $class $ver manually.\n";
+    }
+
+    print << ".";
+*** Trying to fetch it from CPAN...
+.
+
+    # install ourselves
+    _load($class) and return $class->import(@_)
+      if $class->install( [], $class, $ver );
+
+    print << '.'; exit 1;
+
+*** Cannot bootstrap myself. :-( Installation terminated.
+.
+}
+
+# check if we're connected to some host, using inet_aton
+sub _connected_to {
+    my $site = shift;
+
+    return (
+        ( _load('Socket') and Socket::inet_aton($site) ) or _prompt(
+            qq(
+*** Your host cannot resolve the domain name '$site', which
+    probably means the Internet connections are unavailable.
+==> Should we try to install the required module(s) anyway?), 'n'
+          ) =~ /^[Yy]/
+    );
+}
+
+# check if a directory is writable; may create it on demand
+sub _can_write {
+    my $path = shift;
+    mkdir( $path, 0755 ) unless -e $path;
+
+    return 1 if -w $path;
+
+    print << ".";
+*** You are not allowed to write to the directory '$path';
+    the installation may fail due to insufficient permissions.
+.
+
+    if (
+        eval '$>' and lc(`sudo -V`) =~ /version/ and _prompt(
+            qq(
+==> Should we try to re-execute the autoinstall process with 'sudo'?),
+            ((-t STDIN) ? 'y' : 'n')
+        ) =~ /^[Yy]/
+      )
+    {
+
+        # try to bootstrap ourselves from sudo
+        print << ".";
+*** Trying to re-execute the autoinstall process with 'sudo'...
+.
+        my $missing = join( ',', @Missing );
+        my $config = join( ',',
+            UNIVERSAL::isa( $Config, 'HASH' ) ? %{$Config} : @{$Config} )
+          if $Config;
+
+        return
+          unless system( 'sudo', $^X, $0, "--config=$config",
+            "--installdeps=$missing" );
+
+        print << ".";
+*** The 'sudo' command exited with error!  Resuming...
+.
+    }
+
+    return _prompt(
+        qq(
+==> Should we try to install the required module(s) anyway?), 'n'
+    ) =~ /^[Yy]/;
+}
+
+# load a module and return the version it reports
+sub _load {
+    my $mod  = pop;    # class/instance doesn't matter
+    my $file = $mod;
+
+    $file =~ s|::|/|g;
+    $file .= '.pm';
+
+    local $@;
+    return eval { require $file; $mod->VERSION } || ( $@ ? undef: 0 );
+}
+
+# Load CPAN.pm and it's configuration
+sub _load_cpan {
+    return if $CPAN::VERSION and $CPAN::Config and not @_;
+    require CPAN;
+    if ( $CPAN::HandleConfig::VERSION ) {
+        # Newer versions of CPAN have a HandleConfig module
+        CPAN::HandleConfig->load;
+    } else {
+    	# Older versions had the load method in Config directly
+        CPAN::Config->load;
+    }
+}
+
+# compare two versions, either use Sort::Versions or plain comparison
+# return values same as <=>
+sub _version_cmp {
+    my ( $cur, $min ) = @_;
+    return -1 unless defined $cur;  # if 0 keep comparing
+    return 1 unless $min;
+
+    $cur =~ s/\s+$//;
+
+    # check for version numbers that are not in decimal format
+    if ( ref($cur) or ref($min) or $cur =~ /v|\..*\./ or $min =~ /v|\..*\./ ) {
+        if ( ( $version::VERSION or defined( _load('version') )) and
+             version->can('new') 
+            ) {
+
+            # use version.pm if it is installed.
+            return version->new($cur) <=> version->new($min);
+        }
+        elsif ( $Sort::Versions::VERSION or defined( _load('Sort::Versions') ) )
+        {
+
+            # use Sort::Versions as the sorting algorithm for a.b.c versions
+            return Sort::Versions::versioncmp( $cur, $min );
+        }
+
+        warn "Cannot reliably compare non-decimal formatted versions.\n"
+          . "Please install version.pm or Sort::Versions.\n";
+    }
+
+    # plain comparison
+    local $^W = 0;    # shuts off 'not numeric' bugs
+    return $cur <=> $min;
+}
+
+# nothing; this usage is deprecated.
+sub main::PREREQ_PM { return {}; }
+
+sub _make_args {
+    my %args = @_;
+
+    $args{PREREQ_PM} = { %{ $args{PREREQ_PM} || {} }, @Existing, @Missing }
+      if $UnderCPAN or $TestOnly;
+
+    if ( $args{EXE_FILES} and -e 'MANIFEST' ) {
+        require ExtUtils::Manifest;
+        my $manifest = ExtUtils::Manifest::maniread('MANIFEST');
+
+        $args{EXE_FILES} =
+          [ grep { exists $manifest->{$_} } @{ $args{EXE_FILES} } ];
+    }
+
+    $args{test}{TESTS} ||= 't/*.t';
+    $args{test}{TESTS} = join( ' ',
+        grep { !exists( $DisabledTests{$_} ) }
+          map { glob($_) } split( /\s+/, $args{test}{TESTS} ) );
+
+    my $missing = join( ',', @Missing );
+    my $config =
+      join( ',', UNIVERSAL::isa( $Config, 'HASH' ) ? %{$Config} : @{$Config} )
+      if $Config;
+
+    $PostambleActions = (
+        ($missing and not $UnderCPAN)
+        ? "\$(PERL) $0 --config=$config --installdeps=$missing"
+        : "\$(NOECHO) \$(NOOP)"
+    );
+
+    return %args;
+}
+
+# a wrapper to ExtUtils::MakeMaker::WriteMakefile
+sub Write {
+    require Carp;
+    Carp::croak "WriteMakefile: Need even number of args" if @_ % 2;
+
+    if ($CheckOnly) {
+        print << ".";
+*** Makefile not written in check-only mode.
+.
+        return;
+    }
+
+    my %args = _make_args(@_);
+
+    no strict 'refs';
+
+    $PostambleUsed = 0;
+    local *MY::postamble = \&postamble unless defined &MY::postamble;
+    ExtUtils::MakeMaker::WriteMakefile(%args);
+
+    print << "." unless $PostambleUsed;
+*** WARNING: Makefile written with customized MY::postamble() without
+    including contents from Module::AutoInstall::postamble() --
+    auto installation features disabled.  Please contact the author.
+.
+
+    return 1;
+}
+
+sub postamble {
+    $PostambleUsed = 1;
+
+    return <<"END_MAKE";
+
+config :: installdeps
+\t\$(NOECHO) \$(NOOP)
+
+checkdeps ::
+\t\$(PERL) $0 --checkdeps
+
+installdeps ::
+\t$PostambleActions
+
+END_MAKE
+
+}
+
+1;
+
+__END__
+
+#line 1056
diff --git a/src/tcp/test/inc/Module/Install.pm b/src/tcp/test/inc/Module/Install.pm
new file mode 100755
index 0000000..51eda5d
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install.pm
@@ -0,0 +1,430 @@
+#line 1
+package Module::Install;
+
+# For any maintainers:
+# The load order for Module::Install is a bit magic.
+# It goes something like this...
+#
+# IF ( host has Module::Install installed, creating author mode ) {
+#     1. Makefile.PL calls "use inc::Module::Install"
+#     2. $INC{inc/Module/Install.pm} set to installed version of inc::Module::Install
+#     3. The installed version of inc::Module::Install loads
+#     4. inc::Module::Install calls "require Module::Install"
+#     5. The ./inc/ version of Module::Install loads
+# } ELSE {
+#     1. Makefile.PL calls "use inc::Module::Install"
+#     2. $INC{inc/Module/Install.pm} set to ./inc/ version of Module::Install
+#     3. The ./inc/ version of Module::Install loads
+# }
+
+use 5.005;
+use strict 'vars';
+
+use vars qw{$VERSION $MAIN};
+BEGIN {
+	# All Module::Install core packages now require synchronised versions.
+	# This will be used to ensure we don't accidentally load old or
+	# different versions of modules.
+	# This is not enforced yet, but will be some time in the next few
+	# releases once we can make sure it won't clash with custom
+	# Module::Install extensions.
+	$VERSION = '0.91';
+
+	# Storage for the pseudo-singleton
+	$MAIN    = undef;
+
+	*inc::Module::Install::VERSION = *VERSION;
+	@inc::Module::Install::ISA     = __PACKAGE__;
+
+}
+
+
+
+
+
+# Whether or not inc::Module::Install is actually loaded, the
+# $INC{inc/Module/Install.pm} is what will still get set as long as
+# the caller loaded module this in the documented manner.
+# If not set, the caller may NOT have loaded the bundled version, and thus
+# they may not have a MI version that works with the Makefile.PL. This would
+# result in false errors or unexpected behaviour. And we don't want that.
+my $file = join( '/', 'inc', split /::/, __PACKAGE__ ) . '.pm';
+unless ( $INC{$file} ) { die <<"END_DIE" }
+
+Please invoke ${\__PACKAGE__} with:
+
+	use inc::${\__PACKAGE__};
+
+not:
+
+	use ${\__PACKAGE__};
+
+END_DIE
+
+
+
+
+
+# If the script that is loading Module::Install is from the future,
+# then make will detect this and cause it to re-run over and over
+# again. This is bad. Rather than taking action to touch it (which
+# is unreliable on some platforms and requires write permissions)
+# for now we should catch this and refuse to run.
+if ( -f $0 ) {
+	my $s = (stat($0))[9];
+
+	# If the modification time is only slightly in the future,
+	# sleep briefly to remove the problem.
+	my $a = $s - time;
+	if ( $a > 0 and $a < 5 ) { sleep 5 }
+
+	# Too far in the future, throw an error.
+	my $t = time;
+	if ( $s > $t ) { die <<"END_DIE" }
+
+Your installer $0 has a modification time in the future ($s > $t).
+
+This is known to create infinite loops in make.
+
+Please correct this, then run $0 again.
+
+END_DIE
+}
+
+
+
+
+
+# Build.PL was formerly supported, but no longer is due to excessive
+# difficulty in implementing every single feature twice.
+if ( $0 =~ /Build.PL$/i ) { die <<"END_DIE" }
+
+Module::Install no longer supports Build.PL.
+
+It was impossible to maintain duel backends, and has been deprecated.
+
+Please remove all Build.PL files and only use the Makefile.PL installer.
+
+END_DIE
+
+
+
+
+
+# To save some more typing in Module::Install installers, every...
+# use inc::Module::Install
+# ...also acts as an implicit use strict.
+$^H |= strict::bits(qw(refs subs vars));
+
+
+
+
+
+use Cwd        ();
+use File::Find ();
+use File::Path ();
+use FindBin;
+
+sub autoload {
+	my $self = shift;
+	my $who  = $self->_caller;
+	my $cwd  = Cwd::cwd();
+	my $sym  = "${who}::AUTOLOAD";
+	$sym->{$cwd} = sub {
+		my $pwd = Cwd::cwd();
+		if ( my $code = $sym->{$pwd} ) {
+			# Delegate back to parent dirs
+			goto &$code unless $cwd eq $pwd;
+		}
+		$$sym =~ /([^:]+)$/ or die "Cannot autoload $who - $sym";
+		my $method = $1;
+		if ( uc($method) eq $method ) {
+			# Do nothing
+			return;
+		} elsif ( $method =~ /^_/ and $self->can($method) ) {
+			# Dispatch to the root M:I class
+			return $self->$method(@_);
+		}
+
+		# Dispatch to the appropriate plugin
+		unshift @_, ( $self, $1 );
+		goto &{$self->can('call')};
+	};
+}
+
+sub import {
+	my $class = shift;
+	my $self  = $class->new(@_);
+	my $who   = $self->_caller;
+
+	unless ( -f $self->{file} ) {
+		require "$self->{path}/$self->{dispatch}.pm";
+		File::Path::mkpath("$self->{prefix}/$self->{author}");
+		$self->{admin} = "$self->{name}::$self->{dispatch}"->new( _top => $self );
+		$self->{admin}->init;
+		@_ = ($class, _self => $self);
+		goto &{"$self->{name}::import"};
+	}
+
+	*{"${who}::AUTOLOAD"} = $self->autoload;
+	$self->preload;
+
+	# Unregister loader and worker packages so subdirs can use them again
+	delete $INC{"$self->{file}"};
+	delete $INC{"$self->{path}.pm"};
+
+	# Save to the singleton
+	$MAIN = $self;
+
+	return 1;
+}
+
+sub preload {
+	my $self = shift;
+	unless ( $self->{extensions} ) {
+		$self->load_extensions(
+			"$self->{prefix}/$self->{path}", $self
+		);
+	}
+
+	my @exts = @{$self->{extensions}};
+	unless ( @exts ) {
+		@exts = $self->{admin}->load_all_extensions;
+	}
+
+	my %seen;
+	foreach my $obj ( @exts ) {
+		while (my ($method, $glob) = each %{ref($obj) . '::'}) {
+			next unless $obj->can($method);
+			next if $method =~ /^_/;
+			next if $method eq uc($method);
+			$seen{$method}++;
+		}
+	}
+
+	my $who = $self->_caller;
+	foreach my $name ( sort keys %seen ) {
+		*{"${who}::$name"} = sub {
+			${"${who}::AUTOLOAD"} = "${who}::$name";
+			goto &{"${who}::AUTOLOAD"};
+		};
+	}
+}
+
+sub new {
+	my ($class, %args) = @_;
+
+	# ignore the prefix on extension modules built from top level.
+	my $base_path = Cwd::abs_path($FindBin::Bin);
+	unless ( Cwd::abs_path(Cwd::cwd()) eq $base_path ) {
+		delete $args{prefix};
+	}
+
+	return $args{_self} if $args{_self};
+
+	$args{dispatch} ||= 'Admin';
+	$args{prefix}   ||= 'inc';
+	$args{author}   ||= ($^O eq 'VMS' ? '_author' : '.author');
+	$args{bundle}   ||= 'inc/BUNDLES';
+	$args{base}     ||= $base_path;
+	$class =~ s/^\Q$args{prefix}\E:://;
+	$args{name}     ||= $class;
+	$args{version}  ||= $class->VERSION;
+	unless ( $args{path} ) {
+		$args{path}  = $args{name};
+		$args{path}  =~ s!::!/!g;
+	}
+	$args{file}     ||= "$args{base}/$args{prefix}/$args{path}.pm";
+	$args{wrote}      = 0;
+
+	bless( \%args, $class );
+}
+
+sub call {
+	my ($self, $method) = @_;
+	my $obj = $self->load($method) or return;
+        splice(@_, 0, 2, $obj);
+	goto &{$obj->can($method)};
+}
+
+sub load {
+	my ($self, $method) = @_;
+
+	$self->load_extensions(
+		"$self->{prefix}/$self->{path}", $self
+	) unless $self->{extensions};
+
+	foreach my $obj (@{$self->{extensions}}) {
+		return $obj if $obj->can($method);
+	}
+
+	my $admin = $self->{admin} or die <<"END_DIE";
+The '$method' method does not exist in the '$self->{prefix}' path!
+Please remove the '$self->{prefix}' directory and run $0 again to load it.
+END_DIE
+
+	my $obj = $admin->load($method, 1);
+	push @{$self->{extensions}}, $obj;
+
+	$obj;
+}
+
+sub load_extensions {
+	my ($self, $path, $top) = @_;
+
+	unless ( grep { ! ref $_ and lc $_ eq lc $self->{prefix} } @INC ) {
+		unshift @INC, $self->{prefix};
+	}
+
+	foreach my $rv ( $self->find_extensions($path) ) {
+		my ($file, $pkg) = @{$rv};
+		next if $self->{pathnames}{$pkg};
+
+		local $@;
+		my $new = eval { require $file; $pkg->can('new') };
+		unless ( $new ) {
+			warn $@ if $@;
+			next;
+		}
+		$self->{pathnames}{$pkg} = delete $INC{$file};
+		push @{$self->{extensions}}, &{$new}($pkg, _top => $top );
+	}
+
+	$self->{extensions} ||= [];
+}
+
+sub find_extensions {
+	my ($self, $path) = @_;
+
+	my @found;
+	File::Find::find( sub {
+		my $file = $File::Find::name;
+		return unless $file =~ m!^\Q$path\E/(.+)\.pm\Z!is;
+		my $subpath = $1;
+		return if lc($subpath) eq lc($self->{dispatch});
+
+		$file = "$self->{path}/$subpath.pm";
+		my $pkg = "$self->{name}::$subpath";
+		$pkg =~ s!/!::!g;
+
+		# If we have a mixed-case package name, assume case has been preserved
+		# correctly.  Otherwise, root through the file to locate the case-preserved
+		# version of the package name.
+		if ( $subpath eq lc($subpath) || $subpath eq uc($subpath) ) {
+			my $content = Module::Install::_read($subpath . '.pm');
+			my $in_pod  = 0;
+			foreach ( split //, $content ) {
+				$in_pod = 1 if /^=\w/;
+				$in_pod = 0 if /^=cut/;
+				next if ($in_pod || /^=cut/);  # skip pod text
+				next if /^\s*#/;               # and comments
+				if ( m/^\s*package\s+($pkg)\s*;/i ) {
+					$pkg = $1;
+					last;
+				}
+			}
+		}
+
+		push @found, [ $file, $pkg ];
+	}, $path ) if -d $path;
+
+	@found;
+}
+
+
+
+
+
+#####################################################################
+# Common Utility Functions
+
+sub _caller {
+	my $depth = 0;
+	my $call  = caller($depth);
+	while ( $call eq __PACKAGE__ ) {
+		$depth++;
+		$call = caller($depth);
+	}
+	return $call;
+}
+
+sub _read {
+	local *FH;
+	if ( $] >= 5.006 ) {
+		open( FH, '<', $_[0] ) or die "open($_[0]): $!";
+	} else {
+		open( FH, "< $_[0]"  ) or die "open($_[0]): $!";
+	}
+	my $string = do { local $/; <FH> };
+	close FH or die "close($_[0]): $!";
+	return $string;
+}
+
+sub _readperl {
+	my $string = Module::Install::_read($_[0]);
+	$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/sg;
+	$string =~ s/(\n)\n*__(?:DATA|END)__\b.*\z/$1/s;
+	$string =~ s/\n\n=\w+.+?\n\n=cut\b.+?\n+/\n\n/sg;
+	return $string;
+}
+
+sub _readpod {
+	my $string = Module::Install::_read($_[0]);
+	$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/sg;
+	return $string if $_[0] =~ /\.pod\z/;
+	$string =~ s/(^|\n=cut\b.+?\n+)[^=\s].+?\n(\n=\w+|\z)/$1$2/sg;
+	$string =~ s/\n*=pod\b[^\n]*\n+/\n\n/sg;
+	$string =~ s/\n*=cut\b[^\n]*\n+/\n\n/sg;
+	$string =~ s/^\n+//s;
+	return $string;
+}
+
+sub _write {
+	local *FH;
+	if ( $] >= 5.006 ) {
+		open( FH, '>', $_[0] ) or die "open($_[0]): $!";
+	} else {
+		open( FH, "> $_[0]"  ) or die "open($_[0]): $!";
+	}
+	foreach ( 1 .. $#_ ) {
+		print FH $_[$_] or die "print($_[0]): $!";
+	}
+	close FH or die "close($_[0]): $!";
+}
+
+# _version is for processing module versions (eg, 1.03_05) not
+# Perl versions (eg, 5.8.1).
+sub _version ($) {
+	my $s = shift || 0;
+	my $d =()= $s =~ /(\.)/g;
+	if ( $d >= 2 ) {
+		# Normalise multipart versions
+		$s =~ s/(\.)(\d{1,3})/sprintf("$1%03d",$2)/eg;
+	}
+	$s =~ s/^(\d+)\.?//;
+	my $l = $1 || 0;
+	my @v = map {
+		$_ . '0' x (3 - length $_)
+	} $s =~ /(\d{1,3})\D?/g;
+	$l = $l . '.' . join '', @v if @v;
+	return $l + 0;
+}
+
+sub _cmp ($$) {
+	_version($_[0]) <=> _version($_[1]);
+}
+
+# Cloned from Params::Util::_CLASS
+sub _CLASS ($) {
+	(
+		defined $_[0]
+		and
+		! ref $_[0]
+		and
+		$_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s
+	) ? $_[0] : undef;
+}
+
+1;
+
+# Copyright 2008 - 2009 Adam Kennedy.
diff --git a/src/tcp/test/inc/Module/Install/AutoInstall.pm b/src/tcp/test/inc/Module/Install/AutoInstall.pm
new file mode 100755
index 0000000..58dd026
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/AutoInstall.pm
@@ -0,0 +1,61 @@
+#line 1
+package Module::Install::AutoInstall;
+
+use strict;
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+sub AutoInstall { $_[0] }
+
+sub run {
+    my $self = shift;
+    $self->auto_install_now(@_);
+}
+
+sub write {
+    my $self = shift;
+    $self->auto_install(@_);
+}
+
+sub auto_install {
+    my $self = shift;
+    return if $self->{done}++;
+
+    # Flatten array of arrays into a single array
+    my @core = map @$_, map @$_, grep ref,
+               $self->build_requires, $self->requires;
+
+    my @config = @_;
+
+    # We'll need Module::AutoInstall
+    $self->include('Module::AutoInstall');
+    require Module::AutoInstall;
+
+    Module::AutoInstall->import(
+        (@config ? (-config => \@config) : ()),
+        (@core   ? (-core   => \@core)   : ()),
+        $self->features,
+    );
+
+    $self->makemaker_args( Module::AutoInstall::_make_args() );
+
+    my $class = ref($self);
+    $self->postamble(
+        "# --- $class section:\n" .
+        Module::AutoInstall::postamble()
+    );
+}
+
+sub auto_install_now {
+    my $self = shift;
+    $self->auto_install(@_);
+    Module::AutoInstall::do_install();
+}
+
+1;
diff --git a/src/tcp/test/inc/Module/Install/Base.pm b/src/tcp/test/inc/Module/Install/Base.pm
new file mode 100755
index 0000000..60a74d2
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Base.pm
@@ -0,0 +1,78 @@
+#line 1
+package Module::Install::Base;
+
+use strict 'vars';
+use vars qw{$VERSION};
+BEGIN {
+	$VERSION = '0.91';
+}
+
+# Suspend handler for "redefined" warnings
+BEGIN {
+	my $w = $SIG{__WARN__};
+	$SIG{__WARN__} = sub { $w };
+}
+
+#line 42
+
+sub new {
+	my $class = shift;
+	unless ( defined &{"${class}::call"} ) {
+		*{"${class}::call"} = sub { shift->_top->call(@_) };
+	}
+	unless ( defined &{"${class}::load"} ) {
+		*{"${class}::load"} = sub { shift->_top->load(@_) };
+	}
+	bless { @_ }, $class;
+}
+
+#line 61
+
+sub AUTOLOAD {
+	local $@;
+	my $func = eval { shift->_top->autoload } or return;
+	goto &$func;
+}
+
+#line 75
+
+sub _top {
+	$_[0]->{_top};
+}
+
+#line 90
+
+sub admin {
+	$_[0]->_top->{admin}
+	or
+	Module::Install::Base::FakeAdmin->new;
+}
+
+#line 106
+
+sub is_admin {
+	$_[0]->admin->VERSION;
+}
+
+sub DESTROY {}
+
+package Module::Install::Base::FakeAdmin;
+
+my $fake;
+
+sub new {
+	$fake ||= bless(\@_, $_[0]);
+}
+
+sub AUTOLOAD {}
+
+sub DESTROY {}
+
+# Restore warning handler
+BEGIN {
+	$SIG{__WARN__} = $SIG{__WARN__}->();
+}
+
+1;
+
+#line 154
diff --git a/src/tcp/test/inc/Module/Install/Can.pm b/src/tcp/test/inc/Module/Install/Can.pm
new file mode 100755
index 0000000..e65e4f6
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Can.pm
@@ -0,0 +1,81 @@
+#line 1
+package Module::Install::Can;
+
+use strict;
+use Config                ();
+use File::Spec            ();
+use ExtUtils::MakeMaker   ();
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+# check if we can load some module
+### Upgrade this to not have to load the module if possible
+sub can_use {
+	my ($self, $mod, $ver) = @_;
+	$mod =~ s{::|\\}{/}g;
+	$mod .= '.pm' unless $mod =~ /\.pm$/i;
+
+	my $pkg = $mod;
+	$pkg =~ s{/}{::}g;
+	$pkg =~ s{\.pm$}{}i;
+
+	local $@;
+	eval { require $mod; $pkg->VERSION($ver || 0); 1 };
+}
+
+# check if we can run some command
+sub can_run {
+	my ($self, $cmd) = @_;
+
+	my $_cmd = $cmd;
+	return $_cmd if (-x $_cmd or $_cmd = MM->maybe_command($_cmd));
+
+	for my $dir ((split /$Config::Config{path_sep}/, $ENV{PATH}), '.') {
+		next if $dir eq '';
+		my $abs = File::Spec->catfile($dir, $_[1]);
+		return $abs if (-x $abs or $abs = MM->maybe_command($abs));
+	}
+
+	return;
+}
+
+# can we locate a (the) C compiler
+sub can_cc {
+	my $self   = shift;
+	my @chunks = split(/ /, $Config::Config{cc}) or return;
+
+	# $Config{cc} may contain args; try to find out the program part
+	while (@chunks) {
+		return $self->can_run("@chunks") || (pop(@chunks), next);
+	}
+
+	return;
+}
+
+# Fix Cygwin bug on maybe_command();
+if ( $^O eq 'cygwin' ) {
+	require ExtUtils::MM_Cygwin;
+	require ExtUtils::MM_Win32;
+	if ( ! defined(&ExtUtils::MM_Cygwin::maybe_command) ) {
+		*ExtUtils::MM_Cygwin::maybe_command = sub {
+			my ($self, $file) = @_;
+			if ($file =~ m{^/cygdrive/}i and ExtUtils::MM_Win32->can('maybe_command')) {
+				ExtUtils::MM_Win32->maybe_command($file);
+			} else {
+				ExtUtils::MM_Unix->maybe_command($file);
+			}
+		}
+	}
+}
+
+1;
+
+__END__
+
+#line 156
diff --git a/src/tcp/test/inc/Module/Install/Fetch.pm b/src/tcp/test/inc/Module/Install/Fetch.pm
new file mode 100755
index 0000000..05f2079
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Fetch.pm
@@ -0,0 +1,93 @@
+#line 1
+package Module::Install::Fetch;
+
+use strict;
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+sub get_file {
+    my ($self, %args) = @_;
+    my ($scheme, $host, $path, $file) =
+        $args{url} =~ m|^(\w+)://([^/]+)(.+)/(.+)| or return;
+
+    if ( $scheme eq 'http' and ! eval { require LWP::Simple; 1 } ) {
+        $args{url} = $args{ftp_url}
+            or (warn("LWP support unavailable!\n"), return);
+        ($scheme, $host, $path, $file) =
+            $args{url} =~ m|^(\w+)://([^/]+)(.+)/(.+)| or return;
+    }
+
+    $|++;
+    print "Fetching '$file' from $host... ";
+
+    unless (eval { require Socket; Socket::inet_aton($host) }) {
+        warn "'$host' resolve failed!\n";
+        return;
+    }
+
+    return unless $scheme eq 'ftp' or $scheme eq 'http';
+
+    require Cwd;
+    my $dir = Cwd::getcwd();
+    chdir $args{local_dir} or return if exists $args{local_dir};
+
+    if (eval { require LWP::Simple; 1 }) {
+        LWP::Simple::mirror($args{url}, $file);
+    }
+    elsif (eval { require Net::FTP; 1 }) { eval {
+        # use Net::FTP to get past firewall
+        my $ftp = Net::FTP->new($host, Passive => 1, Timeout => 600);
+        $ftp->login("anonymous", 'anonymous@example.com');
+        $ftp->cwd($path);
+        $ftp->binary;
+        $ftp->get($file) or (warn("$!\n"), return);
+        $ftp->quit;
+    } }
+    elsif (my $ftp = $self->can_run('ftp')) { eval {
+        # no Net::FTP, fallback to ftp.exe
+        require FileHandle;
+        my $fh = FileHandle->new;
+
+        local $SIG{CHLD} = 'IGNORE';
+        unless ($fh->open("|$ftp -n")) {
+            warn "Couldn't open ftp: $!\n";
+            chdir $dir; return;
+        }
+
+        my @dialog = split(/\n/, <<"END_FTP");
+open $host
+user anonymous anonymous\@example.com
+cd $path
+binary
+get $file $file
+quit
+END_FTP
+        foreach (@dialog) { $fh->print("$_\n") }
+        $fh->close;
+    } }
+    else {
+        warn "No working 'ftp' program available!\n";
+        chdir $dir; return;
+    }
+
+    unless (-f $file) {
+        warn "Fetching failed: $@\n";
+        chdir $dir; return;
+    }
+
+    return if exists $args{size} and -s $file != $args{size};
+    system($args{run}) if exists $args{run};
+    unlink($file) if $args{remove};
+
+    print(((!exists $args{check_for} or -e $args{check_for})
+        ? "done!" : "failed! ($!)"), "\n");
+    chdir $dir; return !$?;
+}
+
+1;
diff --git a/src/tcp/test/inc/Module/Install/Include.pm b/src/tcp/test/inc/Module/Install/Include.pm
new file mode 100755
index 0000000..7e792e0
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Include.pm
@@ -0,0 +1,34 @@
+#line 1
+package Module::Install::Include;
+
+use strict;
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+sub include {
+	shift()->admin->include(@_);
+}
+
+sub include_deps {
+	shift()->admin->include_deps(@_);
+}
+
+sub auto_include {
+	shift()->admin->auto_include(@_);
+}
+
+sub auto_include_deps {
+	shift()->admin->auto_include_deps(@_);
+}
+
+sub auto_include_dependent_dists {
+	shift()->admin->auto_include_dependent_dists(@_);
+}
+
+1;
diff --git a/src/tcp/test/inc/Module/Install/Makefile.pm b/src/tcp/test/inc/Module/Install/Makefile.pm
new file mode 100755
index 0000000..98779db
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Makefile.pm
@@ -0,0 +1,268 @@
+#line 1
+package Module::Install::Makefile;
+
+use strict 'vars';
+use ExtUtils::MakeMaker   ();
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+sub Makefile { $_[0] }
+
+my %seen = ();
+
+sub prompt {
+	shift;
+
+	# Infinite loop protection
+	my @c = caller();
+	if ( ++$seen{"$c[1]|$c[2]|$_[0]"} > 3 ) {
+		die "Caught an potential prompt infinite loop ($c[1]|$c[2]|$_[0])";
+	}
+
+	# In automated testing, always use defaults
+	if ( $ENV{AUTOMATED_TESTING} and ! $ENV{PERL_MM_USE_DEFAULT} ) {
+		local $ENV{PERL_MM_USE_DEFAULT} = 1;
+		goto &ExtUtils::MakeMaker::prompt;
+	} else {
+		goto &ExtUtils::MakeMaker::prompt;
+	}
+}
+
+sub makemaker_args {
+	my $self = shift;
+	my $args = ( $self->{makemaker_args} ||= {} );
+	%$args = ( %$args, @_ );
+	return $args;
+}
+
+# For mm args that take multiple space-seperated args,
+# append an argument to the current list.
+sub makemaker_append {
+	my $self = sShift;
+	my $name = shift;
+	my $args = $self->makemaker_args;
+	$args->{name} = defined $args->{$name}
+		? join( ' ', $args->{name}, @_ )
+		: join( ' ', @_ );
+}
+
+sub build_subdirs {
+	my $self    = shift;
+	my $subdirs = $self->makemaker_args->{DIR} ||= [];
+	for my $subdir (@_) {
+		push @$subdirs, $subdir;
+	}
+}
+
+sub clean_files {
+	my $self  = shift;
+	my $clean = $self->makemaker_args->{clean} ||= {};
+	  %$clean = (
+		%$clean,
+		FILES => join ' ', grep { length $_ } ($clean->{FILES} || (), @_),
+	);
+}
+
+sub realclean_files {
+	my $self      = shift;
+	my $realclean = $self->makemaker_args->{realclean} ||= {};
+	  %$realclean = (
+		%$realclean,
+		FILES => join ' ', grep { length $_ } ($realclean->{FILES} || (), @_),
+	);
+}
+
+sub libs {
+	my $self = shift;
+	my $libs = ref $_[0] ? shift : [ shift ];
+	$self->makemaker_args( LIBS => $libs );
+}
+
+sub inc {
+	my $self = shift;
+	$self->makemaker_args( INC => shift );
+}
+
+my %test_dir = ();
+
+sub _wanted_t {
+	/\.t$/ and -f $_ and $test_dir{$File::Find::dir} = 1;
+}
+
+sub tests_recursive {
+	my $self = shift;
+	if ( $self->tests ) {
+		die "tests_recursive will not work if tests are already defined";
+	}
+	my $dir = shift || 't';
+	unless ( -d $dir ) {
+		die "tests_recursive dir '$dir' does not exist";
+	}
+	%test_dir = ();
+	require File::Find;
+	File::Find::find( \&_wanted_t, $dir );
+	$self->tests( join ' ', map { "$_/*.t" } sort keys %test_dir );
+}
+
+sub write {
+	my $self = shift;
+	die "&Makefile->write() takes no arguments\n" if @_;
+
+	# Check the current Perl version
+	my $perl_version = $self->perl_version;
+	if ( $perl_version ) {
+		eval "use $perl_version; 1"
+			or die "ERROR: perl: Version $] is installed, "
+			. "but we need version >= $perl_version";
+	}
+
+	# Make sure we have a new enough MakeMaker
+	require ExtUtils::MakeMaker;
+
+	if ( $perl_version and $self->_cmp($perl_version, '5.006') >= 0 ) {
+		# MakeMaker can complain about module versions that include
+		# an underscore, even though its own version may contain one!
+		# Hence the funny regexp to get rid of it.  See RT #35800
+		# for details.
+		$self->build_requires( 'ExtUtils::MakeMaker' => $ExtUtils::MakeMaker::VERSION =~ /^(\d+\.\d+)/ );
+		$self->configure_requires( 'ExtUtils::MakeMaker' => $ExtUtils::MakeMaker::VERSION =~ /^(\d+\.\d+)/ );
+	} else {
+		# Allow legacy-compatibility with 5.005 by depending on the
+		# most recent EU:MM that supported 5.005.
+		$self->build_requires( 'ExtUtils::MakeMaker' => 6.42 );
+		$self->configure_requires( 'ExtUtils::MakeMaker' => 6.42 );
+	}
+
+	# Generate the MakeMaker params
+	my $args = $self->makemaker_args;
+	$args->{DISTNAME} = $self->name;
+	$args->{NAME}     = $self->module_name || $self->name;
+	$args->{VERSION}  = $self->version;
+	$args->{NAME}     =~ s/-/::/g;
+	if ( $self->tests ) {
+		$args->{test} = { TESTS => $self->tests };
+	}
+	if ( $] >= 5.005 ) {
+		$args->{ABSTRACT} = $self->abstract;
+		$args->{AUTHOR}   = $self->author;
+	}
+	if ( eval($ExtUtils::MakeMaker::VERSION) >= 6.10 ) {
+		$args->{NO_META} = 1;
+	}
+	if ( eval($ExtUtils::MakeMaker::VERSION) > 6.17 and $self->sign ) {
+		$args->{SIGN} = 1;
+	}
+	unless ( $self->is_admin ) {
+		delete $args->{SIGN};
+	}
+
+	# Merge both kinds of requires into prereq_pm
+	my $prereq = ($args->{PREREQ_PM} ||= {});
+	%$prereq = ( %$prereq,
+		map { @$_ }
+		map { @$_ }
+		grep $_,
+		($self->configure_requires, $self->build_requires, $self->requires)
+	);
+
+	# Remove any reference to perl, PREREQ_PM doesn't support it
+	delete $args->{PREREQ_PM}->{perl};
+
+	# merge both kinds of requires into prereq_pm
+	my $subdirs = ($args->{DIR} ||= []);
+	if ($self->bundles) {
+		foreach my $bundle (@{ $self->bundles }) {
+			my ($file, $dir) = @$bundle;
+			push @$subdirs, $dir if -d $dir;
+			delete $prereq->{$file};
+		}
+	}
+
+	if ( my $perl_version = $self->perl_version ) {
+		eval "use $perl_version; 1"
+			or die "ERROR: perl: Version $] is installed, "
+			. "but we need version >= $perl_version";
+	}
+
+	$args->{INSTALLDIRS} = $self->installdirs;
+
+	my %args = map { ( $_ => $args->{$_} ) } grep {defined($args->{$_})} keys %$args;
+
+	my $user_preop = delete $args{dist}->{PREOP};
+	if (my $preop = $self->admin->preop($user_preop)) {
+		foreach my $key ( keys %$preop ) {
+			$args{dist}->{$key} = $preop->{$key};
+		}
+	}
+
+	my $mm = ExtUtils::MakeMaker::WriteMakefile(%args);
+	$self->fix_up_makefile($mm->{FIRST_MAKEFILE} || 'Makefile');
+}
+
+sub fix_up_makefile {
+	my $self          = shift;
+	my $makefile_name = shift;
+	my $top_class     = ref($self->_top) || '';
+	my $top_version   = $self->_top->VERSION || '';
+
+	my $preamble = $self->preamble
+		? "# Preamble by $top_class $top_version\n"
+			. $self->preamble
+		: '';
+	my $postamble = "# Postamble by $top_class $top_version\n"
+		. ($self->postamble || '');
+
+	local *MAKEFILE;
+	open MAKEFILE, "< $makefile_name" or die "fix_up_makefile: Couldn't open $makefile_name: $!";
+	my $makefile = do { local $/; <MAKEFILE> };
+	close MAKEFILE or die $!;
+
+	$makefile =~ s/\b(test_harness\(\$\(TEST_VERBOSE\), )/$1'inc', /;
+	$makefile =~ s/( -I\$\(INST_ARCHLIB\))/ -Iinc$1/g;
+	$makefile =~ s/( "-I\$\(INST_LIB\)")/ "-Iinc"$1/g;
+	$makefile =~ s/^(FULLPERL = .*)/$1 "-Iinc"/m;
+	$makefile =~ s/^(PERL = .*)/$1 "-Iinc"/m;
+
+	# Module::Install will never be used to build the Core Perl
+	# Sometimes PERL_LIB and PERL_ARCHLIB get written anyway, which breaks
+	# PREFIX/PERL5LIB, and thus, install_share. Blank them if they exist
+	$makefile =~ s/^PERL_LIB = .+/PERL_LIB =/m;
+	#$makefile =~ s/^PERL_ARCHLIB = .+/PERL_ARCHLIB =/m;
+
+	# Perl 5.005 mentions PERL_LIB explicitly, so we have to remove that as well.
+	$makefile =~ s/(\"?)-I\$\(PERL_LIB\)\1//g;
+
+	# XXX - This is currently unused; not sure if it breaks other MM-users
+	# $makefile =~ s/^pm_to_blib\s+:\s+/pm_to_blib :: /mg;
+
+	open  MAKEFILE, "> $makefile_name" or die "fix_up_makefile: Couldn't open $makefile_name: $!";
+	print MAKEFILE  "$preamble$makefile$postamble" or die $!;
+	close MAKEFILE  or die $!;
+
+	1;
+}
+
+sub preamble {
+	my ($self, $text) = @_;
+	$self->{preamble} = $text . $self->{preamble} if defined $text;
+	$self->{preamble};
+}
+
+sub postamble {
+	my ($self, $text) = @_;
+	$self->{postamble} ||= $self->admin->postamble;
+	$self->{postamble} .= $text if defined $text;
+	$self->{postamble}
+}
+
+1;
+
+__END__
+
+#line 394
diff --git a/src/tcp/test/inc/Module/Install/Metadata.pm b/src/tcp/test/inc/Module/Install/Metadata.pm
new file mode 100755
index 0000000..653193d
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Metadata.pm
@@ -0,0 +1,624 @@
+#line 1
+package Module::Install::Metadata;
+
+use strict 'vars';
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+my @boolean_keys = qw{
+	sign
+};
+
+my @scalar_keys = qw{
+	name
+	module_name
+	abstract
+	author
+	version
+	distribution_type
+	tests
+	installdirs
+};
+
+my @tuple_keys = qw{
+	configure_requires
+	build_requires
+	requires
+	recommends
+	bundles
+	resources
+};
+
+my @resource_keys = qw{
+	homepage
+	bugtracker
+	repository
+};
+
+my @array_keys = qw{
+	keywords
+};
+
+sub Meta              { shift          }
+sub Meta_BooleanKeys  { @boolean_keys  }
+sub Meta_ScalarKeys   { @scalar_keys   }
+sub Meta_TupleKeys    { @tuple_keys    }
+sub Meta_ResourceKeys { @resource_keys }
+sub Meta_ArrayKeys    { @array_keys    }
+
+foreach my $key ( @boolean_keys ) {
+	*$key = sub {
+		my $self = shift;
+		if ( defined wantarray and not @_ ) {
+			return $self->{values}->{$key};
+		}
+		$self->{values}->{$key} = ( @_ ? $_[0] : 1 );
+		return $self;
+	};
+}
+
+foreach my $key ( @scalar_keys ) {
+	*$key = sub {
+		my $self = shift;
+		return $self->{values}->{$key} if defined wantarray and !@_;
+		$self->{values}->{$key} = shift;
+		return $self;
+	};
+}
+
+foreach my $key ( @array_keys ) {
+	*$key = sub {
+		my $self = shift;
+		return $self->{values}->{$key} if defined wantarray and !@_;
+		$self->{values}->{$key} ||= [];
+		push @{$self->{values}->{$key}}, @_;
+		return $self;
+	};
+}
+
+foreach my $key ( @resource_keys ) {
+	*$key = sub {
+		my $self = shift;
+		unless ( @_ ) {
+			return () unless $self->{values}->{resources};
+			return map  { $_->[1] }
+			       grep { $_->[0] eq $key }
+			       @{ $self->{values}->{resources} };
+		}
+		return $self->{values}->{resources}->{$key} unless @_;
+		my $uri = shift or die(
+			"Did not provide a value to $key()"
+		);
+		$self->resources( $key => $uri );
+		return 1;
+	};
+}
+
+foreach my $key ( grep { $_ ne "resources" } @tuple_keys) {
+	*$key = sub {
+		my $self = shift;
+		return $self->{values}->{$key} unless @_;
+		my @added;
+		while ( @_ ) {
+			my $module  = shift or last;
+			my $version = shift || 0;
+			push @added, [ $module, $version ];
+		}
+		push @{ $self->{values}->{$key} }, @added;
+		return map {@$_} @added;
+	};
+}
+
+# Resource handling
+my %lc_resource = map { $_ => 1 } qw{
+	homepage
+	license
+	bugtracker
+	repository
+};
+
+sub resources {
+	my $self = shift;
+	while ( @_ ) {
+		my $name  = shift or last;
+		my $value = shift or next;
+		if ( $name eq lc $name and ! $lc_resource{$name} ) {
+			die("Unsupported reserved lowercase resource '$name'");
+		}
+		$self->{values}->{resources} ||= [];
+		push @{ $self->{values}->{resources} }, [ $name, $value ];
+	}
+	$self->{values}->{resources};
+}
+
+# Aliases for build_requires that will have alternative
+# meanings in some future version of META.yml.
+sub test_requires     { shift->build_requires(@_) }
+sub install_requires  { shift->build_requires(@_) }
+
+# Aliases for installdirs options
+sub install_as_core   { $_[0]->installdirs('perl')   }
+sub install_as_cpan   { $_[0]->installdirs('site')   }
+sub install_as_site   { $_[0]->installdirs('site')   }
+sub install_as_vendor { $_[0]->installdirs('vendor') }
+
+sub dynamic_config {
+	my $self = shift;
+	unless ( @_ ) {
+		warn "You MUST provide an explicit true/false value to dynamic_config\n";
+		return $self;
+	}
+	$self->{values}->{dynamic_config} = $_[0] ? 1 : 0;
+	return 1;
+}
+
+sub perl_version {
+	my $self = shift;
+	return $self->{values}->{perl_version} unless @_;
+	my $version = shift or die(
+		"Did not provide a value to perl_version()"
+	);
+
+	# Normalize the version
+	$version = $self->_perl_version($version);
+
+	# We don't support the reall old versions
+	unless ( $version >= 5.005 ) {
+		die "Module::Install only supports 5.005 or newer (use ExtUtils::MakeMaker)\n";
+	}
+
+	$self->{values}->{perl_version} = $version;
+}
+
+#Stolen from M::B
+my %license_urls = (
+    perl         => 'http://dev.perl.org/licenses/',
+    apache       => 'http://apache.org/licenses/LICENSE-2.0',
+    artistic     => 'http://opensource.org/licenses/artistic-license.php',
+    artistic_2   => 'http://opensource.org/licenses/artistic-license-2.0.php',
+    lgpl         => 'http://opensource.org/licenses/lgpl-license.php',
+    lgpl2        => 'http://opensource.org/licenses/lgpl-2.1.php',
+    lgpl3        => 'http://opensource.org/licenses/lgpl-3.0.html',
+    bsd          => 'http://opensource.org/licenses/bsd-license.php',
+    gpl          => 'http://opensource.org/licenses/gpl-license.php',
+    gpl2         => 'http://opensource.org/licenses/gpl-2.0.php',
+    gpl3         => 'http://opensource.org/licenses/gpl-3.0.html',
+    mit          => 'http://opensource.org/licenses/mit-license.php',
+    mozilla      => 'http://opensource.org/licenses/mozilla1.1.php',
+    open_source  => undef,
+    unrestricted => undef,
+    restrictive  => undef,
+    unknown      => undef,
+);
+
+sub license {
+	my $self = shift;
+	return $self->{values}->{license} unless @_;
+	my $license = shift or die(
+		'Did not provide a value to license()'
+	);
+	$self->{values}->{license} = $license;
+
+	# Automatically fill in license URLs
+	if ( $license_urls{$license} ) {
+		$self->resources( license => $license_urls{$license} );
+	}
+
+	return 1;
+}
+
+sub all_from {
+	my ( $self, $file ) = @_;
+
+	unless ( defined($file) ) {
+		my $name = $self->name or die(
+			"all_from called with no args without setting name() first"
+		);
+		$file = join('/', 'lib', split(/-/, $name)) . '.pm';
+		$file =~ s{.*/}{} unless -e $file;
+		unless ( -e $file ) {
+			die("all_from cannot find $file from $name");
+		}
+	}
+	unless ( -f $file ) {
+		die("The path '$file' does not exist, or is not a file");
+	}
+
+	# Some methods pull from POD instead of code.
+	# If there is a matching .pod, use that instead
+	my $pod = $file;
+	$pod =~ s/\.pm$/.pod/i;
+	$pod = $file unless -e $pod;
+
+	# Pull the different values
+	$self->name_from($file)         unless $self->name;
+	$self->version_from($file)      unless $self->version;
+	$self->perl_version_from($file) unless $self->perl_version;
+	$self->author_from($pod)        unless $self->author;
+	$self->license_from($pod)       unless $self->license;
+	$self->abstract_from($pod)      unless $self->abstract;
+
+	return 1;
+}
+
+sub provides {
+	my $self     = shift;
+	my $provides = ( $self->{values}->{provides} ||= {} );
+	%$provides = (%$provides, @_) if @_;
+	return $provides;
+}
+
+sub auto_provides {
+	my $self = shift;
+	return $self unless $self->is_admin;
+	unless (-e 'MANIFEST') {
+		warn "Cannot deduce auto_provides without a MANIFEST, skipping\n";
+		return $self;
+	}
+	# Avoid spurious warnings as we are not checking manifest here.
+	local $SIG{__WARN__} = sub {1};
+	require ExtUtils::Manifest;
+	local *ExtUtils::Manifest::manicheck = sub { return };
+
+	require Module::Build;
+	my $build = Module::Build->new(
+		dist_name    => $self->name,
+		dist_version => $self->version,
+		license      => $self->license,
+	);
+	$self->provides( %{ $build->find_dist_packages || {} } );
+}
+
+sub feature {
+	my $self     = shift;
+	my $name     = shift;
+	my $features = ( $self->{values}->{features} ||= [] );
+	my $mods;
+
+	if ( @_ == 1 and ref( $_[0] ) ) {
+		# The user used ->feature like ->features by passing in the second
+		# argument as a reference.  Accomodate for that.
+		$mods = $_[0];
+	} else {
+		$mods = \@_;
+	}
+
+	my $count = 0;
+	push @$features, (
+		$name => [
+			map {
+				ref($_) ? ( ref($_) eq 'HASH' ) ? %$_ : @$_ : $_
+			} @$mods
+		]
+	);
+
+	return @$features;
+}
+
+sub features {
+	my $self = shift;
+	while ( my ( $name, $mods ) = splice( @_, 0, 2 ) ) {
+		$self->feature( $name, @$mods );
+	}
+	return $self->{values}->{features}
+		? @{ $self->{values}->{features} }
+		: ();
+}
+
+sub no_index {
+	my $self = shift;
+	my $type = shift;
+	push @{ $self->{values}->{no_index}->{$type} }, @_ if $type;
+	return $self->{values}->{no_index};
+}
+
+sub read {
+	my $self = shift;
+	$self->include_deps( 'YAML::Tiny', 0 );
+
+	require YAML::Tiny;
+	my $data = YAML::Tiny::LoadFile('META.yml');
+
+	# Call methods explicitly in case user has already set some values.
+	while ( my ( $key, $value ) = each %$data ) {
+		next unless $self->can($key);
+		if ( ref $value eq 'HASH' ) {
+			while ( my ( $module, $version ) = each %$value ) {
+				$self->can($key)->($self, $module => $version );
+			}
+		} else {
+			$self->can($key)->($self, $value);
+		}
+	}
+	return $self;
+}
+
+sub write {
+	my $self = shift;
+	return $self unless $self->is_admin;
+	$self->admin->write_meta;
+	return $self;
+}
+
+sub version_from {
+	require ExtUtils::MM_Unix;
+	my ( $self, $file ) = @_;
+	$self->version( ExtUtils::MM_Unix->parse_version($file) );
+}
+
+sub abstract_from {
+	require ExtUtils::MM_Unix;
+	my ( $self, $file ) = @_;
+	$self->abstract(
+		bless(
+			{ DISTNAME => $self->name },
+			'ExtUtils::MM_Unix'
+		)->parse_abstract($file)
+	 );
+}
+
+# Add both distribution and module name
+sub name_from {
+	my ($self, $file) = @_;
+	if (
+		Module::Install::_read($file) =~ m/
+		^ \s*
+		package \s*
+		([\w:]+)
+		\s* ;
+		/ixms
+	) {
+		my ($name, $module_name) = ($1, $1);
+		$name =~ s{::}{-}g;
+		$self->name($name);
+		unless ( $self->module_name ) {
+			$self->module_name($module_name);
+		}
+	} else {
+		die("Cannot determine name from $file\n");
+	}
+}
+
+sub perl_version_from {
+	my $self = shift;
+	if (
+		Module::Install::_read($_[0]) =~ m/
+		^
+		(?:use|require) \s*
+		v?
+		([\d_\.]+)
+		\s* ;
+		/ixms
+	) {
+		my $perl_version = $1;
+		$perl_version =~ s{_}{}g;
+		$self->perl_version($perl_version);
+	} else {
+		warn "Cannot determine perl version info from $_[0]\n";
+		return;
+	}
+}
+
+sub author_from {
+	my $self    = shift;
+	my $content = Module::Install::_read($_[0]);
+	if ($content =~ m/
+		=head \d \s+ (?:authors?)\b \s*
+		([^\n]*)
+		|
+		=head \d \s+ (?:licen[cs]e|licensing|copyright|legal)\b \s*
+		.*? copyright .*? \d\d\d[\d.]+ \s* (?:\bby\b)? \s*
+		([^\n]*)
+	/ixms) {
+		my $author = $1 || $2;
+		$author =~ s{E<lt>}{<}g;
+		$author =~ s{E<gt>}{>}g;
+		$self->author($author);
+	} else {
+		warn "Cannot determine author info from $_[0]\n";
+	}
+}
+
+sub license_from {
+	my $self = shift;
+	if (
+		Module::Install::_read($_[0]) =~ m/
+		(
+			=head \d \s+
+			(?:licen[cs]e|licensing|copyright|legal)\b
+			.*?
+		)
+		(=head\\d.*|=cut.*|)
+		\z
+	/ixms ) {
+		my $license_text = $1;
+		my @phrases      = (
+			'under the same (?:terms|license) as (?:perl|the perl programming language) itself' => 'perl', 1,
+			'GNU general public license'         => 'gpl',         1,
+			'GNU public license'                 => 'gpl',         1,
+			'GNU lesser general public license'  => 'lgpl',        1,
+			'GNU lesser public license'          => 'lgpl',        1,
+			'GNU library general public license' => 'lgpl',        1,
+			'GNU library public license'         => 'lgpl',        1,
+			'BSD license'                        => 'bsd',         1,
+			'Artistic license'                   => 'artistic',    1,
+			'GPL'                                => 'gpl',         1,
+			'LGPL'                               => 'lgpl',        1,
+			'BSD'                                => 'bsd',         1,
+			'Artistic'                           => 'artistic',    1,
+			'MIT'                                => 'mit',         1,
+			'proprietary'                        => 'proprietary', 0,
+		);
+		while ( my ($pattern, $license, $osi) = splice(@phrases, 0, 3) ) {
+			$pattern =~ s{\s+}{\\s+}g;
+			if ( $license_text =~ /\b$pattern\b/i ) {
+				$self->license($license);
+				return 1;
+			}
+		}
+	}
+
+	warn "Cannot determine license info from $_[0]\n";
+	return 'unknown';
+}
+
+sub _extract_bugtracker {
+	my @links   = $_[0] =~ m#L<(\Qhttp://rt.cpan.org/\E[^>]+)>#g;
+	my %links;
+	@links{@links}=();
+	@links=keys %links;
+	return @links;
+}
+
+sub bugtracker_from {
+	my $self    = shift;
+	my $content = Module::Install::_read($_[0]);
+	my @links   = _extract_bugtracker($content);
+	unless ( @links ) {
+		warn "Cannot determine bugtracker info from $_[0]\n";
+		return 0;
+	}
+	if ( @links > 1 ) {
+		warn "Found more than on rt.cpan.org link in $_[0]\n";
+		return 0;
+	}
+
+	# Set the bugtracker
+	bugtracker( $links[0] );
+	return 1;
+}
+
+sub requires_from {
+	my $self     = shift;
+	my $content  = Module::Install::_readperl($_[0]);
+	my @requires = $content =~ m/^use\s+([^\W\d]\w*(?:::\w+)*)\s+([\d\.]+)/mg;
+	while ( @requires ) {
+		my $module  = shift @requires;
+		my $version = shift @requires;
+		$self->requires( $module => $version );
+	}
+}
+
+sub test_requires_from {
+	my $self     = shift;
+	my $content  = Module::Install::_readperl($_[0]);
+	my @requires = $content =~ m/^use\s+([^\W\d]\w*(?:::\w+)*)\s+([\d\.]+)/mg;
+	while ( @requires ) {
+		my $module  = shift @requires;
+		my $version = shift @requires;
+		$self->test_requires( $module => $version );
+	}
+}
+
+# Convert triple-part versions (eg, 5.6.1 or 5.8.9) to
+# numbers (eg, 5.006001 or 5.008009).
+# Also, convert double-part versions (eg, 5.8)
+sub _perl_version {
+	my $v = $_[-1];
+	$v =~ s/^([1-9])\.([1-9]\d?\d?)$/sprintf("%d.%03d",$1,$2)/e;
+	$v =~ s/^([1-9])\.([1-9]\d?\d?)\.(0|[1-9]\d?\d?)$/sprintf("%d.%03d%03d",$1,$2,$3 || 0)/e;
+	$v =~ s/(\.\d\d\d)000$/$1/;
+	$v =~ s/_.+$//;
+	if ( ref($v) ) {
+		# Numify
+		$v = $v + 0;
+	}
+	return $v;
+}
+
+
+
+
+
+######################################################################
+# MYMETA Support
+
+sub WriteMyMeta {
+	die "WriteMyMeta has been deprecated";
+}
+
+sub write_mymeta_yaml {
+	my $self = shift;
+
+	# We need YAML::Tiny to write the MYMETA.yml file
+	unless ( eval { require YAML::Tiny; 1; } ) {
+		return 1;
+	}
+
+	# Generate the data
+	my $meta = $self->_write_mymeta_data or return 1;
+
+	# Save as the MYMETA.yml file
+	print "Writing MYMETA.yml\n";
+	YAML::Tiny::DumpFile('MYMETA.yml', $meta);
+}
+
+sub write_mymeta_json {
+	my $self = shift;
+
+	# We need JSON to write the MYMETA.json file
+	unless ( eval { require JSON; 1; } ) {
+		return 1;
+	}
+
+	# Generate the data
+	my $meta = $self->_write_mymeta_data or return 1;
+
+	# Save as the MYMETA.yml file
+	print "Writing MYMETA.json\n";
+	Module::Install::_write(
+		'MYMETA.json',
+		JSON->new->pretty(1)->canonical->encode($meta),
+	);
+}
+
+sub _write_mymeta_data {
+	my $self = shift;
+
+	# If there's no existing META.yml there is nothing we can do
+	return undef unless -f 'META.yml';
+
+	# We need Parse::CPAN::Meta to load the file
+	unless ( eval { require Parse::CPAN::Meta; 1; } ) {
+		return undef;
+	}
+
+	# Merge the perl version into the dependencies
+	my $val  = $self->Meta->{values};
+	my $perl = delete $val->{perl_version};
+	if ( $perl ) {
+		$val->{requires} ||= [];
+		my $requires = $val->{requires};
+
+		# Canonize to three-dot version after Perl 5.6
+		if ( $perl >= 5.006 ) {
+			$perl =~ s{^(\d+)\.(\d\d\d)(\d*)}{join('.', $1, int($2||0), int($3||0))}e
+		}
+		unshift @$requires, [ perl => $perl ];
+	}
+
+	# Load the advisory META.yml file
+	my @yaml = Parse::CPAN::Meta::LoadFile('META.yml');
+	my $meta = $yaml[0];
+
+	# Overwrite the non-configure dependency hashs
+	delete $meta->{requires};
+	delete $meta->{build_requires};
+	delete $meta->{recommends};
+	if ( exists $val->{requires} ) {
+		$meta->{requires} = { map { @$_ } @{ $val->{requires} } };
+	}
+	if ( exists $val->{build_requires} ) {
+		$meta->{build_requires} = { map { @$_ } @{ $val->{build_requires} } };
+	}
+
+	return $meta;
+}
+
+1;
diff --git a/src/tcp/test/inc/Module/Install/TestBase.pm b/src/tcp/test/inc/Module/Install/TestBase.pm
new file mode 100755
index 0000000..b3f12ea
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/TestBase.pm
@@ -0,0 +1,29 @@
+#line 1
+package Module::Install::TestBase;
+use strict;
+use warnings;
+
+use Module::Install::Base;
+
+use vars qw($VERSION @ISA);
+BEGIN {
+    $VERSION = '0.11';
+    @ISA     = 'Module::Install::Base';
+}
+
+sub use_test_base {
+    my $self = shift;
+    $self->include('Test::Base');
+    $self->include('Test::Base::Filter');
+    $self->include('Spiffy');
+    $self->include('Test::More');
+    $self->include('Test::Builder');
+    $self->include('Test::Builder::Module');
+    $self->requires('Filter::Util::Call');
+}
+
+1;
+
+=encoding utf8
+
+#line 70
diff --git a/src/tcp/test/inc/Module/Install/Win32.pm b/src/tcp/test/inc/Module/Install/Win32.pm
new file mode 100755
index 0000000..f2f99df
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/Win32.pm
@@ -0,0 +1,64 @@
+#line 1
+package Module::Install::Win32;
+
+use strict;
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';
+	@ISA     = 'Module::Install::Base';
+	$ISCORE  = 1;
+}
+
+# determine if the user needs nmake, and download it if needed
+sub check_nmake {
+	my $self = shift;
+	$self->load('can_run');
+	$self->load('get_file');
+
+	require Config;
+	return unless (
+		$^O eq 'MSWin32'                     and
+		$Config::Config{make}                and
+		$Config::Config{make} =~ /^nmake\b/i and
+		! $self->can_run('nmake')
+	);
+
+	print "The required 'nmake' executable not found, fetching it...\n";
+
+	require File::Basename;
+	my $rv = $self->get_file(
+		url       => 'http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/Nmake15.exe',
+		ftp_url   => 'ftp://ftp.microsoft.com/Softlib/MSLFILES/Nmake15.exe',
+		local_dir => File::Basename::dirname($^X),
+		size      => 51928,
+		run       => 'Nmake15.exe /o > nul',
+		check_for => 'Nmake.exe',
+		remove    => 1,
+	);
+
+	die <<'END_MESSAGE' unless $rv;
+
+-------------------------------------------------------------------------------
+
+Since you are using Microsoft Windows, you will need the 'nmake' utility
+before installation. It's available at:
+
+  http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/Nmake15.exe
+      or
+  ftp://ftp.microsoft.com/Softlib/MSLFILES/Nmake15.exe
+
+Please download the file manually, save it to a directory in %PATH% (e.g.
+C:\WINDOWS\COMMAND\), then launch the MS-DOS command line shell, "cd" to
+that directory, and run "Nmake15.exe" from there; that will create the
+'nmake.exe' file needed by this module.
+
+You may then resume the installation process described in README.
+
+-------------------------------------------------------------------------------
+END_MESSAGE
+
+}
+
+1;
diff --git a/src/tcp/test/inc/Module/Install/WriteAll.pm b/src/tcp/test/inc/Module/Install/WriteAll.pm
new file mode 100755
index 0000000..12471e5
--- /dev/null
+++ b/src/tcp/test/inc/Module/Install/WriteAll.pm
@@ -0,0 +1,60 @@
+#line 1
+package Module::Install::WriteAll;
+
+use strict;
+use Module::Install::Base ();
+
+use vars qw{$VERSION @ISA $ISCORE};
+BEGIN {
+	$VERSION = '0.91';;
+	@ISA     = qw{Module::Install::Base};
+	$ISCORE  = 1;
+}
+
+sub WriteAll {
+	my $self = shift;
+	my %args = (
+		meta        => 1,
+		sign        => 0,
+		inline      => 0,
+		check_nmake => 1,
+		@_,
+	);
+
+	$self->sign(1)                if $args{sign};
+	$self->admin->WriteAll(%args) if $self->is_admin;
+
+	$self->check_nmake if $args{check_nmake};
+	unless ( $self->makemaker_args->{PL_FILES} ) {
+		$self->makemaker_args( PL_FILES => {} );
+	}
+
+	# Until ExtUtils::MakeMaker support MYMETA.yml, make sure
+	# we clean it up properly ourself.
+	$self->realclean_files('MYMETA.yml');
+
+	if ( $args{inline} ) {
+		$self->Inline->write;
+	} else {
+		$self->Makefile->write;
+	}
+
+	# The Makefile write process adds a couple of dependencies,
+	# so write the META.yml files after the Makefile.
+	if ( $args{meta} ) {
+		$self->Meta->write;
+	}
+
+	# Experimental support for MYMETA
+	if ( $ENV{X_MYMETA} ) {
+		if ( $ENV{X_MYMETA} eq 'JSON' ) {
+			$self->Meta->write_mymeta_json;
+		} else {
+			$self->Meta->write_mymeta_yaml;
+		}
+	}
+
+	return 1;
+}
+
+1;
diff --git a/src/tcp/test/inc/Spiffy.pm b/src/tcp/test/inc/Spiffy.pm
new file mode 100755
index 0000000..7b10f7a
--- /dev/null
+++ b/src/tcp/test/inc/Spiffy.pm
@@ -0,0 +1,539 @@
+#line 1
+package Spiffy;
+use strict;
+use 5.006001;
+use warnings;
+use Carp;
+require Exporter;
+our $VERSION = '0.30';
+our @EXPORT = ();
+our @EXPORT_BASE = qw(field const stub super);
+our @EXPORT_OK = (@EXPORT_BASE, qw(id WWW XXX YYY ZZZ));
+our %EXPORT_TAGS = (XXX => [qw(WWW XXX YYY ZZZ)]);
+
+my $stack_frame = 0; 
+my $dump = 'yaml';
+my $bases_map = {};
+
+sub WWW; sub XXX; sub YYY; sub ZZZ;
+
+# This line is here to convince "autouse" into believing we are autousable.
+sub can {
+    ($_[1] eq 'import' and caller()->isa('autouse'))
+        ? \&Exporter::import        # pacify autouse's equality test
+        : $_[0]->SUPER::can($_[1])  # normal case
+}
+
+# TODO
+#
+# Exported functions like field and super should be hidden so as not to
+# be confused with methods that can be inherited.
+#
+
+sub new {
+    my $class = shift;
+    $class = ref($class) || $class;
+    my $self = bless {}, $class;
+    while (@_) {
+        my $method = shift;
+        $self->$method(shift);
+    }
+    return $self;    
+}
+
+my $filtered_files = {};
+my $filter_dump = 0;
+my $filter_save = 0;
+our $filter_result = '';
+sub import {
+    no strict 'refs'; 
+    no warnings;
+    my $self_package = shift;
+
+    # XXX Using parse_arguments here might cause confusion, because the
+    # subclass's boolean_arguments and paired_arguments can conflict, causing
+    # difficult debugging. Consider using something truly local.
+    my ($args, @export_list) = do {
+        local *boolean_arguments = sub { 
+            qw(
+                -base -Base -mixin -selfless 
+                -XXX -dumper -yaml 
+                -filter_dump -filter_save
+            ) 
+        };
+        local *paired_arguments = sub { qw(-package) };
+        $self_package->parse_arguments(@_);
+    };
+    return spiffy_mixin_import(scalar(caller(0)), $self_package, @export_list)
+      if $args->{-mixin};
+
+    $filter_dump = 1 if $args->{-filter_dump};
+    $filter_save = 1 if $args->{-filter_save};
+    $dump = 'yaml' if $args->{-yaml};
+    $dump = 'dumper' if $args->{-dumper};
+
+    local @EXPORT_BASE = @EXPORT_BASE;
+
+    if ($args->{-XXX}) {
+        push @EXPORT_BASE, @{$EXPORT_TAGS{XXX}}
+          unless grep /^XXX$/, @EXPORT_BASE;
+    }
+
+    spiffy_filter() 
+      if ($args->{-selfless} or $args->{-Base}) and 
+         not $filtered_files->{(caller($stack_frame))[1]}++;
+
+    my $caller_package = $args->{-package} || caller($stack_frame);
+    push @{"$caller_package\::ISA"}, $self_package
+      if $args->{-Base} or $args->{-base};
+
+    for my $class (@{all_my_bases($self_package)}) {
+        next unless $class->isa('Spiffy');
+        my @export = grep {
+            not defined &{"$caller_package\::$_"};
+        } ( @{"$class\::EXPORT"}, 
+            ($args->{-Base} or $args->{-base})
+              ? @{"$class\::EXPORT_BASE"} : (),
+          );
+        my @export_ok = grep {
+            not defined &{"$caller_package\::$_"};
+        } @{"$class\::EXPORT_OK"};
+
+        # Avoid calling the expensive Exporter::export 
+        # if there is nothing to do (optimization)
+        my %exportable = map { ($_, 1) } @export, @export_ok;
+        next unless keys %exportable;
+
+        my @export_save = @{"$class\::EXPORT"};
+        my @export_ok_save = @{"$class\::EXPORT_OK"};
+        @{"$class\::EXPORT"} = @export;
+        @{"$class\::EXPORT_OK"} = @export_ok;
+        my @list = grep {
+            (my $v = $_) =~ s/^[\!\:]//;
+            $exportable{$v} or ${"$class\::EXPORT_TAGS"}{$v};
+        } @export_list;
+        Exporter::export($class, $caller_package, @list);
+        @{"$class\::EXPORT"} = @export_save;
+        @{"$class\::EXPORT_OK"} = @export_ok_save;
+    }
+}
+
+sub spiffy_filter {
+    require Filter::Util::Call;
+    my $done = 0;
+    Filter::Util::Call::filter_add(
+        sub {
+            return 0 if $done;
+            my ($data, $end) = ('', '');
+            while (my $status = Filter::Util::Call::filter_read()) {
+                return $status if $status < 0;
+                if (/^__(?:END|DATA)__\r?$/) {
+                    $end = $_;
+                    last;
+                }
+                $data .= $_;
+                $_ = '';
+            }
+            $_ = $data;
+            my @my_subs;
+            s[^(sub\s+\w+\s+\{)(.*\n)]
+             [${1}my \$self = shift;$2]gm;
+            s[^(sub\s+\w+)\s*\(\s*\)(\s+\{.*\n)]
+             [${1}${2}]gm;
+            s[^my\s+sub\s+(\w+)(\s+\{)(.*)((?s:.*?\n))\}\n]
+             [push @my_subs, $1; "\$$1 = sub$2my \$self = shift;$3$4\};\n"]gem;
+            my $preclare = '';
+            if (@my_subs) {
+                $preclare = join ',', map "\$$_", @my_subs;
+                $preclare = "my($preclare);";
+            }
+            $_ = "use strict;use warnings;$preclare${_};1;\n$end";
+            if ($filter_dump) { print; exit }
+            if ($filter_save) { $filter_result = $_; $_ = $filter_result; }
+            $done = 1;
+        }
+    );
+}
+
+sub base {
+    push @_, -base;
+    goto &import;
+}
+
+sub all_my_bases {
+    my $class = shift;
+
+    return $bases_map->{$class} 
+      if defined $bases_map->{$class};
+
+    my @bases = ($class);
+    no strict 'refs';
+    for my $base_class (@{"${class}::ISA"}) {
+        push @bases, @{all_my_bases($base_class)};
+    }
+    my $used = {};
+    $bases_map->{$class} = [grep {not $used->{$_}++} @bases];
+}
+
+my %code = ( 
+    sub_start => 
+      "sub {\n",
+    set_default => 
+      "  \$_[0]->{%s} = %s\n    unless exists \$_[0]->{%s};\n",
+    init =>
+      "  return \$_[0]->{%s} = do { my \$self = \$_[0]; %s }\n" .
+      "    unless \$#_ > 0 or defined \$_[0]->{%s};\n",
+    weak_init =>
+      "  return do {\n" .
+      "    \$_[0]->{%s} = do { my \$self = \$_[0]; %s };\n" .
+      "    Scalar::Util::weaken(\$_[0]->{%s}) if ref \$_[0]->{%s};\n" .
+      "    \$_[0]->{%s};\n" .
+      "  } unless \$#_ > 0 or defined \$_[0]->{%s};\n",
+    return_if_get => 
+      "  return \$_[0]->{%s} unless \$#_ > 0;\n",
+    set => 
+      "  \$_[0]->{%s} = \$_[1];\n",
+    weaken => 
+      "  Scalar::Util::weaken(\$_[0]->{%s}) if ref \$_[0]->{%s};\n",
+    sub_end => 
+      "  return \$_[0]->{%s};\n}\n",
+);
+
+sub field {
+    my $package = caller;
+    my ($args, @values) = do {
+        no warnings;
+        local *boolean_arguments = sub { (qw(-weak)) };
+        local *paired_arguments = sub { (qw(-package -init)) };
+        Spiffy->parse_arguments(@_);
+    };
+    my ($field, $default) = @values;
+    $package = $args->{-package} if defined $args->{-package};
+    die "Cannot have a default for a weakened field ($field)"
+        if defined $default && $args->{-weak};
+    return if defined &{"${package}::$field"};
+    require Scalar::Util if $args->{-weak};
+    my $default_string =
+        ( ref($default) eq 'ARRAY' and not @$default )
+        ? '[]'
+        : (ref($default) eq 'HASH' and not keys %$default )
+          ? '{}'
+          : default_as_code($default);
+
+    my $code = $code{sub_start};
+    if ($args->{-init}) {
+        my $fragment = $args->{-weak} ? $code{weak_init} : $code{init};
+        $code .= sprintf $fragment, $field, $args->{-init}, ($field) x 4;
+    }
+    $code .= sprintf $code{set_default}, $field, $default_string, $field
+      if defined $default;
+    $code .= sprintf $code{return_if_get}, $field;
+    $code .= sprintf $code{set}, $field;
+    $code .= sprintf $code{weaken}, $field, $field 
+      if $args->{-weak};
+    $code .= sprintf $code{sub_end}, $field;
+
+    my $sub = eval $code;
+    die $@ if $@;
+    no strict 'refs';
+    *{"${package}::$field"} = $sub;
+    return $code if defined wantarray;
+}
+
+sub default_as_code {
+    require Data::Dumper;
+    local $Data::Dumper::Sortkeys = 1;
+    my $code = Data::Dumper::Dumper(shift);
+    $code =~ s/^\$VAR1 = //;
+    $code =~ s/;$//;
+    return $code;
+}
+
+sub const {
+    my $package = caller;
+    my ($args, @values) = do {
+        no warnings;
+        local *paired_arguments = sub { (qw(-package)) };
+        Spiffy->parse_arguments(@_);
+    };
+    my ($field, $default) = @values;
+    $package = $args->{-package} if defined $args->{-package};
+    no strict 'refs';
+    return if defined &{"${package}::$field"};
+    *{"${package}::$field"} = sub { $default }
+}
+
+sub stub {
+    my $package = caller;
+    my ($args, @values) = do {
+        no warnings;
+        local *paired_arguments = sub { (qw(-package)) };
+        Spiffy->parse_arguments(@_);
+    };
+    my ($field, $default) = @values;
+    $package = $args->{-package} if defined $args->{-package};
+    no strict 'refs';
+    return if defined &{"${package}::$field"};
+    *{"${package}::$field"} = 
+    sub { 
+        require Carp;
+        Carp::confess 
+          "Method $field in package $package must be subclassed";
+    }
+}
+
+sub parse_arguments {
+    my $class = shift;
+    my ($args, @values) = ({}, ());
+    my %booleans = map { ($_, 1) } $class->boolean_arguments;
+    my %pairs = map { ($_, 1) } $class->paired_arguments;
+    while (@_) {
+        my $elem = shift;
+        if (defined $elem and defined $booleans{$elem}) {
+            $args->{$elem} = (@_ and $_[0] =~ /^[01]$/)
+            ? shift
+            : 1;
+        }
+        elsif (defined $elem and defined $pairs{$elem} and @_) {
+            $args->{$elem} = shift;
+        }
+        else {
+            push @values, $elem;
+        }
+    }
+    return wantarray ? ($args, @values) : $args;        
+}
+
+sub boolean_arguments { () }
+sub paired_arguments { () }
+
+# get a unique id for any node
+sub id {
+    if (not ref $_[0]) {
+        return 'undef' if not defined $_[0];
+        \$_[0] =~ /\((\w+)\)$/o or die;
+        return "$1-S";
+    }
+    require overload;
+    overload::StrVal($_[0]) =~ /\((\w+)\)$/o or die;
+    return $1;
+}
+
+#===============================================================================
+# It's super, man.
+#===============================================================================
+package DB;
+{
+    no warnings 'redefine';
+    sub super_args { 
+        my @dummy = caller(@_ ? $_[0] : 2); 
+        return @DB::args;
+    }
+}
+
+package Spiffy;
+sub super {
+    my $method;
+    my $frame = 1;
+    while ($method = (caller($frame++))[3]) {
+        $method =~ s/.*::// and last;
+    }
+    my @args = DB::super_args($frame);
+    @_ = @_ ? ($args[0], @_) : @args;
+    my $class = ref $_[0] ? ref $_[0] : $_[0];
+    my $caller_class = caller;
+    my $seen = 0;
+    my @super_classes = reverse grep {
+        ($seen or $seen = ($_ eq $caller_class)) ? 0 : 1;
+    } reverse @{all_my_bases($class)};
+    for my $super_class (@super_classes) {
+        no strict 'refs';
+        next if $super_class eq $class;
+        if (defined &{"${super_class}::$method"}) {
+            ${"$super_class\::AUTOLOAD"} = ${"$class\::AUTOLOAD"}
+              if $method eq 'AUTOLOAD';
+            return &{"${super_class}::$method"};
+        }
+    }
+    return;
+}
+
+#===============================================================================
+# This code deserves a spanking, because it is being very naughty.
+# It is exchanging base.pm's import() for its own, so that people
+# can use base.pm with Spiffy modules, without being the wiser.
+#===============================================================================
+my $real_base_import;
+my $real_mixin_import;
+
+BEGIN {
+    require base unless defined $INC{'base.pm'};
+    $INC{'mixin.pm'} ||= 'Spiffy/mixin.pm';
+    $real_base_import = \&base::import;
+    $real_mixin_import = \&mixin::import;
+    no warnings;
+    *base::import = \&spiffy_base_import;
+    *mixin::import = \&spiffy_mixin_import;
+}
+
+# my $i = 0;
+# while (my $caller = caller($i++)) {
+#     next unless $caller eq 'base' or $caller eq 'mixin';
+#     croak <<END;
+# Spiffy.pm must be loaded before calling 'use base' or 'use mixin' with a
+# Spiffy module. See the documentation of Spiffy.pm for details.
+# END
+# }
+
+sub spiffy_base_import {
+    my @base_classes = @_;
+    shift @base_classes;
+    no strict 'refs';
+    goto &$real_base_import
+      unless grep {
+          eval "require $_" unless %{"$_\::"};
+          $_->isa('Spiffy');
+      } @base_classes;
+    my $inheritor = caller(0);
+    for my $base_class (@base_classes) {
+        next if $inheritor->isa($base_class);
+        croak "Can't mix Spiffy and non-Spiffy classes in 'use base'.\n", 
+              "See the documentation of Spiffy.pm for details\n  "
+          unless $base_class->isa('Spiffy');
+        $stack_frame = 1; # tell import to use different caller
+        import($base_class, '-base');
+        $stack_frame = 0;
+    }
+}
+
+sub mixin {
+    my $self = shift;
+    my $target_class = ref($self);
+    spiffy_mixin_import($target_class, @_)
+}
+
+sub spiffy_mixin_import {
+    my $target_class = shift;
+    $target_class = caller(0)
+      if $target_class eq 'mixin';
+    my $mixin_class = shift
+      or die "Nothing to mixin";
+    eval "require $mixin_class";
+    my @roles = @_;
+    my $pseudo_class = join '-', $target_class, $mixin_class, @roles;
+    my %methods = spiffy_mixin_methods($mixin_class, @roles);
+    no strict 'refs';
+    no warnings;
+    @{"$pseudo_class\::ISA"} = @{"$target_class\::ISA"};
+    @{"$target_class\::ISA"} = ($pseudo_class);
+    for (keys %methods) {
+        *{"$pseudo_class\::$_"} = $methods{$_};
+    }
+}
+
+sub spiffy_mixin_methods {
+    my $mixin_class = shift;
+    no strict 'refs';
+    my %methods = spiffy_all_methods($mixin_class);
+    map {
+        $methods{$_}
+          ? ($_, \ &{"$methods{$_}\::$_"})
+          : ($_, \ &{"$mixin_class\::$_"})
+    } @_ 
+      ? (get_roles($mixin_class, @_))
+      : (keys %methods);
+}
+
+sub get_roles {
+    my $mixin_class = shift;
+    my @roles = @_;
+    while (grep /^!*:/, @roles) {
+        @roles = map {
+            s/!!//g;
+            /^!:(.*)/ ? do { 
+                my $m = "_role_$1"; 
+                map("!$_", $mixin_class->$m);
+            } :
+            /^:(.*)/ ? do {
+                my $m = "_role_$1"; 
+                ($mixin_class->$m);
+            } :
+            ($_)
+        } @roles;
+    }
+    if (@roles and $roles[0] =~ /^!/) {
+        my %methods = spiffy_all_methods($mixin_class);
+        unshift @roles, keys(%methods);
+    }
+    my %roles;
+    for (@roles) {
+        s/!!//g;
+        delete $roles{$1}, next
+          if /^!(.*)/;
+        $roles{$_} = 1;
+    }
+    keys %roles;
+}
+
+sub spiffy_all_methods {
+    no strict 'refs';
+    my $class = shift;
+    return if $class eq 'Spiffy';
+    my %methods = map {
+        ($_, $class)
+    } grep {
+        defined &{"$class\::$_"} and not /^_/
+    } keys %{"$class\::"};
+    my %super_methods;
+    %super_methods = spiffy_all_methods(${"$class\::ISA"}[0])
+      if @{"$class\::ISA"};
+    %{{%super_methods, %methods}};
+}
+
+
+# END of naughty code.
+#===============================================================================
+# Debugging support
+#===============================================================================
+sub spiffy_dump {
+    no warnings;
+    if ($dump eq 'dumper') {
+        require Data::Dumper;
+        $Data::Dumper::Sortkeys = 1;
+        $Data::Dumper::Indent = 1;
+        return Data::Dumper::Dumper(@_);
+    }
+    require YAML;
+    $YAML::UseVersion = 0;
+    return YAML::Dump(@_) . "...\n";
+}
+
+sub at_line_number {
+    my ($file_path, $line_number) = (caller(1))[1,2];
+    "  at $file_path line $line_number\n";
+}
+
+sub WWW {
+    warn spiffy_dump(@_) . at_line_number;
+    return wantarray ? @_ : $_[0];
+}
+
+sub XXX {
+    die spiffy_dump(@_) . at_line_number;
+}
+
+sub YYY {
+    print spiffy_dump(@_) . at_line_number;
+    return wantarray ? @_ : $_[0];
+}
+
+sub ZZZ {
+    require Carp;
+    Carp::confess spiffy_dump(@_);
+}
+
+1;
+
+__END__
+
+#line 1066
diff --git a/src/tcp/test/inc/Test/Base.pm b/src/tcp/test/inc/Test/Base.pm
new file mode 100755
index 0000000..0d4d982
--- /dev/null
+++ b/src/tcp/test/inc/Test/Base.pm
@@ -0,0 +1,684 @@
+#line 1
+# TODO:
+#
+package Test::Base;
+use 5.006001;
+use Spiffy 0.30 -Base;
+use Spiffy ':XXX';
+our $VERSION = '0.59';
+
+my @test_more_exports;
+BEGIN {
+    @test_more_exports = qw(
+        ok isnt like unlike is_deeply cmp_ok
+        skip todo_skip pass fail
+        eq_array eq_hash eq_set
+        plan can_ok isa_ok diag
+        use_ok
+        $TODO
+    );
+}
+
+use Test::More import => \@test_more_exports;
+use Carp;
+
+our @EXPORT = (@test_more_exports, qw(
+    is no_diff
+
+    blocks next_block first_block
+    delimiters spec_file spec_string 
+    filters filters_delay filter_arguments
+    run run_compare run_is run_is_deeply run_like run_unlike 
+    skip_all_unless_require is_deep run_is_deep
+    WWW XXX YYY ZZZ
+    tie_output no_diag_on_only
+
+    find_my_self default_object
+
+    croak carp cluck confess
+));
+
+field '_spec_file';
+field '_spec_string';
+field _filters => [qw(norm trim)];
+field _filters_map => {};
+field spec =>
+      -init => '$self->_spec_init';
+field block_list =>
+      -init => '$self->_block_list_init';
+field _next_list => [];
+field block_delim =>
+      -init => '$self->block_delim_default';
+field data_delim =>
+      -init => '$self->data_delim_default';
+field _filters_delay => 0;
+field _no_diag_on_only => 0;
+
+field block_delim_default => '===';
+field data_delim_default => '---';
+
+my $default_class;
+my $default_object;
+my $reserved_section_names = {};
+
+sub default_object { 
+    $default_object ||= $default_class->new;
+    return $default_object;
+}
+
+my $import_called = 0;
+sub import() {
+    $import_called = 1;
+    my $class = (grep /^-base$/i, @_) 
+    ? scalar(caller)
+    : $_[0];
+    if (not defined $default_class) {
+        $default_class = $class;
+    }
+#     else {
+#         croak "Can't use $class after using $default_class"
+#           unless $default_class->isa($class);
+#     }
+
+    unless (grep /^-base$/i, @_) {
+        my @args;
+        for (my $ii = 1; $ii <= $#_; ++$ii) {
+            if ($_[$ii] eq '-package') {
+                ++$ii;
+            } else {
+                push @args, $_[$ii];
+            }
+        }
+        Test::More->import(import => \@test_more_exports, @args)
+            if @args;
+     }
+    
+    _strict_warnings();
+    goto &Spiffy::import;
+}
+
+# Wrap Test::Builder::plan
+my $plan_code = \&Test::Builder::plan;
+my $Have_Plan = 0;
+{
+    no warnings 'redefine';
+    *Test::Builder::plan = sub {
+        $Have_Plan = 1;
+        goto &$plan_code;
+    };
+}
+
+my $DIED = 0;
+$SIG{__DIE__} = sub { $DIED = 1; die @_ };
+
+sub block_class  { $self->find_class('Block') }
+sub filter_class { $self->find_class('Filter') }
+
+sub find_class {
+    my $suffix = shift;
+    my $class = ref($self) . "::$suffix";
+    return $class if $class->can('new');
+    $class = __PACKAGE__ . "::$suffix";
+    return $class if $class->can('new');
+    eval "require $class";
+    return $class if $class->can('new');
+    die "Can't find a class for $suffix";
+}
+
+sub check_late {
+    if ($self->{block_list}) {
+        my $caller = (caller(1))[3];
+        $caller =~ s/.*:://;
+        croak "Too late to call $caller()"
+    }
+}
+
+sub find_my_self() {
+    my $self = ref($_[0]) eq $default_class
+    ? splice(@_, 0, 1)
+    : default_object();
+    return $self, @_;
+}
+
+sub blocks() {
+    (my ($self), @_) = find_my_self(@_);
+
+    croak "Invalid arguments passed to 'blocks'"
+      if @_ > 1;
+    croak sprintf("'%s' is invalid argument to blocks()", shift(@_))
+      if @_ && $_[0] !~ /^[a-zA-Z]\w*$/;
+
+    my $blocks = $self->block_list;
+    
+    my $section_name = shift || '';
+    my @blocks = $section_name
+    ? (grep { exists $_->{$section_name} } @$blocks)
+    : (@$blocks);
+
+    return scalar(@blocks) unless wantarray;
+    
+    return (@blocks) if $self->_filters_delay;
+
+    for my $block (@blocks) {
+        $block->run_filters
+          unless $block->is_filtered;
+    }
+
+    return (@blocks);
+}
+
+sub next_block() {
+    (my ($self), @_) = find_my_self(@_);
+    my $list = $self->_next_list;
+    if (@$list == 0) {
+        $list = [@{$self->block_list}, undef];
+        $self->_next_list($list);
+    }
+    my $block = shift @$list;
+    if (defined $block and not $block->is_filtered) {
+        $block->run_filters;
+    }
+    return $block;
+}
+
+sub first_block() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_next_list([]);
+    $self->next_block;
+}
+
+sub filters_delay() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_filters_delay(defined $_[0] ? shift : 1);
+}
+
+sub no_diag_on_only() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_no_diag_on_only(defined $_[0] ? shift : 1);
+}
+
+sub delimiters() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->check_late;
+    my ($block_delimiter, $data_delimiter) = @_;
+    $block_delimiter ||= $self->block_delim_default;
+    $data_delimiter ||= $self->data_delim_default;
+    $self->block_delim($block_delimiter);
+    $self->data_delim($data_delimiter);
+    return $self;
+}
+
+sub spec_file() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->check_late;
+    $self->_spec_file(shift);
+    return $self;
+}
+
+sub spec_string() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->check_late;
+    $self->_spec_string(shift);
+    return $self;
+}
+
+sub filters() {
+    (my ($self), @_) = find_my_self(@_);
+    if (ref($_[0]) eq 'HASH') {
+        $self->_filters_map(shift);
+    }
+    else {    
+        my $filters = $self->_filters;
+        push @$filters, @_;
+    }
+    return $self;
+}
+
+sub filter_arguments() {
+    $Test::Base::Filter::arguments;
+}
+
+sub have_text_diff {
+    eval { require Text::Diff; 1 } &&
+        $Text::Diff::VERSION >= 0.35 &&
+        $Algorithm::Diff::VERSION >= 1.15;
+}
+
+sub is($$;$) {
+    (my ($self), @_) = find_my_self(@_);
+    my ($actual, $expected, $name) = @_;
+    local $Test::Builder::Level = $Test::Builder::Level + 1;
+    if ($ENV{TEST_SHOW_NO_DIFFS} or
+         not defined $actual or
+         not defined $expected or
+         $actual eq $expected or 
+         not($self->have_text_diff) or 
+         $expected !~ /\n./s
+    ) {
+        Test::More::is($actual, $expected, $name);
+    }
+    else {
+        $name = '' unless defined $name;
+        ok $actual eq $expected,
+           $name . "\n" . Text::Diff::diff(\$expected, \$actual);
+    }
+}
+
+sub run(&;$) {
+    (my ($self), @_) = find_my_self(@_);
+    my $callback = shift;
+    for my $block (@{$self->block_list}) {
+        $block->run_filters unless $block->is_filtered;
+        &{$callback}($block);
+    }
+}
+
+my $name_error = "Can't determine section names";
+sub _section_names {
+    return @_ if @_ == 2;
+    my $block = $self->first_block
+      or croak $name_error;
+    my @names = grep {
+        $_ !~ /^(ONLY|LAST|SKIP)$/;
+    } @{$block->{_section_order}[0] || []};
+    croak "$name_error. Need two sections in first block"
+      unless @names == 2;
+    return @names;
+}
+
+sub _assert_plan {
+    plan('no_plan') unless $Have_Plan;
+}
+
+sub END {
+    run_compare() unless $Have_Plan or $DIED or not $import_called;
+}
+
+sub run_compare() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    local $Test::Builder::Level = $Test::Builder::Level + 1;
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        if (ref $block->$x) {
+            is_deeply($block->$x, $block->$y,
+                $block->name ? $block->name : ());
+        }
+        elsif (ref $block->$y eq 'Regexp') {
+            my $regexp = ref $y ? $y : $block->$y;
+            like($block->$x, $regexp, $block->name ? $block->name : ());
+        }
+        else {
+            is($block->$x, $block->$y, $block->name ? $block->name : ());
+        }
+    }
+}
+
+sub run_is() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    local $Test::Builder::Level = $Test::Builder::Level + 1;
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        is($block->$x, $block->$y, 
+           $block->name ? $block->name : ()
+          );
+    }
+}
+
+sub run_is_deeply() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        is_deeply($block->$x, $block->$y, 
+           $block->name ? $block->name : ()
+          );
+    }
+}
+
+sub run_like() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and defined($y);
+        $block->run_filters unless $block->is_filtered;
+        my $regexp = ref $y ? $y : $block->$y;
+        like($block->$x, $regexp,
+             $block->name ? $block->name : ()
+            );
+    }
+}
+
+sub run_unlike() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and defined($y);
+        $block->run_filters unless $block->is_filtered;
+        my $regexp = ref $y ? $y : $block->$y;
+        unlike($block->$x, $regexp,
+               $block->name ? $block->name : ()
+              );
+    }
+}
+
+sub skip_all_unless_require() {
+    (my ($self), @_) = find_my_self(@_);
+    my $module = shift;
+    eval "require $module; 1"
+        or Test::More::plan(
+            skip_all => "$module failed to load"
+        );
+}
+
+sub is_deep() {
+    (my ($self), @_) = find_my_self(@_);
+    require Test::Deep;
+    Test::Deep::cmp_deeply(@_);
+}
+
+sub run_is_deep() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        is_deep($block->$x, $block->$y, 
+           $block->name ? $block->name : ()
+          );
+    }
+}
+
+sub _pre_eval {
+    my $spec = shift;
+    return $spec unless $spec =~
+      s/\A\s*<<<(.*?)>>>\s*$//sm;
+    my $eval_code = $1;
+    eval "package main; $eval_code";
+    croak $@ if $@;
+    return $spec;
+}
+
+sub _block_list_init {
+    my $spec = $self->spec;
+    $spec = $self->_pre_eval($spec);
+    my $cd = $self->block_delim;
+    my @hunks = ($spec =~ /^(\Q${cd}\E.*?(?=^\Q${cd}\E|\z))/msg);
+    my $blocks = $self->_choose_blocks(@hunks);
+    $self->block_list($blocks); # Need to set early for possible filter use
+    my $seq = 1;
+    for my $block (@$blocks) {
+        $block->blocks_object($self);
+        $block->seq_num($seq++);
+    }
+    return $blocks;
+}
+
+sub _choose_blocks {
+    my $blocks = [];
+    for my $hunk (@_) {
+        my $block = $self->_make_block($hunk);
+        if (exists $block->{ONLY}) {
+            diag "I found ONLY: maybe you're debugging?"
+                unless $self->_no_diag_on_only;
+            return [$block];
+        }
+        next if exists $block->{SKIP};
+        push @$blocks, $block;
+        if (exists $block->{LAST}) {
+            return $blocks;
+        }
+    }
+    return $blocks;
+}
+
+sub _check_reserved {
+    my $id = shift;
+    croak "'$id' is a reserved name. Use something else.\n"
+      if $reserved_section_names->{$id} or
+         $id =~ /^_/;
+}
+
+sub _make_block {
+    my $hunk = shift;
+    my $cd = $self->block_delim;
+    my $dd = $self->data_delim;
+    my $block = $self->block_class->new;
+    $hunk =~ s/\A\Q${cd}\E[ \t]*(.*)\s+// or die;
+    my $name = $1;
+    my @parts = split /^\Q${dd}\E +\(?(\w+)\)? *(.*)?\n/m, $hunk;
+    my $description = shift @parts;
+    $description ||= '';
+    unless ($description =~ /\S/) {
+        $description = $name;
+    }
+    $description =~ s/\s*\z//;
+    $block->set_value(description => $description);
+    
+    my $section_map = {};
+    my $section_order = [];
+    while (@parts) {
+        my ($type, $filters, $value) = splice(@parts, 0, 3);
+        $self->_check_reserved($type);
+        $value = '' unless defined $value;
+        $filters = '' unless defined $filters;
+        if ($filters =~ /:(\s|\z)/) {
+            croak "Extra lines not allowed in '$type' section"
+              if $value =~ /\S/;
+            ($filters, $value) = split /\s*:(?:\s+|\z)/, $filters, 2;
+            $value = '' unless defined $value;
+            $value =~ s/^\s*(.*?)\s*$/$1/;
+        }
+        $section_map->{$type} = {
+            filters => $filters,
+        };
+        push @$section_order, $type;
+        $block->set_value($type, $value);
+    }
+    $block->set_value(name => $name);
+    $block->set_value(_section_map => $section_map);
+    $block->set_value(_section_order => $section_order);
+    return $block;
+}
+
+sub _spec_init {
+    return $self->_spec_string
+      if $self->_spec_string;
+    local $/;
+    my $spec;
+    if (my $spec_file = $self->_spec_file) {
+        open FILE, $spec_file or die $!;
+        $spec = <FILE>;
+        close FILE;
+    }
+    else {    
+        $spec = do { 
+            package main; 
+            no warnings 'once';
+            <DATA>;
+        };
+    }
+    return $spec;
+}
+
+sub _strict_warnings() {
+    require Filter::Util::Call;
+    my $done = 0;
+    Filter::Util::Call::filter_add(
+        sub {
+            return 0 if $done;
+            my ($data, $end) = ('', '');
+            while (my $status = Filter::Util::Call::filter_read()) {
+                return $status if $status < 0;
+                if (/^__(?:END|DATA)__\r?$/) {
+                    $end = $_;
+                    last;
+                }
+                $data .= $_;
+                $_ = '';
+            }
+            $_ = "use strict;use warnings;$data$end";
+            $done = 1;
+        }
+    );
+}
+
+sub tie_output() {
+    my $handle = shift;
+    die "No buffer to tie" unless @_;
+    tie $handle, 'Test::Base::Handle', $_[0];
+}
+
+sub no_diff {
+    $ENV{TEST_SHOW_NO_DIFFS} = 1;
+}
+
+package Test::Base::Handle;
+
+sub TIEHANDLE() {
+    my $class = shift;
+    bless \ $_[0], $class;
+}
+
+sub PRINT {
+    $$self .= $_ for @_;
+}
+
+#===============================================================================
+# Test::Base::Block
+#
+# This is the default class for accessing a Test::Base block object.
+#===============================================================================
+package Test::Base::Block;
+our @ISA = qw(Spiffy);
+
+our @EXPORT = qw(block_accessor);
+
+sub AUTOLOAD {
+    return;
+}
+
+sub block_accessor() {
+    my $accessor = shift;
+    no strict 'refs';
+    return if defined &$accessor;
+    *$accessor = sub {
+        my $self = shift;
+        if (@_) {
+            Carp::croak "Not allowed to set values for '$accessor'";
+        }
+        my @list = @{$self->{$accessor} || []};
+        return wantarray
+        ? (@list)
+        : $list[0];
+    };
+}
+
+block_accessor 'name';
+block_accessor 'description';
+Spiffy::field 'seq_num';
+Spiffy::field 'is_filtered';
+Spiffy::field 'blocks_object';
+Spiffy::field 'original_values' => {};
+
+sub set_value {
+    no strict 'refs';
+    my $accessor = shift;
+    block_accessor $accessor
+      unless defined &$accessor;
+    $self->{$accessor} = [@_];
+}
+
+sub run_filters {
+    my $map = $self->_section_map;
+    my $order = $self->_section_order;
+    Carp::croak "Attempt to filter a block twice"
+      if $self->is_filtered;
+    for my $type (@$order) {
+        my $filters = $map->{$type}{filters};
+        my @value = $self->$type;
+        $self->original_values->{$type} = $value[0];
+        for my $filter ($self->_get_filters($type, $filters)) {
+            $Test::Base::Filter::arguments =
+              $filter =~ s/=(.*)$// ? $1 : undef;
+            my $function = "main::$filter";
+            no strict 'refs';
+            if (defined &$function) {
+                local $_ =
+                    (@value == 1 and not defined($value[0])) ? undef :
+                        join '', @value;
+                my $old = $_;
+                @value = &$function(@value);
+                if (not(@value) or 
+                    @value == 1 and defined($value[0]) and $value[0] =~ /\A(\d+|)\z/
+                ) {
+                    if ($value[0] && $_ eq $old) {
+                        Test::Base::diag("Filters returning numbers are supposed to do munging \$_: your filter '$function' apparently doesn't.");
+                    }
+                    @value = ($_);
+                }
+            }
+            else {
+                my $filter_object = $self->blocks_object->filter_class->new;
+                die "Can't find a function or method for '$filter' filter\n"
+                  unless $filter_object->can($filter);
+                $filter_object->current_block($self);
+                @value = $filter_object->$filter(@value);
+            }
+            # Set the value after each filter since other filters may be
+            # introspecting.
+            $self->set_value($type, @value);
+        }
+    }
+    $self->is_filtered(1);
+}
+
+sub _get_filters {
+    my $type = shift;
+    my $string = shift || '';
+    $string =~ s/\s*(.*?)\s*/$1/;
+    my @filters = ();
+    my $map_filters = $self->blocks_object->_filters_map->{$type} || [];
+    $map_filters = [ $map_filters ] unless ref $map_filters;
+    my @append = ();
+    for (
+        @{$self->blocks_object->_filters}, 
+        @$map_filters,
+        split(/\s+/, $string),
+    ) {
+        my $filter = $_;
+        last unless length $filter;
+        if ($filter =~ s/^-//) {
+            @filters = grep { $_ ne $filter } @filters;
+        }
+        elsif ($filter =~ s/^\+//) {
+            push @append, $filter;
+        }
+        else {
+            push @filters, $filter;
+        }
+    }
+    return @filters, @append;
+}
+
+{
+    %$reserved_section_names = map {
+        ($_, 1);
+    } keys(%Test::Base::Block::), qw( new DESTROY );
+}
+
+__DATA__
+
+=encoding utf8
+
+#line 1376
diff --git a/src/tcp/test/inc/Test/Base/Filter.pm b/src/tcp/test/inc/Test/Base/Filter.pm
new file mode 100755
index 0000000..a440ed9
--- /dev/null
+++ b/src/tcp/test/inc/Test/Base/Filter.pm
@@ -0,0 +1,344 @@
+#line 1
+#. TODO:
+#.
+
+#===============================================================================
+# This is the default class for handling Test::Base data filtering.
+#===============================================================================
+package Test::Base::Filter;
+use Spiffy -Base;
+use Spiffy ':XXX';
+
+field 'current_block';
+
+our $arguments;
+sub current_arguments {
+    return undef unless defined $arguments;
+    my $args = $arguments;
+    $args =~ s/(\\s)/ /g;
+    $args =~ s/(\\[a-z])/'"' . $1 . '"'/gee;
+    return $args;
+}
+
+sub assert_scalar {
+    return if @_ == 1;
+    require Carp;
+    my $filter = (caller(1))[3];
+    $filter =~ s/.*:://;
+    Carp::croak "Input to the '$filter' filter must be a scalar, not a list";
+}
+
+sub _apply_deepest {
+    my $method = shift;
+    return () unless @_;
+    if (ref $_[0] eq 'ARRAY') {
+        for my $aref (@_) {
+            @$aref = $self->_apply_deepest($method, @$aref);
+        }
+        return @_;
+    }
+    $self->$method(@_);
+}
+
+sub _split_array {
+    map {
+        [$self->split($_)];
+    } @_;
+}
+
+sub _peel_deepest {
+    return () unless @_;
+    if (ref $_[0] eq 'ARRAY') {
+        if (ref $_[0]->[0] eq 'ARRAY') {
+            for my $aref (@_) {
+                @$aref = $self->_peel_deepest(@$aref);
+            }
+            return @_;
+        }
+        return map { $_->[0] } @_;
+    }
+    return @_;
+}
+
+#===============================================================================
+# these filters work on the leaves of nested arrays
+#===============================================================================
+sub Join { $self->_peel_deepest($self->_apply_deepest(join => @_)) }
+sub Reverse { $self->_apply_deepest(reverse => @_) }
+sub Split { $self->_apply_deepest(_split_array => @_) }
+sub Sort { $self->_apply_deepest(sort => @_) }
+
+
+sub append {
+    my $suffix = $self->current_arguments;
+    map { $_ . $suffix } @_;
+}
+
+sub array {
+    return [@_];
+}
+
+sub base64_decode {
+    $self->assert_scalar(@_);
+    require MIME::Base64;
+    MIME::Base64::decode_base64(shift);
+}
+
+sub base64_encode {
+    $self->assert_scalar(@_);
+    require MIME::Base64;
+    MIME::Base64::encode_base64(shift);
+}
+
+sub chomp {
+    map { CORE::chomp; $_ } @_;
+}
+
+sub chop {
+    map { CORE::chop; $_ } @_;
+}
+
+sub dumper {
+    no warnings 'once';
+    require Data::Dumper;
+    local $Data::Dumper::Sortkeys = 1;
+    local $Data::Dumper::Indent = 1;
+    local $Data::Dumper::Terse = 1;
+    Data::Dumper::Dumper(@_);
+}
+
+sub escape {
+    $self->assert_scalar(@_);
+    my $text = shift;
+    $text =~ s/(\\.)/eval "qq{$1}"/ge;
+    return $text;
+}
+
+sub eval {
+    $self->assert_scalar(@_);
+    my @return = CORE::eval(shift);
+    return $@ if $@;
+    return @return;
+}
+
+sub eval_all {
+    $self->assert_scalar(@_);
+    my $out = '';
+    my $err = '';
+    Test::Base::tie_output(*STDOUT, $out);
+    Test::Base::tie_output(*STDERR, $err);
+    my $return = CORE::eval(shift);
+    no warnings;
+    untie *STDOUT;
+    untie *STDERR;
+    return $return, $@, $out, $err;
+}
+
+sub eval_stderr {
+    $self->assert_scalar(@_);
+    my $output = '';
+    Test::Base::tie_output(*STDERR, $output);
+    CORE::eval(shift);
+    no warnings;
+    untie *STDERR;
+    return $output;
+}
+
+sub eval_stdout {
+    $self->assert_scalar(@_);
+    my $output = '';
+    Test::Base::tie_output(*STDOUT, $output);
+    CORE::eval(shift);
+    no warnings;
+    untie *STDOUT;
+    return $output;
+}
+
+sub exec_perl_stdout {
+    my $tmpfile = "/tmp/test-blocks-$$";
+    $self->_write_to($tmpfile, @_);
+    open my $execution, "$^X $tmpfile 2>&1 |"
+      or die "Couldn't open subprocess: $!\n";
+    local $/;
+    my $output = <$execution>;
+    close $execution;
+    unlink($tmpfile)
+      or die "Couldn't unlink $tmpfile: $!\n";
+    return $output;
+}
+
+sub flatten {
+    $self->assert_scalar(@_);
+    my $ref = shift;
+    if (ref($ref) eq 'HASH') {
+        return map {
+            ($_, $ref->{$_});
+        } sort keys %$ref;
+    }
+    if (ref($ref) eq 'ARRAY') {
+        return @$ref;
+    }
+    die "Can only flatten a hash or array ref";
+}
+
+sub get_url {
+    $self->assert_scalar(@_);
+    my $url = shift;
+    CORE::chomp($url);
+    require LWP::Simple;
+    LWP::Simple::get($url);
+}
+
+sub hash {
+    return +{ @_ };
+}
+
+sub head {
+    my $size = $self->current_arguments || 1;
+    return splice(@_, 0, $size);
+}
+
+sub join {
+    my $string = $self->current_arguments;
+    $string = '' unless defined $string;
+    CORE::join $string, @_;
+}
+
+sub lines {
+    $self->assert_scalar(@_);
+    my $text = shift;
+    return () unless length $text;
+    my @lines = ($text =~ /^(.*\n?)/gm);
+    return @lines;
+}
+
+sub norm {
+    $self->assert_scalar(@_);
+    my $text = shift;
+    $text = '' unless defined $text;
+    $text =~ s/\015\012/\n/g;
+    $text =~ s/\r/\n/g;
+    return $text;
+}
+
+sub prepend {
+    my $prefix = $self->current_arguments;
+    map { $prefix . $_ } @_;
+}
+
+sub read_file {
+    $self->assert_scalar(@_);
+    my $file = shift;
+    CORE::chomp $file;
+    open my $fh, $file
+      or die "Can't open '$file' for input:\n$!";
+    CORE::join '', <$fh>;
+}
+
+sub regexp {
+    $self->assert_scalar(@_);
+    my $text = shift;
+    my $flags = $self->current_arguments;
+    if ($text =~ /\n.*?\n/s) {
+        $flags = 'xism'
+          unless defined $flags;
+    }
+    else {
+        CORE::chomp($text);
+    }
+    $flags ||= '';
+    my $regexp = eval "qr{$text}$flags";
+    die $@ if $@;
+    return $regexp;
+}
+
+sub reverse {
+    CORE::reverse(@_);
+}
+
+sub slice {
+    die "Invalid args for slice"
+      unless $self->current_arguments =~ /^(\d+)(?:,(\d))?$/;
+    my ($x, $y) = ($1, $2);
+    $y = $x if not defined $y;
+    die "Invalid args for slice"
+      if $x > $y;
+    return splice(@_, $x, 1 + $y - $x);
+}
+
+sub sort {
+    CORE::sort(@_);
+}
+
+sub split {
+    $self->assert_scalar(@_);
+    my $separator = $self->current_arguments;
+    if (defined $separator and $separator =~ s{^/(.*)/$}{$1}) {
+        my $regexp = $1;
+        $separator = qr{$regexp};
+    }
+    $separator = qr/\s+/ unless $separator;
+    CORE::split $separator, shift;
+}
+
+sub strict {
+    $self->assert_scalar(@_);
+    <<'...' . shift;
+use strict;
+use warnings;
+...
+}
+
+sub tail {
+    my $size = $self->current_arguments || 1;
+    return splice(@_, @_ - $size, $size);
+}
+
+sub trim {
+    map {
+        s/\A([ \t]*\n)+//;
+        s/(?<=\n)\s*\z//g;
+        $_;
+    } @_;
+}
+
+sub unchomp {
+    map { $_ . "\n" } @_;
+}
+
+sub write_file {
+    my $file = $self->current_arguments
+      or die "No file specified for write_file filter";
+    if ($file =~ /(.*)[\\\/]/) {
+        my $dir = $1;
+        if (not -e $dir) {
+            require File::Path;
+            File::Path::mkpath($dir)
+              or die "Can't create $dir";
+        }
+    }
+    open my $fh, ">$file"
+      or die "Can't open '$file' for output\n:$!";
+    print $fh @_;
+    close $fh;
+    return $file;
+}
+
+sub yaml {
+    $self->assert_scalar(@_);
+    require YAML;
+    return YAML::Load(shift);
+}
+
+sub _write_to {
+    my $filename = shift;
+    open my $script, ">$filename"
+      or die "Couldn't open $filename: $!\n";
+    print $script @_;
+    close $script
+      or die "Couldn't close $filename: $!\n";
+}
+
+__DATA__
+
+#line 639
diff --git a/src/tcp/test/inc/Test/Builder.pm b/src/tcp/test/inc/Test/Builder.pm
new file mode 100755
index 0000000..795361f
--- /dev/null
+++ b/src/tcp/test/inc/Test/Builder.pm
@@ -0,0 +1,1589 @@
+#line 1
+package Test::Builder;
+
+use 5.006;
+use strict;
+use warnings;
+
+our $VERSION = '0.94';
+$VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+BEGIN {
+    if( $] < 5.008 ) {
+        require Test::Builder::IO::Scalar;
+    }
+}
+
+
+# Make Test::Builder thread-safe for ithreads.
+BEGIN {
+    use Config;
+    # Load threads::shared when threads are turned on.
+    # 5.8.0's threads are so busted we no longer support them.
+    if( $] >= 5.008001 && $Config{useithreads} && $INC{'threads.pm'} ) {
+        require threads::shared;
+
+        # Hack around YET ANOTHER threads::shared bug.  It would
+        # occassionally forget the contents of the variable when sharing it.
+        # So we first copy the data, then share, then put our copy back.
+        *share = sub (\[$@%]) {
+            my $type = ref $_[0];
+            my $data;
+
+            if( $type eq 'HASH' ) {
+                %$data = %{ $_[0] };
+            }
+            elsif( $type eq 'ARRAY' ) {
+                @$data = @{ $_[0] };
+            }
+            elsif( $type eq 'SCALAR' ) {
+                $$data = ${ $_[0] };
+            }
+            else {
+                die( "Unknown type: " . $type );
+            }
+
+            $_[0] = &threads::shared::share( $_[0] );
+
+            if( $type eq 'HASH' ) {
+                %{ $_[0] } = %$data;
+            }
+            elsif( $type eq 'ARRAY' ) {
+                @{ $_[0] } = @$data;
+            }
+            elsif( $type eq 'SCALAR' ) {
+                ${ $_[0] } = $$data;
+            }
+            else {
+                die( "Unknown type: " . $type );
+            }
+
+            return $_[0];
+        };
+    }
+    # 5.8.0's threads::shared is busted when threads are off
+    # and earlier Perls just don't have that module at all.
+    else {
+        *share = sub { return $_[0] };
+        *lock  = sub { 0 };
+    }
+}
+
+#line 117
+
+our $Test = Test::Builder->new;
+
+sub new {
+    my($class) = shift;
+    $Test ||= $class->create;
+    return $Test;
+}
+
+#line 139
+
+sub create {
+    my $class = shift;
+
+    my $self = bless {}, $class;
+    $self->reset;
+
+    return $self;
+}
+
+#line 168
+
+sub child {
+    my( $self, $name ) = @_;
+
+    if( $self->{Child_Name} ) {
+        $self->croak("You already have a child named ($self->{Child_Name}) running");
+    }
+
+    my $child = bless {}, ref $self;
+    $child->reset;
+
+    # Add to our indentation
+    $child->_indent( $self->_indent . '    ' );
+    $child->{$_} = $self->{$_} foreach qw{Out_FH Todo_FH Fail_FH};
+
+    # This will be reset in finalize. We do this here lest one child failure
+    # cause all children to fail.
+    $child->{Child_Error} = $?;
+    $?                    = 0;
+    $child->{Parent}      = $self;
+    $child->{Name}        = $name || "Child of " . $self->name;
+    $self->{Child_Name}   = $child->name;
+    return $child;
+}
+
+
+#line 201
+
+sub subtest {
+    my $self = shift;
+    my($name, $subtests) = @_;
+
+    if ('CODE' ne ref $subtests) {
+        $self->croak("subtest()'s second argument must be a code ref");
+    }
+
+    # Turn the child into the parent so anyone who has stored a copy of
+    # the Test::Builder singleton will get the child.
+    my $child = $self->child($name);
+    my %parent = %$self;
+    %$self = %$child;
+
+    my $error;
+    if( !eval { $subtests->(); 1 } ) {
+        $error = $@;
+    }
+
+    # Restore the parent and the copied child.
+    %$child = %$self;
+    %$self = %parent;
+
+    # Die *after* we restore the parent.
+    die $error if $error and !eval { $error->isa('Test::Builder::Exception') };
+
+    return $child->finalize;
+}
+
+
+#line 250
+
+sub finalize {
+    my $self = shift;
+
+    return unless $self->parent;
+    if( $self->{Child_Name} ) {
+        $self->croak("Can't call finalize() with child ($self->{Child_Name}) active");
+    }
+    $self->_ending;
+
+    # XXX This will only be necessary for TAP envelopes (we think)
+    #$self->_print( $self->is_passing ? "PASS\n" : "FAIL\n" );
+
+    my $ok = 1;
+    $self->parent->{Child_Name} = undef;
+    if ( $self->{Skip_All} ) {
+        $self->parent->skip($self->{Skip_All});
+    }
+    elsif ( not @{ $self->{Test_Results} } ) {
+        $self->parent->ok( 0, sprintf q[No tests run for subtest "%s"], $self->name );
+    }
+    else {
+        $self->parent->ok( $self->is_passing, $self->name );
+    }
+    $? = $self->{Child_Error};
+    delete $self->{Parent};
+
+    return $self->is_passing;
+}
+
+sub _indent      {
+    my $self = shift;
+
+    if( @_ ) {
+        $self->{Indent} = shift;
+    }
+
+    return $self->{Indent};
+}
+
+#line 300
+
+sub parent { shift->{Parent} }
+
+#line 312
+
+sub name { shift->{Name} }
+
+sub DESTROY {
+    my $self = shift;
+    if ( $self->parent ) {
+        my $name = $self->name;
+        $self->diag(<<"FAIL");
+Child ($name) exited without calling finalize()
+FAIL
+        $self->parent->{In_Destroy} = 1;
+        $self->parent->ok(0, $name);
+    }
+}
+
+#line 336
+
+our $Level;
+
+sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
+    my($self) = @_;
+
+    # We leave this a global because it has to be localized and localizing
+    # hash keys is just asking for pain.  Also, it was documented.
+    $Level = 1;
+
+    $self->{Name}         = $0;
+    $self->is_passing(1);
+    $self->{Ending}       = 0;
+    $self->{Have_Plan}    = 0;
+    $self->{No_Plan}      = 0;
+    $self->{Have_Output_Plan} = 0;
+
+    $self->{Original_Pid} = $$;
+    $self->{Child_Name}   = undef;
+    $self->{Indent}     ||= '';
+
+    share( $self->{Curr_Test} );
+    $self->{Curr_Test} = 0;
+    $self->{Test_Results} = &share( [] );
+
+    $self->{Exported_To}    = undef;
+    $self->{Expected_Tests} = 0;
+
+    $self->{Skip_All} = 0;
+
+    $self->{Use_Nums} = 1;
+
+    $self->{No_Header} = 0;
+    $self->{No_Ending} = 0;
+
+    $self->{Todo}       = undef;
+    $self->{Todo_Stack} = [];
+    $self->{Start_Todo} = 0;
+    $self->{Opened_Testhandles} = 0;
+
+    $self->_dup_stdhandles;
+
+    return;
+}
+
+#line 414
+
+my %plan_cmds = (
+    no_plan     => \&no_plan,
+    skip_all    => \&skip_all,
+    tests       => \&_plan_tests,
+);
+
+sub plan {
+    my( $self, $cmd, $arg ) = @_;
+
+    return unless $cmd;
+
+    local $Level = $Level + 1;
+
+    $self->croak("You tried to plan twice") if $self->{Have_Plan};
+
+    if( my $method = $plan_cmds{$cmd} ) {
+        local $Level = $Level + 1;
+        $self->$method($arg);
+    }
+    else {
+        my @args = grep { defined } ( $cmd, $arg );
+        $self->croak("plan() doesn't understand @args");
+    }
+
+    return 1;
+}
+
+
+sub _plan_tests {
+    my($self, $arg) = @_;
+
+    if($arg) {
+        local $Level = $Level + 1;
+        return $self->expected_tests($arg);
+    }
+    elsif( !defined $arg ) {
+        $self->croak("Got an undefined number of tests");
+    }
+    else {
+        $self->croak("You said to run 0 tests");
+    }
+
+    return;
+}
+
+
+#line 470
+
+sub expected_tests {
+    my $self = shift;
+    my($max) = @_;
+
+    if(@_) {
+        $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
+          unless $max =~ /^\+?\d+$/;
+
+        $self->{Expected_Tests} = $max;
+        $self->{Have_Plan}      = 1;
+
+        $self->_output_plan($max) unless $self->no_header;
+    }
+    return $self->{Expected_Tests};
+}
+
+#line 494
+
+sub no_plan {
+    my($self, $arg) = @_;
+
+    $self->carp("no_plan takes no arguments") if $arg;
+
+    $self->{No_Plan}   = 1;
+    $self->{Have_Plan} = 1;
+
+    return 1;
+}
+
+
+#line 528
+
+sub _output_plan {
+    my($self, $max, $directive, $reason) = @_;
+
+    $self->carp("The plan was already output") if $self->{Have_Output_Plan};
+
+    my $plan = "1..$max";
+    $plan .= " # $directive" if defined $directive;
+    $plan .= " $reason"      if defined $reason;
+
+    $self->_print("$plan\n");
+
+    $self->{Have_Output_Plan} = 1;
+
+    return;
+}
+
+#line 579
+
+sub done_testing {
+    my($self, $num_tests) = @_;
+
+    # If done_testing() specified the number of tests, shut off no_plan.
+    if( defined $num_tests ) {
+        $self->{No_Plan} = 0;
+    }
+    else {
+        $num_tests = $self->current_test;
+    }
+
+    if( $self->{Done_Testing} ) {
+        my($file, $line) = @{$self->{Done_Testing}}[1,2];
+        $self->ok(0, "done_testing() was already called at $file line $line");
+        return;
+    }
+
+    $self->{Done_Testing} = [caller];
+
+    if( $self->expected_tests && $num_tests != $self->expected_tests ) {
+        $self->ok(0, "planned to run @{[ $self->expected_tests ]} ".
+                     "but done_testing() expects $num_tests");
+    }
+    else {
+        $self->{Expected_Tests} = $num_tests;
+    }
+
+    $self->_output_plan($num_tests) unless $self->{Have_Output_Plan};
+
+    $self->{Have_Plan} = 1;
+
+    # The wrong number of tests were run
+    $self->is_passing(0) if $self->{Expected_Tests} != $self->{Curr_Test};
+
+    # No tests were run
+    $self->is_passing(0) if $self->{Curr_Test} == 0;
+
+    return 1;
+}
+
+
+#line 630
+
+sub has_plan {
+    my $self = shift;
+
+    return( $self->{Expected_Tests} ) if $self->{Expected_Tests};
+    return('no_plan') if $self->{No_Plan};
+    return(undef);
+}
+
+#line 647
+
+sub skip_all {
+    my( $self, $reason ) = @_;
+
+    $self->{Skip_All} = $self->parent ? $reason : 1;
+
+    $self->_output_plan(0, "SKIP", $reason) unless $self->no_header;
+    if ( $self->parent ) {
+        die bless {} => 'Test::Builder::Exception';
+    }
+    exit(0);
+}
+
+#line 672
+
+sub exported_to {
+    my( $self, $pack ) = @_;
+
+    if( defined $pack ) {
+        $self->{Exported_To} = $pack;
+    }
+    return $self->{Exported_To};
+}
+
+#line 702
+
+sub ok {
+    my( $self, $test, $name ) = @_;
+
+    if ( $self->{Child_Name} and not $self->{In_Destroy} ) {
+        $name = 'unnamed test' unless defined $name;
+        $self->is_passing(0);
+        $self->croak("Cannot run test ($name) with active children");
+    }
+    # $test might contain an object which we don't want to accidentally
+    # store, so we turn it into a boolean.
+    $test = $test ? 1 : 0;
+
+    lock $self->{Curr_Test};
+    $self->{Curr_Test}++;
+
+    # In case $name is a string overloaded object, force it to stringify.
+    $self->_unoverload_str( \$name );
+
+    $self->diag(<<"ERR") if defined $name and $name =~ /^[\d\s]+$/;
+    You named your test '$name'.  You shouldn't use numbers for your test names.
+    Very confusing.
+ERR
+
+    # Capture the value of $TODO for the rest of this ok() call
+    # so it can more easily be found by other routines.
+    my $todo    = $self->todo();
+    my $in_todo = $self->in_todo;
+    local $self->{Todo} = $todo if $in_todo;
+
+    $self->_unoverload_str( \$todo );
+
+    my $out;
+    my $result = &share( {} );
+
+    unless($test) {
+        $out .= "not ";
+        @$result{ 'ok', 'actual_ok' } = ( ( $self->in_todo ? 1 : 0 ), 0 );
+    }
+    else {
+        @$result{ 'ok', 'actual_ok' } = ( 1, $test );
+    }
+
+    $out .= "ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+
+    if( defined $name ) {
+        $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
+        $out .= " - $name";
+        $result->{name} = $name;
+    }
+    else {
+        $result->{name} = '';
+    }
+
+    if( $self->in_todo ) {
+        $out .= " # TODO $todo";
+        $result->{reason} = $todo;
+        $result->{type}   = 'todo';
+    }
+    else {
+        $result->{reason} = '';
+        $result->{type}   = '';
+    }
+
+    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = $result;
+    $out .= "\n";
+
+    $self->_print($out);
+
+    unless($test) {
+        my $msg = $self->in_todo ? "Failed (TODO)" : "Failed";
+        $self->_print_to_fh( $self->_diag_fh, "\n" ) if $ENV{HARNESS_ACTIVE};
+
+        my( undef, $file, $line ) = $self->caller;
+        if( defined $name ) {
+            $self->diag(qq[  $msg test '$name'\n]);
+            $self->diag(qq[  at $file line $line.\n]);
+        }
+        else {
+            $self->diag(qq[  $msg test at $file line $line.\n]);
+        }
+    }
+
+    $self->is_passing(0) unless $test || $self->in_todo;
+
+    # Check that we haven't violated the plan
+    $self->_check_is_passing_plan();
+
+    return $test ? 1 : 0;
+}
+
+
+# Check that we haven't yet violated the plan and set
+# is_passing() accordingly
+sub _check_is_passing_plan {
+    my $self = shift;
+
+    my $plan = $self->has_plan;
+    return unless defined $plan;        # no plan yet defined
+    return unless $plan !~ /\D/;        # no numeric plan
+    $self->is_passing(0) if $plan < $self->{Curr_Test};
+}
+
+
+sub _unoverload {
+    my $self = shift;
+    my $type = shift;
+
+    $self->_try(sub { require overload; }, die_on_fail => 1);
+
+    foreach my $thing (@_) {
+        if( $self->_is_object($$thing) ) {
+            if( my $string_meth = overload::Method( $$thing, $type ) ) {
+                $$thing = $$thing->$string_meth();
+            }
+        }
+    }
+
+    return;
+}
+
+sub _is_object {
+    my( $self, $thing ) = @_;
+
+    return $self->_try( sub { ref $thing && $thing->isa('UNIVERSAL') } ) ? 1 : 0;
+}
+
+sub _unoverload_str {
+    my $self = shift;
+
+    return $self->_unoverload( q[""], @_ );
+}
+
+sub _unoverload_num {
+    my $self = shift;
+
+    $self->_unoverload( '0+', @_ );
+
+    for my $val (@_) {
+        next unless $self->_is_dualvar($$val);
+        $$val = $$val + 0;
+    }
+
+    return;
+}
+
+# This is a hack to detect a dualvar such as $!
+sub _is_dualvar {
+    my( $self, $val ) = @_;
+
+    # Objects are not dualvars.
+    return 0 if ref $val;
+
+    no warnings 'numeric';
+    my $numval = $val + 0;
+    return $numval != 0 and $numval ne $val ? 1 : 0;
+}
+
+#line 876
+
+sub is_eq {
+    my( $self, $got, $expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    $self->_unoverload_str( \$got, \$expect );
+
+    if( !defined $got || !defined $expect ) {
+        # undef only matches undef and nothing else
+        my $test = !defined $got && !defined $expect;
+
+        $self->ok( $test, $name );
+        $self->_is_diag( $got, 'eq', $expect ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, 'eq', $expect, $name );
+}
+
+sub is_num {
+    my( $self, $got, $expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    $self->_unoverload_num( \$got, \$expect );
+
+    if( !defined $got || !defined $expect ) {
+        # undef only matches undef and nothing else
+        my $test = !defined $got && !defined $expect;
+
+        $self->ok( $test, $name );
+        $self->_is_diag( $got, '==', $expect ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, '==', $expect, $name );
+}
+
+sub _diag_fmt {
+    my( $self, $type, $val ) = @_;
+
+    if( defined $$val ) {
+        if( $type eq 'eq' or $type eq 'ne' ) {
+            # quote and force string context
+            $$val = "'$$val'";
+        }
+        else {
+            # force numeric context
+            $self->_unoverload_num($val);
+        }
+    }
+    else {
+        $$val = 'undef';
+    }
+
+    return;
+}
+
+sub _is_diag {
+    my( $self, $got, $type, $expect ) = @_;
+
+    $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
+
+    local $Level = $Level + 1;
+    return $self->diag(<<"DIAGNOSTIC");
+         got: $got
+    expected: $expect
+DIAGNOSTIC
+
+}
+
+sub _isnt_diag {
+    my( $self, $got, $type ) = @_;
+
+    $self->_diag_fmt( $type, \$got );
+
+    local $Level = $Level + 1;
+    return $self->diag(<<"DIAGNOSTIC");
+         got: $got
+    expected: anything else
+DIAGNOSTIC
+}
+
+#line 973
+
+sub isnt_eq {
+    my( $self, $got, $dont_expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $dont_expect ) {
+        # undef only matches undef and nothing else
+        my $test = defined $got || defined $dont_expect;
+
+        $self->ok( $test, $name );
+        $self->_isnt_diag( $got, 'ne' ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, 'ne', $dont_expect, $name );
+}
+
+sub isnt_num {
+    my( $self, $got, $dont_expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $dont_expect ) {
+        # undef only matches undef and nothing else
+        my $test = defined $got || defined $dont_expect;
+
+        $self->ok( $test, $name );
+        $self->_isnt_diag( $got, '!=' ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, '!=', $dont_expect, $name );
+}
+
+#line 1022
+
+sub like {
+    my( $self, $this, $regex, $name ) = @_;
+
+    local $Level = $Level + 1;
+    return $self->_regex_ok( $this, $regex, '=~', $name );
+}
+
+sub unlike {
+    my( $self, $this, $regex, $name ) = @_;
+
+    local $Level = $Level + 1;
+    return $self->_regex_ok( $this, $regex, '!~', $name );
+}
+
+#line 1046
+
+my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
+
+sub cmp_ok {
+    my( $self, $got, $type, $expect, $name ) = @_;
+
+    my $test;
+    my $error;
+    {
+        ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+        local( $@, $!, $SIG{__DIE__} );    # isolate eval
+
+        my($pack, $file, $line) = $self->caller();
+
+        $test = eval qq[
+#line 1 "cmp_ok [from $file line $line]"
+\$got $type \$expect;
+];
+        $error = $@;
+    }
+    local $Level = $Level + 1;
+    my $ok = $self->ok( $test, $name );
+
+    # Treat overloaded objects as numbers if we're asked to do a
+    # numeric comparison.
+    my $unoverload
+      = $numeric_cmps{$type}
+      ? '_unoverload_num'
+      : '_unoverload_str';
+
+    $self->diag(<<"END") if $error;
+An error occurred while using $type:
+------------------------------------
+$error
+------------------------------------
+END
+
+    unless($ok) {
+        $self->$unoverload( \$got, \$expect );
+
+        if( $type =~ /^(eq|==)$/ ) {
+            $self->_is_diag( $got, $type, $expect );
+        }
+        elsif( $type =~ /^(ne|!=)$/ ) {
+            $self->_isnt_diag( $got, $type );
+        }
+        else {
+            $self->_cmp_diag( $got, $type, $expect );
+        }
+    }
+    return $ok;
+}
+
+sub _cmp_diag {
+    my( $self, $got, $type, $expect ) = @_;
+
+    $got    = defined $got    ? "'$got'"    : 'undef';
+    $expect = defined $expect ? "'$expect'" : 'undef';
+
+    local $Level = $Level + 1;
+    return $self->diag(<<"DIAGNOSTIC");
+    $got
+        $type
+    $expect
+DIAGNOSTIC
+}
+
+sub _caller_context {
+    my $self = shift;
+
+    my( $pack, $file, $line ) = $self->caller(1);
+
+    my $code = '';
+    $code .= "#line $line $file\n" if defined $file and defined $line;
+
+    return $code;
+}
+
+#line 1145
+
+sub BAIL_OUT {
+    my( $self, $reason ) = @_;
+
+    $self->{Bailed_Out} = 1;
+    $self->_print("Bail out!  $reason");
+    exit 255;
+}
+
+#line 1158
+
+{
+    no warnings 'once';
+    *BAILOUT = \&BAIL_OUT;
+}
+
+#line 1172
+
+sub skip {
+    my( $self, $why ) = @_;
+    $why ||= '';
+    $self->_unoverload_str( \$why );
+
+    lock( $self->{Curr_Test} );
+    $self->{Curr_Test}++;
+
+    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
+        {
+            'ok'      => 1,
+            actual_ok => 1,
+            name      => '',
+            type      => 'skip',
+            reason    => $why,
+        }
+    );
+
+    my $out = "ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+    $out .= " # skip";
+    $out .= " $why"               if length $why;
+    $out .= "\n";
+
+    $self->_print($out);
+
+    return 1;
+}
+
+#line 1213
+
+sub todo_skip {
+    my( $self, $why ) = @_;
+    $why ||= '';
+
+    lock( $self->{Curr_Test} );
+    $self->{Curr_Test}++;
+
+    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
+        {
+            'ok'      => 1,
+            actual_ok => 0,
+            name      => '',
+            type      => 'todo_skip',
+            reason    => $why,
+        }
+    );
+
+    my $out = "not ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+    $out .= " # TODO & SKIP $why\n";
+
+    $self->_print($out);
+
+    return 1;
+}
+
+#line 1293
+
+sub maybe_regex {
+    my( $self, $regex ) = @_;
+    my $usable_regex = undef;
+
+    return $usable_regex unless defined $regex;
+
+    my( $re, $opts );
+
+    # Check for qr/foo/
+    if( _is_qr($regex) ) {
+        $usable_regex = $regex;
+    }
+    # Check for '/foo/' or 'm,foo,'
+    elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
+          ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
+    )
+    {
+        $usable_regex = length $opts ? "(?$opts)$re" : $re;
+    }
+
+    return $usable_regex;
+}
+
+sub _is_qr {
+    my $regex = shift;
+
+    # is_regexp() checks for regexes in a robust manner, say if they're
+    # blessed.
+    return re::is_regexp($regex) if defined &re::is_regexp;
+    return ref $regex eq 'Regexp';
+}
+
+sub _regex_ok {
+    my( $self, $this, $regex, $cmp, $name ) = @_;
+
+    my $ok           = 0;
+    my $usable_regex = $self->maybe_regex($regex);
+    unless( defined $usable_regex ) {
+        local $Level = $Level + 1;
+        $ok = $self->ok( 0, $name );
+        $self->diag("    '$regex' doesn't look much like a regex to me.");
+        return $ok;
+    }
+
+    {
+        ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+        my $test;
+        my $context = $self->_caller_context;
+
+        local( $@, $!, $SIG{__DIE__} );    # isolate eval
+
+        $test = eval $context . q{$test = $this =~ /$usable_regex/ ? 1 : 0};
+
+        $test = !$test if $cmp eq '!~';
+
+        local $Level = $Level + 1;
+        $ok = $self->ok( $test, $name );
+    }
+
+    unless($ok) {
+        $this = defined $this ? "'$this'" : 'undef';
+        my $match = $cmp eq '=~' ? "doesn't match" : "matches";
+
+        local $Level = $Level + 1;
+        $self->diag( sprintf <<'DIAGNOSTIC', $this, $match, $regex );
+                  %s
+    %13s '%s'
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+# I'm not ready to publish this.  It doesn't deal with array return
+# values from the code or context.
+
+#line 1389
+
+sub _try {
+    my( $self, $code, %opts ) = @_;
+
+    my $error;
+    my $return;
+    {
+        local $!;               # eval can mess up $!
+        local $@;               # don't set $@ in the test
+        local $SIG{__DIE__};    # don't trip an outside DIE handler.
+        $return = eval { $code->() };
+        $error = $@;
+    }
+
+    die $error if $error and $opts{die_on_fail};
+
+    return wantarray ? ( $return, $error ) : $return;
+}
+
+#line 1418
+
+sub is_fh {
+    my $self     = shift;
+    my $maybe_fh = shift;
+    return 0 unless defined $maybe_fh;
+
+    return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
+    return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
+
+    return eval { $maybe_fh->isa("IO::Handle") } ||
+           eval { tied($maybe_fh)->can('TIEHANDLE') };
+}
+
+#line 1461
+
+sub level {
+    my( $self, $level ) = @_;
+
+    if( defined $level ) {
+        $Level = $level;
+    }
+    return $Level;
+}
+
+#line 1493
+
+sub use_numbers {
+    my( $self, $use_nums ) = @_;
+
+    if( defined $use_nums ) {
+        $self->{Use_Nums} = $use_nums;
+    }
+    return $self->{Use_Nums};
+}
+
+#line 1526
+
+foreach my $attribute (qw(No_Header No_Ending No_Diag)) {
+    my $method = lc $attribute;
+
+    my $code = sub {
+        my( $self, $no ) = @_;
+
+        if( defined $no ) {
+            $self->{$attribute} = $no;
+        }
+        return $self->{$attribute};
+    };
+
+    no strict 'refs';    ## no critic
+    *{ __PACKAGE__ . '::' . $method } = $code;
+}
+
+#line 1579
+
+sub diag {
+    my $self = shift;
+
+    $self->_print_comment( $self->_diag_fh, @_ );
+}
+
+#line 1594
+
+sub note {
+    my $self = shift;
+
+    $self->_print_comment( $self->output, @_ );
+}
+
+sub _diag_fh {
+    my $self = shift;
+
+    local $Level = $Level + 1;
+    return $self->in_todo ? $self->todo_output : $self->failure_output;
+}
+
+sub _print_comment {
+    my( $self, $fh, @msgs ) = @_;
+
+    return if $self->no_diag;
+    return unless @msgs;
+
+    # Prevent printing headers when compiling (i.e. -c)
+    return if $^C;
+
+    # Smash args together like print does.
+    # Convert undef to 'undef' so its readable.
+    my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
+
+    # Escape the beginning, _print will take care of the rest.
+    $msg =~ s/^/# /;
+
+    local $Level = $Level + 1;
+    $self->_print_to_fh( $fh, $msg );
+
+    return 0;
+}
+
+#line 1644
+
+sub explain {
+    my $self = shift;
+
+    return map {
+        ref $_
+          ? do {
+            $self->_try(sub { require Data::Dumper }, die_on_fail => 1);
+
+            my $dumper = Data::Dumper->new( [$_] );
+            $dumper->Indent(1)->Terse(1);
+            $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
+            $dumper->Dump;
+          }
+          : $_
+    } @_;
+}
+
+#line 1673
+
+sub _print {
+    my $self = shift;
+    return $self->_print_to_fh( $self->output, @_ );
+}
+
+sub _print_to_fh {
+    my( $self, $fh, @msgs ) = @_;
+
+    # Prevent printing headers when only compiling.  Mostly for when
+    # tests are deparsed with B::Deparse
+    return if $^C;
+
+    my $msg = join '', @msgs;
+
+    local( $\, $", $, ) = ( undef, ' ', '' );
+
+    # Escape each line after the first with a # so we don't
+    # confuse Test::Harness.
+    $msg =~ s{\n(?!\z)}{\n# }sg;
+
+    # Stick a newline on the end if it needs it.
+    $msg .= "\n" unless $msg =~ /\n\z/;
+
+    return print $fh $self->_indent, $msg;
+}
+
+#line 1732
+
+sub output {
+    my( $self, $fh ) = @_;
+
+    if( defined $fh ) {
+        $self->{Out_FH} = $self->_new_fh($fh);
+    }
+    return $self->{Out_FH};
+}
+
+sub failure_output {
+    my( $self, $fh ) = @_;
+
+    if( defined $fh ) {
+        $self->{Fail_FH} = $self->_new_fh($fh);
+    }
+    return $self->{Fail_FH};
+}
+
+sub todo_output {
+    my( $self, $fh ) = @_;
+
+    if( defined $fh ) {
+        $self->{Todo_FH} = $self->_new_fh($fh);
+    }
+    return $self->{Todo_FH};
+}
+
+sub _new_fh {
+    my $self = shift;
+    my($file_or_fh) = shift;
+
+    my $fh;
+    if( $self->is_fh($file_or_fh) ) {
+        $fh = $file_or_fh;
+    }
+    elsif( ref $file_or_fh eq 'SCALAR' ) {
+        # Scalar refs as filehandles was added in 5.8.
+        if( $] >= 5.008 ) {
+            open $fh, ">>", $file_or_fh
+              or $self->croak("Can't open scalar ref $file_or_fh: $!");
+        }
+        # Emulate scalar ref filehandles with a tie.
+        else {
+            $fh = Test::Builder::IO::Scalar->new($file_or_fh)
+              or $self->croak("Can't tie scalar ref $file_or_fh");
+        }
+    }
+    else {
+        open $fh, ">", $file_or_fh
+          or $self->croak("Can't open test output log $file_or_fh: $!");
+        _autoflush($fh);
+    }
+
+    return $fh;
+}
+
+sub _autoflush {
+    my($fh) = shift;
+    my $old_fh = select $fh;
+    $| = 1;
+    select $old_fh;
+
+    return;
+}
+
+my( $Testout, $Testerr );
+
+sub _dup_stdhandles {
+    my $self = shift;
+
+    $self->_open_testhandles;
+
+    # Set everything to unbuffered else plain prints to STDOUT will
+    # come out in the wrong order from our own prints.
+    _autoflush($Testout);
+    _autoflush( \*STDOUT );
+    _autoflush($Testerr);
+    _autoflush( \*STDERR );
+
+    $self->reset_outputs;
+
+    return;
+}
+
+sub _open_testhandles {
+    my $self = shift;
+
+    return if $self->{Opened_Testhandles};
+
+    # We dup STDOUT and STDERR so people can change them in their
+    # test suites while still getting normal test output.
+    open( $Testout, ">&STDOUT" ) or die "Can't dup STDOUT:  $!";
+    open( $Testerr, ">&STDERR" ) or die "Can't dup STDERR:  $!";
+
+    #    $self->_copy_io_layers( \*STDOUT, $Testout );
+    #    $self->_copy_io_layers( \*STDERR, $Testerr );
+
+    $self->{Opened_Testhandles} = 1;
+
+    return;
+}
+
+sub _copy_io_layers {
+    my( $self, $src, $dst ) = @_;
+
+    $self->_try(
+        sub {
+            require PerlIO;
+            my @src_layers = PerlIO::get_layers($src);
+
+            binmode $dst, join " ", map ":$_", @src_layers if @src_layers;
+        }
+    );
+
+    return;
+}
+
+#line 1857
+
+sub reset_outputs {
+    my $self = shift;
+
+    $self->output        ($Testout);
+    $self->failure_output($Testerr);
+    $self->todo_output   ($Testout);
+
+    return;
+}
+
+#line 1883
+
+sub _message_at_caller {
+    my $self = shift;
+
+    local $Level = $Level + 1;
+    my( $pack, $file, $line ) = $self->caller;
+    return join( "", @_ ) . " at $file line $line.\n";
+}
+
+sub carp {
+    my $self = shift;
+    return warn $self->_message_at_caller(@_);
+}
+
+sub croak {
+    my $self = shift;
+    return die $self->_message_at_caller(@_);
+}
+
+
+#line 1923
+
+sub current_test {
+    my( $self, $num ) = @_;
+
+    lock( $self->{Curr_Test} );
+    if( defined $num ) {
+        $self->{Curr_Test} = $num;
+
+        # If the test counter is being pushed forward fill in the details.
+        my $test_results = $self->{Test_Results};
+        if( $num > @$test_results ) {
+            my $start = @$test_results ? @$test_results : 0;
+            for( $start .. $num - 1 ) {
+                $test_results->[$_] = &share(
+                    {
+                        'ok'      => 1,
+                        actual_ok => undef,
+                        reason    => 'incrementing test number',
+                        type      => 'unknown',
+                        name      => undef
+                    }
+                );
+            }
+        }
+        # If backward, wipe history.  Its their funeral.
+        elsif( $num < @$test_results ) {
+            $#{$test_results} = $num - 1;
+        }
+    }
+    return $self->{Curr_Test};
+}
+
+#line 1971
+
+sub is_passing {
+    my $self = shift;
+
+    if( @_ ) {
+        $self->{Is_Passing} = shift;
+    }
+
+    return $self->{Is_Passing};
+}
+
+
+#line 1993
+
+sub summary {
+    my($self) = shift;
+
+    return map { $_->{'ok'} } @{ $self->{Test_Results} };
+}
+
+#line 2048
+
+sub details {
+    my $self = shift;
+    return @{ $self->{Test_Results} };
+}
+
+#line 2077
+
+sub todo {
+    my( $self, $pack ) = @_;
+
+    return $self->{Todo} if defined $self->{Todo};
+
+    local $Level = $Level + 1;
+    my $todo = $self->find_TODO($pack);
+    return $todo if defined $todo;
+
+    return '';
+}
+
+#line 2099
+
+sub find_TODO {
+    my( $self, $pack ) = @_;
+
+    $pack = $pack || $self->caller(1) || $self->exported_to;
+    return unless $pack;
+
+    no strict 'refs';    ## no critic
+    return ${ $pack . '::TODO' };
+}
+
+#line 2117
+
+sub in_todo {
+    my $self = shift;
+
+    local $Level = $Level + 1;
+    return( defined $self->{Todo} || $self->find_TODO ) ? 1 : 0;
+}
+
+#line 2167
+
+sub todo_start {
+    my $self = shift;
+    my $message = @_ ? shift : '';
+
+    $self->{Start_Todo}++;
+    if( $self->in_todo ) {
+        push @{ $self->{Todo_Stack} } => $self->todo;
+    }
+    $self->{Todo} = $message;
+
+    return;
+}
+
+#line 2189
+
+sub todo_end {
+    my $self = shift;
+
+    if( !$self->{Start_Todo} ) {
+        $self->croak('todo_end() called without todo_start()');
+    }
+
+    $self->{Start_Todo}--;
+
+    if( $self->{Start_Todo} && @{ $self->{Todo_Stack} } ) {
+        $self->{Todo} = pop @{ $self->{Todo_Stack} };
+    }
+    else {
+        delete $self->{Todo};
+    }
+
+    return;
+}
+
+#line 2222
+
+sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
+    my( $self, $height ) = @_;
+    $height ||= 0;
+
+    my $level = $self->level + $height + 1;
+    my @caller;
+    do {
+        @caller = CORE::caller( $level );
+        $level--;
+    } until @caller;
+    return wantarray ? @caller : $caller[0];
+}
+
+#line 2239
+
+#line 2253
+
+#'#
+sub _sanity_check {
+    my $self = shift;
+
+    $self->_whoa( $self->{Curr_Test} < 0, 'Says here you ran a negative number of tests!' );
+    $self->_whoa( $self->{Curr_Test} != @{ $self->{Test_Results} },
+        'Somehow you got a different number of results than tests ran!' );
+
+    return;
+}
+
+#line 2274
+
+sub _whoa {
+    my( $self, $check, $desc ) = @_;
+    if($check) {
+        local $Level = $Level + 1;
+        $self->croak(<<"WHOA");
+WHOA!  $desc
+This should never happen!  Please contact the author immediately!
+WHOA
+    }
+
+    return;
+}
+
+#line 2298
+
+sub _my_exit {
+    $? = $_[0];    ## no critic (Variables::RequireLocalizedPunctuationVars)
+
+    return 1;
+}
+
+#line 2310
+
+sub _ending {
+    my $self = shift;
+    return if $self->no_ending;
+    return if $self->{Ending}++;
+
+    my $real_exit_code = $?;
+
+    # Don't bother with an ending if this is a forked copy.  Only the parent
+    # should do the ending.
+    if( $self->{Original_Pid} != $$ ) {
+        return;
+    }
+
+    # Ran tests but never declared a plan or hit done_testing
+    if( !$self->{Have_Plan} and $self->{Curr_Test} ) {
+        $self->is_passing(0);
+        $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
+    }
+
+    # Exit if plan() was never called.  This is so "require Test::Simple"
+    # doesn't puke.
+    if( !$self->{Have_Plan} ) {
+        return;
+    }
+
+    # Don't do an ending if we bailed out.
+    if( $self->{Bailed_Out} ) {
+        $self->is_passing(0);
+        return;
+    }
+    # Figure out if we passed or failed and print helpful messages.
+    my $test_results = $self->{Test_Results};
+    if(@$test_results) {
+        # The plan?  We have no plan.
+        if( $self->{No_Plan} ) {
+            $self->_output_plan($self->{Curr_Test}) unless $self->no_header;
+            $self->{Expected_Tests} = $self->{Curr_Test};
+        }
+
+        # Auto-extended arrays and elements which aren't explicitly
+        # filled in with a shared reference will puke under 5.8.0
+        # ithreads.  So we have to fill them in by hand. :(
+        my $empty_result = &share( {} );
+        for my $idx ( 0 .. $self->{Expected_Tests} - 1 ) {
+            $test_results->[$idx] = $empty_result
+              unless defined $test_results->[$idx];
+        }
+
+        my $num_failed = grep !$_->{'ok'}, @{$test_results}[ 0 .. $self->{Curr_Test} - 1 ];
+
+        my $num_extra = $self->{Curr_Test} - $self->{Expected_Tests};
+
+        if( $num_extra != 0 ) {
+            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
+            $self->diag(<<"FAIL");
+Looks like you planned $self->{Expected_Tests} test$s but ran $self->{Curr_Test}.
+FAIL
+            $self->is_passing(0);
+        }
+
+        if($num_failed) {
+            my $num_tests = $self->{Curr_Test};
+            my $s = $num_failed == 1 ? '' : 's';
+
+            my $qualifier = $num_extra == 0 ? '' : ' run';
+
+            $self->diag(<<"FAIL");
+Looks like you failed $num_failed test$s of $num_tests$qualifier.
+FAIL
+            $self->is_passing(0);
+        }
+
+        if($real_exit_code) {
+            $self->diag(<<"FAIL");
+Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
+FAIL
+            $self->is_passing(0);
+            _my_exit($real_exit_code) && return;
+        }
+
+        my $exit_code;
+        if($num_failed) {
+            $exit_code = $num_failed <= 254 ? $num_failed : 254;
+        }
+        elsif( $num_extra != 0 ) {
+            $exit_code = 255;
+        }
+        else {
+            $exit_code = 0;
+        }
+
+        _my_exit($exit_code) && return;
+    }
+    elsif( $self->{Skip_All} ) {
+        _my_exit(0) && return;
+    }
+    elsif($real_exit_code) {
+        $self->diag(<<"FAIL");
+Looks like your test exited with $real_exit_code before it could output anything.
+FAIL
+        $self->is_passing(0);
+        _my_exit($real_exit_code) && return;
+    }
+    else {
+        $self->diag("No tests run!\n");
+        $self->is_passing(0);
+        _my_exit(255) && return;
+    }
+
+    $self->is_passing(0);
+    $self->_whoa( 1, "We fell off the end of _ending()" );
+}
+
+END {
+    $Test->_ending if defined $Test;
+}
+
+#line 2498
+
+1;
+
diff --git a/src/tcp/test/inc/Test/Builder/Module.pm b/src/tcp/test/inc/Test/Builder/Module.pm
new file mode 100755
index 0000000..ffef230
--- /dev/null
+++ b/src/tcp/test/inc/Test/Builder/Module.pm
@@ -0,0 +1,73 @@
+#line 1
+package Test::Builder::Module;
+
+use strict;
+
+use Test::Builder;
+
+require Exporter;
+our @ISA = qw(Exporter);
+
+our $VERSION = '0.94';
+$VERSION = eval $VERSION;      ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+
+#line 74
+
+sub import {
+    my($class) = shift;
+
+    # Don't run all this when loading ourself.
+    return 1 if $class eq 'Test::Builder::Module';
+
+    my $test = $class->builder;
+
+    my $caller = caller;
+
+    $test->exported_to($caller);
+
+    $class->import_extra( \@_ );
+    my(@imports) = $class->_strip_imports( \@_ );
+
+    $test->plan(@_);
+
+    $class->export_to_level( 1, $class, @imports );
+}
+
+sub _strip_imports {
+    my $class = shift;
+    my $list  = shift;
+
+    my @imports = ();
+    my @other   = ();
+    my $idx     = 0;
+    while( $idx <= $#{$list} ) {
+        my $item = $list->[$idx];
+
+        if( defined $item and $item eq 'import' ) {
+            push @imports, @{ $list->[ $idx + 1 ] };
+            $idx++;
+        }
+        else {
+            push @other, $item;
+        }
+
+        $idx++;
+    }
+
+    @$list = @other;
+
+    return @imports;
+}
+
+#line 137
+
+sub import_extra { }
+
+#line 167
+
+sub builder {
+    return Test::Builder->new;
+}
+
+1;
diff --git a/src/tcp/test/inc/Test/More.pm b/src/tcp/test/inc/Test/More.pm
new file mode 100755
index 0000000..9d41458
--- /dev/null
+++ b/src/tcp/test/inc/Test/More.pm
@@ -0,0 +1,746 @@
+#line 1
+package Test::More;
+
+use 5.006;
+use strict;
+use warnings;
+
+#---- perlcritic exemptions. ----#
+
+# We use a lot of subroutine prototypes
+## no critic (Subroutines::ProhibitSubroutinePrototypes)
+
+# Can't use Carp because it might cause use_ok() to accidentally succeed
+# even though the module being used forgot to use Carp.  Yes, this
+# actually happened.
+sub _carp {
+    my( $file, $line ) = ( caller(1) )[ 1, 2 ];
+    return warn @_, " at $file line $line\n";
+}
+
+our $VERSION = '0.94';
+$VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+use Test::Builder::Module;
+our @ISA    = qw(Test::Builder::Module);
+our @EXPORT = qw(ok use_ok require_ok
+  is isnt like unlike is_deeply
+  cmp_ok
+  skip todo todo_skip
+  pass fail
+  eq_array eq_hash eq_set
+  $TODO
+  plan
+  done_testing
+  can_ok isa_ok new_ok
+  diag note explain
+  subtest
+  BAIL_OUT
+);
+
+#line 164
+
+sub plan {
+    my $tb = Test::More->builder;
+
+    return $tb->plan(@_);
+}
+
+# This implements "use Test::More 'no_diag'" but the behavior is
+# deprecated.
+sub import_extra {
+    my $class = shift;
+    my $list  = shift;
+
+    my @other = ();
+    my $idx   = 0;
+    while( $idx <= $#{$list} ) {
+        my $item = $list->[$idx];
+
+        if( defined $item and $item eq 'no_diag' ) {
+            $class->builder->no_diag(1);
+        }
+        else {
+            push @other, $item;
+        }
+
+        $idx++;
+    }
+
+    @$list = @other;
+
+    return;
+}
+
+#line 217
+
+sub done_testing {
+    my $tb = Test::More->builder;
+    $tb->done_testing(@_);
+}
+
+#line 289
+
+sub ok ($;$) {
+    my( $test, $name ) = @_;
+    my $tb = Test::More->builder;
+
+    return $tb->ok( $test, $name );
+}
+
+#line 367
+
+sub is ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->is_eq(@_);
+}
+
+sub isnt ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->isnt_eq(@_);
+}
+
+*isn't = \&isnt;
+
+#line 411
+
+sub like ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->like(@_);
+}
+
+#line 426
+
+sub unlike ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->unlike(@_);
+}
+
+#line 471
+
+sub cmp_ok($$$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->cmp_ok(@_);
+}
+
+#line 506
+
+sub can_ok ($@) {
+    my( $proto, @methods ) = @_;
+    my $class = ref $proto || $proto;
+    my $tb = Test::More->builder;
+
+    unless($class) {
+        my $ok = $tb->ok( 0, "->can(...)" );
+        $tb->diag('    can_ok() called with empty class or reference');
+        return $ok;
+    }
+
+    unless(@methods) {
+        my $ok = $tb->ok( 0, "$class->can(...)" );
+        $tb->diag('    can_ok() called with no methods');
+        return $ok;
+    }
+
+    my @nok = ();
+    foreach my $method (@methods) {
+        $tb->_try( sub { $proto->can($method) } ) or push @nok, $method;
+    }
+
+    my $name = (@methods == 1) ? "$class->can('$methods[0]')" :
+                                 "$class->can(...)"           ;
+
+    my $ok = $tb->ok( !@nok, $name );
+
+    $tb->diag( map "    $class->can('$_') failed\n", @nok );
+
+    return $ok;
+}
+
+#line 572
+
+sub isa_ok ($$;$) {
+    my( $object, $class, $obj_name ) = @_;
+    my $tb = Test::More->builder;
+
+    my $diag;
+
+    if( !defined $object ) {
+        $obj_name = 'The thing' unless defined $obj_name;
+        $diag = "$obj_name isn't defined";
+    }
+    else {
+        my $whatami = ref $object ? 'object' : 'class';
+        # We can't use UNIVERSAL::isa because we want to honor isa() overrides
+        my( $rslt, $error ) = $tb->_try( sub { $object->isa($class) } );
+        if($error) {
+            if( $error =~ /^Can't call method "isa" on unblessed reference/ ) {
+                # Its an unblessed reference
+                $obj_name = 'The reference' unless defined $obj_name;
+                if( !UNIVERSAL::isa( $object, $class ) ) {
+                    my $ref = ref $object;
+                    $diag = "$obj_name isn't a '$class' it's a '$ref'";
+                }
+            }
+            elsif( $error =~ /Can't call method "isa" without a package/ ) {
+                # It's something that can't even be a class
+                $obj_name = 'The thing' unless defined $obj_name;
+                $diag = "$obj_name isn't a class or reference";
+            }
+            else {
+                die <<WHOA;
+WHOA! I tried to call ->isa on your $whatami and got some weird error.
+Here's the error.
+$error
+WHOA
+            }
+        }
+        else {
+            $obj_name = "The $whatami" unless defined $obj_name;
+            if( !$rslt ) {
+                my $ref = ref $object;
+                $diag = "$obj_name isn't a '$class' it's a '$ref'";
+            }
+        }
+    }
+
+    my $name = "$obj_name isa $class";
+    my $ok;
+    if($diag) {
+        $ok = $tb->ok( 0, $name );
+        $tb->diag("    $diag\n");
+    }
+    else {
+        $ok = $tb->ok( 1, $name );
+    }
+
+    return $ok;
+}
+
+#line 651
+
+sub new_ok {
+    my $tb = Test::More->builder;
+    $tb->croak("new_ok() must be given at least a class") unless @_;
+
+    my( $class, $args, $object_name ) = @_;
+
+    $args ||= [];
+    $object_name = "The object" unless defined $object_name;
+
+    my $obj;
+    my( $success, $error ) = $tb->_try( sub { $obj = $class->new(@$args); 1 } );
+    if($success) {
+        local $Test::Builder::Level = $Test::Builder::Level + 1;
+        isa_ok $obj, $class, $object_name;
+    }
+    else {
+        $tb->ok( 0, "new() died" );
+        $tb->diag("    Error was:  $error");
+    }
+
+    return $obj;
+}
+
+#line 719
+
+sub subtest($&) {
+    my ($name, $subtests) = @_;
+
+    my $tb = Test::More->builder;
+    return $tb->subtest(@_);
+}
+
+#line 743
+
+sub pass (;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->ok( 1, @_ );
+}
+
+sub fail (;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->ok( 0, @_ );
+}
+
+#line 806
+
+sub use_ok ($;@) {
+    my( $module, @imports ) = @_;
+    @imports = () unless @imports;
+    my $tb = Test::More->builder;
+
+    my( $pack, $filename, $line ) = caller;
+
+    my $code;
+    if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
+        # probably a version check.  Perl needs to see the bare number
+        # for it to work with non-Exporter based modules.
+        $code = <<USE;
+package $pack;
+use $module $imports[0];
+1;
+USE
+    }
+    else {
+        $code = <<USE;
+package $pack;
+use $module \@{\$args[0]};
+1;
+USE
+    }
+
+    my( $eval_result, $eval_error ) = _eval( $code, \@imports );
+    my $ok = $tb->ok( $eval_result, "use $module;" );
+
+    unless($ok) {
+        chomp $eval_error;
+        $@ =~ s{^BEGIN failed--compilation aborted at .*$}
+                {BEGIN failed--compilation aborted at $filename line $line.}m;
+        $tb->diag(<<DIAGNOSTIC);
+    Tried to use '$module'.
+    Error:  $eval_error
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+sub _eval {
+    my( $code, @args ) = @_;
+
+    # Work around oddities surrounding resetting of $@ by immediately
+    # storing it.
+    my( $sigdie, $eval_result, $eval_error );
+    {
+        local( $@, $!, $SIG{__DIE__} );    # isolate eval
+        $eval_result = eval $code;              ## no critic (BuiltinFunctions::ProhibitStringyEval)
+        $eval_error  = $@;
+        $sigdie      = $SIG{__DIE__} || undef;
+    }
+    # make sure that $code got a chance to set $SIG{__DIE__}
+    $SIG{__DIE__} = $sigdie if defined $sigdie;
+
+    return( $eval_result, $eval_error );
+}
+
+#line 875
+
+sub require_ok ($) {
+    my($module) = shift;
+    my $tb = Test::More->builder;
+
+    my $pack = caller;
+
+    # Try to deterine if we've been given a module name or file.
+    # Module names must be barewords, files not.
+    $module = qq['$module'] unless _is_module_name($module);
+
+    my $code = <<REQUIRE;
+package $pack;
+require $module;
+1;
+REQUIRE
+
+    my( $eval_result, $eval_error ) = _eval($code);
+    my $ok = $tb->ok( $eval_result, "require $module;" );
+
+    unless($ok) {
+        chomp $eval_error;
+        $tb->diag(<<DIAGNOSTIC);
+    Tried to require '$module'.
+    Error:  $eval_error
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+sub _is_module_name {
+    my $module = shift;
+
+    # Module names start with a letter.
+    # End with an alphanumeric.
+    # The rest is an alphanumeric or ::
+    $module =~ s/\b::\b//g;
+
+    return $module =~ /^[a-zA-Z]\w*$/ ? 1 : 0;
+}
+
+#line 952
+
+our( @Data_Stack, %Refs_Seen );
+my $DNE = bless [], 'Does::Not::Exist';
+
+sub _dne {
+    return ref $_[0] eq ref $DNE;
+}
+
+## no critic (Subroutines::RequireArgUnpacking)
+sub is_deeply {
+    my $tb = Test::More->builder;
+
+    unless( @_ == 2 or @_ == 3 ) {
+        my $msg = <<'WARNING';
+is_deeply() takes two or three args, you gave %d.
+This usually means you passed an array or hash instead 
+of a reference to it
+WARNING
+        chop $msg;    # clip off newline so carp() will put in line/file
+
+        _carp sprintf $msg, scalar @_;
+
+        return $tb->ok(0);
+    }
+
+    my( $got, $expected, $name ) = @_;
+
+    $tb->_unoverload_str( \$expected, \$got );
+
+    my $ok;
+    if( !ref $got and !ref $expected ) {    # neither is a reference
+        $ok = $tb->is_eq( $got, $expected, $name );
+    }
+    elsif( !ref $got xor !ref $expected ) {    # one's a reference, one isn't
+        $ok = $tb->ok( 0, $name );
+        $tb->diag( _format_stack({ vals => [ $got, $expected ] }) );
+    }
+    else {                                     # both references
+        local @Data_Stack = ();
+        if( _deep_check( $got, $expected ) ) {
+            $ok = $tb->ok( 1, $name );
+        }
+        else {
+            $ok = $tb->ok( 0, $name );
+            $tb->diag( _format_stack(@Data_Stack) );
+        }
+    }
+
+    return $ok;
+}
+
+sub _format_stack {
+    my(@Stack) = @_;
+
+    my $var       = '$FOO';
+    my $did_arrow = 0;
+    foreach my $entry (@Stack) {
+        my $type = $entry->{type} || '';
+        my $idx = $entry->{'idx'};
+        if( $type eq 'HASH' ) {
+            $var .= "->" unless $did_arrow++;
+            $var .= "{$idx}";
+        }
+        elsif( $type eq 'ARRAY' ) {
+            $var .= "->" unless $did_arrow++;
+            $var .= "[$idx]";
+        }
+        elsif( $type eq 'REF' ) {
+            $var = "\${$var}";
+        }
+    }
+
+    my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
+    my @vars = ();
+    ( $vars[0] = $var ) =~ s/\$FOO/     \$got/;
+    ( $vars[1] = $var ) =~ s/\$FOO/\$expected/;
+
+    my $out = "Structures begin differing at:\n";
+    foreach my $idx ( 0 .. $#vals ) {
+        my $val = $vals[$idx];
+        $vals[$idx]
+          = !defined $val ? 'undef'
+          : _dne($val)    ? "Does not exist"
+          : ref $val      ? "$val"
+          :                 "'$val'";
+    }
+
+    $out .= "$vars[0] = $vals[0]\n";
+    $out .= "$vars[1] = $vals[1]\n";
+
+    $out =~ s/^/    /msg;
+    return $out;
+}
+
+sub _type {
+    my $thing = shift;
+
+    return '' if !ref $thing;
+
+    for my $type (qw(ARRAY HASH REF SCALAR GLOB CODE Regexp)) {
+        return $type if UNIVERSAL::isa( $thing, $type );
+    }
+
+    return '';
+}
+
+#line 1112
+
+sub diag {
+    return Test::More->builder->diag(@_);
+}
+
+sub note {
+    return Test::More->builder->note(@_);
+}
+
+#line 1138
+
+sub explain {
+    return Test::More->builder->explain(@_);
+}
+
+#line 1204
+
+## no critic (Subroutines::RequireFinalReturn)
+sub skip {
+    my( $why, $how_many ) = @_;
+    my $tb = Test::More->builder;
+
+    unless( defined $how_many ) {
+        # $how_many can only be avoided when no_plan is in use.
+        _carp "skip() needs to know \$how_many tests are in the block"
+          unless $tb->has_plan eq 'no_plan';
+        $how_many = 1;
+    }
+
+    if( defined $how_many and $how_many =~ /\D/ ) {
+        _carp
+          "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";
+        $how_many = 1;
+    }
+
+    for( 1 .. $how_many ) {
+        $tb->skip($why);
+    }
+
+    no warnings 'exiting';
+    last SKIP;
+}
+
+#line 1288
+
+sub todo_skip {
+    my( $why, $how_many ) = @_;
+    my $tb = Test::More->builder;
+
+    unless( defined $how_many ) {
+        # $how_many can only be avoided when no_plan is in use.
+        _carp "todo_skip() needs to know \$how_many tests are in the block"
+          unless $tb->has_plan eq 'no_plan';
+        $how_many = 1;
+    }
+
+    for( 1 .. $how_many ) {
+        $tb->todo_skip($why);
+    }
+
+    no warnings 'exiting';
+    last TODO;
+}
+
+#line 1343
+
+sub BAIL_OUT {
+    my $reason = shift;
+    my $tb     = Test::More->builder;
+
+    $tb->BAIL_OUT($reason);
+}
+
+#line 1382
+
+#'#
+sub eq_array {
+    local @Data_Stack = ();
+    _deep_check(@_);
+}
+
+sub _eq_array {
+    my( $a1, $a2 ) = @_;
+
+    if( grep _type($_) ne 'ARRAY', $a1, $a2 ) {
+        warn "eq_array passed a non-array ref";
+        return 0;
+    }
+
+    return 1 if $a1 eq $a2;
+
+    my $ok = 1;
+    my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
+    for( 0 .. $max ) {
+        my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
+        my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
+
+        push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [ $e1, $e2 ] };
+        $ok = _deep_check( $e1, $e2 );
+        pop @Data_Stack if $ok;
+
+        last unless $ok;
+    }
+
+    return $ok;
+}
+
+sub _deep_check {
+    my( $e1, $e2 ) = @_;
+    my $tb = Test::More->builder;
+
+    my $ok = 0;
+
+    # Effectively turn %Refs_Seen into a stack.  This avoids picking up
+    # the same referenced used twice (such as [\$a, \$a]) to be considered
+    # circular.
+    local %Refs_Seen = %Refs_Seen;
+
+    {
+        # Quiet uninitialized value warnings when comparing undefs.
+        no warnings 'uninitialized';
+
+        $tb->_unoverload_str( \$e1, \$e2 );
+
+        # Either they're both references or both not.
+        my $same_ref = !( !ref $e1 xor !ref $e2 );
+        my $not_ref = ( !ref $e1 and !ref $e2 );
+
+        if( defined $e1 xor defined $e2 ) {
+            $ok = 0;
+        }
+        elsif( !defined $e1 and !defined $e2 ) {
+            # Shortcut if they're both defined.
+            $ok = 1;
+        }
+        elsif( _dne($e1) xor _dne($e2) ) {
+            $ok = 0;
+        }
+        elsif( $same_ref and( $e1 eq $e2 ) ) {
+            $ok = 1;
+        }
+        elsif($not_ref) {
+            push @Data_Stack, { type => '', vals => [ $e1, $e2 ] };
+            $ok = 0;
+        }
+        else {
+            if( $Refs_Seen{$e1} ) {
+                return $Refs_Seen{$e1} eq $e2;
+            }
+            else {
+                $Refs_Seen{$e1} = "$e2";
+            }
+
+            my $type = _type($e1);
+            $type = 'DIFFERENT' unless _type($e2) eq $type;
+
+            if( $type eq 'DIFFERENT' ) {
+                push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
+                $ok = 0;
+            }
+            elsif( $type eq 'ARRAY' ) {
+                $ok = _eq_array( $e1, $e2 );
+            }
+            elsif( $type eq 'HASH' ) {
+                $ok = _eq_hash( $e1, $e2 );
+            }
+            elsif( $type eq 'REF' ) {
+                push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
+                $ok = _deep_check( $$e1, $$e2 );
+                pop @Data_Stack if $ok;
+            }
+            elsif( $type eq 'SCALAR' ) {
+                push @Data_Stack, { type => 'REF', vals => [ $e1, $e2 ] };
+                $ok = _deep_check( $$e1, $$e2 );
+                pop @Data_Stack if $ok;
+            }
+            elsif($type) {
+                push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
+                $ok = 0;
+            }
+            else {
+                _whoa( 1, "No type in _deep_check" );
+            }
+        }
+    }
+
+    return $ok;
+}
+
+sub _whoa {
+    my( $check, $desc ) = @_;
+    if($check) {
+        die <<"WHOA";
+WHOA!  $desc
+This should never happen!  Please contact the author immediately!
+WHOA
+    }
+}
+
+#line 1515
+
+sub eq_hash {
+    local @Data_Stack = ();
+    return _deep_check(@_);
+}
+
+sub _eq_hash {
+    my( $a1, $a2 ) = @_;
+
+    if( grep _type($_) ne 'HASH', $a1, $a2 ) {
+        warn "eq_hash passed a non-hash ref";
+        return 0;
+    }
+
+    return 1 if $a1 eq $a2;
+
+    my $ok = 1;
+    my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
+    foreach my $k ( keys %$bigger ) {
+        my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
+        my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
+
+        push @Data_Stack, { type => 'HASH', idx => $k, vals => [ $e1, $e2 ] };
+        $ok = _deep_check( $e1, $e2 );
+        pop @Data_Stack if $ok;
+
+        last unless $ok;
+    }
+
+    return $ok;
+}
+
+#line 1572
+
+sub eq_set {
+    my( $a1, $a2 ) = @_;
+    return 0 unless @$a1 == @$a2;
+
+    no warnings 'uninitialized';
+
+    # It really doesn't matter how we sort them, as long as both arrays are
+    # sorted with the same algorithm.
+    #
+    # Ensure that references are not accidentally treated the same as a
+    # string containing the reference.
+    #
+    # Have to inline the sort routine due to a threading/sort bug.
+    # See [rt.cpan.org 6782]
+    #
+    # I don't know how references would be sorted so we just don't sort
+    # them.  This means eq_set doesn't really work with refs.
+    return eq_array(
+        [ grep( ref, @$a1 ), sort( grep( !ref, @$a1 ) ) ],
+        [ grep( ref, @$a2 ), sort( grep( !ref, @$a2 ) ) ],
+    );
+}
+
+#line 1774
+
+1;
diff --git a/src/tcp/test/lib/Test/Nginx.pm b/src/tcp/test/lib/Test/Nginx.pm
new file mode 100755
index 0000000..54a2215
--- /dev/null
+++ b/src/tcp/test/lib/Test/Nginx.pm
@@ -0,0 +1,77 @@
+package Test::Nginx;
+
+use strict;
+use warnings;
+
+our $VERSION = '0.08';
+
+__END__
+
+=encoding utf-8
+
+=head1 NAME
+
+Test::Nginx - Testing modules for Nginx C module development
+
+=head1 DESCRIPTION
+
+This distribution provides two testing modules for Nginx C module development:
+
+=over
+
+=item *
+
+L<Test::Nginx::LWP>
+
+=item *
+
+L<Test::Nginx::Socket>
+
+=back
+
+All of them are based on L<Test::Base>.
+
+=head1 SOURCE REPOSITORY
+
+This module has a Git repository on Github, which has access for all.
+
+    http://github.com/agentzh/test-nginx
+
+If you want a commit bit, feel free to drop me a line.
+
+=head1 AUTHOR
+
+agentzh (章亦春) C<< <agentzh@gmail.com> >>
+
+=head1 COPYRIGHT & LICENSE
+
+Copyright (c) 2009, Taobao Inc., Alibaba Group (L<http://www.taobao.com>).
+
+Copyright (c) 2009, agentzh C<< <agentzh@gmail.com> >>.
+
+This module is licensed under the terms of the BSD license.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+=over
+
+=item *
+
+Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+=item *
+
+Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+=item *
+
+Neither the name of the Taobao Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+=back
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+=head1 SEE ALSO
+
+L<Test::Nginx::LWP>, L<Test::Nginx::Socket>, L<Test::Base>.
+
diff --git a/src/tcp/test/lib/Test/Nginx/LWP.pm b/src/tcp/test/lib/Test/Nginx/LWP.pm
new file mode 100755
index 0000000..8b64483
--- /dev/null
+++ b/src/tcp/test/lib/Test/Nginx/LWP.pm
@@ -0,0 +1,505 @@
+package Test::Nginx::LWP;
+
+use lib 'lib';
+use lib 'inc';
+use Test::Base -Base;
+
+our $VERSION = '0.08';
+
+our $NoLongString;
+
+use LWP::UserAgent;
+use Time::HiRes qw(sleep);
+use Test::LongString;
+use Test::Nginx::Util qw(
+    setup_server_root
+    write_config_file
+    get_canon_version
+    get_nginx_version
+    trim
+    show_all_chars
+    parse_headers
+    run_tests
+    $ServerPortForClient
+    $PidFile
+    $ServRoot
+    $ConfFile
+    $ServerPort
+    $RunTestHelper
+    $NoNginxManager
+    $RepeatEach
+    worker_connections
+    master_process_enabled
+    config_preamble
+    repeat_each
+);
+
+our $UserAgent = LWP::UserAgent->new(ssl_opts => { verify_hostname => 0 });
+$UserAgent->agent(__PACKAGE__);
+#$UserAgent->default_headers(HTTP::Headers->new);
+
+#use Smart::Comments::JSON '##';
+
+our @EXPORT = qw( plan run_tests run_test
+    repeat_each config_preamble worker_connections
+    master_process_enabled
+    no_long_string);
+
+sub no_long_string () {
+    $NoLongString = 1;
+}
+
+sub run_test_helper ($);
+
+$RunTestHelper = \&run_test_helper;
+
+sub parse_request ($$) {
+    my ($name, $rrequest) = @_;
+    open my $in, '<', $rrequest;
+    my $first = <$in>;
+    if (!$first) {
+        Test::More::BAIL_OUT("$name - Request line should be non-empty");
+        die;
+    }
+    $first =~ s/^\s+|\s+$//g;
+    my ($meth, $rel_url) = split /\s+/, $first, 2;
+    my $url = "http://localhost:$ServerPortForClient" . $rel_url;
+
+    my $content = do { local $/; <$in> };
+    if ($content) {
+        $content =~ s/^\s+|\s+$//s;
+    }
+
+    close $in;
+
+    return {
+        method  => $meth,
+        url     => $url,
+        content => $content,
+    };
+}
+
+sub parse_request_https ($$) {
+    my ($name, $rrequest) = @_;
+    open my $in, '<', $rrequest;
+    my $first = <$in>;
+    if (!$first) {
+        Test::More::BAIL_OUT("$name - Request line should be non-empty");
+        die;
+    }
+    $first =~ s/^\s+|\s+$//g;
+    my ($meth, $rel_url) = split /\s+/, $first, 2;
+    my $url = "https://localhost:$ServerPortForClient" . $rel_url;
+
+    my $content = do { local $/; <$in> };
+    if ($content) {
+        $content =~ s/^\s+|\s+$//s;
+    }
+
+    close $in;
+
+    return {
+        method  => $meth,
+        url     => $url,
+        content => $content,
+    };
+}
+
+sub chunk_it ($$$) {
+    my ($chunks, $start_delay, $middle_delay) = @_;
+    my $i = 0;
+    return sub {
+        if ($i == 0) {
+            if ($start_delay) {
+                sleep($start_delay);
+            }
+        } elsif ($middle_delay) {
+            sleep($middle_delay);
+        }
+        return $chunks->[$i++];
+    }
+}
+
+sub run_test_helper ($) {
+    my ($block) = @_;
+
+    my $request = $block->request;
+    my $request_https = $block->request_https;
+
+    my $name = $block->name;
+    #if (defined $TODO) {
+    #$name .= "# $TODO";
+    #}
+
+    my $req_spec;
+
+    if ($request) {
+        $req_spec = parse_request($name, \$request);
+    }
+    else {
+        $req_spec = parse_request_https($name, \$request_https);
+    }
+
+    ## $req_spec
+    my $method = $req_spec->{method};
+    my $req = HTTP::Request->new($method);
+    my $content = $req_spec->{content};
+
+    if (defined ($block->request_headers)) {
+        my $headers = parse_headers($block->request_headers);
+        while (my ($key, $val) = each %$headers) {
+            $req->header($key => $val);
+        }
+    }
+
+    #$req->header('Accept', '*/*');
+    $req->url($req_spec->{url});
+    if ($content) {
+        if ($method eq 'GET' or $method eq 'HEAD') {
+            croak "HTTP 1.0/1.1 $method request should not have content: $content";
+        }
+        $req->content($content);
+    } elsif ($method eq 'POST' or $method eq 'PUT') {
+        my $chunks = $block->chunked_body;
+        if (defined $chunks) {
+            if (!ref $chunks or ref $chunks ne 'ARRAY') {
+
+                Test::More::BAIL_OUT("$name - --- chunked_body should takes a Perl array ref as its value");
+            }
+
+            my $start_delay = $block->start_chunk_delay || 0;
+            my $middle_delay = $block->middle_chunk_delay || 0;
+            $req->content(chunk_it($chunks, $start_delay, $middle_delay));
+            if (!defined $req->header('Content-Type')) {
+                $req->header('Content-Type' => 'text/plain');
+            }
+        } else {
+            if (!defined $req->header('Content-Type')) {
+                $req->header('Content-Type' => 'text/plain');
+            }
+
+            $req->header('Content-Length' => 0);
+        }
+    }
+
+    if ($block->more_headers) {
+        my @headers = split /\n+/, $block->more_headers;
+        for my $header (@headers) {
+            next if $header =~ /^\s*\#/;
+            my ($key, $val) = split /:\s*/, $header, 2;
+            #warn "[$key, $val]\n";
+            $req->header($key => $val);
+        }
+    }
+
+    #warn "req: ", $req->as_string, "\n";
+    #warn "DONE!!!!!!!!!!!!!!!!!!!!";
+
+    my $res = $UserAgent->request($req);
+
+    #warn "res returned!!!";
+
+    if (defined $block->error_code) {
+        is($res->code, $block->error_code, "$name - status code ok");
+    } else {
+        is($res->code, 200, "$name - status code ok");
+    }
+
+    if (defined $block->response_headers) {
+        my $headers = parse_headers($block->response_headers);
+        while (my ($key, $val) = each %$headers) {
+            my $expected_val = $res->header($key);
+            if (!defined $expected_val) {
+                $expected_val = '';
+            }
+            is $expected_val, $val,
+                "$name - header $key ok";
+        }
+    } elsif (defined $block->response_headers_like) {
+        my $headers = parse_headers($block->response_headers_like);
+        while (my ($key, $val) = each %$headers) {
+            my $expected_val = $res->header($key);
+            if (!defined $expected_val) {
+                $expected_val = '';
+            }
+            like $expected_val, qr/^$val$/,
+                "$name - header $key like ok";
+        }
+    }
+
+    if (defined $block->response_body) {
+        my $content = $res->content;
+        if (defined $content) {
+            $content =~ s/^TE: deflate,gzip;q=0\.3\r\n//gms;
+        }
+
+        $content =~ s/^Connection: TE, close\r\n//gms;
+        my $expected = $block->response_body;
+        $expected =~ s/\$ServerPort\b/$ServerPort/g;
+        $expected =~ s/\$ServerPortForClient\b/$ServerPortForClient/g;
+        #warn show_all_chars($content);
+
+        if ($NoLongString) {
+            is($content, $expected, "$name - response_body - response is expected");
+        } else {
+            is_string($content, $expected, "$name - response_body - response is expected");
+        }
+        #is($content, $expected, "$name - response_body - response is expected");
+
+    } elsif (defined $block->response_body_like) {
+        my $content = $res->content;
+        if (defined $content) {
+            $content =~ s/^TE: deflate,gzip;q=0\.3\r\n//gms;
+        }
+        $content =~ s/^Connection: TE, close\r\n//gms;
+        my $expected_pat = $block->response_body_like;
+        $expected_pat =~ s/\$ServerPort\b/$ServerPort/g;
+        $expected_pat =~ s/\$ServerPortForClient\b/$ServerPortForClient/g;
+        my $summary = trim($content);
+        like($content, qr/$expected_pat/s, "$name - response_body_like - response is expected ($summary)");
+    }
+}
+
+1;
+__END__
+
+=encoding utf-8
+
+=head1 NAME
+
+Test::Nginx::LWP - LWP-backed test scaffold for the Nginx C modules
+
+=head1 SYNOPSIS
+
+    use Test::Nginx::LWP;
+
+    plan tests => $Test::Nginx::LWP::RepeatEach * 2 * blocks();
+
+    run_tests();
+
+    __DATA__
+
+    === TEST 1: sanity
+    --- config
+        location /echo {
+            echo_before_body hello;
+            echo world;
+        }
+    --- request
+        GET /echo
+    --- response_body
+    hello
+    world
+    --- error_code: 200
+
+
+    === TEST 2: set Server
+    --- config
+        location /foo {
+            echo hi;
+            more_set_headers 'Server: Foo';
+        }
+    --- request
+        GET /foo
+    --- response_headers
+    Server: Foo
+    --- response_body
+    hi
+
+
+    === TEST 3: clear Server
+    --- config
+        location /foo {
+            echo hi;
+            more_clear_headers 'Server: ';
+        }
+    --- request
+        GET /foo
+    --- response_headers_like
+    Server: nginx.*
+    --- response_body
+    hi
+
+
+    === TEST 4: set request header at client side and rewrite it
+    --- config
+        location /foo {
+            more_set_input_headers 'X-Foo: howdy';
+            echo $http_x_foo;
+        }
+    --- request
+        GET /foo
+    --- request_headers
+    X-Foo: blah
+    --- response_headers
+    X-Foo:
+    --- response_body
+    howdy
+
+
+    === TEST 3: rewrite content length
+    --- config
+        location /bar {
+            more_set_input_headers 'Content-Length: 2048';
+            echo_read_request_body;
+            echo_request_body;
+        }
+    --- request eval
+    "POST /bar\n" .
+    "a" x 4096
+    --- response_body eval
+    "a" x 2048
+
+
+    === TEST 4: timer without explicit reset
+    --- config
+        location /timer {
+            echo_sleep 0.03;
+            echo "elapsed $echo_timer_elapsed sec.";
+        }
+    --- request
+        GET /timer
+    --- response_body_like
+    ^elapsed 0\.0(2[6-9]|3[0-6]) sec\.$
+
+
+    === TEST 5: small buf (using 2-byte buf)
+    --- config
+        chunkin on;
+        location /main {
+            client_body_buffer_size    2;
+            echo "body:";
+            echo $echo_request_body;
+            echo_request_body;
+        }
+    --- request
+    POST /main
+    --- start_chunk_delay: 0.01
+    --- middle_chunk_delay: 0.01
+    --- chunked_body eval
+    ["hello", "world"]
+    --- error_code: 200
+    --- response_body eval
+    "body:
+
+    helloworld"
+
+=head1 DESCRIPTION
+
+This module provides a test scaffold based on L<LWP::UserAgent> for automated testing in Nginx C module development.
+
+This class inherits from L<Test::Base>, thus bringing all its
+declarative power to the Nginx C module testing practices.
+
+You need to terminate or kill any Nginx processes before running the test suite if you have changed the Nginx server binary. Normally it's as simple as
+
+  killall nginx
+  PATH=/path/to/your/nginx-with-memc-module:$PATH prove -r t
+
+This module will create a temporary server root under t/servroot/ of the current working directory and starts and uses the nginx executable in the PATH environment.
+
+You will often want to look into F<t/servroot/logs/error.log>
+when things go wrong ;)
+
+=head1 Sections supported
+
+The following sections are supported:
+
+=over
+
+=item config
+
+=item http_config
+
+=item request
+
+=item request_headers
+
+=item more_headers
+
+=item response_body
+
+=item response_body_like
+
+=item response_headers
+
+=item response_headers_like
+
+=item error_code
+
+=item chunked_body
+
+=item middle_chunk_delay
+
+=item start_chunk_delay
+
+=back
+
+=head1 Samples
+
+You'll find live samples in the following Nginx 3rd-party modules:
+
+=over
+
+=item ngx_echo
+
+L<http://wiki.nginx.org/NginxHttpEchoModule>
+
+=item ngx_headers_more
+
+L<http://wiki.nginx.org/NginxHttpHeadersMoreModule>
+
+=item ngx_chunkin
+
+L<http://wiki.nginx.org/NginxHttpChunkinModule>
+
+=item ngx_memc
+
+L<http://wiki.nginx.org/NginxHttpMemcModule>
+
+=back
+
+=head1 SOURCE REPOSITORY
+
+This module has a Git repository on Github, which has access for all.
+
+    http://github.com/agentzh/test-nginx
+
+If you want a commit bit, feel free to drop me a line.
+
+=head1 AUTHOR
+
+agentzh (章亦春) C<< <agentzh@gmail.com> >>
+
+=head1 COPYRIGHT & LICENSE
+
+Copyright (c) 2009, Taobao Inc., Alibaba Group (L<http://www.taobao.com>).
+
+Copyright (c) 2009, agentzh C<< <agentzh@gmail.com> >>.
+
+This module is licensed under the terms of the BSD license.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+=over
+
+=item *
+
+Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+=item *
+
+Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+=item *
+
+Neither the name of the Taobao Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+=back
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+=head1 SEE ALSO
+
+L<Test::Nginx::Socket>, L<Test::Base>.
+
diff --git a/src/tcp/test/lib/Test/Nginx/Socket.pm b/src/tcp/test/lib/Test/Nginx/Socket.pm
new file mode 100755
index 0000000..9749006
--- /dev/null
+++ b/src/tcp/test/lib/Test/Nginx/Socket.pm
@@ -0,0 +1,755 @@
+package Test::Nginx::Socket;
+
+use lib 'lib';
+use lib 'inc';
+
+use Test::Base -Base;
+
+our $VERSION = '0.08';
+
+use Data::Dumper;
+use Time::HiRes qw(sleep time);
+use Test::LongString;
+use List::MoreUtils qw( any );
+use IO::Select ();
+
+our $Timeout = 2;
+
+use Test::Nginx::Util qw(
+    setup_server_root
+    write_config_file
+    get_canon_version
+    get_nginx_version
+    trim
+    show_all_chars
+    parse_headers
+    run_tests
+    $ServerPortForClient
+    $ServerPort
+    $PidFile
+    $ServRoot
+    $ConfFile
+    $RunTestHelper
+    $RepeatEach
+    worker_connections
+    master_process_enabled
+    config_preamble
+    repeat_each
+    workers
+    master_on
+    log_level
+);
+
+#use Smart::Comments::JSON '###';
+use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
+use POSIX qw(EAGAIN);
+use IO::Socket;
+
+#our ($PrevRequest, $PrevConfig);
+
+our $NoLongString = undef;
+
+our @EXPORT = qw( plan run_tests run_test
+    repeat_each config_preamble worker_connections
+    master_process_enabled
+    no_long_string workers master_on
+    log_level);
+
+sub send_request ($$$);
+
+sub run_test_helper ($);
+
+sub error_event_handler ($);
+sub read_event_handler ($);
+sub write_event_handler ($);
+
+sub no_long_string () {
+    $NoLongString = 1;
+}
+
+$RunTestHelper = \&run_test_helper;
+
+sub parse_request ($$) {
+    my ($name, $rrequest) = @_;
+    open my $in, '<', $rrequest;
+    my $first = <$in>;
+    if (!$first) {
+        Test::More::BAIL_OUT("$name - Request line should be non-empty");
+        die;
+    }
+    $first =~ s/^\s+|\s+$//gs;
+    my ($meth, $rel_url) = split /\s+/, $first, 2;
+    if (!defined $rel_url) {
+        $rel_url = "/";
+    }
+    #my $url = "http://localhost:$ServerPortForClient" . $rel_url;
+
+    my $content = do { local $/; <$in> };
+    if (!defined $content) {
+        $content = "";
+    }
+    #warn Dumper($content);
+
+    close $in;
+
+    return {
+        method  => $meth,
+        url     => $rel_url,
+        content => $content,
+    };
+}
+
+sub run_test_helper ($) {
+    my $block = shift;
+
+    my $name = $block->name;
+
+    my $req;
+
+    if (defined $block->raw_request) {
+        $req = $block->raw_request;
+    } else {
+        my $request;
+        if (defined $block->request_eval) {
+            $request = eval $block->request_eval;
+            if ($@) {
+                warn $@;
+            }
+        } else {
+            $request = $block->request;
+        }
+
+        my $is_chunked = 0;
+        my $more_headers = '';
+        if ($block->more_headers) {
+            my @headers = split /\n+/, $block->more_headers;
+            for my $header (@headers) {
+                next if $header =~ /^\s*\#/;
+                my ($key, $val) = split /:\s*/, $header, 2;
+                if (lc($key) eq 'transfer-encoding' and $val eq 'chunked') {
+                    $is_chunked = 1;
+                }
+                #warn "[$key, $val]\n";
+                $more_headers .= "$key: $val\r\n";
+            }
+        }
+
+        if ($block->pipelined_requests) {
+            my $reqs = $block->pipelined_requests;
+            if (!ref $reqs || ref $reqs ne 'ARRAY') {
+                Test::More::BAIL_OUT("$name - invalid entries in --- pipelined_requests");
+            }
+            my $i = 0;
+            for my $request (@$reqs) {
+                my $conn_type;
+                if ($i++ == @$reqs - 1) {
+                    $conn_type = 'close';
+                } else {
+                    $conn_type = 'keep-alive';
+                }
+                my $parsed_req = parse_request($name, \$request);
+
+                my $len_header = '';
+                if (!$is_chunked && defined $parsed_req->{content} 
+                        && $parsed_req->{content} ne ''
+                        && $more_headers !~ /\bContent-Length:/)
+                {
+                    $parsed_req->{content} =~ s/^\s+|\s+$//gs;
+
+                    $len_header .= "Content-Length: " . length($parsed_req->{content}) . "\r\n";
+                }
+
+                $req .= "$parsed_req->{method} $parsed_req->{url} HTTP/1.1\r
+Host: localhost\r
+Connection: $conn_type\r
+$more_headers$len_header\r
+$parsed_req->{content}";
+            }
+        } else {
+            my $parsed_req = parse_request($name, \$request);
+            ### $parsed_req
+
+            my $len_header = '';
+            if (!$is_chunked && defined $parsed_req->{content}
+                    && $parsed_req->{content} ne ''
+                    && $more_headers !~ /\bContent-Length:/)
+            {
+                $parsed_req->{content} =~ s/^\s+|\s+$//gs;
+                $len_header .= "Content-Length: " . length($parsed_req->{content}) . "\r\n";
+            }
+
+            $req = "$parsed_req->{method} $parsed_req->{url} HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+$more_headers$len_header\r
+$parsed_req->{content}";
+        }
+
+    }
+
+    if (!$req) {
+        Test::More::BAIL_OUT("$name - request empty");
+    }
+
+    #warn "request: $req\n";
+
+    my $timeout = $block->timeout;
+    if (!defined $timeout) {
+        $timeout = $Timeout;
+    }
+
+    my $raw_resp = send_request($req, $block->raw_request_middle_delay,
+        $timeout);
+
+    #warn "raw resonse: [$raw_resp]\n";
+
+    my $res = HTTP::Response->parse($raw_resp);
+    my $enc = $res->header('Transfer-Encoding');
+
+    if (defined $enc && $enc eq 'chunked') {
+        #warn "Found chunked!";
+        my $raw = $res->content;
+        if (!defined $raw) {
+            $raw = '';
+        }
+
+        my $decoded = '';
+        while (1) {
+            if ($raw =~ /\G 0 [\ \t]* \r\n \r\n /gcsx) {
+                last;
+            }
+            if ($raw =~ m{ \G [\ \t]* ( [A-Fa-f0-9]+ ) [\ \t]* \r\n }gcsx) {
+                my $rest = hex($1);
+                #warn "chunk size: $rest\n";
+                my $bit_sz = 32765;
+                while ($rest > 0) {
+                    my $bit = $rest < $bit_sz ? $rest : $bit_sz;
+                    #warn "bit: $bit\n";
+                    if ($raw =~ /\G(.{$bit})/gcs) {
+                        $decoded .= $1;
+                        #warn "decoded: [$1]\n";
+                    } else {
+                        fail("$name - invalid chunked data received (not enought octets for the data section)");
+                        return;
+                    }
+
+                    $rest -= $bit;
+                }
+                if ($raw !~ /\G\r\n/gcs) {
+                    fail("$name - invalid chunked data received (expected CRLF).");
+                    return;
+                }
+            } elsif ($raw =~ /\G.+/gcs) {
+                fail "$name - invalid chunked body received: $&";
+                return;
+            } else {
+                fail "$name - no last chunk found";
+                return;
+            }
+        }
+        #warn "decoded: $decoded\n";
+        $res->content($decoded);
+    }
+
+    if (defined $block->error_code) {
+        is($res->code || '', $block->error_code, "$name - status code ok");
+    } else {
+        is($res->code || '', 200, "$name - status code ok");
+    }
+
+    if (defined $block->response_headers) {
+        my $headers = parse_headers($block->response_headers);
+        while (my ($key, $val) = each %$headers) {
+            my $expected_val = $res->header($key);
+            if (!defined $expected_val) {
+                $expected_val = '';
+            }
+            is $expected_val, $val,
+                "$name - header $key ok";
+        }
+    } elsif (defined $block->response_headers_like) {
+        my $headers = parse_headers($block->response_headers_like);
+        while (my ($key, $val) = each %$headers) {
+            my $expected_val = $res->header($key);
+            if (!defined $expected_val) {
+                $expected_val = '';
+            }
+            like $expected_val, qr/^$val$/,
+                "$name - header $key like ok";
+        }
+    }
+
+    if (defined $block->response_body
+           || defined $block->response_body_eval) {
+        my $content = $res->content;
+        if (defined $content) {
+            $content =~ s/^TE: deflate,gzip;q=0\.3\r\n//gms;
+            $content =~ s/^Connection: TE, close\r\n//gms;
+        }
+
+        my $expected;
+        if ($block->response_body_eval) {
+            $expected = eval $block->response_body_eval;
+            if ($@) {
+                warn $@;
+            }
+        } else {
+            $expected = $block->response_body;
+        }
+
+        $expected =~ s/\$ServerPort\b/$ServerPort/g;
+        $expected =~ s/\$ServerPortForClient\b/$ServerPortForClient/g;
+        #warn show_all_chars($content);
+
+        #warn "no long string: $NoLongString";
+        if ($NoLongString) {
+            is($content, $expected, "$name - response_body - response is expected");
+        } else {
+            is_string($content, $expected, "$name - response_body - response is expected");
+        }
+
+    } elsif (defined $block->response_body_like) {
+        my $content = $res->content;
+        if (defined $content) {
+            $content =~ s/^TE: deflate,gzip;q=0\.3\r\n//gms;
+        }
+        $content =~ s/^Connection: TE, close\r\n//gms;
+        my $expected_pat = $block->response_body_like;
+        $expected_pat =~ s/\$ServerPort\b/$ServerPort/g;
+        $expected_pat =~ s/\$ServerPortForClient\b/$ServerPortForClient/g;
+        my $summary = trim($content);
+        like($content, qr/$expected_pat/s, "$name - response_body_like - response is expected ($summary)");
+    }
+}
+
+sub send_request ($$$) {
+    my ($req, $middle_delay, $timeout) = @_;
+
+    my @req_bits = ref $req ? @$req : ($req);
+
+    my $sock = IO::Socket::INET->new(
+        PeerAddr => 'localhost',
+        PeerPort => $ServerPortForClient,
+        Proto    => 'tcp'
+    ) or die "Can't connect to localhost:$ServerPortForClient: $!\n";
+
+    my $flags = fcntl $sock, F_GETFL, 0
+        or die "Failed to get flags: $!\n";
+
+    fcntl $sock, F_SETFL, $flags | O_NONBLOCK
+        or die "Failed to set flags: $!\n";
+
+    my $ctx = {
+        resp => '',
+        write_offset => 0,
+        buf_size => 1024,
+        req_bits => \@req_bits,
+        write_buf => shift @req_bits,
+        middle_delay => $middle_delay,
+        sock => $sock,
+    };
+
+    my $readable_hdls = IO::Select->new($sock);
+    my $writable_hdls = IO::Select->new($sock);
+    my $err_hdls = IO::Select->new($sock);
+
+    while (1) {
+        if ($readable_hdls->count == 0 && $writable_hdls->count == 0 && $err_hdls->count == 0) {
+            last;
+        }
+
+        my ($new_readable, $new_writable, $new_err) =
+            IO::Select->select($readable_hdls, $writable_hdls,
+                $err_hdls, $timeout);
+
+        if (!defined $new_err && !defined $new_readable
+                && !defined $new_writable)
+        {
+            # timed out
+            timeout_event_handler($ctx);
+            last;
+        }
+
+        for my $hdl (@$new_err) {
+            next if !defined $hdl;
+
+            error_event_handler($ctx);
+
+            if ($err_hdls->exists($hdl)) {
+                $err_hdls->remove($hdl);
+            }
+
+            if ($readable_hdls->exists($hdl)) {
+                $readable_hdls->remove($hdl);
+            }
+
+            if ($writable_hdls->exists($hdl)) {
+                $writable_hdls->remove($hdl);
+            }
+
+            for my $h (@$readable_hdls) {
+                next if !defined $h;
+                if ($h eq $hdl) {
+                    undef $h;
+                    last;
+                }
+            }
+
+            for my $h (@$writable_hdls) {
+                next if !defined $h;
+                if ($h eq $hdl) {
+                    undef $h;
+                    last;
+                }
+            }
+
+            close $hdl;
+        }
+
+        for my $hdl (@$new_readable) {
+            next if !defined $hdl;
+
+            my $res = read_event_handler($ctx);
+            if (!$res) {
+                # error occured
+                if ($err_hdls->exists($hdl)) {
+                    $err_hdls->remove($hdl);
+                }
+
+                if ($readable_hdls->exists($hdl)) {
+                    $readable_hdls->remove($hdl);
+                }
+
+                if ($writable_hdls->exists($hdl)) {
+                    $writable_hdls->remove($hdl);
+                }
+
+                for my $h (@$writable_hdls) {
+                    next if !defined $h;
+                    if ($h eq $hdl) {
+                        undef $h;
+                        last;
+                    }
+                }
+
+                close $hdl;
+            }
+        }
+
+        for my $hdl (@$new_writable) {
+            next if !defined $hdl;
+
+            my $res = write_event_handler($ctx);
+            if (!$res) {
+                # error occured
+                if ($err_hdls->exists($hdl)) {
+                    $err_hdls->remove($hdl);
+                }
+
+                if ($readable_hdls->exists($hdl)) {
+                    $readable_hdls->remove($hdl);
+                }
+
+                if ($writable_hdls->exists($hdl)) {
+                    $writable_hdls->remove($hdl);
+                }
+
+                close $hdl;
+            }
+
+            if ($res == 2) {
+                if ($writable_hdls->exists($hdl)) {
+                    $writable_hdls->remove($hdl);
+                }
+            }
+        }
+    }
+
+    return $ctx->{resp};
+}
+
+sub timeout_event_handler ($) {
+    warn "socket client: timed out";
+}
+
+sub error_event_handler ($) {
+    warn "exception occurs on the socket: $!\n";
+}
+
+sub write_event_handler ($) {
+    my ($ctx) = @_;
+
+    while (1) {
+        return undef if !defined $ctx->{write_buf};
+
+        my $rest = length($ctx->{write_buf}) - $ctx->{write_offset};
+        #warn "offset: $write_offset, rest: $rest, length ", length($write_buf), "\n";
+        #die;
+
+        if ($rest > 0) {
+            my $bytes = syswrite($ctx->{sock}, $ctx->{write_buf}, $rest, $ctx->{write_offset});
+
+            if (!defined $bytes) {
+                if ($! == EAGAIN) {
+                    #warn "write again...";
+                    #sleep 0.002;
+                    return 1;
+                }
+                my $errmsg = "write failed: $!";
+                warn "$errmsg\n";
+                if (!$ctx->{resp}) {
+                    $ctx->{resp} = "$errmsg";
+                }
+                return undef;
+            }
+
+            #warn "wrote $bytes bytes.\n";
+            $ctx->{write_offset} += $bytes;
+        } else {
+            $ctx->{write_buf} = shift @{$ctx->{req_bits}} or return 2;
+            $ctx->{write_offset} = 0;
+            if (defined $ctx->{middle_delay}) {
+                #warn "sleeping..";
+                sleep $ctx->{middle_delay};
+            }
+        }
+    }
+
+    # impossible to reach here...
+    return undef;
+}
+
+sub read_event_handler ($) {
+    my ($ctx) = @_;
+    while (1) {
+        my $read_buf;
+        my $bytes = sysread($ctx->{sock}, $read_buf, $ctx->{buf_size});
+
+        if (!defined $bytes) {
+            if ($! == EAGAIN) {
+                #warn "read again...";
+                #sleep 0.002;
+                return 1;
+            }
+            $ctx->{resp} = "500 read failed: $!";
+            return undef;
+        }
+
+        if ($bytes == 0) {
+            return undef; # connection closed
+        }
+
+        $ctx->{resp} .= $read_buf;
+        #warn "read $bytes ($read_buf) bytes.\n";
+    }
+
+    # impossible to reach here...
+    return undef;
+}
+
+1;
+__END__
+
+=encoding utf-8
+
+=head1 NAME
+
+Test::Nginx::Socket - Socket-backed test scaffold for the Nginx C modules
+
+=head1 SYNOPSIS
+
+    use Test::Nginx::Socket;
+
+    plan tests => $Test::Nginx::Socket::RepeatEach * 2 * blocks();
+
+    run_tests();
+
+    __DATA__
+
+    === TEST 1: sanity
+    --- config
+        location /echo {
+            echo_before_body hello;
+            echo world;
+        }
+    --- request
+        GET /echo
+    --- response_body
+    hello
+    world
+    --- error_code: 200
+
+
+    === TEST 2: set Server
+    --- config
+        location /foo {
+            echo hi;
+            more_set_headers 'Server: Foo';
+        }
+    --- request
+        GET /foo
+    --- response_headers
+    Server: Foo
+    --- response_body
+    hi
+
+
+    === TEST 3: clear Server
+    --- config
+        location /foo {
+            echo hi;
+            more_clear_headers 'Server: ';
+        }
+    --- request
+        GET /foo
+    --- response_headers_like
+    Server: nginx.*
+    --- response_body
+    hi
+
+
+    === TEST 3: chunk size too small
+    --- config
+        chunkin on;
+        location /main {
+            echo_request_body;
+        }
+    --- more_headers
+    Transfer-Encoding: chunked
+    --- request eval
+    "POST /main
+    4\r
+    hello\r
+    0\r
+    \r
+    "
+    --- error_code: 400
+    --- response_body_like: 400 Bad Request
+
+=head1 DESCRIPTION
+
+This module provides a test scaffold based on non-blocking L<IO::Socket> for automated testing in Nginx C module development.
+
+This class inherits from L<Test::Base>, thus bringing all its
+declarative power to the Nginx C module testing practices.
+
+You need to terminate or kill any Nginx processes before running the test suite if you have changed the Nginx server binary. Normally it's as simple as
+
+  killall nginx
+  PATH=/path/to/your/nginx-with-memc-module:$PATH prove -r t
+
+This module will create a temporary server root under t/servroot/ of the current working directory and starts and uses the nginx executable in the PATH environment.
+
+You will often want to look into F<t/servroot/logs/error.log>
+when things go wrong ;)
+
+=head1 Sections supported
+
+The following sections are supported:
+
+=over
+
+=item config
+
+=item http_config
+
+=item request
+
+=item request_eval
+
+=item more_headers
+
+=item response_body
+
+=item response_body_eval
+
+=item response_body_like
+
+=item response_headers
+
+=item response_headers_like
+
+=item error_code
+
+=item raw_request
+
+Both string scalar and string arrays are supported as values.
+
+=item raw_request_middle_delay
+
+Delay in sec between sending successive packets in the "raw_request" array value.
+
+=back
+
+=head1 Samples
+
+You'll find live samples in the following Nginx 3rd-party modules:
+
+=over
+
+=item ngx_chunkin
+
+L<http://wiki.nginx.org/NginxHttpChunkinModule>
+
+=item ngx_memc
+
+L<http://wiki.nginx.org/NginxHttpMemcModule>
+
+=item ngx_drizzle
+
+L<http://github.com/chaoslawful/drizzle-nginx-module>
+
+=item ngx_rds_json
+
+L<http://github.com/agentzh/rds-json-nginx-module>
+
+=item ngx_xss
+
+L<http://github.com/agentzh/xss-nginx-module>
+
+=back
+
+=head1 SOURCE REPOSITORY
+
+This module has a Git repository on Github, which has access for all.
+
+    http://github.com/agentzh/test-nginx
+
+If you want a commit bit, feel free to drop me a line.
+
+=head1 AUTHOR
+
+agentzh (章亦春) C<< <agentzh@gmail.com> >>
+
+=head1 COPYRIGHT & LICENSE
+
+Copyright (c) 2009, Taobao Inc., Alibaba Group (L<http://www.taobao.com>).
+
+Copyright (c) 2009, agentzh C<< <agentzh@gmail.com> >>.
+
+This module is licensed under the terms of the BSD license.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+=over
+
+=item *
+
+Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+=item *
+
+Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+=item *
+
+Neither the name of the Taobao Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+=back
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+=head1 SEE ALSO
+
+L<Test::Nginx::LWP>, L<Test::Base>.
+
diff --git a/src/tcp/test/lib/Test/Nginx/Util.pm b/src/tcp/test/lib/Test/Nginx/Util.pm
new file mode 100755
index 0000000..56b9543
--- /dev/null
+++ b/src/tcp/test/lib/Test/Nginx/Util.pm
@@ -0,0 +1,516 @@
+package Test::Nginx::Util;
+
+use strict;
+use warnings;
+
+our $VERSION = '0.08';
+
+use base 'Exporter';
+
+use POSIX qw( SIGQUIT SIGKILL SIGTERM );
+use File::Spec ();
+use HTTP::Response;
+use Module::Install::Can;
+use Cwd qw( cwd );
+use List::Util qw( shuffle );
+
+our $NoNginxManager = 0;
+our $Profiling = 0;
+
+our $RepeatEach = 1;
+our $MAX_PROCESSES = 10;
+
+our $ForkManager;
+
+if ($Profiling) {
+    eval "use Parallel::ForkManager";
+    if ($@) {
+        die "Failed to load Parallel::ForkManager: $@\n";
+    }
+    $ForkManager = new Parallel::ForkManager($MAX_PROCESSES);
+}
+
+our $Workers                = 2;
+our $WorkerConnections      = 1024;
+our $LogLevel               = 'debug';
+our $MasterProcessEnabled   = 'off';
+our $DaemonEnabled          = 'on';
+our $ServerPort             = 1984;
+our $ServerPortForClient    = 1984;
+
+
+sub repeat_each (@) {
+    if (@_) {
+        $RepeatEach = shift;
+    } else {
+        return $RepeatEach;
+    }
+}
+
+sub worker_connections (@) {
+    if (@_) {
+        $WorkerConnections = shift;
+    } else {
+        return $WorkerConnections;
+    }
+}
+
+sub workers (@) {
+    if (@_) {
+        #warn "setting workers to $_[0]";
+        $Workers = shift;
+    } else {
+        return $Workers;
+    }
+}
+
+sub log_level (@) {
+    if (@_) {
+        $LogLevel = shift;
+    } else {
+        return $LogLevel;
+    }
+}
+
+sub master_on () {
+    $MasterProcessEnabled = 'on';
+}
+
+sub master_process_enabled (@) {
+    if (@_) {
+        $MasterProcessEnabled = shift() ? 'on' : 'off';
+    } else {
+        return $MasterProcessEnabled;
+    }
+}
+
+our @EXPORT_OK = qw(
+    setup_server_root
+    write_config_file
+    get_canon_version
+    get_nginx_version
+    trim
+    show_all_chars
+    parse_headers
+    run_tests
+    $ServerPortForClient
+    $ServerPort
+    $NginxVersion
+    $PidFile
+    $ServRoot
+    $ConfFile
+    $RunTestHelper
+    $NoNginxManager
+    $RepeatEach
+    worker_connections
+    workers
+    master_on
+    config_preamble
+    repeat_each
+    master_process_enabled
+    log_level
+);
+
+
+if ($Profiling) {
+    $DaemonEnabled          = 'off';
+    $MasterProcessEnabled   = 'off';
+}
+
+our $ConfigPreamble = '';
+
+sub config_preamble ($) {
+    $ConfigPreamble = shift;
+}
+
+our $RunTestHelper;
+
+our $NginxVersion;
+our $NginxRawVersion;
+our $TODO;
+
+#our ($PrevRequest, $PrevConfig);
+
+our $ServRoot   = File::Spec->catfile(cwd(), 't/servroot');
+our $LogDir     = File::Spec->catfile($ServRoot, 'logs');
+our $ErrLogFile = File::Spec->catfile($LogDir, 'error.log');
+our $AccLogFile = File::Spec->catfile($LogDir, 'access.log');
+our $HtmlDir    = File::Spec->catfile($ServRoot, 'html');
+our $ConfDir    = File::Spec->catfile($ServRoot, 'conf');
+our $ConfFile   = File::Spec->catfile($ConfDir, 'nginx.conf');
+our $PidFile    = File::Spec->catfile($LogDir, 'nginx.pid');
+
+sub run_tests () {
+    $NginxVersion = get_nginx_version();
+
+    if (defined $NginxVersion) {
+        #warn "[INFO] Using nginx version $NginxVersion ($NginxRawVersion)\n";
+    }
+
+    for my $block (shuffle Test::Base::blocks()) {
+        #for (1..3) {
+            run_test($block);
+        #}
+    }
+
+    if ($Profiling) {
+        $ForkManager->wait_all_children;
+    }
+}
+
+sub setup_server_root () {
+    if (-d $ServRoot) {
+        #sleep 0.5;
+        #die ".pid file $PidFile exists.\n";
+        system("rm -rf t/servroot > /dev/null") == 0 or
+            die "Can't remove t/servroot";
+        #sleep 0.5;
+    }
+    mkdir $ServRoot or
+        die "Failed to do mkdir $ServRoot\n";
+    mkdir $LogDir or
+        die "Failed to do mkdir $LogDir\n";
+    mkdir $HtmlDir or
+        die "Failed to do mkdir $HtmlDir\n";
+
+    my $index_file = "$HtmlDir/index.html";
+
+    my $out;
+
+    open $out, ">$index_file" or
+        die "Can't open $index_file for writing: $!\n";
+
+    print $out '<html><head><title>It works!</title></head><body>It works!</body></html>';
+
+    close $out;
+
+    mkdir $ConfDir or
+        die "Failed to do mkdir $ConfDir\n";
+
+    my $ssl_crt = "$ConfDir/ssl.crt";
+
+    open $out, ">$ssl_crt" or
+        die "Can't open $ssl_crt for writing: $!\n";
+
+    print $out <<_EOC_;
+-----BEGIN CERTIFICATE-----
+MIIClzCCAgACCQCKlE5LBV9thDANBgkqhkiG9w0BAQUFADCBjzELMAkGA1UEBhMC
+Q04xEjAQBgNVBAgTCVpoZSBKaWFuZzERMA8GA1UEBxMISGFuZ3pob3UxFDASBgNV
+BAoTC05ldGVhc2UgTHRkMQswCQYDVQQLEwJJVDEUMBIGA1UEAxMLbml4Y3JhZnQu
+aW4xIDAeBgkqhkiG9w0BCQEWEWFkbWluQG5peGNyYWZ0LmluMB4XDTEwMDkwMzA2
+NTk1OFoXDTExMDkwMzA2NTk1OFowgY8xCzAJBgNVBAYTAkNOMRIwEAYDVQQIEwla
+aGUgSmlhbmcxETAPBgNVBAcTCEhhbmd6aG91MRQwEgYDVQQKEwtOZXRlYXNlIEx0
+ZDELMAkGA1UECxMCSVQxFDASBgNVBAMTC25peGNyYWZ0LmluMSAwHgYJKoZIhvcN
+AQkBFhFhZG1pbkBuaXhjcmFmdC5pbjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkC
+gYEAyGpGE56F6KcC2EnU/Nf0JWUrwApvJjDc6yYYpZWtYoSHdwDMwnbF7nQbBTjQ
+Ew2C23RvYlrpxaEBvIi6y4CnE98AvYfI50dDtT1cO4lBoDugbIgtryZywXHL2TbU
+ZQ2eJc+6vJClVGc1LjZ10ZzAAt63VroO2FAh/fZUZPXEzUMCAwEAATANBgkqhkiG
+9w0BAQUFAAOBgQA7x4lND+41f5ihXgd4cAM8W4GQ+mpQpKt+BRxto740SdUL+DNt
+PmMLoqw7Pis9Pkn7PQj/O3vJkx4Bfzmrm/s0bX82mYJSjPz8XL42n7n3Cg8HCCLG
+3JeNnJc75EYwpqf7tyauMUZSACBIGXeteu4OyZ4j/qObJ3GyKVFqR/PJrQ==
+-----END CERTIFICATE-----
+_EOC_
+    close $out;
+
+    my $ssl_key = "$ConfDir/ssl.key";
+
+    open $out, ">$ssl_key" or
+        die "Can't open $ssl_key for writing: $!\n";
+
+    print $out <<_EOC_;
+-----BEGIN RSA PRIVATE KEY-----
+MIICXQIBAAKBgQDIakYTnoXopwLYSdT81/QlZSvACm8mMNzrJhilla1ihId3AMzC
+dsXudBsFONATDYLbdG9iWunFoQG8iLrLgKcT3wC9h8jnR0O1PVw7iUGgO6BsiC2v
+JnLBccvZNtRlDZ4lz7q8kKVUZzUuNnXRnMAC3rdWug7YUCH99lRk9cTNQwIDAQAB
+AoGAdWCAoFb0mHjQGrrLKjaUgB5LzFKQHG77xCDwyHHsNUnnSNRIGBCWBf0sIhfP
+DYmZPUxpO9KBHcUZjkEKHcvAjcGUDdm2HoXYt9V5peAYqdbYOZ/cfEGRzRVTDcy4
+etDvmNqj4t6F9nuq5Rkx7wg/mkGp7Jj0JC5nn7gIcpBiAVkCQQD12rXZ9nhvwKuD
+yF+7lUnmIHRePjtJQcK4+xS9F4UgPiL/cZ3JRcZeo2bagE5ye+mLeGuL3zDOsbY1
+/4dzfulPAkEA0K+HK5rESxFuCOH/XhY85jrt1P2ICFfr1S4zi9Sijquczo9XXHJx
+cXrj4nOiIzmvLSk6MjrMYNhwW7Sycbw3zQJAD7MUs8N6c2BxU2wDOP5ShsCBzdbZ
+gFcTsS5PZ7fNx35QS9GcitLK1RZIJiHVYJgrFL3u2DK7cieFBDO6GZT8HwJBAI7I
+2rqaDV6zkU8gmqKcopSAk4Qc6HuU9LaLAxfUqFjn0MWATCzj3PzhMZUau0BQ0qwa
+vkfp9Tb6QH5ut32cY60CQQCycpFyUhKpY4l81On7LK3Nq2z0+RZ85MbCIkQkQn2H
+4fqfNoKrLPP2JrMCYrvjrc+hez/ffd3u2II/93kksfCx
+-----END RSA PRIVATE KEY-----
+_EOC_
+    close $out;
+
+}
+
+sub write_config_file ($$) {
+    my ($config, $http_config) = @_;
+
+    if (!defined $config) {
+        $config = '';
+    }
+
+    if (!defined $http_config) {
+        $http_config = '';
+    }
+
+    open my $out, ">$ConfFile" or
+        die "Can't open $ConfFile for writing: $!\n";
+    print $out <<_EOC_;
+worker_processes  $Workers;
+daemon $DaemonEnabled;
+master_process $MasterProcessEnabled;
+error_log $ErrLogFile $LogLevel;
+pid       $PidFile;
+
+tcp {
+
+ssl_certificate "$ConfDir/ssl.crt";
+ssl_certificate_key "$ConfDir/ssl.key";
+
+# Begin test case config...
+    $config
+# End test case config.
+}
+
+events {
+    worker_connections  $WorkerConnections;
+}
+
+_EOC_
+    close $out;
+}
+
+sub get_canon_version (@) {
+    sprintf "%d.%03d%03d", $_[0], $_[1], $_[2];
+}
+
+sub get_nginx_version () {
+    my $out = `nginx -V 2>&1`;
+    if (!defined $out || $? != 0) {
+        warn "Failed to get the version of the Nginx in PATH.\n";
+    }
+    if ($out =~ m{nginx/(\d+)\.(\d+)\.(\d+)}s) {
+        $NginxRawVersion = "$1.$2.$3";
+        return get_canon_version($1, $2, $3);
+    }
+    warn "Failed to parse the output of \"nginx -V\": $out\n";
+    return undef;
+}
+
+sub get_pid_from_pidfile ($) {
+    my ($name) = @_;
+    open my $in, $PidFile or
+        Test::More::BAIL_OUT("$name - Failed to open the pid file $PidFile for reading: $!");
+    my $pid = do { local $/; <$in> };
+    #warn "Pid: $pid\n";
+    close $in;
+    $pid;
+}
+
+sub trim ($) {
+    (my $s = shift) =~ s/^\s+|\s+$//g;
+    $s =~ s/\n/ /gs;
+    $s =~ s/\s{2,}/ /gs;
+    $s;
+}
+
+sub show_all_chars ($) {
+    my $s = shift;
+    $s =~ s/\n/\\n/gs;
+    $s =~ s/\r/\\r/gs;
+    $s =~ s/\t/\\t/gs;
+    $s;
+}
+
+sub parse_headers ($) {
+    my $s = shift;
+    my %headers;
+    open my $in, '<', \$s;
+    while (<$in>) {
+        s/^\s+|\s+$//g;
+        my ($key, $val) = split /\s*:\s*/, $_, 2;
+        $headers{$key} = $val;
+    }
+    close $in;
+    return \%headers;
+}
+
+sub run_test ($) {
+    my $block = shift;
+    my $name = $block->name;
+
+    my $config = $block->config;
+    if (!defined $config) {
+        Test::More::BAIL_OUT("$name - No '--- config' section specified");
+        #$config = $PrevConfig;
+        die;
+    }
+
+    my $skip_nginx = $block->skip_nginx;
+    my ($tests_to_skip, $should_skip, $skip_reason);
+    if (defined $skip_nginx) {
+        if ($skip_nginx =~ m{
+                ^ \s* (\d+) \s* : \s*
+                    ([<>]=?) \s* (\d+)\.(\d+)\.(\d+)
+                    (?: \s* : \s* (.*) )?
+                \s*$}x) {
+            $tests_to_skip = $1;
+            my ($op, $ver1, $ver2, $ver3) = ($2, $3, $4, $5);
+            $skip_reason = $6;
+            #warn "$ver1 $ver2 $ver3";
+            my $ver = get_canon_version($ver1, $ver2, $ver3);
+            if ((!defined $NginxVersion and $op =~ /^</)
+                    or eval "$NginxVersion $op $ver")
+            {
+                $should_skip = 1;
+            }
+        } else {
+            Test::More::BAIL_OUT("$name - Invalid --- skip_nginx spec: " .
+                $skip_nginx);
+            die;
+        }
+    }
+    if (!defined $skip_reason) {
+        $skip_reason = "various reasons";
+    }
+
+    my $todo_nginx = $block->todo_nginx;
+    my ($should_todo, $todo_reason);
+    if (defined $todo_nginx) {
+        if ($todo_nginx =~ m{
+                ^ \s*
+                    ([<>]=?) \s* (\d+)\.(\d+)\.(\d+)
+                    (?: \s* : \s* (.*) )?
+                \s*$}x) {
+            my ($op, $ver1, $ver2, $ver3) = ($1, $2, $3, $4);
+            $todo_reason = $5;
+            my $ver = get_canon_version($ver1, $ver2, $ver3);
+            if ((!defined $NginxVersion and $op =~ /^</)
+                    or eval "$NginxVersion $op $ver")
+            {
+                $should_todo = 1;
+            }
+        } else {
+            Test::More::BAIL_OUT("$name - Invalid --- todo_nginx spec: " .
+                $todo_nginx);
+            die;
+        }
+    }
+
+    if (!defined $todo_reason) {
+        $todo_reason = "various reasons";
+    }
+
+    if (!$NoNginxManager && !$should_skip) {
+        my $nginx_is_running = 1;
+        if (-f $PidFile) {
+            my $pid = get_pid_from_pidfile($name);
+            if (!defined $pid or $pid eq '') {
+                undef $nginx_is_running;
+                goto start_nginx;
+            }
+
+            if (system("ps $pid > /dev/null") == 0) {
+                #warn "found running nginx...";
+                write_config_file($config, $block->http_config);
+                if (kill(SIGQUIT, $pid) == 0) { # send quit signal
+                    #warn("$name - Failed to send quit signal to the nginx process with PID $pid");
+                }
+                sleep 0.02;
+                if (system("ps $pid > /dev/null") == 0) {
+                    #warn "killing with force...\n";
+                    kill(SIGKILL, $pid);
+                    sleep 0.02;
+                }
+                undef $nginx_is_running;
+            } else {
+                unlink $PidFile or
+                    die "Failed to remove pid file $PidFile\n";
+                undef $nginx_is_running;
+            }
+        } else {
+            undef $nginx_is_running;
+        }
+
+start_nginx:
+
+        unless ($nginx_is_running) {
+            #system("killall -9 nginx");
+
+            #warn "*** Restarting the nginx server...\n";
+            setup_server_root();
+            write_config_file($config, $block->http_config);
+            if ( ! Module::Install::Can->can_run('nginx') ) {
+                Test::More::BAIL_OUT("$name - Cannot find the nginx executable in the PATH environment");
+                die;
+            }
+        #if (system("nginx -p $ServRoot -c $ConfFile -t") != 0) {
+        #Test::More::BAIL_OUT("$name - Invalid config file");
+        #}
+        #my $cmd = "nginx -p $ServRoot -c $ConfFile > /dev/null";
+            my $cmd;
+            if ($NginxVersion >= 0.007053) {
+                $cmd = "nginx -p $ServRoot/ -c $ConfFile > /dev/null";
+            } else {
+                $cmd = "nginx -c $ConfFile > /dev/null";
+            }
+
+            if ($Profiling) {
+                my $pid = $ForkManager->start;
+                if (!$pid) {
+                    # child process
+                    if (system($cmd) != 0) {
+                        Test::More::BAIL_OUT("$name - Cannot start nginx using command \"$cmd\".");
+                    }
+
+                    $ForkManager->finish; # terminate the child process
+                }
+            } else {
+                if (system($cmd) != 0) {
+                    Test::More::BAIL_OUT("$name - Cannot start nginx using command \"$cmd\".");
+                }
+            }
+
+            sleep 10;
+        }
+    }
+
+    my $i = 0;
+    while ($i++ < $RepeatEach) {
+        if ($should_skip) {
+            SKIP: {
+                Test::More::skip("$name - $skip_reason", $tests_to_skip);
+
+                $RunTestHelper->($block);
+            }
+        } elsif ($should_todo) {
+            TODO: {
+                local $TODO = "$name - $todo_reason";
+
+                $RunTestHelper->($block);
+            }
+        } else {
+            $RunTestHelper->($block);
+        }
+    }
+
+    if (defined $block->quit && $Profiling) {
+        warn "Found quit...";
+        if (-f $PidFile) {
+            my $pid = get_pid_from_pidfile($name);
+            if (system("ps $pid > /dev/null") == 0) {
+                write_config_file($config, $block->http_config);
+                if (kill(SIGQUIT, $pid) == 0) { # send quit signal
+                    #warn("$name - Failed to send quit signal to the nginx process with PID $pid");
+                }
+                sleep 0.02;
+                if (system("ps $pid > /dev/null") == 0) {
+                    #warn "killing with force...\n";
+                    kill(SIGKILL, $pid);
+                    sleep 0.02;
+                }
+            } else {
+                unlink $PidFile or
+                    die "Failed to remove pid file $PidFile\n";
+            }
+        }
+    }
+}
+
+1;
diff --git a/src/tcp/test/ragel/http11.c b/src/tcp/test/ragel/http11.c
new file mode 100755
index 0000000..b810246
--- /dev/null
+++ b/src/tcp/test/ragel/http11.c
@@ -0,0 +1,534 @@
+/**
+ * Copyright (c) 2005 Zed A. Shaw
+ * You can redistribute it and/or modify it under the same terms as Ruby.
+ */
+#include "ruby.h"
+#include "ext_help.h"
+#include <assert.h>
+#include <string.h>
+#include "http11_parser.h"
+
+#ifndef RSTRING_PTR
+#define RSTRING_PTR(s) (RSTRING(s)->ptr)
+#endif
+#ifndef RSTRING_LEN
+#define RSTRING_LEN(s) (RSTRING(s)->len)
+#endif
+
+#ifndef RSTRING_PTR
+#define RSTRING_PTR(s) (RSTRING(s)->ptr)
+#endif
+#ifndef RSTRING_LEN
+#define RSTRING_LEN(s) (RSTRING(s)->len)
+#endif
+
+static VALUE mMongrel;
+static VALUE cHttpParser;
+static VALUE eHttpParserError;
+
+#define id_handler_map rb_intern("@handler_map")
+#define id_http_body rb_intern("@http_body")
+#define HTTP_PREFIX "HTTP_"
+#define HTTP_PREFIX_LEN (sizeof(HTTP_PREFIX) - 1)
+
+static VALUE global_request_method;
+static VALUE global_request_uri;
+static VALUE global_fragment;
+static VALUE global_query_string;
+static VALUE global_http_version;
+static VALUE global_content_length;
+static VALUE global_http_content_length;
+static VALUE global_request_path;
+static VALUE global_content_type;
+static VALUE global_http_content_type;
+static VALUE global_gateway_interface;
+static VALUE global_gateway_interface_value;
+static VALUE global_server_name;
+static VALUE global_server_port;
+static VALUE global_server_protocol;
+static VALUE global_server_protocol_value;
+static VALUE global_http_host;
+static VALUE global_mongrel_version;
+static VALUE global_server_software;
+static VALUE global_port_80;
+
+#define TRIE_INCREASE 30
+
+/** Defines common length and error messages for input length validation. */
+#define DEF_MAX_LENGTH(N,length) const size_t MAX_##N##_LENGTH = length; const char *MAX_##N##_LENGTH_ERR = "HTTP element " # N  " is longer than the " # length " allowed length."
+
+/** Validates the max length of given input and throws an HttpParserError exception if over. */
+#define VALIDATE_MAX_LENGTH(len, N) if(len > MAX_##N##_LENGTH) { rb_raise(eHttpParserError, MAX_##N##_LENGTH_ERR); }
+
+/** Defines global strings in the init method. */
+#define DEF_GLOBAL(N, val)   global_##N = rb_obj_freeze(rb_str_new2(val)); rb_global_variable(&global_##N)
+
+
+/* Defines the maximum allowed lengths for various input elements.*/
+DEF_MAX_LENGTH(FIELD_NAME, 256);
+DEF_MAX_LENGTH(FIELD_VALUE, 80 * 1024);
+DEF_MAX_LENGTH(REQUEST_URI, 1024 * 12);
+DEF_MAX_LENGTH(FRAGMENT, 1024); /* Don't know if this length is specified somewhere or not */
+DEF_MAX_LENGTH(REQUEST_PATH, 1024);
+DEF_MAX_LENGTH(QUERY_STRING, (1024 * 10));
+DEF_MAX_LENGTH(HEADER, (1024 * (80 + 32)));
+
+struct common_field {
+	const signed long len;
+	const char *name;
+	VALUE value;
+};
+
+/*
+ * A list of common HTTP headers we expect to receive.
+ * This allows us to avoid repeatedly creating identical string
+ * objects to be used with rb_hash_aset().
+ */
+static struct common_field common_http_fields[] = {
+# define f(N) { (sizeof(N) - 1), N, Qnil }
+	f("ACCEPT"),
+	f("ACCEPT_CHARSET"),
+	f("ACCEPT_ENCODING"),
+	f("ACCEPT_LANGUAGE"),
+	f("ALLOW"),
+	f("AUTHORIZATION"),
+	f("CACHE_CONTROL"),
+	f("CONNECTION"),
+	f("CONTENT_ENCODING"),
+	f("CONTENT_LENGTH"),
+	f("CONTENT_TYPE"),
+	f("COOKIE"),
+	f("DATE"),
+	f("EXPECT"),
+	f("FROM"),
+	f("HOST"),
+	f("IF_MATCH"),
+	f("IF_MODIFIED_SINCE"),
+	f("IF_NONE_MATCH"),
+	f("IF_RANGE"),
+	f("IF_UNMODIFIED_SINCE"),
+	f("KEEP_ALIVE"), /* Firefox sends this */
+	f("MAX_FORWARDS"),
+	f("PRAGMA"),
+	f("PROXY_AUTHORIZATION"),
+	f("RANGE"),
+	f("REFERER"),
+	f("TE"),
+	f("TRAILER"),
+	f("TRANSFER_ENCODING"),
+	f("UPGRADE"),
+	f("USER_AGENT"),
+	f("VIA"),
+	f("X_FORWARDED_FOR"), /* common for proxies */
+	f("X_REAL_IP"), /* common for proxies */
+	f("WARNING")
+# undef f
+};
+
+/*
+ * qsort(3) and bsearch(3) improve average performance slightly, but may
+ * not be worth it for lack of portability to certain platforms...
+ */
+#if defined(HAVE_QSORT_BSEARCH)
+/* sort by length, then by name if there's a tie */
+static int common_field_cmp(const void *a, const void *b)
+{
+  struct common_field *cfa = (struct common_field *)a;
+  struct common_field *cfb = (struct common_field *)b;
+  signed long diff = cfa->len - cfb->len;
+  return diff ? diff : memcmp(cfa->name, cfb->name, cfa->len);
+}
+#endif /* HAVE_QSORT_BSEARCH */
+
+static void init_common_fields(void)
+{
+  int i;
+  struct common_field *cf = common_http_fields;
+  char tmp[256]; /* MAX_FIELD_NAME_LENGTH */
+  memcpy(tmp, HTTP_PREFIX, HTTP_PREFIX_LEN);
+
+  for(i = 0; i < ARRAY_SIZE(common_http_fields); cf++, i++) {
+    memcpy(tmp + HTTP_PREFIX_LEN, cf->name, cf->len + 1);
+    cf->value = rb_obj_freeze(rb_str_new(tmp, HTTP_PREFIX_LEN + cf->len));
+    rb_global_variable(&cf->value);
+  }
+
+#if defined(HAVE_QSORT_BSEARCH)
+  qsort(common_http_fields,
+        ARRAY_SIZE(common_http_fields),
+        sizeof(struct common_field),
+        common_field_cmp);
+#endif /* HAVE_QSORT_BSEARCH */
+}
+
+static VALUE find_common_field_value(const char *field, size_t flen)
+{
+#if defined(HAVE_QSORT_BSEARCH)
+  struct common_field key;
+  struct common_field *found;
+  key.name = field;
+  key.len = (signed long)flen;
+  found = (struct common_field *)bsearch(&key, common_http_fields,
+                                         ARRAY_SIZE(common_http_fields),
+                                         sizeof(struct common_field),
+                                         common_field_cmp);
+  return found ? found->value : Qnil;
+#else /* !HAVE_QSORT_BSEARCH */
+  int i;
+  struct common_field *cf = common_http_fields;
+  for(i = 0; i < ARRAY_SIZE(common_http_fields); i++, cf++) {
+    if (cf->len == flen && !memcmp(cf->name, field, flen))
+      return cf->value;
+  }
+  return Qnil;
+#endif /* !HAVE_QSORT_BSEARCH */
+}
+
+void http_field(void *data, const char *field, size_t flen, const char *value, size_t vlen)
+{
+  VALUE req = (VALUE)data;
+  VALUE v = Qnil;
+  VALUE f = Qnil;
+
+  VALIDATE_MAX_LENGTH(flen, FIELD_NAME);
+  VALIDATE_MAX_LENGTH(vlen, FIELD_VALUE);
+
+  v = rb_str_new(value, vlen);
+
+  f = find_common_field_value(field, flen);
+
+  if (f == Qnil) {
+    /*
+     * We got a strange header that we don't have a memoized value for.
+     * Fallback to creating a new string to use as a hash key.
+     *
+     * using rb_str_new(NULL, len) here is faster than rb_str_buf_new(len)
+     * in my testing, because: there's no minimum allocation length (and
+     * no check for it, either), RSTRING_LEN(f) does not need to be
+     * written twice, and and RSTRING_PTR(f) will already be
+     * null-terminated for us.
+     */
+    f = rb_str_new(NULL, HTTP_PREFIX_LEN + flen);
+    memcpy(RSTRING_PTR(f), HTTP_PREFIX, HTTP_PREFIX_LEN);
+    memcpy(RSTRING_PTR(f) + HTTP_PREFIX_LEN, field, flen);
+    assert(*(RSTRING_PTR(f) + RSTRING_LEN(f)) == '\0'); /* paranoia */
+    /* fprintf(stderr, "UNKNOWN HEADER <%s>\n", RSTRING_PTR(f)); */
+  }
+
+  rb_hash_aset(req, f, v);
+}
+
+void request_method(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE val = Qnil;
+
+  val = rb_str_new(at, length);
+  rb_hash_aset(req, global_request_method, val);
+}
+
+void request_uri(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE val = Qnil;
+
+  VALIDATE_MAX_LENGTH(length, REQUEST_URI);
+
+  val = rb_str_new(at, length);
+  rb_hash_aset(req, global_request_uri, val);
+}
+
+void fragment(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE val = Qnil;
+
+  VALIDATE_MAX_LENGTH(length, FRAGMENT);
+
+  val = rb_str_new(at, length);
+  rb_hash_aset(req, global_fragment, val);
+}
+
+void request_path(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE val = Qnil;
+
+  VALIDATE_MAX_LENGTH(length, REQUEST_PATH);
+
+  val = rb_str_new(at, length);
+  rb_hash_aset(req, global_request_path, val);
+}
+
+void query_string(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE val = Qnil;
+
+  VALIDATE_MAX_LENGTH(length, QUERY_STRING);
+
+  val = rb_str_new(at, length);
+  rb_hash_aset(req, global_query_string, val);
+}
+
+void http_version(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE val = rb_str_new(at, length);
+  rb_hash_aset(req, global_http_version, val);
+}
+
+/** Finalizes the request header to have a bunch of stuff that's
+  needed. */
+
+void header_done(void *data, const char *at, size_t length)
+{
+  VALUE req = (VALUE)data;
+  VALUE temp = Qnil;
+  VALUE ctype = Qnil;
+  VALUE clen = Qnil;
+  char *colon = NULL;
+
+  clen = rb_hash_aref(req, global_http_content_length);
+  if(clen != Qnil) {
+    rb_hash_aset(req, global_content_length, clen);
+  }
+
+  ctype = rb_hash_aref(req, global_http_content_type);
+  if(ctype != Qnil) {
+    rb_hash_aset(req, global_content_type, ctype);
+  }
+
+  rb_hash_aset(req, global_gateway_interface, global_gateway_interface_value);
+  if((temp = rb_hash_aref(req, global_http_host)) != Qnil) {
+    colon = memchr(RSTRING_PTR(temp), ':', RSTRING_LEN(temp));
+    if(colon != NULL) {
+      rb_hash_aset(req, global_server_name, rb_str_substr(temp, 0, colon - RSTRING_PTR(temp)));
+      rb_hash_aset(req, global_server_port, 
+          rb_str_substr(temp, colon - RSTRING_PTR(temp)+1, 
+            RSTRING_LEN(temp)));
+    } else {
+      rb_hash_aset(req, global_server_name, temp);
+      rb_hash_aset(req, global_server_port, global_port_80);
+    }
+  }
+
+  /* grab the initial body and stuff it into an ivar */
+  rb_ivar_set(req, id_http_body, rb_str_new(at, length));
+  rb_hash_aset(req, global_server_protocol, global_server_protocol_value);
+  rb_hash_aset(req, global_server_software, global_mongrel_version);
+}
+
+
+void HttpParser_free(void *data) {
+  TRACE();
+
+  if(data) {
+    free(data);
+  }
+}
+
+
+VALUE HttpParser_alloc(VALUE klass)
+{
+  VALUE obj;
+  http_parser *hp = ALLOC_N(http_parser, 1);
+  TRACE();
+  hp->http_field = http_field;
+  hp->request_method = request_method;
+  hp->request_uri = request_uri;
+  hp->fragment = fragment;
+  hp->request_path = request_path;
+  hp->query_string = query_string;
+  hp->http_version = http_version;
+  hp->header_done = header_done;
+  http_parser_init(hp);
+
+  obj = Data_Wrap_Struct(klass, NULL, HttpParser_free, hp);
+
+  return obj;
+}
+
+
+/**
+ * call-seq:
+ *    parser.new -> parser
+ *
+ * Creates a new parser.
+ */
+VALUE HttpParser_init(VALUE self)
+{
+  http_parser *http = NULL;
+  DATA_GET(self, http_parser, http);
+  http_parser_init(http);
+
+  return self;
+}
+
+
+/**
+ * call-seq:
+ *    parser.reset -> nil
+ *
+ * Resets the parser to it's initial state so that you can reuse it
+ * rather than making new ones.
+ */
+VALUE HttpParser_reset(VALUE self)
+{
+  http_parser *http = NULL;
+  DATA_GET(self, http_parser, http);
+  http_parser_init(http);
+
+  return Qnil;
+}
+
+
+/**
+ * call-seq:
+ *    parser.finish -> true/false
+ *
+ * Finishes a parser early which could put in a "good" or bad state.
+ * You should call reset after finish it or bad things will happen.
+ */
+VALUE HttpParser_finish(VALUE self)
+{
+  http_parser *http = NULL;
+  DATA_GET(self, http_parser, http);
+  http_parser_finish(http);
+
+  return http_parser_is_finished(http) ? Qtrue : Qfalse;
+}
+
+
+/**
+ * call-seq:
+ *    parser.execute(req_hash, data, start) -> Integer
+ *
+ * Takes a Hash and a String of data, parses the String of data filling in the Hash
+ * returning an Integer to indicate how much of the data has been read.  No matter
+ * what the return value, you should call HttpParser#finished? and HttpParser#error?
+ * to figure out if it's done parsing or there was an error.
+ * 
+ * This function now throws an exception when there is a parsing error.  This makes 
+ * the logic for working with the parser much easier.  You can still test for an 
+ * error, but now you need to wrap the parser with an exception handling block.
+ *
+ * The third argument allows for parsing a partial request and then continuing
+ * the parsing from that position.  It needs all of the original data as well 
+ * so you have to append to the data buffer as you read.
+ */
+VALUE HttpParser_execute(VALUE self, VALUE req_hash, VALUE data, VALUE start)
+{
+  http_parser *http = NULL;
+  int from = 0;
+  char *dptr = NULL;
+  long dlen = 0;
+
+  DATA_GET(self, http_parser, http);
+
+  from = FIX2INT(start);
+  dptr = RSTRING_PTR(data);
+  dlen = RSTRING_LEN(data);
+
+  if(from >= dlen) {
+    rb_raise(eHttpParserError, "Requested start is after data buffer end.");
+  } else {
+    http->data = (void *)req_hash;
+    http_parser_execute(http, dptr, dlen, from);
+
+    VALIDATE_MAX_LENGTH(http_parser_nread(http), HEADER);
+
+    if(http_parser_has_error(http)) {
+      rb_raise(eHttpParserError, "Invalid HTTP format, parsing fails.");
+    } else {
+      return INT2FIX(http_parser_nread(http));
+    }
+  }
+}
+
+
+
+/**
+ * call-seq:
+ *    parser.error? -> true/false
+ *
+ * Tells you whether the parser is in an error state.
+ */
+VALUE HttpParser_has_error(VALUE self)
+{
+  http_parser *http = NULL;
+  DATA_GET(self, http_parser, http);
+
+  return http_parser_has_error(http) ? Qtrue : Qfalse;
+}
+
+
+/**
+ * call-seq:
+ *    parser.finished? -> true/false
+ *
+ * Tells you whether the parser is finished or not and in a good state.
+ */
+VALUE HttpParser_is_finished(VALUE self)
+{
+  http_parser *http = NULL;
+  DATA_GET(self, http_parser, http);
+
+  return http_parser_is_finished(http) ? Qtrue : Qfalse;
+}
+
+
+/**
+ * call-seq:
+ *    parser.nread -> Integer
+ *
+ * Returns the amount of data processed so far during this processing cycle.  It is
+ * set to 0 on initialize or reset calls and is incremented each time execute is called.
+ */
+VALUE HttpParser_nread(VALUE self)
+{
+  http_parser *http = NULL;
+  DATA_GET(self, http_parser, http);
+
+  return INT2FIX(http->nread);
+}
+
+void Init_http11()
+{
+
+  mMongrel = rb_define_module("Mongrel");
+
+  DEF_GLOBAL(request_method, "REQUEST_METHOD");
+  DEF_GLOBAL(request_uri, "REQUEST_URI");
+  DEF_GLOBAL(fragment, "FRAGMENT");
+  DEF_GLOBAL(query_string, "QUERY_STRING");
+  DEF_GLOBAL(http_version, "HTTP_VERSION");
+  DEF_GLOBAL(request_path, "REQUEST_PATH");
+  DEF_GLOBAL(content_length, "CONTENT_LENGTH");
+  DEF_GLOBAL(http_content_length, "HTTP_CONTENT_LENGTH");
+  DEF_GLOBAL(content_type, "CONTENT_TYPE");
+  DEF_GLOBAL(http_content_type, "HTTP_CONTENT_TYPE");
+  DEF_GLOBAL(gateway_interface, "GATEWAY_INTERFACE");
+  DEF_GLOBAL(gateway_interface_value, "CGI/1.2");
+  DEF_GLOBAL(server_name, "SERVER_NAME");
+  DEF_GLOBAL(server_port, "SERVER_PORT");
+  DEF_GLOBAL(server_protocol, "SERVER_PROTOCOL");
+  DEF_GLOBAL(server_protocol_value, "HTTP/1.1");
+  DEF_GLOBAL(http_host, "HTTP_HOST");
+  DEF_GLOBAL(mongrel_version, "Mongrel 1.2.0.pre2"); /* XXX Why is this defined here? */
+  DEF_GLOBAL(server_software, "SERVER_SOFTWARE");
+  DEF_GLOBAL(port_80, "80");
+
+  eHttpParserError = rb_define_class_under(mMongrel, "HttpParserError", rb_eIOError);
+
+  cHttpParser = rb_define_class_under(mMongrel, "HttpParser", rb_cObject);
+  rb_define_alloc_func(cHttpParser, HttpParser_alloc);
+  rb_define_method(cHttpParser, "initialize", HttpParser_init,0);
+  rb_define_method(cHttpParser, "reset", HttpParser_reset,0);
+  rb_define_method(cHttpParser, "finish", HttpParser_finish,0);
+  rb_define_method(cHttpParser, "execute", HttpParser_execute,3);
+  rb_define_method(cHttpParser, "error?", HttpParser_has_error,0);
+  rb_define_method(cHttpParser, "finished?", HttpParser_is_finished,0);
+  rb_define_method(cHttpParser, "nread", HttpParser_nread,0);
+  init_common_fields();
+}
diff --git a/src/tcp/test/ragel/http11_parser.c b/src/tcp/test/ragel/http11_parser.c
new file mode 100755
index 0000000..d54cd36
--- /dev/null
+++ b/src/tcp/test/ragel/http11_parser.c
@@ -0,0 +1,1231 @@
+
+#line 1 "http11_parser.rl"
+/**
+ * Copyright (c) 2005 Zed A. Shaw
+ * You can redistribute it and/or modify it under the same terms as Ruby.
+ */
+#include "http11_parser.h"
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+
+#line 75 "http11_parser.rl"
+
+
+/** Data **/
+
+#line 28 "http11_parser.c"
+static const int http_parser_start = 1;
+static const int http_parser_first_final = 57;
+static const int http_parser_error = 0;
+
+static const int http_parser_en_main = 1;
+
+
+#line 79 "http11_parser.rl"
+
+int http_parser_init(http_parser *parser)  {
+  int cs = 0;
+  
+#line 41 "http11_parser.c"
+	{
+	cs = http_parser_start;
+	}
+
+#line 83 "http11_parser.rl"
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_parser_execute(http_parser *parser, const char *buffer, size_t len, size_t off)  {
+  const char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer+off;
+  pe = buffer+len;
+
+  /* assert(*pe == '\0' && "pointer does not end on NUL"); */
+  assert(pe - p == len - off && "pointers aren't same distance");
+
+  
+#line 73 "http11_parser.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	switch( (*p) ) {
+		case 36: goto tr0;
+		case 95: goto tr0;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto tr0;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto tr0;
+	} else
+		goto tr0;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+tr0:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st2;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+#line 104 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st38;
+		case 95: goto st38;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st38;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st38;
+	} else
+		goto st38;
+	goto st0;
+tr2:
+#line 37 "http11_parser.rl"
+	{ 
+    if(parser->request_method != NULL) 
+      parser->request_method(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st3;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+#line 130 "http11_parser.c"
+	switch( (*p) ) {
+		case 42: goto tr4;
+		case 43: goto tr5;
+		case 47: goto tr6;
+		case 58: goto tr7;
+	}
+	if ( (*p) < 65 ) {
+		if ( 45 <= (*p) && (*p) <= 57 )
+			goto tr5;
+	} else if ( (*p) > 90 ) {
+		if ( 97 <= (*p) && (*p) <= 122 )
+			goto tr5;
+	} else
+		goto tr5;
+	goto st0;
+tr4:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st4;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+#line 154 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr8;
+		case 35: goto tr9;
+	}
+	goto st0;
+tr8:
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr31:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+#line 45 "http11_parser.rl"
+	{
+    if(parser->fragment != NULL)
+      parser->fragment(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr34:
+#line 45 "http11_parser.rl"
+	{
+    if(parser->fragment != NULL)
+      parser->fragment(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr42:
+#line 61 "http11_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr53:
+#line 50 "http11_parser.rl"
+	{MARK(query_start, p); }
+#line 51 "http11_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+tr57:
+#line 51 "http11_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st5;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+#line 225 "http11_parser.c"
+	if ( (*p) == 72 )
+		goto tr10;
+	goto st0;
+tr10:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st6;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+#line 237 "http11_parser.c"
+	if ( (*p) == 84 )
+		goto st7;
+	goto st0;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+	if ( (*p) == 84 )
+		goto st8;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	if ( (*p) == 80 )
+		goto st9;
+	goto st0;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+	if ( (*p) == 47 )
+		goto st10;
+	goto st0;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st11;
+	goto st0;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+	if ( (*p) == 46 )
+		goto st12;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st11;
+	goto st0;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st13;
+	goto st0;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+	if ( (*p) == 13 )
+		goto tr18;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st13;
+	goto st0;
+tr18:
+#line 56 "http11_parser.rl"
+	{	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st14;
+tr26:
+#line 31 "http11_parser.rl"
+	{ MARK(mark, p); }
+#line 32 "http11_parser.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+tr29:
+#line 32 "http11_parser.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+#line 323 "http11_parser.c"
+	if ( (*p) == 10 )
+		goto st15;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	switch( (*p) ) {
+		case 13: goto st16;
+		case 33: goto tr21;
+		case 124: goto tr21;
+		case 126: goto tr21;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto tr21;
+		} else if ( (*p) >= 35 )
+			goto tr21;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto tr21;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto tr21;
+		} else
+			goto tr21;
+	} else
+		goto tr21;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 10 )
+		goto tr22;
+	goto st0;
+tr22:
+#line 66 "http11_parser.rl"
+	{ 
+    parser->body_start = p - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, p + 1, pe - p - 1);
+    {p++; cs = 57; goto _out;}
+  }
+	goto st57;
+st57:
+	if ( ++p == pe )
+		goto _test_eof57;
+case 57:
+#line 375 "http11_parser.c"
+	goto st0;
+tr21:
+#line 26 "http11_parser.rl"
+	{ MARK(field_start, p); }
+	goto st17;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+#line 385 "http11_parser.c"
+	switch( (*p) ) {
+		case 33: goto st17;
+		case 58: goto tr24;
+		case 124: goto st17;
+		case 126: goto st17;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto st17;
+		} else if ( (*p) >= 35 )
+			goto st17;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto st17;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto st17;
+		} else
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+tr24:
+#line 27 "http11_parser.rl"
+	{ 
+    parser->field_len = LEN(field_start, p);
+  }
+	goto st18;
+tr27:
+#line 31 "http11_parser.rl"
+	{ MARK(mark, p); }
+	goto st18;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+#line 424 "http11_parser.c"
+	switch( (*p) ) {
+		case 13: goto tr26;
+		case 32: goto tr27;
+	}
+	goto tr25;
+tr25:
+#line 31 "http11_parser.rl"
+	{ MARK(mark, p); }
+	goto st19;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+#line 438 "http11_parser.c"
+	if ( (*p) == 13 )
+		goto tr29;
+	goto st19;
+tr9:
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+tr43:
+#line 61 "http11_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+tr54:
+#line 50 "http11_parser.rl"
+	{MARK(query_start, p); }
+#line 51 "http11_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+tr58:
+#line 51 "http11_parser.rl"
+	{ 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, p));
+  }
+#line 41 "http11_parser.rl"
+	{ 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st20;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+#line 491 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr31;
+		case 37: goto tr32;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( (*p) > 31 ) {
+		if ( 34 <= (*p) && (*p) <= 35 )
+			goto st0;
+	} else if ( (*p) >= 0 )
+		goto st0;
+	goto tr30;
+tr30:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st21;
+st21:
+	if ( ++p == pe )
+		goto _test_eof21;
+case 21:
+#line 513 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr34;
+		case 37: goto st22;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( (*p) > 31 ) {
+		if ( 34 <= (*p) && (*p) <= 35 )
+			goto st0;
+	} else if ( (*p) >= 0 )
+		goto st0;
+	goto st21;
+tr32:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st22;
+st22:
+	if ( ++p == pe )
+		goto _test_eof22;
+case 22:
+#line 535 "http11_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st23;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st23;
+	} else
+		goto st23;
+	goto st0;
+st23:
+	if ( ++p == pe )
+		goto _test_eof23;
+case 23:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st21;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st21;
+	} else
+		goto st21;
+	goto st0;
+tr5:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st24;
+st24:
+	if ( ++p == pe )
+		goto _test_eof24;
+case 24:
+#line 566 "http11_parser.c"
+	switch( (*p) ) {
+		case 43: goto st24;
+		case 58: goto st25;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st24;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 90 ) {
+			if ( 97 <= (*p) && (*p) <= 122 )
+				goto st24;
+		} else if ( (*p) >= 65 )
+			goto st24;
+	} else
+		goto st24;
+	goto st0;
+tr7:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st25;
+st25:
+	if ( ++p == pe )
+		goto _test_eof25;
+case 25:
+#line 591 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr8;
+		case 34: goto st0;
+		case 35: goto tr9;
+		case 37: goto st26;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st25;
+st26:
+	if ( ++p == pe )
+		goto _test_eof26;
+case 26:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st27;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st27;
+	} else
+		goto st27;
+	goto st0;
+st27:
+	if ( ++p == pe )
+		goto _test_eof27;
+case 27:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st25;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st25;
+	} else
+		goto st25;
+	goto st0;
+tr6:
+#line 23 "http11_parser.rl"
+	{MARK(mark, p); }
+	goto st28;
+st28:
+	if ( ++p == pe )
+		goto _test_eof28;
+case 28:
+#line 638 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr42;
+		case 34: goto st0;
+		case 35: goto tr43;
+		case 37: goto st29;
+		case 59: goto tr45;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 63: goto tr46;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st28;
+st29:
+	if ( ++p == pe )
+		goto _test_eof29;
+case 29:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st30;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st30;
+	} else
+		goto st30;
+	goto st0;
+st30:
+	if ( ++p == pe )
+		goto _test_eof30;
+case 30:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st28;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st28;
+	} else
+		goto st28;
+	goto st0;
+tr45:
+#line 61 "http11_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st31;
+st31:
+	if ( ++p == pe )
+		goto _test_eof31;
+case 31:
+#line 690 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr8;
+		case 34: goto st0;
+		case 35: goto tr9;
+		case 37: goto st32;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 63: goto st34;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st31;
+st32:
+	if ( ++p == pe )
+		goto _test_eof32;
+case 32:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st33;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st33;
+	} else
+		goto st33;
+	goto st0;
+st33:
+	if ( ++p == pe )
+		goto _test_eof33;
+case 33:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st31;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st31;
+	} else
+		goto st31;
+	goto st0;
+tr46:
+#line 61 "http11_parser.rl"
+	{
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st34;
+st34:
+	if ( ++p == pe )
+		goto _test_eof34;
+case 34:
+#line 741 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr53;
+		case 34: goto st0;
+		case 35: goto tr54;
+		case 37: goto tr55;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto tr52;
+tr52:
+#line 50 "http11_parser.rl"
+	{MARK(query_start, p); }
+	goto st35;
+st35:
+	if ( ++p == pe )
+		goto _test_eof35;
+case 35:
+#line 762 "http11_parser.c"
+	switch( (*p) ) {
+		case 32: goto tr57;
+		case 34: goto st0;
+		case 35: goto tr58;
+		case 37: goto st36;
+		case 60: goto st0;
+		case 62: goto st0;
+		case 127: goto st0;
+	}
+	if ( 0 <= (*p) && (*p) <= 31 )
+		goto st0;
+	goto st35;
+tr55:
+#line 50 "http11_parser.rl"
+	{MARK(query_start, p); }
+	goto st36;
+st36:
+	if ( ++p == pe )
+		goto _test_eof36;
+case 36:
+#line 783 "http11_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st37;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st37;
+	} else
+		goto st37;
+	goto st0;
+st37:
+	if ( ++p == pe )
+		goto _test_eof37;
+case 37:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st35;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st35;
+	} else
+		goto st35;
+	goto st0;
+st38:
+	if ( ++p == pe )
+		goto _test_eof38;
+case 38:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st39;
+		case 95: goto st39;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st39;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st39;
+	} else
+		goto st39;
+	goto st0;
+st39:
+	if ( ++p == pe )
+		goto _test_eof39;
+case 39:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st40;
+		case 95: goto st40;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st40;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st40;
+	} else
+		goto st40;
+	goto st0;
+st40:
+	if ( ++p == pe )
+		goto _test_eof40;
+case 40:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st41;
+		case 95: goto st41;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st41;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st41;
+	} else
+		goto st41;
+	goto st0;
+st41:
+	if ( ++p == pe )
+		goto _test_eof41;
+case 41:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st42;
+		case 95: goto st42;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st42;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st42;
+	} else
+		goto st42;
+	goto st0;
+st42:
+	if ( ++p == pe )
+		goto _test_eof42;
+case 42:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st43;
+		case 95: goto st43;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st43;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st43;
+	} else
+		goto st43;
+	goto st0;
+st43:
+	if ( ++p == pe )
+		goto _test_eof43;
+case 43:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st44;
+		case 95: goto st44;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st44;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st44;
+	} else
+		goto st44;
+	goto st0;
+st44:
+	if ( ++p == pe )
+		goto _test_eof44;
+case 44:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st45;
+		case 95: goto st45;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st45;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st45;
+	} else
+		goto st45;
+	goto st0;
+st45:
+	if ( ++p == pe )
+		goto _test_eof45;
+case 45:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st46;
+		case 95: goto st46;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st46;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st46;
+	} else
+		goto st46;
+	goto st0;
+st46:
+	if ( ++p == pe )
+		goto _test_eof46;
+case 46:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st47;
+		case 95: goto st47;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st47;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st47;
+	} else
+		goto st47;
+	goto st0;
+st47:
+	if ( ++p == pe )
+		goto _test_eof47;
+case 47:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st48;
+		case 95: goto st48;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st48;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st48;
+	} else
+		goto st48;
+	goto st0;
+st48:
+	if ( ++p == pe )
+		goto _test_eof48;
+case 48:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st49;
+		case 95: goto st49;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st49;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st49;
+	} else
+		goto st49;
+	goto st0;
+st49:
+	if ( ++p == pe )
+		goto _test_eof49;
+case 49:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st50;
+		case 95: goto st50;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st50;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st50;
+	} else
+		goto st50;
+	goto st0;
+st50:
+	if ( ++p == pe )
+		goto _test_eof50;
+case 50:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st51;
+		case 95: goto st51;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st51;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st51;
+	} else
+		goto st51;
+	goto st0;
+st51:
+	if ( ++p == pe )
+		goto _test_eof51;
+case 51:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st52;
+		case 95: goto st52;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st52;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st52;
+	} else
+		goto st52;
+	goto st0;
+st52:
+	if ( ++p == pe )
+		goto _test_eof52;
+case 52:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st53;
+		case 95: goto st53;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st53;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st53;
+	} else
+		goto st53;
+	goto st0;
+st53:
+	if ( ++p == pe )
+		goto _test_eof53;
+case 53:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st54;
+		case 95: goto st54;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st54;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st54;
+	} else
+		goto st54;
+	goto st0;
+st54:
+	if ( ++p == pe )
+		goto _test_eof54;
+case 54:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st55;
+		case 95: goto st55;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st55;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st55;
+	} else
+		goto st55;
+	goto st0;
+st55:
+	if ( ++p == pe )
+		goto _test_eof55;
+case 55:
+	switch( (*p) ) {
+		case 32: goto tr2;
+		case 36: goto st56;
+		case 95: goto st56;
+	}
+	if ( (*p) < 48 ) {
+		if ( 45 <= (*p) && (*p) <= 46 )
+			goto st56;
+	} else if ( (*p) > 57 ) {
+		if ( 65 <= (*p) && (*p) <= 90 )
+			goto st56;
+	} else
+		goto st56;
+	goto st0;
+st56:
+	if ( ++p == pe )
+		goto _test_eof56;
+case 56:
+	if ( (*p) == 32 )
+		goto tr2;
+	goto st0;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof57: cs = 57; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof21: cs = 21; goto _test_eof; 
+	_test_eof22: cs = 22; goto _test_eof; 
+	_test_eof23: cs = 23; goto _test_eof; 
+	_test_eof24: cs = 24; goto _test_eof; 
+	_test_eof25: cs = 25; goto _test_eof; 
+	_test_eof26: cs = 26; goto _test_eof; 
+	_test_eof27: cs = 27; goto _test_eof; 
+	_test_eof28: cs = 28; goto _test_eof; 
+	_test_eof29: cs = 29; goto _test_eof; 
+	_test_eof30: cs = 30; goto _test_eof; 
+	_test_eof31: cs = 31; goto _test_eof; 
+	_test_eof32: cs = 32; goto _test_eof; 
+	_test_eof33: cs = 33; goto _test_eof; 
+	_test_eof34: cs = 34; goto _test_eof; 
+	_test_eof35: cs = 35; goto _test_eof; 
+	_test_eof36: cs = 36; goto _test_eof; 
+	_test_eof37: cs = 37; goto _test_eof; 
+	_test_eof38: cs = 38; goto _test_eof; 
+	_test_eof39: cs = 39; goto _test_eof; 
+	_test_eof40: cs = 40; goto _test_eof; 
+	_test_eof41: cs = 41; goto _test_eof; 
+	_test_eof42: cs = 42; goto _test_eof; 
+	_test_eof43: cs = 43; goto _test_eof; 
+	_test_eof44: cs = 44; goto _test_eof; 
+	_test_eof45: cs = 45; goto _test_eof; 
+	_test_eof46: cs = 46; goto _test_eof; 
+	_test_eof47: cs = 47; goto _test_eof; 
+	_test_eof48: cs = 48; goto _test_eof; 
+	_test_eof49: cs = 49; goto _test_eof; 
+	_test_eof50: cs = 50; goto _test_eof; 
+	_test_eof51: cs = 51; goto _test_eof; 
+	_test_eof52: cs = 52; goto _test_eof; 
+	_test_eof53: cs = 53; goto _test_eof; 
+	_test_eof54: cs = 54; goto _test_eof; 
+	_test_eof55: cs = 55; goto _test_eof; 
+	_test_eof56: cs = 56; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 109 "http11_parser.rl"
+
+  if (!http_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_parser_finish(http_parser *parser)
+{
+  if (http_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_parser_has_error(http_parser *parser) {
+  return parser->cs == http_parser_error;
+}
+
+int http_parser_is_finished(http_parser *parser) {
+  return parser->cs >= http_parser_first_final;
+}
diff --git a/src/tcp/test/ragel/http11_parser.h b/src/tcp/test/ragel/http11_parser.h
new file mode 100755
index 0000000..8d074ba
--- /dev/null
+++ b/src/tcp/test/ragel/http11_parser.h
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) 2005 Zed A. Shaw
+ * You can redistribute it and/or modify it under the same terms as Ruby.
+ */
+
+#ifndef http11_parser_h
+#define http11_parser_h
+
+#include <sys/types.h>
+
+#if defined(_WIN32)
+#include <stddef.h>
+#endif
+
+typedef void (*element_cb)(void *data, const char *at, size_t length);
+typedef void (*field_cb)(void *data, const char *field, size_t flen, const char *value, size_t vlen);
+
+typedef struct http_parser { 
+  int cs;
+  size_t body_start;
+  int content_len;
+  size_t nread;
+  size_t mark;
+  size_t field_start;
+  size_t field_len;
+  size_t query_start;
+
+  void *data;
+
+  field_cb http_field;
+  element_cb request_method;
+  element_cb request_uri;
+  element_cb fragment;
+  element_cb request_path;
+  element_cb query_string;
+  element_cb http_version;
+  element_cb header_done;
+  
+} http_parser;
+
+int http_parser_init(http_parser *parser);
+int http_parser_finish(http_parser *parser);
+size_t http_parser_execute(http_parser *parser, const char *data, size_t len, size_t off);
+int http_parser_has_error(http_parser *parser);
+int http_parser_is_finished(http_parser *parser);
+
+#define http_parser_nread(parser) (parser)->nread 
+
+#endif
diff --git a/src/tcp/test/ragel/http11_parser.rl b/src/tcp/test/ragel/http11_parser.rl
new file mode 100755
index 0000000..d6fdc5a
--- /dev/null
+++ b/src/tcp/test/ragel/http11_parser.rl
@@ -0,0 +1,141 @@
+/**
+ * Copyright (c) 2005 Zed A. Shaw
+ * You can redistribute it and/or modify it under the same terms as Ruby.
+ */
+#include "http11_parser.h"
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+%%{
+  
+  machine http_parser;
+
+  action mark {MARK(mark, fpc); }
+
+
+  action start_field { MARK(field_start, fpc); }
+  action write_field { 
+    parser->field_len = LEN(field_start, fpc);
+  }
+
+  action start_value { MARK(mark, fpc); }
+  action write_value {
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, fpc));
+    }
+  }
+  action request_method { 
+    if(parser->request_method != NULL) 
+      parser->request_method(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+  action request_uri { 
+    if(parser->request_uri != NULL)
+      parser->request_uri(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+  action fragment {
+    if(parser->fragment != NULL)
+      parser->fragment(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action start_query {MARK(query_start, fpc); }
+  action query_string { 
+    if(parser->query_string != NULL)
+      parser->query_string(parser->data, PTR_TO(query_start), LEN(query_start, fpc));
+  }
+
+  action http_version {	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action request_path {
+    if(parser->request_path != NULL)
+      parser->request_path(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action done { 
+    parser->body_start = fpc - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, fpc + 1, pe - fpc - 1);
+    fbreak;
+  }
+
+  include http_parser_common "http11_parser_common.rl";
+
+}%%
+
+/** Data **/
+%% write data;
+
+int http_parser_init(http_parser *parser)  {
+  int cs = 0;
+  %% write init;
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_parser_execute(http_parser *parser, const char *buffer, size_t len, size_t off)  {
+  const char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer+off;
+  pe = buffer+len;
+
+  /* assert(*pe == '\0' && "pointer does not end on NUL"); */
+  assert(pe - p == len - off && "pointers aren't same distance");
+
+  %% write exec;
+
+  if (!http_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_parser_finish(http_parser *parser)
+{
+  if (http_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_parser_has_error(http_parser *parser) {
+  return parser->cs == http_parser_error;
+}
+
+int http_parser_is_finished(http_parser *parser) {
+  return parser->cs >= http_parser_first_final;
+}
diff --git a/src/tcp/test/ragel/http11_parser_common.rl b/src/tcp/test/ragel/http11_parser_common.rl
new file mode 100755
index 0000000..108e6fa
--- /dev/null
+++ b/src/tcp/test/ragel/http11_parser_common.rl
@@ -0,0 +1,55 @@
+%%{
+  
+  machine http_parser_common;
+
+#### HTTP PROTOCOL GRAMMAR
+# line endings
+  CRLF = "\r\n";
+
+# character types
+  CTL = (cntrl | 127);
+  safe = ("$" | "-" | "_" | ".");
+  extra = ("!" | "*" | "'" | "(" | ")" | ",");
+  reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+");
+  unsafe = (CTL | " " | "\"" | "#" | "%" | "<" | ">");
+  national = any -- (alpha | digit | reserved | extra | safe | unsafe);
+  unreserved = (alpha | digit | safe | extra | national);
+  escape = ("%" xdigit xdigit);
+  uchar = (unreserved | escape);
+  pchar = (uchar | ":" | "@" | "&" | "=" | "+");
+  tspecials = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" | "\"" | "/" | "[" | "]" | "?" | "=" | "{" | "}" | " " | "\t");
+
+# elements
+  token = (ascii -- (CTL | tspecials));
+
+# URI schemes and absolute paths
+  scheme = ( alpha | digit | "+" | "-" | "." )* ;
+  absolute_uri = (scheme ":" (uchar | reserved )*);
+
+  path = ( pchar+ ( "/" pchar* )* ) ;
+  query = ( uchar | reserved )* %query_string ;
+  param = ( pchar | "/" )* ;
+  params = ( param ( ";" param )* ) ;
+  rel_path = ( path? %request_path (";" params)? ) ("?" %start_query query)?;
+  absolute_path = ( "/"+ rel_path );
+
+  Request_URI = ( "*" | absolute_uri | absolute_path ) >mark %request_uri;
+  Fragment = ( uchar | reserved )* >mark %fragment;
+  Method = ( upper | digit | safe ){1,20} >mark %request_method;
+
+  http_number = ( digit+ "." digit+ ) ;
+  HTTP_Version = ( "HTTP/" http_number ) >mark %http_version ;
+  Request_Line = ( Method " " Request_URI ("#" Fragment){0,1} " " HTTP_Version CRLF ) ;
+
+#field_name = ( token -- ":" )+ >start_field $snake_upcase_field %write_field;
+  field_name = ( token -- ":" )+ >start_field %write_field;
+
+  field_value = any* >start_value %write_value;
+
+  message_header = field_name ":" " "* field_value :> CRLF;
+
+  Request = Request_Line ( message_header )* ( CRLF @done );
+
+main := Request;
+
+}%%
diff --git a/src/tcp/test/ragel/http11_response.c b/src/tcp/test/ragel/http11_response.c
new file mode 100755
index 0000000..7bbc864
--- /dev/null
+++ b/src/tcp/test/ragel/http11_response.c
@@ -0,0 +1,419 @@
+
+#line 1 "http11_response.rl"
+
+#include "http11_response.h"
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+
+#line 59 "http11_response.rl"
+
+
+/** Data **/
+
+#line 25 "http11_response.c"
+static const int http_parser_start = 1;
+static const int http_parser_first_final = 20;
+static const int http_parser_error = 0;
+
+static const int http_parser_en_main = 1;
+
+
+#line 63 "http11_response.rl"
+
+int http_parser_init(http_parser *parser)  {
+  int cs = 0;
+  
+#line 38 "http11_response.c"
+	{
+	cs = http_parser_start;
+	}
+
+#line 67 "http11_response.rl"
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_parser_execute(http_parser *parser, const char *buffer, size_t len, size_t off)  {
+  const char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer+off;
+  pe = buffer+len;
+
+  assert(pe - p == len - off && "pointers aren't same distance");
+
+  
+#line 69 "http11_response.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	if ( (*p) == 72 )
+		goto tr0;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+tr0:
+#line 20 "http11_response.rl"
+	{MARK(mark, p); }
+	goto st2;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+#line 90 "http11_response.c"
+	if ( (*p) == 84 )
+		goto st3;
+	goto st0;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+	if ( (*p) == 84 )
+		goto st4;
+	goto st0;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+	if ( (*p) == 80 )
+		goto st5;
+	goto st0;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+	if ( (*p) == 47 )
+		goto st6;
+	goto st0;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st7;
+	goto st0;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+	if ( (*p) == 46 )
+		goto st8;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st7;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+	if ( (*p) == 32 )
+		goto tr9;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+tr9:
+#line 35 "http11_response.rl"
+	{	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, p));
+  }
+	goto st10;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+#line 158 "http11_response.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr10;
+	goto st0;
+tr10:
+#line 20 "http11_response.rl"
+	{MARK(mark, p); }
+	goto st11;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+#line 170 "http11_response.c"
+	if ( (*p) == 32 )
+		goto tr11;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st11;
+	goto st0;
+tr11:
+#line 40 "http11_response.rl"
+	{
+    if(parser->status_code != NULL)
+      parser->status_code(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st12;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+#line 187 "http11_response.c"
+	if ( (*p) < 11 ) {
+		if ( 0 <= (*p) && (*p) <= 9 )
+			goto tr13;
+	} else if ( (*p) > 12 ) {
+		if ( 14 <= (*p) )
+			goto tr13;
+	} else
+		goto tr13;
+	goto st0;
+tr13:
+#line 20 "http11_response.rl"
+	{MARK(mark, p); }
+	goto st13;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+#line 205 "http11_response.c"
+	if ( (*p) == 13 )
+		goto tr15;
+	if ( (*p) > 9 ) {
+		if ( 11 <= (*p) )
+			goto st13;
+	} else if ( (*p) >= 0 )
+		goto st13;
+	goto st0;
+tr15:
+#line 45 "http11_response.rl"
+	{
+    if(parser->reason_phrase != NULL)
+      parser->reason_phrase(parser->data, PTR_TO(mark), LEN(mark,p));
+  }
+	goto st14;
+tr23:
+#line 27 "http11_response.rl"
+	{ MARK(mark, p); }
+#line 29 "http11_response.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+tr26:
+#line 29 "http11_response.rl"
+	{
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));
+    }
+  }
+	goto st14;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+#line 243 "http11_response.c"
+	if ( (*p) == 10 )
+		goto st15;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	switch( (*p) ) {
+		case 13: goto st16;
+		case 33: goto tr18;
+		case 124: goto tr18;
+		case 126: goto tr18;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto tr18;
+		} else if ( (*p) >= 35 )
+			goto tr18;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto tr18;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto tr18;
+		} else
+			goto tr18;
+	} else
+		goto tr18;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 10 )
+		goto tr19;
+	goto st0;
+tr19:
+#line 50 "http11_response.rl"
+	{ 
+    parser->body_start = p - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, p + 1, pe - p - 1);
+    {p++; cs = 20; goto _out;}
+  }
+	goto st20;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+#line 295 "http11_response.c"
+	goto st0;
+tr18:
+#line 22 "http11_response.rl"
+	{ MARK(field_start, p); }
+	goto st17;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+#line 305 "http11_response.c"
+	switch( (*p) ) {
+		case 33: goto st17;
+		case 58: goto tr21;
+		case 124: goto st17;
+		case 126: goto st17;
+	}
+	if ( (*p) < 45 ) {
+		if ( (*p) > 39 ) {
+			if ( 42 <= (*p) && (*p) <= 43 )
+				goto st17;
+		} else if ( (*p) >= 35 )
+			goto st17;
+	} else if ( (*p) > 46 ) {
+		if ( (*p) < 65 ) {
+			if ( 48 <= (*p) && (*p) <= 57 )
+				goto st17;
+		} else if ( (*p) > 90 ) {
+			if ( 94 <= (*p) && (*p) <= 122 )
+				goto st17;
+		} else
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+tr21:
+#line 23 "http11_response.rl"
+	{ 
+    parser->field_len = LEN(field_start, p);
+  }
+	goto st18;
+tr24:
+#line 27 "http11_response.rl"
+	{ MARK(mark, p); }
+	goto st18;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+#line 344 "http11_response.c"
+	switch( (*p) ) {
+		case 13: goto tr23;
+		case 32: goto tr24;
+	}
+	goto tr22;
+tr22:
+#line 27 "http11_response.rl"
+	{ MARK(mark, p); }
+	goto st19;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+#line 358 "http11_response.c"
+	if ( (*p) == 13 )
+		goto tr26;
+	goto st19;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 92 "http11_response.rl"
+
+  if (!http_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_parser_finish(http_parser *parser)
+{
+  if (http_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_parser_has_error(http_parser *parser) {
+  return parser->cs == http_parser_error;
+}
+
+int http_parser_is_finished(http_parser *parser) {
+  return parser->cs >= http_parser_first_final;
+}
diff --git a/src/tcp/test/ragel/http11_response.h b/src/tcp/test/ragel/http11_response.h
new file mode 100755
index 0000000..9904986
--- /dev/null
+++ b/src/tcp/test/ragel/http11_response.h
@@ -0,0 +1,43 @@
+
+#ifndef http11_parser_h
+#define http11_parser_h
+
+#include <sys/types.h>
+
+#if defined(_WIN32)
+#include <stddef.h>
+#endif
+
+typedef void (*element_cb)(void *data, const char *at, size_t length);
+typedef void (*field_cb)(void *data, const char *field, size_t flen, const char *value, size_t vlen);
+
+typedef struct http_parser { 
+  int cs;
+  size_t body_start;
+  int content_len;
+  size_t nread;
+  size_t mark;
+  size_t field_start;
+  size_t field_len;
+  size_t query_start;
+
+  void *data;
+
+  field_cb http_field;
+
+  element_cb http_version;
+  element_cb status_code;
+  element_cb reason_phrase;
+  element_cb header_done;
+  
+} http_parser;
+
+int http_parser_init(http_parser *parser);
+int http_parser_finish(http_parser *parser);
+size_t http_parser_execute(http_parser *parser, const char *data, size_t len, size_t off);
+int http_parser_has_error(http_parser *parser);
+int http_parser_is_finished(http_parser *parser);
+
+#define http_parser_nread(parser) (parser)->nread 
+
+#endif
diff --git a/src/tcp/test/ragel/http11_response.rl b/src/tcp/test/ragel/http11_response.rl
new file mode 100755
index 0000000..3e99bc4
--- /dev/null
+++ b/src/tcp/test/ragel/http11_response.rl
@@ -0,0 +1,124 @@
+
+#include "http11_response.h"
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+
+#define LEN(AT, FPC) (FPC - buffer - parser->AT)
+#define MARK(M,FPC) (parser->M = (FPC) - buffer)
+#define PTR_TO(F) (buffer + parser->F)
+
+/** Machine **/
+
+%%{
+  
+  machine http_parser;
+
+  action mark {MARK(mark, fpc); }
+
+  action start_field { MARK(field_start, fpc); }
+  action write_field { 
+    parser->field_len = LEN(field_start, fpc);
+  }
+
+  action start_value { MARK(mark, fpc); }
+
+  action write_value {
+    if(parser->http_field != NULL) {
+      parser->http_field(parser->data, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, fpc));
+    }
+  }
+
+  action http_version {	
+    if(parser->http_version != NULL)
+      parser->http_version(parser->data, PTR_TO(mark), LEN(mark, fpc));
+  }
+
+  action status_code {
+    if(parser->status_code != NULL)
+      parser->status_code(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action reason_phrase {
+    if(parser->reason_phrase != NULL)
+      parser->reason_phrase(parser->data, PTR_TO(mark), LEN(mark,fpc));
+  }
+
+  action done { 
+    parser->body_start = fpc - buffer + 1; 
+    if(parser->header_done != NULL)
+      parser->header_done(parser->data, fpc + 1, pe - fpc - 1);
+    fbreak;
+  }
+
+  include http_response_common "http11_response_common.rl";
+
+}%%
+
+/** Data **/
+%% write data;
+
+int http_parser_init(http_parser *parser)  {
+  int cs = 0;
+  %% write init;
+  parser->cs = cs;
+  parser->body_start = 0;
+  parser->content_len = 0;
+  parser->mark = 0;
+  parser->nread = 0;
+  parser->field_len = 0;
+  parser->field_start = 0;    
+
+  return(1);
+}
+
+
+/** exec **/
+size_t http_parser_execute(http_parser *parser, const char *buffer, size_t len, size_t off)  {
+  const char *p, *pe;
+  int cs = parser->cs;
+
+  assert(off <= len && "offset past end of buffer");
+
+  p = buffer+off;
+  pe = buffer+len;
+
+  assert(pe - p == len - off && "pointers aren't same distance");
+
+  %% write exec;
+
+  if (!http_parser_has_error(parser))
+    parser->cs = cs;
+  parser->nread += p - (buffer + off);
+
+  assert(p <= pe && "buffer overflow after parsing execute");
+  assert(parser->nread <= len && "nread longer than length");
+  assert(parser->body_start <= len && "body starts after buffer end");
+  assert(parser->mark < len && "mark is after buffer end");
+  assert(parser->field_len <= len && "field has length longer than whole buffer");
+  assert(parser->field_start < len && "field starts after buffer end");
+
+  return(parser->nread);
+}
+
+int http_parser_finish(http_parser *parser)
+{
+  if (http_parser_has_error(parser) ) {
+    return -1;
+  } else if (http_parser_is_finished(parser) ) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+int http_parser_has_error(http_parser *parser) {
+  return parser->cs == http_parser_error;
+}
+
+int http_parser_is_finished(http_parser *parser) {
+  return parser->cs >= http_parser_first_final;
+}
diff --git a/src/tcp/test/ragel/http11_response_common.rl b/src/tcp/test/ragel/http11_response_common.rl
new file mode 100755
index 0000000..cbee06d
--- /dev/null
+++ b/src/tcp/test/ragel/http11_response_common.rl
@@ -0,0 +1,35 @@
+%%{
+  
+  machine http_response_common;
+
+#### HTTP PROTOCOL GRAMMAR
+# line endings
+  CRLF = "\r\n";
+
+# character types
+  CTL = (cntrl | 127);
+  tspecials = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" | "\"" | "/" | "[" | "]" | "?" | "=" | "{" | "}" | " " | "\t");
+
+# elements
+  token = (ascii -- (CTL | tspecials));
+
+  Reason_Phrase = ( ascii -- ("\r" | "\n") )+ >mark %reason_phrase;
+
+  Status_Code = ( digit+ ) >mark %status_code ;
+
+  http_number = ( digit+ "." digit+ ) ;
+  HTTP_Version = ( "HTTP/" http_number ) >mark %http_version ;
+
+  Response_Line = ( HTTP_Version " " Status_Code " " Reason_Phrase CRLF ) ;
+
+  field_name = ( token -- ":" )+ >start_field %write_field;
+
+  field_value = any* >start_value %write_value;
+
+  message_header = field_name ":" " "* field_value :> CRLF;
+
+  Response = Response_Line ( message_header )* ( CRLF @done );
+
+main := Response;
+
+}%%
diff --git a/src/tcp/test/ragel/ragel_http_client.c b/src/tcp/test/ragel/ragel_http_client.c
new file mode 100755
index 0000000..566775f
--- /dev/null
+++ b/src/tcp/test/ragel/ragel_http_client.c
@@ -0,0 +1,115 @@
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include "http11_response.h"
+#include <ctype.h>
+
+#define BUFF_LEN 4096
+
+void http_field(void *data, const char *field, 
+        size_t flen, const char *value, size_t vlen)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, field, flen);
+    strcat(buff, ": ");
+    strncat(buff, value, vlen);
+
+    printf("HEADER: \"%s\"\n", buff);
+}
+
+void http_version(void *data, const char *at, size_t length)
+{
+    printf("VERSION: \"%.*s\"\n", length, at);
+}
+
+void status_code(void *data, const char *at, size_t length)
+{
+    printf("STATUS_CODE: \"%.*s\"\n", length, at);
+}
+
+void reason_phrase(void *data, const char *at, size_t length)
+{
+    printf("REASON_PHRASE: \"%.*s\"\n", length, at);
+}
+
+void header_done(void *data, const char *at, size_t length)
+{
+    printf("HEADER_DONE.\n");
+}
+
+void parser_init(http_parser *hp) 
+{
+    hp->http_field = http_field;
+    hp->http_version = http_version;
+    hp->status_code = status_code;
+    hp->reason_phrase = reason_phrase;
+    hp->header_done = header_done;
+    http_parser_init(hp);
+}
+
+int main1 ()
+{
+    char *data = "HTTP/1.0 200 OK\r\n"
+        "Server: nginx\r\n"
+        "Date: Fri, 26 Mar 2010 03:39:03 GMT\r\n"
+        "Content-Type: text/html; charset=GBK\r\n"
+        "Vary: Accept-Encoding\r\n"
+        "Expires: Fri, 26 Mar 2010 03:40:23 GMT\r\n"
+        "Cache-Control: max-age=80\r\n"
+        "Vary: User-Agent\r\n"
+        "Vary: Accept\r\n"
+        "X-Cache: MISS from cache.163.com\r\n"
+        "Connection: close\r\n"
+        "\r\n"
+        "I am the body"
+        ;
+    size_t dlen;
+    http_parser parser, *hp;
+
+    hp = &parser;
+    dlen = strlen(data);
+
+    parser_init(hp);
+
+    http_parser_execute(hp, data, dlen, 0);
+
+    return 0;
+}
+
+int main ()
+{
+    char *data = "HTTP/1.0 200 OK\r\n"
+        "Server: nginx\r\n"
+        "Date: Fri, 26 Mar 2010 03:39:03 GMT\r\n"
+        "Content-Type: text/html; charset=GBK\r\n"
+        "Vary: Accept-Encoding\r\n"
+        "Expires: Fri, 26 Mar 2010 03:40:23 GMT\r\n"
+        "Cache-Control: max-age=80\r\n"
+        "Vary: User-Agent\r\n"
+        "Vary: Accept\r\n"
+        "X-Cache: MISS from cache.163.com\r\n"
+        "Connection: close\r\n"
+        "\r\n"
+        "I am the body"
+        ;
+
+
+    size_t dlen, dlen1;
+    http_parser parser, *hp;
+    int i;
+
+    hp = &parser;
+    dlen = strlen(data);
+
+    for (i = 1;i < dlen;i++) {
+        printf("\n\nblock point: %d\n", i);
+        parser_init(hp);
+        dlen1 = http_parser_execute(hp, data, i, 0);
+        dlen1 = http_parser_execute(hp, data, dlen, dlen1);
+        printf("BODY: \"%s\"\n", data + hp->body_start);
+    }
+
+    return 0;
+}
diff --git a/src/tcp/test/ragel/ragel_http_server.c b/src/tcp/test/ragel/ragel_http_server.c
new file mode 100755
index 0000000..c861074
--- /dev/null
+++ b/src/tcp/test/ragel/ragel_http_server.c
@@ -0,0 +1,139 @@
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include "http11_parser.h"
+#include <ctype.h>
+
+#define BUFF_LEN 4096
+
+void http_field(void *data, const char *field, 
+        size_t flen, const char *value, size_t vlen)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, field, flen);
+    strcat(buff, ": ");
+    strncat(buff, value, vlen);
+
+    printf("HEADER: \"%s\"\n", buff);
+}
+
+void request_method(void *data, const char *at, size_t length)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, at, length);
+
+    printf("METHOD: \"%s\"\n", buff);
+}
+
+void request_uri(void *data, const char *at, size_t length)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, at, length);
+
+    printf("URI: \"%s\"\n", buff);
+}
+
+void fragment(void *data, const char *at, size_t length)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, at, length);
+
+    printf("FRAGMENT: \"%s\"\n", buff);
+}
+
+void request_path(void *data, const char *at, size_t length)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, at, length);
+
+    printf("PATH: \"%s\"\n", buff);
+}
+
+void query_string(void *data, const char *at, size_t length)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, at, length);
+
+    printf("QUERY: \"%s\"\n", buff);
+}
+
+void http_version(void *data, const char *at, size_t length)
+{
+    char buff[BUFF_LEN] = {0};
+
+    strncpy(buff, at, length);
+
+    printf("VERSION: \"%s\"\n", buff);
+}
+
+void header_done(void *data, const char *at, size_t length)
+{
+    printf("done.\n");
+}
+
+void parser_init(http_parser *hp) 
+{
+    hp->http_field = http_field;
+    hp->request_method = request_method;
+    hp->request_uri = request_uri;
+    hp->fragment = fragment;
+    hp->request_path = request_path;
+    hp->query_string = query_string;
+    hp->http_version = http_version;
+    hp->header_done = header_done;
+    http_parser_init(hp);
+}
+
+int main1 ()
+{
+    char *data = "GET / HTTP/1.0\r\n" 
+        "User-Agent: Wget/1.11.4\r\n" 
+        "Accept: */*\r\n"
+        "Host: www.163.com\r\n"
+        "Connection: Keep-Alive\r\n"
+        "\r\n";
+    size_t dlen;
+    http_parser parser, *hp;
+
+    hp = &parser;
+    dlen = strlen(data);
+
+    parser_init(hp);
+
+    http_parser_execute(hp, data, dlen, 0);
+
+    return 0;
+}
+
+int main ()
+{
+    char *data = "GET / HTTP/1.0\r\n" 
+        "User-Agent: Wget/1.11.4\r\n" 
+        "Accept: */*\r\n"
+        "Host: www.163.com\r\n"
+        "Connection: Keep-Alive\r\n"
+        "\r\n";
+
+
+    size_t dlen, dlen1;
+    http_parser parser, *hp;
+    int i;
+
+    hp = &parser;
+    dlen = strlen(data);
+
+    for (i = 1;i < dlen;i++) {
+        parser_init(hp);
+        dlen1 = http_parser_execute(hp, data, i, 0);
+        dlen1 = http_parser_execute(hp, data, dlen, dlen1);
+    }
+
+    return 0;
+}
diff --git a/src/tcp/test/t/acl.t b/src/tcp/test/t/acl.t
new file mode 100755
index 0000000..b9575b2
--- /dev/null
+++ b/src/tcp/test/t/acl.t
@@ -0,0 +1,84 @@
+#
+#===============================================================================
+#
+#         FILE:  acl.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: test ACL
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        deny 127.0.0.1;
+
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- error_code: 500
+--- response_body_like: ^.*$
+
+=== TEST 2: test ACL without anything
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^.*$
+
+=== TEST 3: test ACL witht other ip
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        deny 10.231.143.122;
+        listen 1984;
+
+        server_name _;
+
+        tcp_nodelay on;
+        so_keepalive on;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^.*$
diff --git a/src/tcp/test/t/http_check.t b/src/tcp/test/t/http_check.t
new file mode 100755
index 0000000..78db42b
--- /dev/null
+++ b/src/tcp/test/t/http_check.t
@@ -0,0 +1,83 @@
+#
+#===============================================================================
+#
+#         FILE:  http_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the http_check test
+--- config
+    upstream test{
+        server blog.163.com;
+
+        check interval=3000 rise=1 fall=5 timeout=1000 type=http;
+        check_http_send "GET /test HTTP/1.0\r\n\r\n";
+        check_http_expect_alive http_2xx http_3xx http_4xx;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 2: the http_check test without check
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 3: the http_check which use the raw name 
+--- config
+    upstream test{
+        server blog.163.com;
+
+        check interval=3000 rise=1 fall=5 timeout=1000 type=http;
+        check_http_send "GET /test HTTP/1.0\r\n\r\n";
+        check_http_expect_alive http_2xx http_3xx http_4xx;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass blog.163.com;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
diff --git a/src/tcp/test/t/imap_check.t b/src/tcp/test/t/imap_check.t
new file mode 100755
index 0000000..6d23ad0
--- /dev/null
+++ b/src/tcp/test/t/imap_check.t
@@ -0,0 +1,47 @@
+#
+#===============================================================================
+#
+#         FILE:  imap_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the imap_check
+--- config
+    upstream test{
+        server imap.163.com:143;
+
+        check interval=3000 rise=1 fall=5 timeout=1000 type=imap;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^(.*)$
diff --git a/src/tcp/test/t/mysql_check.t b/src/tcp/test/t/mysql_check.t
new file mode 100755
index 0000000..43a2a7a
--- /dev/null
+++ b/src/tcp/test/t/mysql_check.t
@@ -0,0 +1,48 @@
+#
+#===============================================================================
+#
+#         FILE:  mysql_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the mysql_check
+--- config
+    upstream test{
+        server 127.0.0.1:3306;
+
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000 type=mysql;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^(.*)$
diff --git a/src/tcp/test/t/pop3_check.t b/src/tcp/test/t/pop3_check.t
new file mode 100755
index 0000000..172e42b
--- /dev/null
+++ b/src/tcp/test/t/pop3_check.t
@@ -0,0 +1,48 @@
+#
+#===============================================================================
+#
+#         FILE:  pop3_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the pop3_check
+--- config
+    upstream test{
+        server pop3.163.com:110;
+
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000 type=pop3;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^(.*)$
diff --git a/src/tcp/test/t/smtp_check.t b/src/tcp/test/t/smtp_check.t
new file mode 100755
index 0000000..5e1b2ac
--- /dev/null
+++ b/src/tcp/test/t/smtp_check.t
@@ -0,0 +1,50 @@
+#
+#===============================================================================
+#
+#         FILE:  smtp_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the smtp_check
+--- config
+    upstream test{
+    #server 127.0.0.1:25;
+    server smtp.163.com:25;
+
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000 type=smtp;
+        check_smtp_send "HELO localhost\r\n";
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^2(.*)$
diff --git a/src/tcp/test/t/ssl.t b/src/tcp/test/t/ssl.t
new file mode 100755
index 0000000..45a6739
--- /dev/null
+++ b/src/tcp/test/t/ssl.t
@@ -0,0 +1,117 @@
+#
+#===============================================================================
+#
+#         FILE:  sample.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the ssl command
+--- config
+    upstream test{
+        server blog.163.com;
+        ip_hash;
+    }
+
+    server {
+        listen 1984 ssl;
+
+        proxy_pass test;
+    }
+--- request_https
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 2: the ssl command with websocket
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984 ssl;
+
+        websocket_pass test;
+    }
+--- request_https
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 3: the ssl command with websocket
+
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984 ssl;
+
+        ssl_session_cache builtin:1000 shared:SSL:5m;
+
+        websocket_pass test;
+    }
+--- request_https
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 4: the ssl command with ssl on
+
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984;
+
+        ssl on;
+        ssl_session_cache builtin:1000 shared:SSL:5m;
+
+        websocket_pass test;
+    }
+--- request_https
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 5: the ssl command with ssl on and listen ssl
+
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984 ssl;
+
+        ssl on;
+        ssl_session_cache builtin:1000 shared:SSL:5m;
+
+        websocket_pass test;
+    }
+--- request_https
+GET /
+--- response_body_like: ^<(.*)>$
diff --git a/src/tcp/test/t/ssl_hello_check.t b/src/tcp/test/t/ssl_hello_check.t
new file mode 100755
index 0000000..aa4b4ec
--- /dev/null
+++ b/src/tcp/test/t/ssl_hello_check.t
@@ -0,0 +1,48 @@
+#
+#===============================================================================
+#
+#         FILE:  ssl_hello_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the ssl_hello_check test
+--- config
+    upstream test{
+        server www.varnish-cache.org:443;
+
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000 type=ssl_hello;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request_https
+GET /
+--- response_body_like: ^.*$
diff --git a/src/tcp/test/t/tcp_check.t b/src/tcp/test/t/tcp_check.t
new file mode 100755
index 0000000..8863d29
--- /dev/null
+++ b/src/tcp/test/t/tcp_check.t
@@ -0,0 +1,80 @@
+#
+#===============================================================================
+#
+#         FILE:  tcp_check.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the tcp_check test
+--- config
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+
+        protocol tcp_generic;
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 2: the round robin test without check
+--- config
+    upstream test{
+        server blog.163.com;
+    }
+
+    server {
+        listen 1984;
+        #server_names a.b.c d.e.f;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 3: the ip_hash test without check
+--- config
+    upstream test{
+        server blog.163.com;
+        ip_hash;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
diff --git a/src/tcp/test/t/upstream_busyness.t b/src/tcp/test/t/upstream_busyness.t
new file mode 100755
index 0000000..ca87d21
--- /dev/null
+++ b/src/tcp/test/t/upstream_busyness.t
@@ -0,0 +1,64 @@
+#
+#===============================================================================
+#
+#         FILE:  sample.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the upstream_busyness command
+--- config
+    upstream test{
+        server blog.163.com;
+        busyness;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 2: the upstream_busyness command with check
+--- config
+    upstream test{
+        server blog.163.com;
+
+        check interval=3000 rise=1 fall=5 timeout=1000;
+        busyness;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
diff --git a/src/tcp/test/t/upstream_ip_hash.t b/src/tcp/test/t/upstream_ip_hash.t
new file mode 100755
index 0000000..8a98985
--- /dev/null
+++ b/src/tcp/test/t/upstream_ip_hash.t
@@ -0,0 +1,64 @@
+#
+#===============================================================================
+#
+#         FILE:  sample.t
+#
+#  DESCRIPTION: test 
+#
+#        FILES:  ---
+#         BUGS:  ---
+#        NOTES:  ---
+#       AUTHOR:  Weibin Yao (http://yaoweibin.cn/), yaoweibin@gmail.com
+#      COMPANY:  
+#      VERSION:  1.0
+#      CREATED:  03/02/2010 03:18:28 PM
+#     REVISION:  ---
+#===============================================================================
+
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: the upstream_ip_hash command
+--- config
+    upstream test{
+        server blog.163.com;
+        ip_hash;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 2: the upstream_ip_hash command with check
+--- config
+    upstream test{
+        server blog.163.com;
+
+        check interval=2000;
+        ip_hash;
+    }
+
+    server {
+        listen 1984;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
diff --git a/src/tcp/test/t/websocket.t b/src/tcp/test/t/websocket.t
new file mode 100755
index 0000000..7d308e1
--- /dev/null
+++ b/src/tcp/test/t/websocket.t
@@ -0,0 +1,251 @@
+
+# vi:filetype=perl
+
+use lib 'lib';
+use Test::Nginx::LWP;
+
+plan tests => repeat_each() * 2 * blocks();
+
+#no_diff;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: test the default
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        proxy_pass bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        proxy_pass test;
+    }
+--- request
+GET /
+--- response_body_like: ^<(.*)>$
+
+=== TEST 2: test the server_name
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        websocket_pass bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        websocket_pass test;
+    }
+--- request_headers
+Host: foo.barzzzz.com
+--- request
+GET /
+--- error_code: 500
+--- response_body_like: ^.*$
+
+=== TEST 3: test the default server_name
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        websocket_pass ws://bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        websocket_pass ws://test;
+    }
+--- request_headers
+Host: foo.barzzzzoo.com
+--- request
+GET /
+--- response_body_like: ^.*$
+
+=== TEST 4: test the default path
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        websocket_pass bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        websocket_pass test;
+        websocket_pass /bad bad_server;
+        websocket_pass /public test;
+    }
+--- request
+GET /404
+--- error_code: 404
+--- response_body_like: ^.*$
+
+=== TEST 5: test the bad path
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        websocket_pass bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        websocket_pass test;
+        websocket_pass /bad bad_server;
+        websocket_pass /public test;
+    }
+--- request
+GET /bad
+--- error_code: 500
+--- response_body_like: ^.*$
+
+=== TEST 6: test the good path
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        websocket_pass bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        websocket_pass test;
+        websocket_pass /bad bad_server;
+        websocket_pass /public test;
+    }
+--- request_headers
+Host: blog.163.com
+--- request
+GET /public/theme
+--- error_code: 200
+--- response_body_like: ^.*$
+
+=== TEST 7: test the unknow path
+--- config
+ 
+    upstream bad_server{
+       #unknown server
+       server 127.0.0.1:5678;
+    }
+
+    upstream test{
+        server blog.163.com;
+        #ip_hash;
+        check interval=3000 rise=1 fall=5 timeout=1000;
+    }
+
+    server {
+        listen 1984;
+        server_name foo.barzzzz.com;
+
+        websocket_pass bad_server;
+    }
+
+    server {
+        listen 1984 default;
+        server_name blog.163.com;
+
+        websocket_pass / bad_server;
+        websocket_pass /bad bad_server;
+        websocket_pass /public test;
+    }
+--- request_headers
+Host: blog.163.com
+--- request
+GET /hoho
+--- error_code: 500
+--- response_body_like: ^.*$
diff --git a/src/tcp/test/websocket/server.rb b/src/tcp/test/websocket/server.rb
new file mode 100755
index 0000000..c326b83
--- /dev/null
+++ b/src/tcp/test/websocket/server.rb
@@ -0,0 +1,20 @@
+require 'em-websocket'
+
+EventMachine.run {
+
+  EventMachine::WebSocket.start(:host => "0.0.0.0", :port => 2000) do |ws|
+    ws.onopen {
+      puts "WebSocket connection open"
+
+      # publish message to the client
+      ws.send "Hello Client"
+    }
+
+    ws.onclose { puts "Connection closed" }
+    ws.onmessage { |msg|
+      puts "Recieved message: #{msg}"
+      ws.send "Pong: #{msg}"
+    }
+  end
+
+}
diff --git a/src/tcp/util/wiki2pod.pl b/src/tcp/util/wiki2pod.pl
new file mode 100755
index 0000000..cdd33a2
--- /dev/null
+++ b/src/tcp/util/wiki2pod.pl
@@ -0,0 +1,131 @@
+#!/usr/bin/env perl
+
+use strict;
+use warnings;
+use bytes;
+
+my @nl_counts;
+my $last_nl_count_level;
+
+my @bl_counts;
+my $last_bl_count_level;
+
+sub fmt_pos ($) {
+    (my $s = $_[0]) =~ s{\#(.*)}{/"$1"};
+    $s;
+}
+
+sub fmt_mark ($$) {
+    my ($tag, $s) = @_;
+    my $max_level = 0;
+    while ($s =~ /([<>])\1*/g) {
+        my $level = length $&;
+        if ($level > $max_level) {
+            $max_level = $level;
+        }
+    }
+
+    my $times = $max_level + 1;
+    if ($times > 1) {
+        $s = " $s ";
+    }
+    return $tag . ('<' x $times) . $s . ('>' x $times);
+}
+
+print "=encoding utf-8\n\n";
+
+while (<>) {
+    if ($. == 1) {
+        # strip the leading U+FEFF byte in MS-DOS text files
+        my $first = ord(substr($_, 0, 1));
+        #printf STDERR "0x%x", $first;
+        #my $second = ord(substr($_, 2, 1));
+        #printf STDERR "0x%x", $second;
+        if ($first == 0xEF) {
+            substr($_, 0, 1, '');
+            #warn "Hit!";
+        }
+    }
+    s{\[(http[^ \]]+) ([^\]]*)\]}{$2 (L<$1>)}gi;
+    s{ \[\[ ( [^\]\|]+ ) \| ([^\]]*) \]\] }{"L<$2|" . fmt_pos($1) . ">"}gixe;
+    s{<code>(.*?)</code>}{fmt_mark('C', $1)}gie;
+    s{'''(.*?)'''}{fmt_mark('B', $1)}ge;
+    s{''(.*?)''}{fmt_mark('I', $1)}ge;
+    if (s{^\s*<[^>]+>\s*$}{}) {
+        next;
+    }
+
+    if (/^\s*$/) {
+        print "\n";
+        next;
+    }
+
+=begin cmt
+
+    if ($. == 1) {
+        warn $_;
+        for my $i (0..length($_) - 1) {
+            my $chr = substr($_, $i, 1);
+            warn "chr ord($i): ".ord($chr)." \"$chr\"\n";
+        }
+    }
+
+=end cmt
+=cut
+
+    if (/(=+) (.*) \1$/) {
+        #warn "HERE! $_" if $. == 1;
+        my ($level, $title) = (length $1, $2);
+        collapse_lists();
+
+        print "\n=head$level $title\n\n";
+    } elsif (/^(\#+) (.*)/) {
+        my ($level, $txt) = (length($1) - 1, $2);
+        if (defined $last_nl_count_level && $level != $last_nl_count_level) {
+            print "\n=back\n\n";
+        }
+        $last_nl_count_level = $level;
+        $nl_counts[$level] ||= 0;
+        if ($nl_counts[$level] == 0) {
+            print "\n=over\n\n";
+        }
+        $nl_counts[$level]++;
+        print "\n=item $nl_counts[$level].\n\n";
+        print "$txt\n";
+    } elsif (/^(\*+) (.*)/) {
+        my ($level, $txt) = (length($1) - 1, $2);
+        if (defined $last_bl_count_level && $level != $last_bl_count_level) {
+            print "\n=back\n\n";
+        }
+        $last_bl_count_level = $level;
+        $bl_counts[$level] ||= 0;
+        if ($bl_counts[$level] == 0) {
+            print "\n=over\n\n";
+        }
+        $bl_counts[$level]++;
+        print "\n=item *\n\n";
+        print "$txt\n";
+    } else {
+        collapse_lists();
+        print;
+    }
+}
+
+collapse_lists();
+
+sub collapse_lists {
+    while (defined $last_nl_count_level && $last_nl_count_level >= 0) {
+        print "\n=back\n\n";
+        $last_nl_count_level--;
+    }
+    undef $last_nl_count_level;
+    undef @nl_counts;
+
+    while (defined $last_bl_count_level && $last_bl_count_level >= 0) {
+        print "\n=back\n\n";
+        $last_bl_count_level--;
+    }
+    undef $last_bl_count_level;
+    undef @bl_counts;
+}
+
