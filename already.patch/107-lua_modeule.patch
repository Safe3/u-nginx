diff -rNu a/src/lua/lua-nginx-module/Changes b/src/lua/lua-nginx-module/Changes
--- a/src/lua/lua-nginx-module/Changes	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/Changes	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,51 @@
+0.2.0 - 5 July 2011
+* now we support ngx.var[1], ngx.var[2], and etc to refer to the nginx regex capturing variables \$1, \$2, and etc in Lua. this resolved github issue #43. thanks Tobia Conforto for reporting it.
+
+* now we use the same value overriding mechanism as ngx_rewrite's set command for ngx.var.VAR = new_value. Assigning values to special variables like $limit_rate and $args should now work; also writing to built-in variables that are not changeable (like $arg_PARAMETER) will result in a 500 error page, as expected, now. thanks Richard Kearsley for reporting it.
+
+* fixed the lua_code_cache off warning when the lua_code_cache is explicitly on. thanks Feng Xingguo.
+
+* applied the patch from cyberty to add ngx.http_time() function to expose the nginx core function ngx_http_time to the Lua land.
+
+* fixed an issue on i386: we now use off_t consistently. mixing it with size_t on 32-bit systems can cause Bad Things. this fixed github issue #42. thanks moodydeath.
+
+* fixed an issue on i386: fixed a formatter mismatch issue in ngx_http_echo_adjust_subrequest. thanks Wang Bin. This caused incorrect subrequest Content-Length header when a body is specified.
+
+* now in the subrequest capturing processor, we worked around an issue in ngx_http_static_module that when it issues 301 redirect for directory access w/o a trailing slash, it does not inject r->headers_out.location into the r->headers_out.headers list. thanks moodydeath for reporting it in the discussion of github issue #41.
+
+* fixed a bug in ngx.location.capture() and ngx.location.capture_multi() that we could not capture locations with internal redirections in them. thanks moodydeath for reporting it in github issue #41.
+
+* fixed redundant last chunk issue for ngx.exec() invocation at rewrite and access phases: we should quit the current core_run_phases cycle; this also fixed github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location.
+
+* fixed ngx.exit(status) where status >= 200 and status < 300 for access_by_lua* and rewrite_by_lua*: it should quit the whole request altegother and skip all those subsequent phase handlers (if any). thanks moodydeath for reporting it.
+
+* fixed github issue #39: setting differnt response headers in Lua with common prefix might interfere with each other. thanks moodydeath.
+
+* fixed GitHub issue #38: request headers did not forward to subrequests when the "method" or "body" option is explicitly specified by a non-nil value for ngx.location.capture(). thanks Richard Kearsley.
+
+* fixed a bug in output header set; we should always set the header->hash to 1. thanks moodydeath for reporting it.
+
+* fixed spots that trigger the "variable set but not used" warning issued by gcc 4.6.0.
+
+* now we turn the ngx.req.header table into an ngx.req.get_headers() function; we also added ngx.req.set_header(name, value) and ngx.req.clear_header(name). thanks moodydeath.
+
+* now we make ngx_devel_kit (NDK) optional. thanks Kirill A. Korinskiy.
+
+* removed a duplicate definition of the ngx_str_set macro caught by ctags; also fixed a warning thrown by gcc -O3 on Mac OS X 10.6.
+
+* added patch to use PCRE related Lua extensions in ngx_lua (chaoslawful)
+
+* now we change the way we process HTTP 1.0 requests by automatically buffering all the user outputs generated by ngx.print()/ngx.say() calls, which is much more natural than the old broken way.
+
+* fixed the "ngx.exec() after ngx.location.capture() hanging" bug for rewrite_by_lua* and access_by_lua* as well. thanks Wendal Chen.
+
+* applied a patch from moodydeath to introduce the "ngx.is_subrequest" attribute.
+
+* now we encourage use of the client_body_in_single_buffer directive instead of big client_body_buffer_size when lua_need_request_body is turned on.
+
+* fixed the config script and added extra linking options needed by LuaJIT in 64-bit Mac OS X.
+
+* fixed the zero size alert caused by ngx.print("") in Lua.
+
+* now we always allocate r->request_body for subrequests when the method option is specified for ngx.location.capture*. this prevents accidental inheritance of parent request's request body when client_body_buffer_size < client_max_body_size.
+
diff -rNu a/src/lua/lua-nginx-module/config b/src/lua/lua-nginx-module/config
--- a/src/lua/lua-nginx-module/config	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/config	2013-10-22 16:41:30.878531068 +0800
@@ -0,0 +1,202 @@
+ngx_feature="Lua library"
+ngx_feature_libs="-llua -lm"
+ngx_feature_name=
+ngx_feature_run=no
+ngx_feature_incs="#include <lauxlib.h>"
+ngx_feature_path=
+ngx_feature_test="(void) luaL_newstate();"
+
+if [ -n "$LUAJIT_INC" -o -n "$LUAJIT_LIB" ]; then
+    # explicitly set Lua lib path
+    ngx_feature="LuaJIT library in $LUAJIT_LIB and $LUAJIT_INC (specified by the LUAJIT_LIB and LUAJIT_INC env)"
+    ngx_feature_path="$LUAJIT_INC"
+    if [ $NGX_RPATH = YES ]; then
+        ngx_feature_libs="-R$LUAJIT_LIB -L$LUAJIT_LIB -lluajit-5.1 -lm"
+    else
+        ngx_feature_libs="-L$LUAJIT_LIB -lluajit-5.1 -lm"
+    fi
+
+    . auto/feature
+
+
+    case "$NGX_PLATFORM" in
+        Darwin:*)
+            case "$NGX_MACHINE" in
+                amd64 | x86_64 | i386)
+                    echo "adding extra linking options needed by LuaJIT"
+                    ngx_feature_libs="$ngx_feature_libs -pagezero_size 10000 -image_base 100000000"
+                ;;
+
+                *)
+                ;;
+            esac
+        ;;
+
+        *)
+        ;;
+    esac
+else
+    if [ -n "$LUA_INC" -o -n "$LUA_LIB" ]; then
+        # explicitly set Lua lib path
+        ngx_feature="Lua library in $LUA_LIB and $LUA_INC (specified by the LUA_LIB and LUA_INC env)"
+        ngx_feature_path="$LUA_INC"
+        if [ $NGX_RPATH = YES ]; then
+            ngx_feature_libs="-R$LUA_LIB -L$LUA_LIB -llua -lm"
+        else
+            ngx_feature_libs="-L$LUA_LIB -llua -lm"
+        fi
+
+        . auto/feature
+
+    else
+        # auto-discovery
+        ngx_feature="Lua library"
+        ngx_feature_libs="-llua -lm"
+        . auto/feature
+
+    fi
+fi
+
+    CORE_INCS="$CORE_INCS $ngx_feature_path"
+    CORE_LIBS="$CORE_LIBS $ngx_feature_libs"
+
+ngx_addon_name=ngx_http_lua_module
+HTTP_AUX_FILTER_MODULES="$HTTP_AUX_FILTER_MODULES ngx_http_lua_module"
+NGX_ADDON_SRCS="$NGX_ADDON_SRCS \
+                $ngx_addon_dir/src/ngx_http_lua_script.c \
+                $ngx_addon_dir/src/ngx_http_lua_log.c \
+                $ngx_addon_dir/src/ngx_http_lua_subrequest.c \
+                $ngx_addon_dir/src/ngx_http_lua_ndk.c \
+                $ngx_addon_dir/src/ngx_http_lua_control.c \
+                $ngx_addon_dir/src/ngx_http_lua_time.c \
+                $ngx_addon_dir/src/ngx_http_lua_misc.c \
+                $ngx_addon_dir/src/ngx_http_lua_variable.c \
+                $ngx_addon_dir/src/ngx_http_lua_string.c \
+                $ngx_addon_dir/src/ngx_http_lua_output.c \
+                $ngx_addon_dir/src/ngx_http_lua_headers.c \
+                $ngx_addon_dir/src/ngx_http_lua_req_body.c \
+                $ngx_addon_dir/src/ngx_http_lua_uri.c \
+                $ngx_addon_dir/src/ngx_http_lua_args.c \
+                $ngx_addon_dir/src/ngx_http_lua_ctx.c \
+                $ngx_addon_dir/src/ngx_http_lua_regex.c \
+                $ngx_addon_dir/src/ngx_http_lua_module.c \
+                $ngx_addon_dir/src/ngx_http_lua_headers_out.c \
+                $ngx_addon_dir/src/ngx_http_lua_headers_in.c \
+                $ngx_addon_dir/src/ngx_http_lua_directive.c \
+                $ngx_addon_dir/src/ngx_http_lua_consts.c \
+                $ngx_addon_dir/src/ngx_http_lua_exception.c \
+                $ngx_addon_dir/src/ngx_http_lua_util.c \
+                $ngx_addon_dir/src/ngx_http_lua_cache.c \
+                $ngx_addon_dir/src/ngx_http_lua_contentby.c \
+                $ngx_addon_dir/src/ngx_http_lua_rewriteby.c \
+                $ngx_addon_dir/src/ngx_http_lua_accessby.c \
+                $ngx_addon_dir/src/ngx_http_lua_setby.c \
+                $ngx_addon_dir/src/ngx_http_lua_capturefilter.c \
+                $ngx_addon_dir/src/ngx_http_lua_clfactory.c \
+                $ngx_addon_dir/src/ngx_http_lua_pcrefix.c \
+                $ngx_addon_dir/src/ngx_http_lua_headerfilterby.c \
+                $ngx_addon_dir/src/ngx_http_lua_shdict.c \
+                $ngx_addon_dir/src/ngx_http_lua_socket_tcp.c \
+                $ngx_addon_dir/src/ngx_http_lua_api.c \
+                $ngx_addon_dir/src/ngx_http_lua_logby.c \
+                $ngx_addon_dir/src/ngx_http_lua_sleep.c \
+                $ngx_addon_dir/src/ngx_http_lua_coroutine.c \
+                $ngx_addon_dir/src/ngx_http_lua_bodyfilterby.c \
+                $ngx_addon_dir/src/ngx_http_lua_initby.c \
+                $ngx_addon_dir/src/ngx_http_lua_socket_udp.c \
+                $ngx_addon_dir/src/ngx_http_lua_req_method.c \
+                $ngx_addon_dir/src/ngx_http_lua_phase.c \
+                $ngx_addon_dir/src/ngx_http_lua_uthread.c \
+                $ngx_addon_dir/src/ngx_http_lua_timer.c \
+                $ngx_addon_dir/src/ngx_http_lua_config.c \
+                "
+
+NGX_ADDON_DEPS="$NGX_ADDON_DEPS \
+                $ngx_addon_dir/src/ddebug.h \
+                $ngx_addon_dir/src/ngx_http_lua_script.h \
+                $ngx_addon_dir/src/ngx_http_lua_log.h \
+                $ngx_addon_dir/src/ngx_http_lua_subrequest.h \
+                $ngx_addon_dir/src/ngx_http_lua_ndk.h \
+                $ngx_addon_dir/src/ngx_http_lua_control.h \
+                $ngx_addon_dir/src/ngx_http_lua_time.h \
+                $ngx_addon_dir/src/ngx_http_lua_string.h \
+                $ngx_addon_dir/src/ngx_http_lua_misc.h \
+                $ngx_addon_dir/src/ngx_http_lua_variable.h \
+                $ngx_addon_dir/src/ngx_http_lua_output.h \
+                $ngx_addon_dir/src/ngx_http_lua_headers.h \
+                $ngx_addon_dir/src/ngx_http_lua_uri.h \
+                $ngx_addon_dir/src/ngx_http_lua_req_body.h \
+                $ngx_addon_dir/src/ngx_http_lua_args.h \
+                $ngx_addon_dir/src/ngx_http_lua_ctx.h \
+                $ngx_addon_dir/src/ngx_http_lua_regex.h \
+                $ngx_addon_dir/src/ngx_http_lua_common.h \
+                $ngx_addon_dir/src/ngx_http_lua_directive.h \
+                $ngx_addon_dir/src/ngx_http_lua_headers_out.h \
+                $ngx_addon_dir/src/ngx_http_lua_headers_in.h \
+                $ngx_addon_dir/src/ngx_http_lua_consts.h \
+                $ngx_addon_dir/src/ngx_http_lua_exception.h \
+                $ngx_addon_dir/src/ngx_http_lua_util.h \
+                $ngx_addon_dir/src/ngx_http_lua_cache.h \
+                $ngx_addon_dir/src/ngx_http_lua_contentby.h \
+                $ngx_addon_dir/src/ngx_http_lua_rewriteby.h \
+                $ngx_addon_dir/src/ngx_http_lua_accessby.h \
+                $ngx_addon_dir/src/ngx_http_lua_setby.h \
+                $ngx_addon_dir/src/ngx_http_lua_capturefilter.h \
+                $ngx_addon_dir/src/ngx_http_lua_clfactory.h \
+                $ngx_addon_dir/src/ngx_http_lua_pcrefix.h \
+                $ngx_addon_dir/src/ngx_http_lua_headerfilterby.h \
+                $ngx_addon_dir/src/ngx_http_lua_shdict.h \
+                $ngx_addon_dir/src/ngx_http_lua_socket_tcp.h \
+                $ngx_addon_dir/src/api/ngx_http_lua_api.h \
+                $ngx_addon_dir/src/ngx_http_lua_logby.h \
+                $ngx_addon_dir/src/ngx_http_lua_sleep.h \
+                $ngx_addon_dir/src/ngx_http_lua_coroutine.h \
+                $ngx_addon_dir/src/ngx_http_lua_bodyfilterby.h \
+                $ngx_addon_dir/src/ngx_http_lua_initby.h \
+                $ngx_addon_dir/src/ngx_http_lua_socket_udp.h \
+                $ngx_addon_dir/src/ngx_http_lua_req_method.h \
+                $ngx_addon_dir/src/ngx_http_lua_phase.h \
+                $ngx_addon_dir/src/ngx_http_lua_probe.h \
+                $ngx_addon_dir/src/ngx_http_lua_uthread.h \
+                $ngx_addon_dir/src/ngx_http_lua_timer.h \
+                $ngx_addon_dir/src/ngx_http_lua_config.h \
+                "
+
+CFLAGS="$CFLAGS -DNDK_SET_VAR"
+
+ngx_feature="export symbols by default"
+ngx_feature_libs="-Wl,-E"
+ngx_feature_name=
+ngx_feature_run=no
+ngx_feature_incs="#include <stdio.h>"
+ngx_feature_path=
+ngx_feature_test='printf("hello");'
+
+. auto/feature
+
+if [ $ngx_found = yes ]; then
+    CORE_LIBS="-Wl,-E $CORE_LIBS"
+fi
+
+NGX_DTRACE_PROVIDERS="$NGX_DTRACE_PROVIDERS $ngx_addon_dir/dtrace/ngx_lua_provider.d"
+NGX_TAPSET_SRCS="$NGX_TAPSET_SRCS $ngx_addon_dir/tapset/ngx_lua.stp"
+
+USE_MD5=YES
+USE_SHA1=YES
+
+CORE_INCS="$CORE_INCS $ngx_addon_dir/src/api"
+
+ngx_feature="SO_PASSCRED"
+ngx_feature_libs=
+ngx_feature_name="NGX_HTTP_LUA_HAVE_SO_PASSCRED"
+ngx_feature_run=no
+ngx_feature_incs="#include <sys/types.h>
+#include <sys/socket.h>"
+ngx_feature_path=
+ngx_feature_test='setsockopt(1, SOL_SOCKET, SO_PASSCRED, NULL, 0);'
+
+. auto/feature
+
+#CFLAGS=$"$CFLAGS -DLUA_DEFAULT_PATH='\"/usr/local/openresty/lualib/?.lua\"'"
+#CFLAGS=$"$CFLAGS -DLUA_DEFAULT_CPATH='\"/usr/local/openresty/lualib/?.so\"'"
+
diff -rNu a/src/lua/lua-nginx-module/doc/HttpLuaModule.wiki b/src/lua/lua-nginx-module/doc/HttpLuaModule.wiki
--- a/src/lua/lua-nginx-module/doc/HttpLuaModule.wiki	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/doc/HttpLuaModule.wiki	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,5334 @@
+﻿= Name =
+
+ngx_lua - Embed the power of Lua into Nginx
+
+''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].
+
+= Status =
+
+This module is under active development and is production ready.
+
+= Version =
+
+This document describes ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.9.0] released on 29 September 2013.
+
+= Synopsis =
+<geshi lang="nginx">
+    # set search paths for pure Lua external libraries (';;' is the default path):
+    lua_package_path '/foo/bar/?.lua;/blah/?.lua;;';
+ 
+    # set search paths for Lua external libraries written in C (can also use ';;'):
+    lua_package_cpath '/bar/baz/?.so;/blah/blah/?.so;;';
+ 
+    server {
+        location /inline_concat {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            set $a "hello";
+            set $b "world";
+            # inline Lua script
+            set_by_lua $res "return ngx.arg[1]..ngx.arg[2]" $a $b;
+            echo $res;
+        }
+ 
+        location /rel_file_concat {
+            set $a "foo";
+            set $b "bar";
+            # script path relative to nginx prefix
+            # $ngx_prefix/conf/concat.lua contents:
+            #
+            #    return ngx.arg[1]..ngx.arg[2]
+            #
+            set_by_lua_file $res conf/concat.lua $a $b;
+            echo $res;
+        }
+ 
+        location /abs_file_concat {
+            set $a "fee";
+            set $b "baz";
+            # absolute script path not modified
+            set_by_lua_file $res /usr/nginx/conf/concat.lua $a $b;
+            echo $res;
+        }
+ 
+        location /lua_content {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            content_by_lua "ngx.say('Hello,world!')";
+        }
+ 
+         location /nginx_var {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            # try access /nginx_var?a=hello,world
+            content_by_lua "ngx.print(ngx.var['arg_a'], '\\n')";
+        }
+ 
+        location /request_body {
+             # force reading request body (default off)
+             lua_need_request_body on;
+             client_max_body_size 50k;
+             client_body_buffer_size 50k;
+ 
+             content_by_lua 'ngx.print(ngx.var.request_body)';
+        }
+ 
+        # transparent non-blocking I/O in Lua via subrequests
+        location /lua {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            content_by_lua '
+                local res = ngx.location.capture("/some_other_location")
+                if res.status == 200 then
+                    ngx.print(res.body)
+                end';
+        }
+ 
+        # GET /recur?num=5
+        location /recur {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            content_by_lua '
+               local num = tonumber(ngx.var.arg_num) or 0
+
+               if num > 50 then
+                   ngx.say("num too big")
+                   return
+               end
+
+               ngx.say("num is: ", num)
+ 
+               if num > 0 then
+                   res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
+                   ngx.print("status=", res.status, " ")
+                   ngx.print("body=", res.body)
+               else
+                   ngx.say("end")
+               end
+               ';
+        }
+ 
+        location /foo {
+            rewrite_by_lua '
+                res = ngx.location.capture("/memc",
+                    { args = { cmd = "incr", key = ngx.var.uri } }
+                )
+            ';
+ 
+            proxy_pass http://blah.blah.com;
+        }
+ 
+        location /blah {
+            access_by_lua '
+                local res = ngx.location.capture("/auth")
+ 
+                if res.status == ngx.HTTP_OK then
+                    return
+                end
+ 
+                if res.status == ngx.HTTP_FORBIDDEN then
+                    ngx.exit(res.status)
+                end
+ 
+                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+            ';
+ 
+            # proxy_pass/fastcgi_pass/postgres_pass/...
+        }
+ 
+        location /mixed {
+            rewrite_by_lua_file /path/to/rewrite.lua;
+            access_by_lua_file /path/to/access.lua;
+            content_by_lua_file /path/to/content.lua;
+        }
+ 
+        # use nginx var in code path
+        # WARN: contents in nginx var must be carefully filtered,
+        # otherwise there'll be great security risk!
+        location ~ ^/app/(.+) {
+                content_by_lua_file /path/to/lua/app/root/$1.lua;
+        }
+ 
+        location / {
+           lua_need_request_body on;
+ 
+           client_max_body_size 100k;
+           client_body_buffer_size 100k;
+ 
+           access_by_lua '
+               -- check the client IP address is in our black list
+               if ngx.var.remote_addr == "132.5.72.3" then
+                   ngx.exit(ngx.HTTP_FORBIDDEN)
+               end
+ 
+               -- check if the request body contains bad words
+               if ngx.var.request_body and
+                        string.match(ngx.var.request_body, "fsck")
+               then
+                   return ngx.redirect("/terms_of_use.html")
+               end
+ 
+               -- tests passed
+           ';
+ 
+           # proxy_pass/fastcgi_pass/etc settings
+        }
+    }
+</geshi>
+
+= Description =
+
+This module embeds Lua, via the standard Lua 5.1 interpreter or [http://luajit.org/luajit.html LuaJIT 2.0], into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.
+
+Unlike [http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] and [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet], Lua code executed using this module can be ''100% non-blocking'' on network traffic as long as the [[#Nginx API for Lua|Nginx API for Lua]] provided by this module is used to handle
+requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.
+
+At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:
+
+* [https://github.com/agentzh/lua-resty-memcached lua-resty-memcached]
+* [https://github.com/agentzh/lua-resty-mysql lua-resty-mysql]
+* [https://github.com/agentzh/lua-resty-redis lua-resty-redis]
+* [https://github.com/agentzh/lua-resty-dns lua-resty-dns]
+* [https://github.com/agentzh/lua-resty-upload lua-resty-upload]
+* [[HttpMemcModule|ngx_memc]]
+* [https://github.com/FRiCKLE/ngx_postgres ngx_postgres]
+* [[HttpRedis2Module|ngx_redis2]]
+* [[HttpRedisModule|ngx_redis]]
+* [[HttpProxyModule|ngx_proxy]]
+* [[HttpFastcgiModule|ngx_fastcgi]]
+
+Almost all the Nginx modules can be used with this ngx_lua module by means of [[#ngx.location.capture|ngx.location.capture]] or [[#ngx.location.capture_multi|ngx.location.capture_multi]] but it is recommended to use those <code>lua-resty-*</code> libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.
+
+The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.
+
+Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.
+
+= Directives =
+
+== lua_code_cache ==
+'''syntax:''' ''lua_code_cache on | off''
+
+'''default:''' ''lua_code_cache on''
+
+'''context:''' ''main, server, location, location if''
+
+Enables or disables the Lua code cache for [[#set_by_lua_file|set_by_lua_file]],
+[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
+[[#access_by_lua_file|access_by_lua_file]], and also force Lua module reloading on a per-request basis.
+
+The Lua files referenced in [[#set_by_lua_file|set_by_lua_file]],
+[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
+and [[#rewrite_by_lua_file|rewrite_by_lua_file]] will not be cached
+and the Lua <code>package.loaded</code> table will be cleared
+at the entry point of every request (such that Lua modules
+will not be cached either). With this in place, developers can adopt an edit-and-refresh approach.
+
+Please note however, that Lua code written inlined within nginx.conf
+such as those specified by [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
+[[#access_by_lua|access_by_lua]], and [[#rewrite_by_lua|rewrite_by_lua]] will ''always'' be
+cached because only the Nginx config file parser can correctly parse the <code>nginx.conf</code>
+file and the only ways to to reload the config file
+are to send a <code>HUP</code> signal or to restart Nginx.
+
+Also, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code>
+in *_by_lua_file will never be cached. To ensure code caching, you can either use the [[#init_by_lua|init_by_lua]]
+or [[#init-by_lua_file|init_by_lua_file]] directives to load all such files or just make these Lua files true Lua modules
+and load them via <code>require</code>.
+
+The ngx_lua module does not currently support the <code>stat</code> mode available with the
+Apache <code>mod_lua</code> module but this is planned for implementation in the future.
+
+Disabling the Lua code cache is strongly
+discouraged for production use and should only be used during 
+development as it has a significant negative impact on overall performance.
+In addition, race conditions when reloading Lua modules are common for concurrent requests
+when the code cache is disabled.
+
+== lua_regex_cache_max_entries ==
+'''syntax:''' ''lua_regex_cache_max_entries <num>''
+
+'''default:''' ''lua_regex_cache_max_entries 1024''
+
+'''context:''' ''http''
+
+Specifies the maximum number of entries allowed in the worker process level compiled regex cache.
+
+The regular expressions used in [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]] will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.
+
+The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:
+
+<geshi lang="text">
+    2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...
+</geshi>
+
+Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for [[#ngx.re.sub|ngx.re.sub]] and [[#ngx.re.gsub|ngx.re.gsub]]) that are generated ''on the fly'' and give rise to infinite variations to avoid hitting the specified limit.
+
+== lua_regex_match_limit ==
+'''syntax:''' ''lua_regex_match_limit <num>''
+
+'''default:''' ''lua_regex_match_limit 0''
+
+'''context:''' ''http''
+
+Specifies the "match limit" used by the PCRE library when executing the [[#ngx.re.match|ngx.re API]]. To quote the PCRE manpage, "the limit ... has the effect of limiting the amount of backtracking that can take place."
+
+When the limit is hit, the error string "pcre_exec() failed: -8" will be returned by the [[#ngx.re.match|ngx.re API]] functions on the Lua land.
+
+When setting the limit to 0, the default "match limit" when compiling the PCRE library is used. And this is the default value of this directive.
+
+This directive was first introduced in the <code>v0.8.5</code> release.
+
+== lua_package_path ==
+
+'''syntax:''' ''lua_package_path <lua-style-path-str>''
+
+'''default:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''
+
+'''context:''' ''main''
+
+Sets the Lua module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
+[[#content_by_lua|content_by_lua]] and others. The path string is in standard Lua path form, and <code>;;</code>
+can be used to stand for the original search paths.
+
+As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+== lua_package_cpath ==
+
+'''syntax:''' ''lua_package_cpath <lua-style-cpath-str>''
+
+'''default:''' ''The content of LUA_CPATH environment variable or Lua's compiled-in defaults.''
+
+'''context:''' ''main''
+
+Sets the Lua C-module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
+[[#content_by_lua|content_by_lua]] and others. The cpath string is in standard Lua cpath form, and <code>;;</code>
+can be used to stand for the original cpath.
+
+As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+== init_by_lua ==
+
+'''syntax:''' ''init_by_lua <lua-script-str>''
+
+'''context:''' ''http''
+
+'''phase:''' ''loading-config''
+
+Runs the Lua code specified by the argument <code><lua-script-str></code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.
+
+When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code> will run again on the new Lua VM.
+
+Usually you can register (true) Lua global variables or pre-load Lua modules at server start-up by means of this hook. Here is an example for pre-loading Lua modules:
+
+<geshi lang="nginx">
+    init_by_lua 'cjson = require "cjson"';
+
+    server {
+        location = /api {
+            content_by_lua '
+                ngx.say(cjson.encode({dog = 5, cat = 6}))
+            ';
+        }
+    }
+</geshi>
+
+You can also initialize the [[#lua_shared_dict|lua_shared_dict]] shm storage at this phase. Here is an example for this:
+
+<geshi lang="nginx">
+    lua_shared_dict dogs 1m;
+
+    init_by_lua '
+        local dogs = ngx.shared.dogs;
+        dogs:set("Tom", 56)
+    ';
+
+    server {
+        location = /api {
+            content_by_lua '
+                local dogs = ngx.shared.dogs;
+                ngx.say(dogs:get("Tom"))
+            ';
+        }
+    }
+</geshi>
+
+But note that, the [[#lua_shared_dict|lua_shared_dict]]'s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do ''not'' want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.
+
+Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the [http://en.wikipedia.org/wiki/Copy-on-write Copy-on-write (COW)] feature provided by many operating systems among all the worker processes, thus saving a lot of memory.
+
+Only a small set of the [[#Nginx API for Lua|Nginx API for Lua]] is supported in this context:
+
+* Logging APIs: [[#ngx.log|ngx.log]] and [[#print|print]],
+* Shared Dictionary API: [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+More Nginx APIs for Lua may be supported in this context upon future user requests.
+
+Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.
+
+You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.
+
+This directive was first introduced in the <code>v0.5.5</code> release.
+
+== init_by_lua_file ==
+
+'''syntax:''' ''init_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''http''
+
+'''phase:''' ''loading-config''
+
+Equivalent to [[#init_by_lua|init_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code or [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+This directive was first introduced in the <code>v0.5.5</code> release.
+
+== set_by_lua ==
+
+'''syntax:''' ''set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]''
+
+'''context:''' ''server, server if, location, location if''
+
+'''phase:''' ''server-rewrite, rewrite''
+
+Executes code specified in <code><lua-script-str></code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>. 
+The code in <code><lua-script-str></code> can make [[#Nginx API for Lua|API calls]] and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).
+
+This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
+* Control API functions (e.g., [[#ngx.exit|ngx.exit]]) 
+* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
+* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).
+
+In addition, note that this directive can only write out a value to a single Nginx variable at
+a time. However, a workaround is possible using the [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] interface.
+
+<geshi lang="nginx">
+    location /foo {
+        set $diff ''; # we have to predefine the $diff variable here
+ 
+        set_by_lua $sum '
+            local a = 32
+            local b = 56
+ 
+            ngx.var.diff = a - b;  -- write to $diff directly
+            return a + b;          -- return the $sum value normally
+        ';
+ 
+        echo "sum = $sum, diff = $diff";
+    }
+</geshi>
+
+This directive can be freely mixed with all directives of the [[HttpRewriteModule]], [[HttpSetMiscModule]], and [[HttpArrayVarModule]] modules. All of these directives will run in the same order as they appear in the config file.
+
+<geshi lang="nginx">
+    set $foo 32;
+    set_by_lua $bar 'tonumber(ngx.var.foo) + 1';
+    set $baz "bar: $bar";  # $baz == "bar: 33"
+</geshi>
+
+As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code><lua-script-str></code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.
+
+This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.
+
+== set_by_lua_file ==
+'''syntax:''' ''set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]''
+
+'''context:''' ''server, server if, location, location if''
+
+'''phase:''' ''server-rewrite, rewrite''
+
+Equivalent to [[#set_by_lua|set_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed. 
+
+Nginx variable interpolation is supported in the <code><path-to-lua-script-file></code> argument string of this directive. But special care must be taken for injection attacks.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
+and the Nginx config must be reloaded each time the Lua source file is modified.
+The Lua code cache can be temporarily disabled during development by 
+switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.
+
+This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.
+
+== content_by_lua ==
+
+'''syntax:''' ''content_by_lua <lua-script-str>''
+
+'''context:''' ''location, location if''
+
+'''phase:''' ''content''
+
+Acts as a "content handler" and executes Lua code string specified in <code><lua-script-str></code> for every request. 
+The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
+
+Do not use this directive and other content handler directives in the same location. For example, this directive and the [[HttpProxyModule#proxy_pass|proxy_pass]] directive should not be used in the same location.
+
+== content_by_lua_file ==
+
+'''syntax:''' ''content_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''location, location if''
+
+'''phase:''' ''content''
+
+Equivalent to [[#content_by_lua|content_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+Nginx variables can be used in the <code><path-to-lua-script-file></code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
+and the Nginx config must be reloaded each time the Lua source file is modified.
+The Lua code cache can be temporarily disabled during development by 
+switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.
+
+== rewrite_by_lua ==
+
+'''syntax:''' ''rewrite_by_lua <lua-script-str>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''rewrite tail''
+
+Acts as a rewrite phase handler and executes Lua code string specified in <code><lua-script-str></code> for every request.
+The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
+
+Note that this handler always runs ''after'' the standard [[HttpRewriteModule]]. So the following will work as expected:
+
+<geshi lang="nginx">
+   location /foo {
+       set $a 12; # create and initialize $a
+       set $b ""; # create and initialize $b
+       rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
+       echo "res = $b";
+   }
+</geshi>
+
+because <code>set $a 12</code> and <code>set $b ""</code> run ''before'' [[#rewrite_by_lua|rewrite_by_lua]].
+
+On the other hand, the following will not work as expected:
+
+<geshi lang="nginx">
+    ?  location /foo {
+    ?      set $a 12; # create and initialize $a
+    ?      set $b ''; # create and initialize $b
+    ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
+    ?      if ($b = '13') {
+    ?         rewrite ^ /bar redirect;
+    ?         break;
+    ?      }
+    ?
+    ?      echo "res = $b";
+    ?  }
+</geshi>
+
+because <code>if</code> runs ''before'' [[#rewrite_by_lua|rewrite_by_lua]] even if it is placed after [[#rewrite_by_lua|rewrite_by_lua]] in the config.
+
+The right way of doing this is as follows:
+
+<geshi lang="nginx">
+    location /foo {
+        set $a 12; # create and initialize $a
+        set $b ''; # create and initialize $b
+        rewrite_by_lua '
+            ngx.var.b = tonumber(ngx.var.a) + 1
+            if tonumber(ngx.var.b) == 13 then
+                return ngx.redirect("/bar");
+            end
+        ';
+ 
+        echo "res = $b";
+    }
+</geshi>
+
+Note that the [http://www.grid.net.ru/nginx/eval.en.html ngx_eval] module can be approximated by using [[#rewrite_by_lua|rewrite_by_lua]]. For example,
+
+<geshi lang="nginx">
+    location / {
+        eval $res {
+            proxy_pass http://foo.com/check-spam;
+        }
+ 
+        if ($res = 'spam') {
+            rewrite ^ /terms-of-use.html redirect;
+        }
+ 
+        fastcgi_pass ...;
+    }
+</geshi>
+
+can be implemented in ngx_lua as:
+
+<geshi lang="nginx">
+    location = /check-spam {
+        internal;
+        proxy_pass http://foo.com/check-spam;
+    }
+ 
+    location / {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/check-spam")
+            if res.body == "spam" then
+                return ngx.redirect("/terms-of-use.html")
+            end
+        ';
+ 
+        fastcgi_pass ...;
+    }
+</geshi>
+
+Just as any other rewrite phase handlers, [[#rewrite_by_lua|rewrite_by_lua]] also runs in subrequests.
+
+Note that when calling <code>ngx.exit(ngx.OK)</code> within a [[#rewrite_by_lua|rewrite_by_lua]] handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [[#rewrite_by_lua|rewrite_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.
+
+If the [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive is used to change the URI and initiate location re-lookups (internal redirections), then any [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code sequences within the current location will not be executed. For example,
+
+<geshi lang="nginx">
+    location /foo {
+        rewrite ^ /bar;
+        rewrite_by_lua 'ngx.exit(503)';
+    }
+    location /bar {
+        ...
+    }
+</geshi>
+
+Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.
+
+The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless [[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]] is turned on.
+
+== rewrite_by_lua_file ==
+
+'''syntax:''' ''rewrite_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''rewrite tail''
+
+Equivalent to [[#rewrite_by_lua|rewrite_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+Nginx variables can be used in the <code><path-to-lua-script-file></code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.
+
+The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless [[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]] is turned on.
+
+== access_by_lua ==
+
+'''syntax:''' ''access_by_lua <lua-script-str>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''access tail''
+
+Acts as an access phase handler and executes Lua code string specified in <code><lua-script-str></code> for every request.
+The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
+
+Note that this handler always runs ''after'' the standard [[HttpAccessModule]]. So the following will work as expected:
+
+<geshi lang="nginx">
+    location / {
+        deny    192.168.1.1;
+        allow   192.168.1.0/24;
+        allow   10.1.1.0/16;
+        deny    all;
+ 
+        access_by_lua '
+            local res = ngx.location.capture("/mysql", { ... })
+            ...
+        ';
+ 
+        # proxy_pass/fastcgi_pass/...
+    }
+</geshi>
+
+That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by [[#access_by_lua|access_by_lua]].
+
+Note that the [http://mdounin.ru/hg/ngx_http_auth_request_module/ ngx_auth_request] module can be approximated by using [[#access_by_lua|access_by_lua]]:
+
+<geshi lang="nginx">
+    location / {
+        auth_request /auth;
+ 
+        # proxy_pass/fastcgi_pass/postgres_pass/...
+    }
+</geshi>
+
+can be implemented in ngx_lua as:
+
+<geshi lang="nginx">
+    location / {
+        access_by_lua '
+            local res = ngx.location.capture("/auth")
+ 
+            if res.status == ngx.HTTP_OK then
+                return
+            end
+ 
+            if res.status == ngx.HTTP_FORBIDDEN then
+                ngx.exit(res.status)
+            end
+ 
+            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+        ';
+ 
+        # proxy_pass/fastcgi_pass/postgres_pass/...
+    }
+</geshi>
+
+As with other access phase handlers, [[#access_by_lua|access_by_lua]] will ''not'' run in subrequests.
+
+Note that when calling <code>ngx.exit(ngx.OK)</code> within a [[#access_by_lua|access_by_lua]] handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [[#access_by_lua|access_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.
+
+== access_by_lua_file ==
+
+'''syntax:''' ''access_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''access tail''
+
+Equivalent to [[#access_by_lua|access_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+Nginx variables can be used in the <code><path-to-lua-script-file></code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
+and the Nginx config must be reloaded each time the Lua source file is modified.
+The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.
+
+== header_filter_by_lua ==
+
+'''syntax:''' ''header_filter_by_lua <lua-script-str>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''output-header-filter''
+
+Uses Lua code specified in <code><lua-script-str></code> to define an output header filter.
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
+* Control API functions (e.g., [[#ngx.exit|ngx.exit]] and [[#ngx.exec|ngx.exec]])
+* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
+* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).
+
+Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:
+
+<geshi lang="nginx">
+    location / {
+        proxy_pass http://mybackend;
+        header_filter_by_lua 'ngx.header.Foo = "blah"';
+    }
+</geshi>
+
+This directive was first introduced in the <code>v0.2.1rc20</code> release.
+
+== header_filter_by_lua_file ==
+
+'''syntax:''' ''header_filter_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''output-header-filter''
+
+Equivalent to [[#header_filter_by_lua|header_filter_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+This directive was first introduced in the <code>v0.2.1rc20</code> release.
+
+== body_filter_by_lua ==
+
+'''syntax:''' ''body_filter_by_lua <lua-script-str>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''output-body-filter''
+
+Uses Lua code specified in <code><lua-script-str></code> to define an output body filter.
+
+The input data chunk is passed via [[#ngx.arg|ngx.arg]][1] (as a Lua string value) and the "eof" flag indicating the end of the response body data stream is passed via [[#ngx.arg|ngx.arg]][2] (as a Lua boolean value).
+
+Behind the scene, the "eof" flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the "eof" flag does not work at all in subrequests.)
+
+The output data stream can be aborted immediately by running the following Lua statement:
+
+<geshi lang="lua">
+    return ngx.ERROR
+</geshi>
+
+This will truncate the response body and usually result in incomplete and also invalid responses.
+
+The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding [[#ngx.arg|ngx.arg]][1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:
+
+<geshi lang="nginx">
+    location / {
+        proxy_pass http://mybackend;
+        body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';
+    }
+</geshi>
+
+When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.
+
+Likewise, new "eof" flag can also be specified by setting a boolean value to [[#ngx.arg|ngx.arg]][2]. For example,
+
+<geshi lang="nginx">
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk = ngx.arg[1]
+            if string.match(chunk, "hello") then
+                ngx.arg[2] = true  -- new eof
+                return
+            end
+
+            -- just throw away any remaining chunk data
+            ngx.arg[1] = nil
+        ';
+    }
+</geshi>
+
+Then <code>GET /t</code> will just return the output
+
+<geshi lang="text">
+    hello world
+</geshi>
+
+That is, when the body filter sees a chunk containing the word "hello", then it will set the "eof" flag to true immediately, resulting in truncated but still valid responses.
+
+When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code> response header (if any) in a header filter to enforce streaming output, as in
+
+<geshi lang="nginx">
+    location /foo {
+        # fastcgi_pass/proxy_pass/...
+
+        header_filter_by_lua 'ngx.header.content_length = nil';
+        body_filter_by_lua 'ngx.arg[1] = string.len(ngx.arg[1]) .. "\\n"';
+    }
+</geshi>
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
+* Control API functions (e.g., [[#ngx.exit|ngx.exit]] and [[#ngx.exec|ngx.exec]])
+* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
+* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).
+
+Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.
+
+This directive was first introduced in the <code>v0.5.0rc32</code> release.
+
+== body_filter_by_lua_file ==
+
+'''syntax:''' ''body_filter_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''output-body-filter''
+
+Equivalent to [[#body_filter_by_lua|body_filter_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+This directive was first introduced in the <code>v0.5.0rc32</code> release.
+
+== log_by_lua ==
+
+'''syntax:''' ''log_by_lua <lua-script-str>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''log''
+
+Run the Lua source code inlined as the <code><lua-script-str></code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs after.
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
+* Control API functions (e.g., [[#ngx.exit|ngx.exit]]) 
+* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
+* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).
+
+Here is an example of gathering average data for [[HttpUpstreamModule#$upstream_response_time|$upstream_response_time]]:
+
+<geshi lang="nginx">
+    lua_shared_dict log_dict 5M;
+
+    server {
+        location / {
+            proxy_pass http://mybackend;
+
+            log_by_lua '
+                local log_dict = ngx.shared.log_dict
+                local upstream_time = tonumber(ngx.var.upstream_response_time)
+
+                local sum = log_dict:get("upstream_time-sum") or 0
+                sum = sum + upstream_time
+                log_dict:set("upstream_time-sum", sum)
+
+                local newval, err = log_dict:incr("upstream_time-nb", 1)
+                if not newval and err == "not found" then
+                    log_dict:add("upstream_time-nb", 0)
+                    log_dict:incr("upstream_time-nb", 1)
+                end
+            ';
+        }
+
+        location = /status {
+            content_by_lua '
+                local log_dict = ngx.shared.log_dict
+                local sum = log_dict:get("upstream_time-sum")
+                local nb = log_dict:get("upstream_time-nb")
+    
+                if nb and sum then
+                    ngx.say("average upstream response time: ", sum / nb,
+                            " (", nb, " reqs)")
+                else
+                    ngx.say("no data yet")
+                end
+            ';
+        }
+    }
+</geshi>
+
+This directive was first introduced in the <code>v0.5.0rc31</code> release.
+
+== log_by_lua_file ==
+
+'''syntax:''' ''log_by_lua_file <path-to-lua-script-file>''
+
+'''context:''' ''http, server, location, location if''
+
+'''phase:''' ''log''
+
+Equivalent to [[#log_by_lua|log_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.
+
+When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
+
+This directive was first introduced in the <code>v0.5.0rc31</code> release.
+
+== lua_need_request_body ==
+
+'''syntax:''' ''lua_need_request_body <on|off>''
+
+'''default:''' ''off''
+
+'''context:''' ''main | server | location''
+
+'''phase:''' ''depends on usage''
+
+Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the [[#ngx.req.read_body|ngx.req.read_body]] function should be called within the Lua code.
+
+To read the request body data within the [[HttpCoreModule#$request_body|$request_body]] variable, 
+[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] must have the same value as [[HttpCoreModule#client_max_body_size|client_max_body_size]]. Because when the content length exceeds [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] but less than [[HttpCoreModule#client_max_body_size|client_max_body_size]], Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the [[HttpCoreModule#$request_body|$request_body]] variable.
+
+If the current location includes [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives,
+then the request body will be read just before the [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code is run (and also at the
+<code>rewrite</code> phase). Similarly, if only [[#content_by_lua|content_by_lua]] is specified,
+the request body will not be read until the content handler's Lua code is
+about to run (i.e., the request body will be read during the content phase).
+
+It is recommended however, to use the [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]] functions for finer control over the request body reading process instead.
+
+This also applies to [[#access_by_lua|access_by_lua]] and [[#access_by_lua_file|access_by_lua_file]].
+
+== lua_shared_dict ==
+
+'''syntax:''' ''lua_shared_dict <name> <size>''
+
+'''default:''' ''no''
+
+'''context:''' ''http''
+
+'''phase:''' ''depends on usage''
+
+Declares a shared memory zone, <code><name></code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.<name></code>.
+
+The <code><size></code> argument accepts size units such as <code>k</code> and <code>m</code>:
+
+<geshi lang="nginx">
+    http {
+        lua_shared_dict dogs 10m;
+        ...
+    }
+</geshi>
+
+See [[#ngx.shared.DICT|ngx.shared.DICT]] for details.
+
+This directive was first introduced in the <code>v0.3.1rc22</code> release.
+
+== lua_socket_connect_timeout ==
+
+'''syntax:''' ''lua_socket_connect_timeout <time>''
+
+'''default:''' ''lua_socket_connect_timeout 60s''
+
+'''context:''' ''http, server, location''
+
+This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:connect|connect]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.
+
+The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
+
+This directive was first introduced in the <code>v0.5.0rc1</code> release.
+
+== lua_socket_send_timeout ==
+
+'''syntax:''' ''lua_socket_send_timeout <time>''
+
+'''default:''' ''lua_socket_send_timeout 60s''
+
+'''context:''' ''http, server, location''
+
+Controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:send|send]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.
+
+The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
+
+This directive was first introduced in the <code>v0.5.0rc1</code> release.
+
+== lua_socket_send_lowat ==
+
+'''syntax:''' ''lua_socket_send_lowat <size>''
+
+'''default:''' ''lua_socket_send_lowat 0''
+
+'''context:''' ''http, server, location''
+
+Controls the <code>lowat</code> (low water) value for the cosocket send buffer.
+
+== lua_socket_read_timeout ==
+
+'''syntax:''' ''lua_socket_read_timeout <time>''
+
+'''default:''' ''lua_socket_read_timeout 60s''
+
+'''context:''' ''http, server, location''
+
+'''phase:''' ''depends on usage''
+
+This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:receive|receive]] method and iterator functions returned by the [[#tcpsock:receiveuntil|receiveuntil]] method. This setting can be overridden by the [[#tcpsock:settimeout|settimeout]] method.
+
+The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
+
+This directive was first introduced in the <code>v0.5.0rc1</code> release.
+
+== lua_socket_buffer_size ==
+
+'''syntax:''' ''lua_socket_buffer_size <size>''
+
+'''default:''' ''lua_socket_buffer_size 4k/8k''
+
+'''context:''' ''http, server, location''
+
+Specifies the buffer size used by cosocket reading operations.
+
+This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.
+
+This directive was first introduced in the <code>v0.5.0rc1</code> release.
+
+== lua_socket_pool_size ==
+
+'''syntax:''' ''lua_socket_pool_size <size>''
+
+'''default:''' ''lua_socket_pool_size 30''
+
+'''context:''' ''http, server, location''
+
+Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).
+
+Default to 30 connections for every pool.
+
+When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.
+
+Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.
+
+This directive was first introduced in the <code>v0.5.0rc1</code> release.
+
+== lua_socket_keepalive_timeout ==
+
+'''syntax:''' ''lua_socket_keepalive_timeout <time>''
+
+'''default:''' ''lua_socket_keepalive_timeout 60s''
+
+'''context:''' ''http, server, location''
+
+This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' [[#tcpsock:setkeepalive|setkeepalive]] method.
+
+The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
+
+This directive was first introduced in the <code>v0.5.0rc1</code> release.
+
+== lua_socket_log_errors ==
+
+'''syntax:''' ''lua_socket_log_errors on|off''
+
+'''default:''' ''lua_socket_log_errors on''
+
+'''context:''' ''http, server, location''
+
+This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).
+
+This directive was first introduced in the <code>v0.5.13</code> release.
+
+== lua_http10_buffering ==
+
+'''syntax:''' ''lua_http10_buffering on|off''
+
+'''default:''' ''lua_http10_buffering on''
+
+'''context:''' ''http, server, location, location-if''
+
+Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which replies on a proper <code>Content-Length</code> response header.
+
+If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via [[#ngx.send_headers|ngx.send_headers]] or implicitly via the first [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.
+
+To output very large response data in a streaming fashion (via the [[#ngx.flush|ngx.flush]] call, for example), this directive MUST be turned off to minimize memory usage.
+
+This directive is turned <code>on</code> by default.
+
+This directive was first introduced in the <code>v0.5.0rc19</code> release.
+
+== rewrite_by_lua_no_postpone ==
+
+'''syntax:''' ''rewrite_by_lua_no_postpone on|off''
+
+'''default:''' ''rewrite_by_lua_no_postpone off''
+
+'''context:''' ''http''
+
+Controls whether or not to disable postponing [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.
+
+This directive was first introduced in the <code>v0.5.0rc29</code> release.
+
+== lua_transform_underscores_in_response_headers ==
+
+'''syntax:''' ''lua_transform_underscores_in_response_headers on|off''
+
+'''default:''' ''lua_transform_underscores_in_response_headers on''
+
+'''context:''' ''http, server, location, location-if''
+
+Controls whether to transform underscores (<code>_</code>) in the response header names specified in the [[#ngx.header.HEADER|ngx.header.HEADER]] API to hypens (<code>-</code>).
+
+This directive was first introduced in the <code>v0.5.0rc32</code> release.
+
+== lua_check_client_abort ==
+
+'''syntax:''' ''lua_check_client_abort on|off''
+
+'''default:''' ''lua_check_client_abort off''
+
+'''context:''' ''http, server, location, location-if''
+
+This directive controls whether to check for premature client connection abortion.
+
+When this directive is turned on, the ngx_lua module will monitor the premature connection close event on the downstream connections. And when there is such an event, it will call the user Lua function callback (registered by [[#ngx.on_abort|ngx.on_abort]]) or just stop and clean up all the Lua "light threads" running in the current request's request handler when there is no user callback function registered.
+
+According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via [[#ngx.req.socket|ngx.req.socket]], then ngx_lua will neither stop all the running "light threads" nor call the user callback (if [[#ngx.on_abort|ngx.on_abort]] has been called). Instead, the reading operation on [[#ngx.req.socket|ngx.req.socket]] will just return the error message "client aborted" as the second return value (the first return value is surely <code>nil</code>).
+
+When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the [http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html TCP keepalive] support in your system's TCP stack implementation in order to detect "half-open" TCP connections in time.
+
+For example, on Linux, you can configure the standard [[HttpCoreModule#listen|listen]] directive in your <code>nginx.conf</code> file like this:
+
+<geshi lang="nginx">
+    listen 80 so_keepalive=2s:2s:8;
+</geshi>
+
+On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:
+
+    # sysctl net.inet.tcp.keepintvl=2000
+    # sysctl net.inet.tcp.keepidle=2000
+
+This directive was first introduced in the <code>v0.7.4</code> release.
+
+See also [[#ngx.on_abort|ngx.on_abort]].
+
+== lua_max_pending_timers ==
+
+'''syntax:''' ''lua_max_pending_timers <count>''
+
+'''default:''' ''lua_max_pending_timers 1024''
+
+'''context:''' ''http''
+
+Controls the maximum number of pending timers allowed.
+
+Pending timers are those timers that have not expired yet.
+
+When exceeding this limit, the [[#ngx.timer.at|ngx.timer.at]] call will immediately return <code>nil</code> and the error string "too many pending timers".
+
+This directive was first introduced in the <code>v0.8.0</code> release.
+
+== lua_max_running_timers ==
+
+'''syntax:''' ''lua_max_running_timers <count>''
+
+'''default:''' ''lua_max_running_timers 256''
+
+'''context:''' ''http''
+
+Controls the maximum number of "running timers" allowed.
+
+Running timers are those timers whose user callback functions are still running.
+
+When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message "N lua_max_running_timers are not enough" where "N" is the current value of this directive.
+
+This directive was first introduced in the <code>v0.8.0</code> release.
+
+= Nginx API for Lua =
+== Introduction ==
+The various <code>*_by_lua</code> and <code>*_by_lua_file</code> configuration directives serve as gateways to the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.
+
+The API is exposed to Lua in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.
+
+The packages can be introduced into external Lua modules like this:
+
+<geshi lang="lua">
+    local say = ngx.say
+
+    local _M = {}
+
+    function _M.foo(a)
+        say(a)
+    end
+
+    return _M
+</geshi>
+
+Use of the [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] flag is strongly discouraged due to its various bad side-effects.
+
+It is also possible to directly require the packages in external Lua modules:
+
+<geshi lang="lua">
+    local ngx = require "ngx"
+    local ndk = require "ndk"
+</geshi>
+
+The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.
+
+Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua <code>io</code> library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the [[#ngx.location.capture|ngx.location.capture]] method and similar) is strongly recommended for maximum performance.
+
+== ngx.arg ==
+'''syntax:''' ''val = ngx.arg[index]''
+
+'''context:''' ''set_by_lua*, body_filter_by_lua*''
+
+When this is used in the context of the [[#set_by_lua|set_by_lua]] or [[#set_by_lua_file|set_by_lua_file]] directives, this table is read-only and holds the input arguments to the config directives:
+
+<geshi lang="lua">
+    value = ngx.arg[n]
+</geshi>
+
+Here is an example
+
+<geshi lang="nginx">
+    location /foo {
+        set $a 32;
+        set $b 56;
+ 
+        set_by_lua $res
+            'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
+            $a $b;
+ 
+        echo $sum;
+    }
+</geshi>
+
+that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.
+
+When this table is used in the context of [[#body_filter_by_lua|body_filter_by_lua]] or [[#body_filter_by_lua_file|body_filter_by_lua_file]], the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the "eof" flag indicating the end of the whole output data stream.
+
+The data chunk and "eof" flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.
+
+== ngx.var.VARIABLE ==
+'''syntax:''' ''ngx.var.VAR_NAME''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''
+
+Read and write Nginx variable values.
+
+<geshi lang="nginx">
+    value = ngx.var.some_nginx_variable_name
+    ngx.var.some_nginx_variable_name = value
+</geshi>
+
+Note that only already defined nginx variables can be written to.
+For example:
+
+<geshi lang="nginx">
+    location /foo {
+        set $my_var ''; # this line is required to create $my_var at config time
+        content_by_lua '
+            ngx.var.my_var = 123;
+            ...
+        ';
+    }
+</geshi>
+
+That is, nginx variables cannot be created on-the-fly.
+
+Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value,
+some are not, like <code>$arg_PARAMETER</code>.
+
+Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this
+interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.
+
+Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will unset the <code>$Foo</code> Nginx variable. 
+
+<geshi lang="lua">
+    ngx.var.args = nil
+</geshi>
+
+'''WARNING''' When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,
+
+<geshi lang="lua">
+    local val = ngx.var.some_var
+    --- use the val repeatedly later
+</geshi>
+
+to prevent (temporary) memory leaking within the current request's lifetime.
+
+== Core constants ==
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.*''
+
+<geshi lang="lua">
+  ngx.OK (0)
+  ngx.ERROR (-1)
+  ngx.AGAIN (-2)
+  ngx.DONE (-4)
+  ngx.DECLINED (-5)
+</geshi>
+
+Note that only three of these constants are utilized by the [[#Nginx API for Lua|Nginx API for Lua]] (i.e., [[#ngx.exit|ngx.exit]] accepts <code>NGX_OK</code>, <code>NGX_ERROR</code>, and <code>NGX_DECLINED</code> as input).
+
+<geshi lang="lua">
+  ngx.null
+</geshi>
+
+The <code>ngx.null</code> constant is a <code>NULL</code> light userdata usually used to represent nil values in Lua tables etc and is similar to the [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson] library's <code>cjson.null</code> constant. This constant was first introduced in the <code>v0.5.0rc5</code> release.
+
+The <code>ngx.DECLINED</code> constant was first introduced in the <code>v0.5.0rc19</code> release.
+
+== HTTP method constants ==
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''
+
+<geshi lang="text">
+  ngx.HTTP_GET
+  ngx.HTTP_HEAD
+  ngx.HTTP_PUT
+  ngx.HTTP_POST
+  ngx.HTTP_DELETE
+  ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)
+  ngx.HTTP_MKCOL     (added in the v0.8.2 release)
+  ngx.HTTP_COPY      (added in the v0.8.2 release)
+  ngx.HTTP_MOVE      (added in the v0.8.2 release)
+  ngx.HTTP_PROPFIND  (added in the v0.8.2 release)
+  ngx.HTTP_PROPPATCH (added in the v0.8.2 release)
+  ngx.HTTP_LOCK      (added in the v0.8.2 release)
+  ngx.HTTP_UNLOCK    (added in the v0.8.2 release)
+  ngx.HTTP_PATCH     (added in the v0.8.2 release)
+  ngx.HTTP_TRACE     (added in the v0.8.2 release)
+</geshi>
+
+These constants are usually used in [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] method calls.
+
+== HTTP status constants ==
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''
+
+<geshi lang="nginx">
+  value = ngx.HTTP_OK (200)
+  value = ngx.HTTP_CREATED (201)
+  value = ngx.HTTP_SPECIAL_RESPONSE (300)
+  value = ngx.HTTP_MOVED_PERMANENTLY (301)
+  value = ngx.HTTP_MOVED_TEMPORARILY (302)
+  value = ngx.HTTP_SEE_OTHER (303)
+  value = ngx.HTTP_NOT_MODIFIED (304)
+  value = ngx.HTTP_BAD_REQUEST (400)
+  value = ngx.HTTP_UNAUTHORIZED (401)
+  value = ngx.HTTP_FORBIDDEN (403)
+  value = ngx.HTTP_NOT_FOUND (404)
+  value = ngx.HTTP_NOT_ALLOWED (405)
+  value = ngx.HTTP_GONE (410)
+  value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
+  value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)
+  value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
+  value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
+</geshi>
+
+== Nginx log level constants ==
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''
+
+<geshi lang="lua">
+  ngx.STDERR
+  ngx.EMERG
+  ngx.ALERT
+  ngx.CRIT
+  ngx.ERR
+  ngx.WARN
+  ngx.NOTICE
+  ngx.INFO
+  ngx.DEBUG
+</geshi>
+
+These constants are usually used by the [[#ngx.log|ngx.log]] method.
+
+== print ==
+'''syntax:''' ''print(...)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''
+
+Writes argument values into the nginx <code>error.log</code> file with the <code>ngx.NOTICE</code> log level.
+
+It is equivalent to
+
+<geshi lang="lua">
+    ngx.log(ngx.NOTICE, ...)
+</geshi>
+
+Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code> strings while Lua booleans result in literal <code>"true"</code> or <code>"false"</code> strings. And the <code>ngx.null</code> constant will yield the <code>"null"</code> string output.
+
+There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.
+
+== ngx.ctx ==
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''
+
+This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables). 
+
+Consider the following example,
+
+<geshi lang="nginx">
+    location /test {
+        rewrite_by_lua '
+            ngx.say("foo = ", ngx.ctx.foo)
+            ngx.ctx.foo = 76
+        ';
+        access_by_lua '
+            ngx.ctx.foo = ngx.ctx.foo + 3
+        ';
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+</geshi>
+
+Then <code>GET /test</code> will yield the output
+
+<geshi lang="bash">
+    foo = nil
+    79
+</geshi>
+
+That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.
+
+Every request, including subrequests, has its own copy of the table. For example:
+
+<geshi lang="nginx">
+    location /sub {
+        content_by_lua '
+            ngx.say("sub pre: ", ngx.ctx.blah)
+            ngx.ctx.blah = 32
+            ngx.say("sub post: ", ngx.ctx.blah)
+        ';
+    }
+ 
+    location /main {
+        content_by_lua '
+            ngx.ctx.blah = 73
+            ngx.say("main pre: ", ngx.ctx.blah)
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+            ngx.say("main post: ", ngx.ctx.blah)
+        ';
+    }
+</geshi>
+
+Then <code>GET /main</code> will give the output
+
+<geshi lang="bash">
+    main pre: 73
+    sub pre: nil
+    sub post: 32
+    main post: 73
+</geshi>
+
+Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.
+
+Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code> table. For instance,
+
+<geshi lang="nginx">
+    location /new {
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+ 
+    location /orig {
+        content_by_lua '
+            ngx.ctx.foo = "hello"
+            ngx.exec("/new")
+        ';
+    }
+</geshi>
+
+Then <code>GET /orig</code> will give
+
+<geshi lang="bash">
+    nil
+</geshi>
+
+rather than the original <code>"hello"</code> value.
+
+Arbitrary data values, including Lua closures and nested tables, can be inserted into this "magic" table. It also allows the registration of custom meta methods.
+
+Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,
+
+<geshi lang="lua">
+    ngx.ctx = { foo = 32, bar = 54 }
+</geshi>
+
+== ngx.location.capture ==
+'''syntax:''' ''res = ngx.location.capture(uri, options?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Issue a synchronous but still non-blocking ''Nginx Subrequest'' using <code>uri</code>.
+
+Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or ''any'' other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>,
+<code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua itself and etc etc etc.
+
+Also note that subrequests just mimic the HTTP interface but there is ''no'' extra HTTP/TCP traffic ''nor'' IPC involved. Everything works internally, efficiently, on the C level.
+
+Subrequests are completely different from HTTP 301/302 redirection (via [[#ngx.redirect|ngx.redirect]]) and internal redirection (via [[#ngx.exec|ngx.exec]]).
+
+Here is a basic example:
+
+<geshi lang="lua">
+    res = ngx.location.capture(uri)
+</geshi>
+
+Returns a Lua table with three slots (<code>res.status</code>, <code>res.header</code>, <code>res.body</code>, and <code>res.truncated</code>).
+
+<code>res.status</code> holds the response status code for the subrequest response.
+
+<code>res.header</code> holds all the response headers of the
+subrequest and it is a normal Lua table. For multi-value response headers,
+the value is a Lua (array) table that holds all the values in the order that
+they appear. For instance, if the subrequest response headers contain the following
+lines:
+
+<geshi lang="bash">
+    Set-Cookie: a=3
+    Set-Cookie: foo=bar
+    Set-Cookie: baz=blah
+</geshi>
+
+Then <code>res.header["Set-Cookie"]</code> will be evaluated to the table value
+<code>{"a=3", "foo=bar", "baz=blah"}</code>.
+
+<code>res.body</code> holds the subrequest's response body data, which might be truncated. You always need to check the <code>res.truncated</code> boolean flag to see if <code>res.body</code> contains truncated data.
+
+URI query strings can be concatenated to URI itself, for instance,
+
+<geshi lang="lua">
+    res = ngx.location.capture('/foo/bar?a=3&b=4')
+</geshi>
+
+Named locations like <code>@foo</code> are not allowed due to a limitation in
+the nginx core. Use normal locations combined with the <code>internal</code> directive to
+prepare internal-only locations.
+
+An optional option table can be fed as the second
+argument, which supports the options:
+
+* <code>method</code>
+: specify the subrequest's request method, which only accepts constants like <code>ngx.HTTP_POST</code>.
+* <code>body</code>
+: specify the subrequest's request body (string value only).
+* <code>args</code>
+: specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
+* <code>ctx</code>
+: specify a Lua table to be the [[#ngx.ctx|ngx.ctx]] table for the subrequest. It can be the current request's [[#ngx.ctx|ngx.ctx]] table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the <code>v0.3.1rc25</code> release.
+* <code>vars</code>
+: take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the <code>v0.3.1rc31</code> release.
+* <code>copy_all_vars</code>
+: specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.
+* <code>share_all_vars</code>
+: specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request.
+* <code>always_forward_body</code>
+: when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the <code>body</code> option is not specified. By default, this option is false and when the <code>body</code> option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the <code>PUT</code> or <code>POST</code> request method.
+
+Issuing a POST subrequest, for example, can be done as follows
+
+<geshi lang="lua">
+    res = ngx.location.capture(
+        '/foo/bar',
+        { method = ngx.HTTP_POST, body = 'hello, world' }
+    )
+</geshi>
+
+See HTTP method constants methods other than POST.
+The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.
+
+The <code>args</code> option can specify extra URI arguments, for instance,
+
+<geshi lang="lua">
+    ngx.location.capture('/foo?a=1',
+        { args = { b = 3, c = ':' } }
+    )
+</geshi>
+
+is equivalent to
+
+<geshi lang="lua">
+    ngx.location.capture('/foo?a=1&b=3&c=%3a')
+</geshi>
+
+that is, this method will escape argument keys and values according to URI rules and
+concatenate them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [[#ngx.encode_args|ngx.encode_args]] method.
+
+The <code>args</code> option can also take plain query strings:
+
+<geshi lang="lua">
+    ngx.location.capture('/foo?a=1',
+        { args = 'b=3&c=%3a' } }
+    )
+</geshi>
+
+This is functionally identical to the previous examples.
+
+The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. 
+If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.
+
+Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.
+
+This option is set to <code>false</code> by default
+
+<geshi lang="nginx">
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { share_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+</geshi>
+
+Accessing location <code>/lua</code> gives
+
+<geshi lang="text">
+    /other dog: hello world
+    /lua: hello world
+</geshi>
+
+The <code>copy_all_vars</code> option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.
+
+<geshi lang="nginx">
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { copy_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+</geshi>
+
+Request <code>GET /lua</code> will give the output
+
+<geshi lang="text">
+    /other dog: hello world
+    /lua: hello
+</geshi>
+
+Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.
+
+In addition to the two settings above, it is possible to specify
+values for variables in the subrequest using the <code>vars</code> option. These
+variables are set after the sharing or copying of variables has been
+evaluated, and provides a more efficient method of passing specific
+values to a subrequest over encoding them as URL arguments and 
+unescaping them in the Nginx config file.
+
+<geshi lang="nginx">
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog '';
+        set $cat '';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { dog = "hello", cat = 32 }});
+
+            ngx.print(res.body)
+        ';
+    }
+</geshi>
+
+Accessing <code>/lua</code> will yield the output
+
+<geshi lang="text">
+    dog = hello
+    cat = 32
+</geshi>
+
+The <code>ctx</code> option can be used to specify a custom Lua table to serve as the [[#ngx.ctx|ngx.ctx]] table for the subrequest.
+
+<geshi lang="nginx">
+    location /sub {
+        content_by_lua '
+            ngx.ctx.foo = "bar";
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            local ctx = {}
+            res = ngx.location.capture("/sub", { ctx = ctx })
+
+            ngx.say(ctx.foo);
+            ngx.say(ngx.ctx.foo);
+        ';
+    }
+</geshi>
+
+Then request <code>GET /lua</code> gives
+
+<geshi lang="text">
+    bar
+    nil
+</geshi>
+
+It is also possible to use this <code>ctx</code> option to share the same [[#ngx.ctx|ngx.ctx]] table between the current (parent) request and the subrequest:
+
+<geshi lang="nginx">
+    location /sub {
+        content_by_lua '
+            ngx.ctx.foo = "bar";
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/sub", { ctx = ngx.ctx })
+            ngx.say(ngx.ctx.foo);
+        ';
+    }
+</geshi>
+
+Request <code>GET /lua</code> yields the output
+
+<geshi lang="text">
+    bar
+</geshi>
+
+Note that subrequests issued by [[#ngx.location.capture|ngx.location.capture]] inherit all the
+request headers of the current request by default and that this may have unexpected side effects on the
+subrequest responses. For example, when using the standard <code>ngx_proxy</code> module to serve
+subrequests, an "Accept-Encoding: gzip" header in the main request may result
+in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting 
+[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] to <code>off</code> in subrequest locations.
+
+When the <code>body</code> option is not specified and the <code>always_forward_body</code> option is false (the default value), the <code>POST</code> and <code>PUT</code> subrequests will inherit the request bodies of the parent request (if any).
+
+There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was <code>50</code> concurrent subrequests and in more recent versions, Nginx <code>1.1.x</code> onwards, this was increased to <code>200</code> concurrent subrequests. When this limit is exceeded, the following error message is added to the <code>error.log</code> file:
+
+<geshi lang="text">
+    [error] 13983#0: *1 subrequests cycle while processing "/uri"
+</geshi>
+
+The limit can be manually modified if required by editing the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree.
+
+Please also refer to restrictions on capturing locations configured by [[#Locations_Configured_by_Subrequest_Directives_of_Other_Modules|subrequest directives of other modules]].
+
+== ngx.location.capture_multi ==
+'''syntax:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Just like [[#ngx.location.capture|ngx.location.capture]], but supports multiple subrequests running in parallel.
+
+This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,
+
+<geshi lang="lua">
+    res1, res2, res3 = ngx.location.capture_multi{
+        { "/foo", { args = "a=3&b=4" } },
+        { "/bar" },
+        { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
+    }
+ 
+    if res1.status == ngx.HTTP_OK then
+        ...
+    end
+ 
+    if res2.body == "BLAH" then
+        ...
+    end
+</geshi>
+
+This function will not return until all the subrequests terminate.
+The total latency is the longest latency of the individual subrequests rather than the sum.
+
+Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:
+
+<geshi lang="lua">
+    -- construct the requests table
+    local reqs = {}
+    table.insert(reqs, { "/mysql" })
+    table.insert(reqs, { "/postgres" })
+    table.insert(reqs, { "/redis" })
+    table.insert(reqs, { "/memcached" })
+ 
+    -- issue all the requests at once and wait until they all return
+    local resps = { ngx.location.capture_multi(reqs) }
+ 
+    -- loop over the responses table
+    for i, resp in ipairs(resps) do
+        -- process the response table "resp"
+    end
+</geshi>
+
+The [[#ngx.location.capture|ngx.location.capture]] function is just a special form
+of this function. Logically speaking, the [[#ngx.location.capture|ngx.location.capture]] can be implemented like this
+
+<geshi lang="lua">
+    ngx.location.capture =
+        function (uri, args)
+            return ngx.location.capture_multi({ {uri, args} })
+        end
+</geshi>
+
+Please also refer to restrictions on capturing locations configured by [[#Locations_Configured_by_Subrequest_Directives_of_Other_Modules|subrequest directives of other modules]].
+
+== ngx.status ==
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''
+
+Read and write the current request's response status. This should be called
+before sending out the response headers.
+
+<geshi lang="lua">
+    ngx.status = ngx.HTTP_CREATED
+    status = ngx.status
+</geshi>
+
+Setting <code>ngx.status</code> after the response header is sent out has no effect but leaving an error message in your nginx's error log file:
+
+<geshi lang="text">
+    attempt to set ngx.status after sending out response headers
+</geshi>
+
+== ngx.header.HEADER ==
+'''syntax:''' ''ngx.header.HEADER = VALUE''
+
+'''syntax:''' ''value = ngx.header.HEADER''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''
+
+Set, add to, or clear the current request's <code>HEADER</code> response header that is to be sent.
+
+Underscores (<code>_</code>) in the header names will be replaced by hyphens (<code>-</code>) by default. This transformation can be turned off via the [[#lua_transform_underscores_in_response_headers|lua_transform_underscores_in_response_headers]] directive.
+
+The header names are matched case-insensitively.
+
+<geshi lang="lua">
+    -- equivalent to ngx.header["Content-Type"] = 'text/plain'
+    ngx.header.content_type = 'text/plain';
+ 
+    ngx.header["X-My-Header"] = 'blah blah';
+</geshi>
+
+Multi-value headers can be set this way:
+
+<geshi lang="lua">
+    ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
+</geshi>
+
+will yield
+
+<geshi lang="bash">
+    Set-Cookie: a=32; path=/
+    Set-Cookie: b=4; path=/
+</geshi>
+
+in the response headers. 
+
+Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as <code>Content-Type</code> that only accept a single value).
+
+<geshi lang="lua">
+    ngx.header.content_type = {'a', 'b'}
+</geshi>
+
+is equivalent to
+
+<geshi lang="lua">
+    ngx.header.content_type = 'b'
+</geshi>
+
+Setting a slot to <code>nil</code> effectively removes it from the response headers:
+
+<geshi lang="lua">
+    ngx.header["X-My-Header"] = nil;
+</geshi>
+
+The same applies to assigning an empty table:
+
+<geshi lang="lua">
+    ngx.header["X-My-Header"] = {};
+</geshi>
+
+Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with [[#ngx.send_headers|ngx.send_headers]] or implicitly with [[#ngx.print|ngx.print]] and similar) will throw out a Lua exception.
+
+Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>. 
+
+Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.
+
+This is particularly useful in the context of [[#header_filter_by_lua|header_filter_by_lua]] and [[#header_filter_by_lua_file|header_filter_by_lua_file]], for example,
+
+<geshi lang="nginx">
+    location /test {
+        set $footer '';
+
+        proxy_pass http://some-backend;
+
+        header_filter_by_lua '
+            if ngx.header["X-My-Header"] == "blah" then
+                ngx.var.footer = "some value"
+            end
+        ';
+
+        echo_after_body $footer;
+    }
+</geshi>
+
+For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers
+
+<geshi lang="text">
+    Foo: bar
+    Foo: baz
+</geshi>
+
+will result in
+
+<geshi lang="lua">
+    {"bar", "baz"}
+</geshi>
+
+to be returned when reading <code>ngx.header.Foo</code>.
+
+Note that <code>ngx.header</code> is not a normal Lua table and as such, it is not possible to iterate through it using the Lua <code>ipairs</code> function.
+
+For reading ''request'' headers, use the [[#ngx.req.get_headers|ngx.req.get_headers]] function instead.
+
+== ngx.req.start_time ==
+'''syntax:''' ''secs = ngx.req.start_time()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''
+
+Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.
+
+The following example emulates the <code>$request_time</code> variable value (provided by [[HttpLogModule]]) in pure Lua:
+
+<geshi lang="lua">
+    local request_time = ngx.now() - ngx.req.start_time()
+</geshi>
+
+This function was first introduced in the <code>v0.7.7</code> release.
+
+See also [[#ngx.now|ngx.now]] and [[#ngx.update_time|ngx.update_time]].
+
+== ngx.req.http_version ==
+'''syntax:''' ''num = ngx.req.http_version()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
+
+Returns the HTTP version number for the current request as a Lua number.
+
+Current possible values are 1.0, 1.1, and 0.9. Returns <code>nil</code> for unrecognized values.
+
+This method was first introduced in the <code>v0.7.17</code> release.
+
+== ngx.req.raw_header ==
+'''syntax:''' ''str = ngx.req.raw_header(no_request_line?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
+
+Returns the original raw HTTP protocol header received by the Nginx server.
+
+By default, the request line and trailing <code>CR LF</code> terminator will also be included. For example,
+
+<geshi lang="lua">
+    ngx.print(ngx.req.raw_header())
+</geshi>
+
+gives something like this:
+
+<geshi lang="text">
+    GET /t HTTP/1.1
+    Host: localhost
+    Connection: close
+    Foo: bar
+
+</geshi>
+
+You can specify the optional
+<code>no_request_line</code> argument as a <code>true</code> value to exclude the request line from the result. For example,
+
+<geshi lang="lua">
+    ngx.print(ngx.req.raw_header(true))
+</geshi>
+
+outputs something like this:
+
+<geshi lang="text">
+    Host: localhost
+    Connection: close
+    Foo: bar
+
+</geshi>
+
+This method was first introduced in the <code>v0.7.17</code> release.
+
+== ngx.req.get_method ==
+'''syntax:''' ''method_name = ngx.req.get_method()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
+
+Retrieves the current request's request method name. Strings like <code>"GET"</code> and <code>"POST"</code> are returned instead of numerical [[#HTTP method constants|method constants]].
+
+If the current request is an Nginx subrequest, then the subrequest's method name will be returned.
+
+This method was first introduced in the <code>v0.5.6</code> release.
+
+See also [[#ngx.req.set_method|ngx.req.set_method]].
+
+== ngx.req.set_method ==
+'''syntax:''' ''ngx.req.set_method(method_id)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
+
+Overrides the current request's request method with the <code>request_id</code> argument. Currently only numerical [[#HTTP method constants|method constants]] are supported, like <code>ngx.HTTP_POST</code> and <code>ngx.HTTP_GET</code>.
+
+If the current request is an Nginx subrequest, then the subrequest's method will be overridden.
+
+This method was first introduced in the <code>v0.5.6</code> release.
+
+See also [[#ngx.req.get_method|ngx.req.get_method]].
+
+== ngx.req.set_uri ==
+'''syntax:''' ''ngx.req.set_uri(uri, jump?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''
+
+Rewrite the current request's (parsed) URI by the <code>uri</code> argument. The <code>uri</code> argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.
+
+The optional boolean <code>jump</code> argument can trigger location rematch (or location jump) as [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive, that is, when <code>jump</code> is <code>true</code> (default to <code>false</code>), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later <code>post-rewrite</code> phase and jumping to the new location.
+
+Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the <code>jump</code> argument is <code>false</code> or absent altogether.
+
+For example, the following nginx config snippet
+
+<geshi lang="nginx">
+    rewrite ^ /foo last;
+</geshi>
+
+can be coded in Lua like this:
+
+<geshi lang="lua">
+    ngx.req.set_uri("/foo", true)
+</geshi>
+
+Similarly, Nginx config
+
+<geshi lang="nginx">
+    rewrite ^ /foo break;
+</geshi>
+
+can be coded in Lua as
+
+<geshi lang="lua">
+    ngx.req.set_uri("/foo", false)
+</geshi>
+
+or equivalently,
+
+<geshi lang="lua">
+    ngx.req.set_uri("/foo")
+</geshi>
+
+The <code>jump</code> can only be set to <code>true</code> in [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]]. Use of jump in other contexts is prohibited and will throw out a Lua exception.
+
+A more sophisticated example involving regex substitutions is as follows
+
+<geshi lang="nginx">
+    location /test {
+        rewrite_by_lua '
+            local uri = ngx.re.sub(ngx.var.uri, "^/test/(.*)", "$1", "o")
+            ngx.req.set_uri(uri)
+        ';
+        proxy_pass http://my_backend;
+    }
+</geshi>
+
+which is functionally equivalent to
+
+<geshi lang="nginx">
+    location /test {
+        rewrite ^/test/(.*) /$1 break;
+        proxy_pass http://my_backend;
+    }
+</geshi>
+
+Note that it is not possible to use this interface to rewrite URI arguments and that [[#ngx.req.set_uri_args|ngx.req.set_uri_args]] should be used for this instead. For instance, Nginx config
+
+<geshi lang="nginx">
+    rewrite ^ /foo?a=3? last;
+</geshi>
+
+can be coded as
+
+<geshi lang="nginx">
+    ngx.req.set_uri_args("a=3")
+    ngx.req.set_uri("/foo", true)
+</geshi>
+
+or
+
+<geshi lang="nginx">
+    ngx.req.set_uri_args({a = 3})
+    ngx.req.set_uri("/foo", true)
+</geshi>
+
+This interface was first introduced in the <code>v0.3.1rc14</code> release.
+
+== ngx.req.set_uri_args ==
+'''syntax:''' ''ngx.req.set_uri_args(args)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''
+
+Rewrite the current request's URI query arguments by the <code>args</code> argument. The <code>args</code> argument can be either a Lua string, as in
+
+<geshi lang="lua">
+    ngx.req.set_uri_args("a=3&b=hello%20world")
+</geshi>
+
+or a Lua table holding the query arguments' key-value pairs, as in
+
+<geshi lang="lua">
+    ngx.req.set_uri_args({ a = 3, b = "hello world" })
+</geshi>
+
+where in the latter case, this method will escape argument keys and values according to the URI escaping rule.
+
+Multi-value arguments are also supported:
+
+<geshi lang="lua">
+    ngx.req.set_uri_args({ a = 3, b = {5, 6} })
+</geshi>
+
+which will result in a query string like <code>a=3&b=5&b=6</code>.
+
+This interface was first introduced in the <code>v0.3.1rc13</code> release.
+
+See also [[#ngx.req.set_uri|ngx.req.set_uri]].
+
+== ngx.req.get_uri_args ==
+'''syntax:''' ''args = ngx.req.get_uri_args(max_args?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''
+
+Returns a Lua table holding all the current request URL query arguments.
+
+<geshi lang="nginx">
+    location = /test {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            for key, val in pairs(args) do
+                if type(val) == "table" then
+                    ngx.say(key, ": ", table.concat(val, ", "))
+                else
+                    ngx.say(key, ": ", val)
+                end
+            end
+        ';
+    }
+</geshi>
+
+Then <code>GET /test?foo=bar&bar=baz&bar=blah</code> will yield the response body
+
+<geshi lang="bash">
+    foo: bar
+    bar: baz, blah
+</geshi>
+
+Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.
+
+Keys and values are unescaped according to URI escaping rules. In the settings above, <code>GET /test?a%20b=1%61+2</code> will yield:
+
+<geshi lang="bash">
+    a b: 1a 2
+</geshi>
+
+Arguments without the <code>=<value></code> parts are treated as boolean arguments. <code>GET /test?foo&bar</code> will yield:
+
+<geshi lang="bash">
+    foo: true
+    bar: true
+</geshi>
+
+That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>GET /test?foo=&bar=</code> will give something like
+
+<geshi lang="bash">
+    foo: 
+    bar: 
+</geshi>
+
+Empty key arguments are discarded. <code>GET /test?=hello&=world</code> will yield an empty output for instance.
+
+Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime is also supported:
+
+<geshi lang="lua">
+    ngx.var.args = "a=3&b=42"
+    local args = ngx.req.get_uri_args()
+</geshi>
+
+Here the <code>args</code> table will always look like
+
+<geshi lang="lua">
+    {a = 3, b = 42}
+</geshi>
+
+regardless of the actual request query string.
+
+Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.
+
+However, the optional <code>max_args</code> function argument can be used to override this limit:
+
+<geshi lang="lua">
+    local args = ngx.req.get_uri_args(10)
+</geshi>
+
+This argument can be set to zero to remove the limit and to process all request arguments received:
+
+<geshi lang="lua">
+    local args = ngx.req.get_uri_args(0)
+</geshi>
+
+Removing the <code>max_args</code> cap is strongly discouraged.
+
+== ngx.req.get_post_args ==
+'''syntax:''' ''args, err = ngx.req.get_post_args(max_args?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''
+
+Returns a Lua table holding all the current request POST query arguments (of the MIME type <code>application/x-www-form-urlencoded</code>). Call [[#ngx.req.read_body|ngx.req.read_body]] to read the request body first or turn on the [[#lua_need_request_body|lua_need_request_body]] directive to avoid errors.
+
+<geshi lang="nginx">
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            local args = ngx.req.get_post_args()
+            if not args then
+                ngx.say("failed to get post args: ", err)
+                return
+            end
+            for key, val in pairs(args) do
+                if type(val) == "table" then
+                    ngx.say(key, ": ", table.concat(val, ", "))
+                else
+                    ngx.say(key, ": ", val)
+                end
+            end
+        ';
+    }
+</geshi>
+
+Then
+
+<geshi lang="bash">
+    # Post request with the body 'foo=bar&bar=baz&bar=blah'
+    $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
+</geshi>
+
+will yield the response body like
+
+<geshi lang="bash">
+    foo: bar
+    bar: baz, blah
+</geshi>
+
+Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.
+
+Keys and values will be unescaped according to URI escaping rules.
+
+With the settings above,
+
+<geshi lang="bash">
+    # POST request with body 'a%20b=1%61+2'
+    $ curl -d 'a%20b=1%61+2' localhost/test
+</geshi>
+
+will yield:
+
+<geshi lang="bash">
+    a b: 1a 2
+</geshi>
+
+Arguments without the <code>=<value></code> parts are treated as boolean arguments. <code>GET /test?foo&bar</code> will yield:
+
+<geshi lang="bash">
+    foo: true
+    bar: true
+</geshi>
+
+That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>POST /test</code> with request body <code>foo=&bar=</code> will return something like
+
+<geshi lang="bash">
+    foo: 
+    bar: 
+</geshi>
+
+Empty key arguments are discarded. <code>POST /test</code> with body <code>=hello&=world</code> will yield empty outputs for instance.
+
+Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.  
+
+However, the optional <code>max_args</code> function argument can be used to override this limit:
+
+<geshi lang="lua">
+    local args = ngx.req.get_post_args(10)
+</geshi>
+
+This argument can be set to zero to remove the limit and to process all request arguments received:
+
+<geshi lang="lua">
+    local args = ngx.req.get_post_args(0)
+</geshi>
+
+Removing the <code>max_args</code> cap is strongly discouraged.
+
+== ngx.req.get_headers ==
+'''syntax:''' ''headers = ngx.req.get_headers(max_headers?, raw?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''
+
+Returns a Lua table holding all the current request headers.
+
+<geshi lang="lua">
+    local h = ngx.req.get_headers()
+    for k, v in pairs(h) do
+        ...
+    end
+</geshi>
+
+To read an individual header:
+
+<geshi lang="lua">
+    ngx.say("Host: ", ngx.req.get_headers()["Host"])
+</geshi>
+
+Note that the [[#ngx.var.VARIABLE|ngx.var.HEADER]] API call, which uses core [[HttpCoreModule#$http_HEADER|$http_HEADER]] variables, may be more preferable for reading individual request headers.
+
+For multiple instances of request headers such as:
+
+<geshi lang="bash">
+    Foo: foo
+    Foo: bar
+    Foo: baz
+</geshi>
+
+the value of <code>ngx.req.get_headers()["Foo"]</code> will be a Lua (array) table such as:
+
+<geshi lang="lua">
+    {"foo", "bar", "baz"}
+</geshi>
+
+Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.  
+
+However, the optional <code>max_headers</code> function argument can be used to override this limit:
+
+<geshi lang="lua">
+    local args = ngx.req.get_headers(10)
+</geshi>
+
+This argument can be set to zero to remove the limit and to process all request headers received:
+
+<geshi lang="lua">
+    local args = ngx.req.get_headers(0)
+</geshi>
+
+Removing the <code>max_headers</code> cap is strongly discouraged.
+
+Since the <code>0.6.9</code> release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the <code>raw</code> argument is set to <code>true</code> (default to <code>false</code>).
+
+Also, by default, an <code>__index</code> metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header <code>My-Foo-Header</code> is present, then the following invocations will all pick up the value of this header correctly:
+
+<geshi lang="lua">
+    ngx.say(headers.my_foo_header)
+    ngx.say(headers["My-Foo-Header"])
+    ngx.say(headers["my-foo-header"])
+</geshi>
+
+The <code>__index</code> metamethod will not be added when the <code>raw</code> argument is set to <code>true</code>.
+
+== ngx.req.set_header ==
+'''syntax:''' ''ngx.req.set_header(header_name, header_value)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua''
+
+Set the current request's request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.
+
+By default, all the subrequests subsequently initiated by [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] will inherit the new header.
+
+Here is an example of setting the <code>Content-Length</code> header:
+
+<geshi lang="lua">
+    ngx.req.set_header("Content-Type", "text/css")
+</geshi>
+
+The <code>header_value</code> can take an array list of values,
+for example,
+
+<geshi lang="lua">
+    ngx.req.set_header("Foo", {"a", "abc"})
+</geshi>
+
+will produce two new request headers:
+
+<geshi lang="bash">
+    Foo: a
+    Foo: abc
+</geshi>
+
+and old <code>Foo</code> headers will be overridden if there is any.
+
+When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So
+
+<geshi lang="lua">
+    ngx.req.set_header("X-Foo", nil)
+</geshi>
+
+is equivalent to
+
+<geshi lang="lua">
+    ngx.req.clear_header("X-Foo")
+</geshi>
+
+== ngx.req.clear_header ==
+'''syntax:''' ''ngx.req.clear_header(header_name)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''
+
+Clear the current request's request header named <code>header_name</code>. None of the current request's subrequests will be affected.
+
+== ngx.req.read_body ==
+'''syntax:''' ''ngx.req.read_body()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Reads the client request body synchronously without blocking the Nginx event loop.
+
+<geshi lang="lua">
+    ngx.req.read_body()
+    local args = ngx.req.get_post_args()
+</geshi>
+
+If the request body is already read previously by turning on [[#lua_need_request_body|lua_need_request_body]] or by using other modules, then this function does not run and returns immediately.
+
+If the request body has already been explicitly discarded, either by the [[#ngx.req.discard_body|ngx.req.discard_body]] function or other modules, this function does not run and returns immediately.
+
+In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception ''or'' terminate the current request with a 500 status code immediately.
+
+The request body data read using this function can be retrieved later via [[#ngx.req.get_body_data|ngx.req.get_body_data]] or, alternatively, the temporary file name for the body data cached to disk using [[#ngx.req.get_body_file|ngx.req.get_body_file]]. This depends on
+
+# whether the current request body is already larger than the [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]],
+# and whether [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]] has been switched on.
+
+In cases where current request may have a request body and the request body data is not required, The [[#ngx.req.discard_body|ngx.req.discard_body]] function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
+
+This function was first introduced in the <code>v0.3.1rc17</code> release.
+
+== ngx.req.discard_body ==
+'''syntax:''' ''ngx.req.discard_body()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately. Please note that ignoring request body is not the right way to discard it, and that this function must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
+
+This function is an asynchronous call and returns immediately.
+
+If the request body has already been read, this function does nothing and returns immediately.
+
+This function was first introduced in the <code>v0.3.1rc17</code> release.
+
+See also [[#ngx.req.read_body|ngx.req.read_body]].
+
+== ngx.req.get_body_data ==
+'''syntax:''' ''data = ngx.req.get_body_data()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [[#ngx.req.get_post_args|ngx.req.get_post_args]] function instead if a Lua table is required.
+
+This function returns <code>nil</code> if
+# the request body has not been read,
+# the request body has been read into disk temporary files,
+# or the request body has zero size.
+
+If the request body has not been read yet, call [[#ngx.req.read_body|ngx.req.read_body]] first (or turned on [[#lua_need_request_body|lua_need_request_body]] to force this module to read the request body. This is not recommended however).
+
+If the request body has been read into disk files, try calling the [[#ngx.req.get_body_file|ngx.req.get_body_file]] function instead.
+
+To force in-memory request bodies, try setting [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] to the same size value in [[HttpCoreModule#client_max_body_size|client_max_body_size]].
+
+Note that calling this function instead of using <code>ngx.var.request_body</code> or <code>ngx.var.echo_request_body</code> is more efficient because it can save one dynamic memory allocation and one data copy.
+
+This function was first introduced in the <code>v0.3.1rc17</code> release.
+
+See also [[#ngx.req.get_body_file|ngx.req.get_body_file]].
+
+== ngx.req.get_body_file ==
+'''syntax:''' ''file_name = ngx.req.get_body_file()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Retrieves the file name for the in-file request body data. Returns <code>nil</code> if the request body has not been read or has been read into memory.
+
+The returned file is read only and is usually cleaned up by Nginx's memory pool. It should not be manually modified, renamed, or removed in Lua code.
+
+If the request body has not been read yet, call [[#ngx.req.read_body|ngx.req.read_body]] first (or turned on [[#lua_need_request_body|lua_need_request_body]] to force this module to read the request body. This is not recommended however).
+
+If the request body has been read into memory, try calling the [[#ngx.req.get_body_data|ngx.req.get_body_data]] function instead.
+
+To force in-file request bodies, try turning on [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]].
+
+This function was first introduced in the <code>v0.3.1rc17</code> release.
+
+See also [[#ngx.req.get_body_data|ngx.req.get_body_data]].
+
+== ngx.req.set_body_data ==
+'''syntax:''' ''ngx.req.set_body_data(data)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Set the current request's request body using the in-memory data specified by the <code>data</code> argument.
+
+If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.
+
+This function was first introduced in the <code>v0.3.1rc18</code> release.
+
+See also [[#ngx.req.set_body_file|ngx.req.set_body_file]].
+
+== ngx.req.set_body_file ==
+'''syntax:''' ''ngx.req.set_body_file(file_name, auto_clean?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Set the current request's request body using the in-file data specified by the <code>file_name</code> argument.
+
+If the optional <code>auto_clean</code> argument is given a <code>true</code> value, then this file will be removed at request completion or the next time this function or [[#ngx.req.set_body_data|ngx.req.set_body_data]] are called in the same request. The <code>auto_clean</code> is default to <code>false</code>.
+
+Please ensure that the file specified by the <code>file_name</code> argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.
+
+If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.
+
+This function was first introduced in the <code>v0.3.1rc18</code> release.
+
+See also [[#ngx.req.set_body_data|ngx.req.set_body_data]].
+
+== ngx.req.init_body ==
+'''syntax:''' ''ngx.req.init_body(buffer_size?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [[#ngx.req.append_body|ngx.req.append_body]] and [[#ngx.req.finish_body|ngx.req.finish_body]] APIs.
+
+If the <code>buffer_size</code> argument is specified, then its value will be used for the size of the memory buffer for body writing with [[#ngx.req.append_body|ngx.req.append_body]]. If the argument is omitted, then the value specified by the standard [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] directive will be used instead.
+
+When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.
+
+It is important to always call the [[#ngx.req.finish_body|ngx.req.finish_body]] after all the data has been appended onto the current request body. Also, when this function is used together with [[#ngx.req.socket|ngx.req.socket]], it is required to call [[#ngx.req.socket|ngx.req.socket]] ''before'' this function, or you will get the "request body already exists" error message.
+
+The usage of this function is often like this:
+
+<geshi lang="lua">
+    ngx.req.init_body(128 * 1024)  -- buffer is 128KB
+    for chunk in next_data_chunk() do
+        ngx.req.append_body(chunk) -- each chunk can be 4KB
+    end
+    ngx.req.finish_body()
+</geshi>
+
+This function can be used with [[#ngx.req.append_body|ngx.req.append_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].
+
+This function was first introduced in the <code>v0.5.11</code> release.
+
+== ngx.req.append_body ==
+'''syntax:''' ''ngx.req.append_body(data_chunk)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Append new data chunk specified by the <code>data_chunk</code> argument onto the existing request body created by the [[#ngx.req.init_body|ngx.req.init_body]] call.
+
+When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.
+
+It is important to always call the [[#ngx.req.finish_body|ngx.req.finish_body]] after all the data has been appended onto the current request body.
+
+This function can be used with [[#ngx.req.init_body|ngx.req.init_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].
+
+This function was first introduced in the <code>v0.5.11</code> release.
+
+See also [[#ngx.req.init_body|ngx.req.init_body]].
+
+== ngx.req.finish_body ==
+'''syntax:''' ''ngx.req.finish_body()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Completes the construction process of the new request body created by the [[#ngx.req.init_body|ngx.req.init_body]] and [[#ngx.req.append_body|ngx.req.append_body]] calls.
+
+This function can be used with [[#ngx.req.init_body|ngx.req.init_body]], [[#ngx.req.append_body|ngx.req.append_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].
+
+This function was first introduced in the <code>v0.5.11</code> release.
+
+See also [[#ngx.req.init_body|ngx.req.init_body]].
+
+== ngx.req.socket ==
+'''syntax:''' ''tcpsock, err = ngx.req.socket()''
+
+'''syntax:''' ''tcpsock, err = ngx.req.socket(raw)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Returns a read-only cosocket object that wraps the downstream connection. Only [[#tcpsock:receive|receive]] and [[#tcpsock:receiveuntil|receiveuntil]] methods are supported on this object.
+
+In case of error, <code>nil</code> will be returned as well as a string describing the error.
+
+The socket object returned by this method is usually used to read the current request's body in a streaming fashion. Do not turn on the [[#lua_need_request_body|lua_need_request_body]] directive, and do not mix this call with [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]].
+
+If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading.
+Chunked request bodies are not yet supported in this API.
+
+Since the <code>v0.9.0</code> release, this function accepts an optional boolean <code>raw</code> argument. When this argument is <code>true</code>, this function returns a full duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the [[#tcpsock:receive|receive]], [[#tcpsock:receiveuntil|receiveuntil]], and [[#tcpsock:send|send]] methods.
+
+When the <code>raw</code> argument is <code>true</code>, it is required that no pending data from any previous [[#ngx.say|ngx.say]], [[#ngx.print|ngx.print]], or [[#ngx.send_headers|ngx.send_headers]] calls exists. So if you have these downstream output calls previously, you should call [[#ngx.flush|ngx.flush(true)]] before calling <code>ngx.req.socket(true)</code> to ensure that there is no pending output data. Another requirement for this case is that the request body must have already been read completely.
+
+You can use the "raw request socket" returned by <code>ngx.req.socket(true)</code> to implement fancy protocols like [http://en.wikipedia.org/wiki/WebSocket WebSocket], or just emit your own raw HTTP response header or body data. You can refer to the [https://github.com/agentzh/lua-resty-websocket lua-resty-websocket library] for a real world example.
+
+This function was first introduced in the <code>v0.5.0rc1</code> release.
+
+== ngx.exec ==
+'''syntax:''' ''ngx.exec(uri, args?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Does an internal redirect to <code>uri</code> with <code>args</code>.
+
+<geshi lang="lua">
+    ngx.exec('/some-location');
+    ngx.exec('/some-location', 'a=3&b=5&c=6');
+    ngx.exec('/some-location?a=3&b=5', 'c=6');
+</geshi>
+
+Named locations are also supported, but query strings are ignored. For example,
+
+<geshi lang="nginx">
+    location /foo {
+        content_by_lua '
+            ngx.exec("@bar");
+        ';
+    }
+ 
+    location @bar {
+        ...
+    }
+</geshi>
+
+The optional second <code>args</code> can be used to specify extra URI query arguments, for example:
+
+<geshi lang="lua">
+    ngx.exec("/foo", "a=3&b=hello%20world")
+</geshi>
+
+Alternatively, a Lua table can be passed for the <code>args</code> argument for ngx_lua to carry out URI escaping and string concatenation.
+
+<geshi lang="lua">
+    ngx.exec("/foo", { a = 3, b = "hello world" })
+</geshi>
+
+The result is exactly the same as the previous example. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [[#ngx.encode_args|ngx.encode_args]] method.
+
+Note that this is very different from [[#ngx.redirect|ngx.redirect]] in that
+it is just an internal redirect and no new HTTP traffic is involved.
+
+This method never returns.
+
+This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body
+outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].
+
+It is strongly recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.exec(...)</code>.
+
+This method is similar to the [[HttpEchoModule#echo_exec|echo_exec]] directive of the [[HttpEchoModule]].
+
+== ngx.redirect ==
+'''syntax:''' ''ngx.redirect(uri, status?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Issue an <code>HTTP 301</code> or <code>302</code> redirection to <code>uri</code>.
+
+The optional <code>status</code> parameter specifies whether
+<code>301</code> or <code>302</code> to be used. It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.
+
+Here is an example assuming the current server name is <code>localhost</code> and that it is listening on Port 1984:
+
+<geshi lang="lua">
+    return ngx.redirect("/foo")
+</geshi>
+
+which is equivalent to
+
+<geshi lang="lua">
+    return ngx.redirect("http://localhost:1984/foo", ngx.HTTP_MOVED_TEMPORARILY)
+</geshi>
+
+Redirecting arbitrary external URLs is also supported, for example:
+
+<geshi lang="lua">
+    return ngx.redirect("http://www.google.com")
+</geshi>
+
+We can also use the numerical code directly as the second <code>status</code> argument:
+
+<geshi lang="lua">
+    return ngx.redirect("/foo", 301)
+</geshi>
+
+This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].
+
+This method is very much like the [[HttpRewriteModule#rewrite|rewrite]] directive with the <code>redirect</code> modifier in the standard
+[[HttpRewriteModule]], for example, this <code>nginx.conf</code> snippet
+
+<geshi lang="nginx">
+    rewrite ^ /foo? redirect;  # nginx config
+</geshi>
+
+is equivalent to the following Lua code
+
+<geshi lang="lua">
+    return ngx.redirect('/foo');  -- Lua code
+</geshi>
+
+while
+
+<geshi lang="nginx">
+    rewrite ^ /foo? permanent;  # nginx config
+</geshi>
+
+is equivalent to
+
+<geshi lang="lua">
+    return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
+</geshi>
+
+URI arguments can be specified as well, for example:
+
+<geshi lang="lua">
+    return ngx.redirect('/foo?a=3&b=4')
+</geshi>
+
+This method call terminates the current request's processing and never returns. It is recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.redirect(...)</code>, so as to be more explicit.
+
+== ngx.send_headers ==
+'''syntax:''' ''ok, err = ngx.send_headers()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Explicitly send out the response headers.
+
+Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
+
+Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out
+before content is output with [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] or when [[#content_by_lua|content_by_lua]] exits normally.
+
+== ngx.headers_sent ==
+'''syntax:''' ''value = ngx.headers_sent''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.
+
+This API was first introduced in ngx_lua v0.3.1rc6.
+
+== ngx.print ==
+'''syntax:''' ''ok, err = ngx.print(...)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.
+
+Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
+
+Lua <code>nil</code> values will output <code>"nil"</code> strings and Lua boolean values will output <code>"true"</code> and <code>"false"</code> literal strings respectively.
+
+Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:
+
+<geshi lang="lua">
+    local table = {
+        "hello, ",
+        {"world: ", true, " or ", false,
+            {": ", nil}}
+    }
+    ngx.print(table)
+</geshi>
+
+will yield the output
+
+<geshi lang="bash">
+    hello, world: true or false: nil
+</geshi>
+
+Non-array table arguments will cause a Lua exception to be thrown.
+
+The <code>ngx.null</code> constant will yield the <code>"null"</code> string output.
+
+This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call <code>ngx.flush(true)</code> after calling <code>ngx.print</code>. This can be particularly useful for streaming output. See [[#ngx.flush|ngx.flush]] for more details.
+
+Please note that both <code>ngx.print</code> and [[#ngx.say|ngx.say]] will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.
+
+== ngx.say ==
+'''syntax:''' ''ok, err = ngx.say(...)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Just as [[#ngx.print|ngx.print]] but also emit a trailing newline.
+
+== ngx.log ==
+'''syntax:''' ''ngx.log(log_level, ...)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Log arguments concatenated to error.log with the given logging level.
+
+Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code> string while Lua booleans result in literal <code>"true"</code> or <code>"false"</code> string outputs. And the <code>ngx.null</code> constant will yield the <code>"null"</code> string output.
+
+The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out [[#Nginx log level constants|Nginx log level constants]] for details.
+
+There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.
+
+== ngx.flush ==
+'''syntax:''' ''ok, err = ngx.flush(wait?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Flushes response output to the client. 
+
+<code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode. 
+
+In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the [[HttpCoreModule#send_timeout|send_timeout]] setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.
+
+When <code>ngx.flush(true)</code> is called immediately after [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]], it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.
+
+Note that <code>ngx.flush</code> is non functional when in the HTTP 1.0 output buffering mode. See [[#HTTP 1.0 support|HTTP 1.0 support]].
+
+Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
+
+== ngx.exit ==
+'''syntax:''' ''ngx.exit(status)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+When <code>status >= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.
+
+When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the [[#content_by_lua|content_by_lua]] directive is used) and continue to run later phases (if any) for the current request.
+
+The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>,
+<code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other [[#HTTP status constants|HTTP status constants]].
+
+To return an error page with custom contents, use code snippets like this:
+
+<geshi lang="lua">
+    ngx.status = ngx.HTTP_GONE
+    ngx.say("This is our own content")
+    -- to cause quit the whole request rather than the current phase handler
+    ngx.exit(ngx.HTTP_OK)
+</geshi>
+
+The effect in action:
+
+<geshi lang="bash">
+    $ curl -i http://localhost/test
+    HTTP/1.1 410 Gone
+    Server: nginx/1.0.6
+    Date: Thu, 15 Sep 2011 00:51:48 GMT
+    Content-Type: text/plain
+    Transfer-Encoding: chunked
+    Connection: keep-alive
+
+    This is our own content
+</geshi>
+
+Number literals can be used directly as the argument, for instance,
+
+<geshi lang="lua">
+    ngx.exit(501)
+</geshi>
+
+Note that while this method accepts all [[#HTTP status constants|HTTP status constants]] as input, it only accepts <code>NGX_OK</code> and <code>NGX_ERROR</code> of the [[#core constants|core constants]].
+
+It is recommended, though not necessary, to combine the <code>return</code> statement with this call, i.e., <code>return ngx.exit(...)</code>, to give a visual hint to others reading the code.
+
+== ngx.eof ==
+'''syntax:''' ''ok, err = ngx.eof()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the "last chunk".
+
+When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on descent HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:
+
+<geshi lang="nginx">
+    location = /async {
+        keepalive_timeout 0;
+        content_by_lua '
+            ngx.say("got the task!")
+            ngx.eof()  -- descent HTTP client will close the connection at this point
+            -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...
+        ';
+    }
+</geshi>
+
+But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard [[HttpProxyModule]] will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the [[HttpProxyModule#proxy_ignore_client_abort|proxy_ignore_client_abort]] directive in your location block configured by [[HttpProxyModule]]:
+
+<geshi lang="nginx">
+    proxy_ignore_client_abort on;
+</geshi>
+
+Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
+
+== ngx.sleep ==
+'''syntax:''' ''ngx.sleep(seconds)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).
+
+Behind the scene, this method makes use of the Nginx timers.
+
+Since the <code>0.7.20</code> release, The <code>0</code> time argument can also be specified.
+
+This method was introduced in the <code>0.5.0rc30</code> release.
+
+== ngx.escape_uri ==
+'''syntax:''' ''newstr = ngx.escape_uri(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Escape <code>str</code> as a URI component.
+
+== ngx.unescape_uri ==
+'''syntax:''' ''newstr = ngx.unescape_uri(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Unescape <code>str</code> as an escaped URI component.
+
+For example,
+
+<geshi lang="lua">
+    ngx.say(ngx.unescape_uri("b%20r56+7"))
+</geshi>
+
+gives the output
+
+<geshi lang="text">
+    b r56 7
+</geshi>
+
+== ngx.encode_args ==
+'''syntax:''' ''str = ngx.encode_args(table)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Encode the Lua table to a query args string according to the URI encoded rules.
+
+For example,
+
+<geshi lang="lua">
+    ngx.encode_args({foo = 3, ["b r"] = "hello world"})
+</geshi>
+
+yields
+
+<geshi lang="text">
+    foo=3&b%20r=hello%20world
+</geshi>
+
+The table keys must be Lua strings.
+
+Multi-value query args are also supported. Just use a Lua table for the argument's value, for example:
+
+<geshi lang="lua">
+    ngx.encode_args({baz = {32, "hello"}})
+</geshi>
+
+gives
+
+<geshi lang="text">
+    baz=32&baz=hello
+</geshi>
+
+If the value table is empty and the effect is equivalent to the <code>nil</code> value.
+
+Boolean argument values are also supported, for instance,
+
+<geshi lang="lua">
+    ngx.encode_args({a = true, b = 1})
+</geshi>
+
+yields
+
+<geshi lang="text">
+    a&b=1
+</geshi>
+
+If the argument value is <code>false</code>, then the effect is equivalent to the <code>nil</code> value.
+
+This method was first introduced in the <code>v0.3.1rc27</code> release.
+
+== ngx.decode_args ==
+'''syntax:''' ''table = ngx.decode_args(str, max_args?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Decodes a URI encoded query-string into a Lua table. This is the inverse function of [[#ngx.encode_args|ngx.encode_args]].
+
+The optional <code>max_args</code> argument can be used to specify the maximum number of arguments parsed from the <code>str</code> argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks.
+
+This argument can be set to zero to remove the limit and to process all request arguments received:
+
+<geshi lang="lua">
+    local args = ngx.decode_args(str, 0)
+</geshi>
+
+Removing the <code>max_args</code> cap is strongly discouraged.
+
+This method was introduced in the <code>v0.5.0rc29</code>.
+
+== ngx.encode_base64 ==
+'''syntax:''' ''newstr = ngx.encode_base64(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Encode <code>str</code> to a base64 digest.
+
+== ngx.decode_base64 ==
+'''syntax:''' ''newstr = ngx.decode_base64(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.
+
+== ngx.crc32_short ==
+'''syntax:''' ''intval = ngx.crc32_short(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.
+
+This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to [[#ngx.crc32_long|ngx.crc32_long]]. The result is exactly the same as [[#ngx.crc32_long|ngx.crc32_long]].
+
+Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.
+
+This API was first introduced in the <code>v0.3.1rc8</code> release.
+
+== ngx.crc32_long ==
+'''syntax:''' ''intval = ngx.crc32_long(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.
+
+This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to [[#ngx.crc32_short|ngx.crc32_short]].  The result is exactly the same as [[#ngx.crc32_short|ngx.crc32_short]].
+
+Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.
+
+This API was first introduced in the <code>v0.3.1rc8</code> release.
+
+== ngx.hmac_sha1 ==
+'''syntax:''' ''digest = ngx.hmac_sha1(secret_key, str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Computes the [http://en.wikipedia.org/wiki/HMAC HMAC-SHA1] digest of the argument <code>str</code> and turns the result using the secret key <code><secret_key></code>.
+
+The raw binary form of the <code>HMAC-SHA1</code> digest will be generated, use [[#ngx.encode_base64|ngx.encode_base64]], for example, to encode the result to a textual representation if desired.
+
+For example,
+
+<geshi lang="lua">
+    local key = "thisisverysecretstuff"
+    local src = "some string we want to sign"
+    local digest = ngx.hmac_sha1(key, src)
+    ngx.say(ngx.encode_base64(digest))
+</geshi>
+
+yields the output
+
+<geshi lang="text">
+    R/pvxzHC4NLtj7S+kXFg/NePTmk=
+</geshi>
+
+This API requires the OpenSSL library enabled in the Nginx build (usually by passing the <code>--with-http_ssl_module</code> option to the <code>./configure</code> script).
+
+This function was first introduced in the <code>v0.3.1rc29</code> release.
+
+== ngx.md5 ==
+'''syntax:''' ''digest = ngx.md5(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns the hexadecimal representation of the MD5 digest of the <code>str</code> argument.
+
+For example,
+
+<geshi lang="nginx">
+    location = /md5 {
+        content_by_lua 'ngx.say(ngx.md5("hello"))';
+    }
+</geshi>
+
+yields the output
+
+<geshi lang="text">
+    5d41402abc4b2a76b9719d911017c592
+</geshi>
+
+See [[#ngx.md5_bin|ngx.md5_bin]] if the raw binary MD5 digest is required.
+
+== ngx.md5_bin ==
+'''syntax:''' ''digest = ngx.md5_bin(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns the binary form of the MD5 digest of the <code>str</code> argument.
+
+See [[#ngx.md5|ngx.md5]] if the hexadecimal form of the MD5 digest is required.
+
+== ngx.sha1_bin ==
+'''syntax:''' ''digest = ngx.sha1_bin(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns the binary form of the SHA-1 digest of the <code>str</code> argument.
+
+This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).
+
+This function was first introduced in the <code>v0.5.0rc6</code>.
+
+== ngx.quote_sql_str ==
+'''syntax:''' ''quoted_value = ngx.quote_sql_str(raw_value)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns a quoted SQL string literal according to the MySQL quoting rules.
+
+== ngx.today ==
+'''syntax:''' ''str = ngx.today()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns current date (in the format <code>yyyy-mm-dd</code>) from the nginx cached time (no syscall involved unlike Lua's date library).
+
+This is the local time.
+
+== ngx.time ==
+'''syntax:''' ''secs = ngx.time()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).
+
+Updates of the Nginx time cache an be forced by calling [[#ngx.update_time|ngx.update_time]] first.
+
+== ngx.now ==
+'''syntax:''' ''secs = ngx.now()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).
+
+You can forcibly update the Nginx time cache by calling [[#ngx.update_time|ngx.update_time]] first.
+
+This API was first introduced in <code>v0.3.1rc32</code>.
+
+== ngx.update_time ==
+'''syntax:''' ''ngx.update_time()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.
+
+This API was first introduced in <code>v0.3.1rc32</code>.
+
+== ngx.localtime ==
+'''syntax:''' ''str = ngx.localtime()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).
+
+This is the local time.
+
+== ngx.utctime ==
+'''syntax:''' ''str = ngx.utctime()''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).
+
+This is the UTC time.
+
+== ngx.cookie_time ==
+'''syntax:''' ''str = ngx.cookie_time(sec)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns a formated string can be used as the cookie expiration time. The parameter <code>sec</code> is the time stamp in seconds (like those returned from [[#ngx.time|ngx.time]]).
+
+<geshi lang="nginx">
+    ngx.say(ngx.cookie_time(1290079655))
+        -- yields "Thu, 18-Nov-10 11:27:35 GMT"
+</geshi>
+
+== ngx.http_time ==
+'''syntax:''' ''str = ngx.http_time(sec)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the time stamp in seconds (like those returned from [[#ngx.time|ngx.time]]).
+
+<geshi lang="nginx">
+    ngx.say(ngx.http_time(1290079655))
+        -- yields "Thu, 18 Nov 2010 11:27:35 GMT"
+</geshi>
+
+== ngx.parse_http_time ==
+'''syntax:''' ''sec = ngx.parse_http_time(str)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Parse the http time string (as returned by [[#ngx.http_time|ngx.http_time]]) into seconds. Returns the seconds or <code>nil</code> if the input string is in bad forms.
+
+<geshi lang="nginx">
+    local time = ngx.parse_http_time("Thu, 18 Nov 2010 11:27:35 GMT")
+    if time == nil then
+        ...
+    end
+</geshi>
+
+== ngx.is_subrequest ==
+'''syntax:''' ''value = ngx.is_subrequest''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''
+
+Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.
+
+== ngx.re.match ==
+'''syntax:''' ''captures, err = ngx.re.match(subject, regex, options?, ctx?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Matches the <code>subject</code> string using the Perl compatible regular expression <code>regex</code> with the optional <code>options</code>.
+
+Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, <code>nil</code> and a string describing the error will be returned.
+
+When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized sub-pattern's capturing, <code>captures[2]</code> the second, and so on.
+
+<geshi lang="lua">
+    local m, err = ngx.re.match("hello, 1234", "[0-9]+")
+    if m then
+        -- m[0] == "1234"
+
+    else
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        ngx.say("match not found")
+    end
+</geshi>
+
+<geshi lang="lua">
+    local m, err = ngx.re.match("hello, 1234", "([0-9])[0-9]+")
+    -- m[0] == "1234"
+    -- m[1] == "1"
+</geshi>
+
+Named captures are also supported since the <code>v0.7.14</code> release
+and are returned in the same Lua table as key-value pairs as the numbered captures.
+
+<geshi lang="lua">
+    local m, err = ngx.re.match("hello, 1234", "([0-9])(?<remaining>[0-9]+)")
+    -- m[0] == "1234"
+    -- m[1] == "1"
+    -- m[2] == "234"
+    -- m["remaining"] == "234"
+</geshi>
+
+Unmatched subpatterns will have <code>nil</code> values in their <code>captures</code> table fields.
+
+<geshi lang="lua">
+    local m, err = ngx.re.match("hello, world", "(world)|(hello)|(?<named>howdy)")
+    -- m[0] == "hello"
+    -- m[1] == nil
+    -- m[2] == "hello"
+    -- m[3] == nil
+    -- m["named"] == nil
+</geshi>
+
+Specify <code>options</code> to control how the match operation will be performed. The following option characters are supported:
+
+<geshi lang="text">
+    a             anchored mode (only match from the beginning)
+
+    d             enable the DFA mode (or the longest token match semantics).
+                  this requires PCRE 6.0+ or else a Lua exception will be thrown.
+                  first introduced in ngx_lua v0.3.1rc30.
+
+    D             enable duplicate named pattern support. This allows named
+                  subpattern names to be repeated, returning the captures in
+                  an array-like Lua table. for example,
+                    local m = ngx.re.match("hello, world",
+                                           "(?<named>\w+), (?<named>\w+)",
+                                           "D")
+                    -- m["named"] == {"hello", "world"}
+                  this option was first introduced in the v0.7.14 release.
+                  this option requires at least PCRE 8.12.
+
+    i             case insensitive mode (similar to Perl's /i modifier)
+
+    j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
+                  must be built with the --enable-jit option. for optimum performance,
+                  this option should always be used together with the 'o' option.
+                  first introduced in ngx_lua v0.3.1rc30.
+
+    J             enable the PCRE Javascript compatible mode. this option was
+                  first introduced in the v0.7.14 release. this option requires
+                  at least PCRE 8.12.
+
+    m             multi-line mode (similar to Perl's /m modifier)
+
+    o             compile-once mode (similar to Perl's /o modifier),
+                  to enable the worker-process-level compiled-regex cache
+
+    s             single-line mode (similar to Perl's /s modifier)
+
+    u             UTF-8 mode. this requires PCRE to be built with
+                  the --enable-utf8 option or else a Lua exception will be thrown.
+
+    U             similar to "u" but disables PCRE's UTF-8 validity check on
+                  the subject string. first introduced in ngx_lua v0.8.1.
+
+    x             extended mode (similar to Perl's /x modifier)
+</geshi>
+
+These options can be combined:
+
+<geshi lang="nginx">
+    local m, err = ngx.re.match("hello, world", "HEL LO", "ix")
+    -- m[0] == "hello"
+</geshi>
+
+<geshi lang="nginx">
+    local m, err = ngx.re.match("hello, 美好生活", "HELLO, (.{2})", "iu")
+    -- m[0] == "hello, 美好"
+    -- m[1] == "美好"
+</geshi>
+
+The <code>o</code> option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [[#lua_regex_cache_max_entries|lua_regex_cache_max_entries]] directive.
+
+The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset. Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position ''after'' the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will be left intact.
+
+<geshi lang="lua">
+    local ctx = {}
+    local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
+         -- m[0] = "1234"
+         -- ctx.pos == 4
+</geshi>
+
+<geshi lang="lua">
+    local ctx = { pos = 2 }
+    local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
+         -- m[0] = "34"
+         -- ctx.pos == 4
+</geshi>
+
+The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.
+
+Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified and that the empty Lua string (<code>""</code>) must be used as placeholder for <code>options</code> if no meaningful regex options are required.
+
+This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).
+
+To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the <code>--with-debug</code> option to Nginx or ngx_openresty's <code>./configure</code> script. Then, enable the "debug" error log level in <code>error_log</code> directive. The following message will be generated if PCRE JIT is enabled:
+
+<geshi lang="text">
+    pcre JIT compiling result: 1
+</geshi>
+
+This feature was introduced in the <code>v0.2.1rc11</code> release.
+
+== ngx.re.gmatch ==
+'''syntax:''' ''iterator, err = ngx.re.gmatch(subject, regex, options?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Similar to [[#ngx.re.match|ngx.re.match]], but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the <code><subject></code> string argument with the PCRE <code>regex</code>.
+
+In case of errors, like seeing an ill-formed regular expression, <code>nil</code> and a string describing the error will be returned.
+
+Here is a small example to demonstrate its basic usage:
+
+<geshi lang="lua">
+    local iterator, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
+    if not iterator then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    local m
+    m, err = iterator()    -- m[0] == m[1] == "hello"
+    if err then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    m, err = iterator()    -- m[0] == m[1] == "world"
+    if err then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    m, err = iterator()    -- m == nil
+    if err then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+</geshi>
+
+More often we just put it into a Lua loop:
+
+<geshi lang="lua">
+    local it, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
+    if not it then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    while true do
+        local m, err = it()
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        if not m then
+            -- no match found (any more)
+            break
+        end
+
+        -- found a match
+        ngx.say(m[0])
+        ngx.say(m[1])
+    end
+</geshi>
+
+The optional <code>options</code> argument takes exactly the same semantics as the [[#ngx.re.match|ngx.re.match]] method.
+
+The current implementation requires that the iterator returned should only be used in a single request. That is, one should ''not'' assign it to a variable belonging to persistent namespace like a Lua package.
+
+This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).
+
+This feature was first introduced in the <code>v0.2.1rc12</code> release.
+
+== ngx.re.sub ==
+'''syntax:''' ''newstr, n, err = ngx.re.sub(subject, regex, replace, options?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Substitutes the first match of the Perl compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in [[#ngx.re.match|ngx.re.match]].
+
+This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the <code><replace></code> string argument, it will return <code>nil</code> and a string describing the error.
+
+When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,
+
+<geshi lang="lua">
+    local newstr, n, err = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")
+    if newstr then
+        -- newstr == "hello, [12][1]34"
+        -- n == 1
+    else
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+</geshi>
+
+where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.
+
+Curly braces can also be used to disambiguate variable names from the background string literals: 
+
+<geshi lang="lua">
+    local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")
+        -- newstr == "hello, 10034"
+        -- n == 1
+</geshi>
+
+Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,
+
+<geshi lang="lua">
+    local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "$$")
+        -- newstr == "hello, $234"
+        -- n == 1
+</geshi>
+
+Do not use backlashes to escape dollar signs; it will not work as expected.
+
+When the <code>replace</code> argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the <code>replace</code> function is exactly the same as the return value of [[#ngx.re.match|ngx.re.match]]. Here is an example:
+
+<geshi lang="lua">
+    local func = function (m)
+        return "[" .. m[0] .. "][" .. m[1] .. "]"
+    end
+    local newstr, n, err = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")
+        -- newstr == "hello, [12][1]34"
+        -- n == 1
+</geshi>
+
+The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.
+
+This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).
+
+This feature was first introduced in the <code>v0.2.1rc13</code> release.
+
+== ngx.re.gsub ==
+'''syntax:''' ''newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Just like [[#ngx.re.sub|ngx.re.sub]], but does global substitution.
+
+Here is some examples:
+
+<geshi lang="lua">
+    local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "i")
+    if newstr then
+        -- newstr == "[hello,h], [world,w]"
+        -- n == 2
+    else
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+</geshi>
+
+<geshi lang="lua">
+    local func = function (m)
+        return "[" .. m[0] .. "," .. m[1] .. "]"
+    end
+    local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", func, "i")
+        -- newstr == "[hello,h], [world,w]"
+        -- n == 2
+</geshi>
+
+This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).
+
+This feature was first introduced in the <code>v0.2.1rc15</code> release.
+
+== ngx.shared.DICT ==
+'''syntax:''' ''dict = ngx.shared.DICT''
+
+'''syntax:''' ''dict = ngx.shared[name_var]''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Fetching the shm-based Lua dictionary object for the shared memory zone named <code>DICT</code> defined by the [[#lua_shared_dict|lua_shared_dict]] directive.
+
+The resulting object <code>dict</code> has the following methods:
+
+* [[#ngx.shared.DICT.get|get]]
+* [[#ngx.shared.DICT.get_stale|get_stale]]
+* [[#ngx.shared.DICT.set|set]]
+* [[#ngx.shared.DICT.safe_set|safe_set]]
+* [[#ngx.shared.DICT.add|add]]
+* [[#ngx.shared.DICT.safe_add|safe_add]]
+* [[#ngx.shared.DICT.replace|replace]]
+* [[#ngx.shared.DICT.incr|incr]]
+* [[#ngx.shared.DICT.delete|delete]]
+* [[#ngx.shared.DICT.flush_all|flush_all]]
+* [[#ngx.shared.DICT.flush_expired|flush_expired]]
+
+Here is an example:
+
+<geshi lang="nginx">
+    http {
+        lua_shared_dict dogs 10m;
+        server {
+            location /set {
+                content_by_lua '
+                    local dogs = ngx.shared.dogs
+                    dogs:set("Jim", 8)
+                    ngx.say("STORED")
+                ';
+            }
+            location /get {
+                content_by_lua '
+                    local dogs = ngx.shared.dogs
+                    ngx.say(dogs:get("Jim"))
+                ';
+            }
+        }
+    }
+</geshi>
+
+Let us test it:
+
+<geshi lang="bash">
+    $ curl localhost/set
+    STORED
+
+    $ curl localhost/get
+    8
+
+    $ curl localhost/get
+    8
+</geshi>
+
+The number <code>8</code> will be consistently output when accessing <code>/get</code> regardless of how many Nginx workers there are because the <code>dogs</code> dictionary resides in the shared memory and visible to ''all'' of the worker processes.
+
+The shared dictionary will retain its contents through a server config reload (either by sending the <code>HUP</code> signal to the Nginx process or by using the <code>-s reload</code> command-line option).
+
+The contents in the dictionary storage will be lost, however, when the Nginx server quits.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+== ngx.shared.DICT.get ==
+'''syntax:''' ''value, flags = ngx.shared.DICT:get(key)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Retrieving the value in the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] for the key <code>key</code>. If the key does not exist or has been expired, then <code>nil</code> will be returned.
+
+The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.
+
+The first argument to this method must be the dictionary object itself, for example,
+
+<geshi lang="lua">
+    local cats = ngx.shared.cats
+    local value, flags = cats.get(cats, "Marry")
+</geshi>
+
+or use Lua's syntactic sugar for method calls:
+
+<geshi lang="lua">
+    local cats = ngx.shared.cats
+    local value, flags = cats:get("Marry")
+</geshi>
+
+These two forms are fundamentally equivalent.
+
+If the user flags is <code>0</code> (the default), then no flags value will be returned.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.get_stale ==
+'''syntax:''' ''value, flags, stale = ngx.shared.DICT:get_stale(key)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Similar to the [[#ngx.shared.DICT.get|get]] method but returns the value even if the key has already expired.
+
+Returns a 3rd value, <code>stale</code>, indicating whether the key has expired or not.
+
+Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.
+
+This method was first introduced in the <code>0.8.6</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.set ==
+'''syntax:''' ''success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Unconditionally sets a key-value pair into the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]]. Returns three values:
+
+* <code>success</code>: boolean value to indicate whether the key-value pair is stored or not.
+* <code>err</code>: textual error message, can be <code>"no memory"</code>.
+* <code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.
+
+The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [[#ngx.shared.DICT.get|get]] method.
+
+The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never be expired.
+
+The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.
+
+When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [[#lua_shared_dict|lua_shared_dict]] or memory segmentation), then the <code>err</code> return value will be <code>no memory</code> and <code>success</code> will be <code>false</code>.
+
+If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.
+
+The first argument to this method must be the dictionary object itself, for example,
+
+<geshi lang="lua">
+    local cats = ngx.shared.cats
+    local succ, err, forcible = cats.set(cats, "Marry", "it is a nice cat!")
+</geshi>
+
+or use Lua's syntactic sugar for method calls:
+
+<geshi lang="lua">
+    local cats = ngx.shared.cats
+    local succ, err, forcible = cats:set("Marry", "it is a nice cat!")
+</geshi>
+
+These two forms are fundamentally equivalent.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.safe_set ==
+'''syntax:''' ''ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Similar to the [[#ngx.shared.DICT.set|set]] method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string "no memory".
+
+This feature was first introduced in the <code>v0.7.18</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.add ==
+'''syntax:''' ''success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Just like the [[#ngx.shared.DICT.set|set]] method, but only stores the key-value pair into the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] if the key does ''not'' exist.
+
+If the <code>key</code> argument already exists in the dictionary (and not expired for sure), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>"exists"</code>.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.safe_add ==
+'''syntax:''' ''ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Similar to the [[#ngx.shared.DICT.add|add]] method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string "no memory".
+
+This feature was first introduced in the <code>v0.7.18</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.replace ==
+'''syntax:''' ''success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Just like the [[#ngx.shared.DICT.set|set]] method, but only stores the key-value pair into the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] if the key ''does'' exist.
+
+If the <code>key</code> argument does ''not'' exist in the dictionary (or expired already), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>"not found"</code>.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.delete ==
+'''syntax:''' ''ngx.shared.DICT:delete(key)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Unconditionally removes the key-value pair from the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.incr ==
+'''syntax:''' ''newval, err = ngx.shared.DICT:incr(key, value)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Increments the (numerical) value for <code>key</code> in the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] by the step value <code>value</code>. Returns the new resulting number if the operation is successfully completed or <code>nil</code> and an error message otherwise.
+
+The key must already exist in the dictionary, otherwise it will return <code>nil</code> and <code>"not found"</code>.
+
+If the original value is not a valid Lua number in the dictionary, it will return <code>nil</code> and <code>"not a number"</code>.
+
+The <code>value</code> argument can be any valid Lua numbers, like negative numbers or floating-point numbers.
+
+This feature was first introduced in the <code>v0.3.1rc22</code> release.
+
+See also [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.flush_all ==
+'''syntax:''' ''ngx.shared.DICT:flush_all()''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.
+
+This feature was first introduced in the <code>v0.5.0rc17</code> release.
+
+See also [[#ngx.shared.DICT.flush_expired|ngx.shared.DICT.flush_expired]] and [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.flush_expired ==
+'''syntax:''' ''flushed = ngx.shared.DICT:flush_expired(max_count?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Flushes out the expired items in the dictionary, up to the maximal number specified by the optional <code>max_count</code> argument. When the <code>max_count</code> argument is given <code>0</code> or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.
+
+Unlike the [[#ngx.shared.DICT.flush_all|flush_all]] method, this method actually free up the memory used by the expired items.
+
+This feature was first introduced in the <code>v0.6.3</code> release.
+
+See also [[#ngx.shared.DICT.flush_all|ngx.shared.DICT.flush_all]] and [[#ngx.shared.DICT|ngx.shared.DICT]].
+
+== ngx.shared.DICT.get_keys ==
+'''syntax:''' ''keys = ngx.shared.DICT:get_keys(max_count?)''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Fetch a list of the keys from the dictionary, up to <code><max_count></code>.
+
+By default, only the first 1024 keys (if any) are returned. When the <code><max_count></code> argument is given the value <code>0</code>, then all the keys will be returned even there is more than 1024 keys in the dictionary.
+
+'''WARNING''' Be careful when calling this method on dictionaries with a really huge number of keys. This method may lock the dictionary for quite a while and block all the nginx worker processes that are trying to access the dictionary.
+
+This feature was first introduced in the <code>v0.7.3</code> release.
+
+== ngx.socket.udp ==
+'''syntax:''' ''udpsock = ngx.socket.udp()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:
+
+* [[#udpsock:setpeername|setpeername]]
+* [[#udpsock:send|send]]
+* [[#udpsock:receive|receive]]
+* [[#udpsock:close|close]]
+* [[#udpsock:settimeout|settimeout]]
+
+It is intended to be compatible with the UDP API of the [http://w3.impa.br/~diego/software/luasocket/udp.html LuaSocket] library but is 100% nonblocking out of the box.
+
+This feature was first introduced in the <code>v0.5.7</code> release.
+
+See also [[#ngx.socket.tcp|ngx.socket.tcp]].
+
+== udpsock:setpeername ==
+'''syntax:''' ''ok, err = udpsock:setpeername(host, port)''
+
+'''syntax:''' ''ok, err = udpsock:setpeername("unix:/path/to/unix-domain.socket")''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a "connection", but only just set the name of the remote peer for subsequent read/write operations.
+
+Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [[HttpCoreModule#resolver|resolver]] directive in the <code>nginx.conf</code> file like this:
+
+<geshi lang="nginx">
+    resolver 8.8.8.8;  # use Google's public DNS nameserver
+</geshi>
+
+If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.
+
+In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.
+
+Here is an example for connecting to a UDP (memcached) server:
+
+<geshi lang="nginx">
+    location /test {
+        resolver 8.8.8.8;
+
+        content_by_lua '
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("my.memcached.server.domain", 11211)
+            if not ok then
+                ngx.say("failed to connect to memcached: ", err)
+                return
+            end
+            ngx.say("successfully connected to memcached!")
+            sock:close()
+        ';
+    }
+</geshi>
+
+Since the <code>v0.7.18</code> release, connecting to a datagram unix domain socket file is also possible on Linux:
+
+<geshi lang="lua">
+    local sock = ngx.socket.udp()
+    local ok, err = sock:setpeername("unix:/tmp/some-datagram-service.sock")
+    if not ok then
+        ngx.say("failed to connect to the datagram unix domain socket: ", err)
+        return
+    end
+</geshi>
+
+assuming the datagram service is listening on the unix domain socket file <code>/tmp/some-datagram-service.sock</code> and the client socket will use the "autobind" feature on Linux.
+
+Calling this method on an already connected socket object will cause the original connection to be closed first.
+
+This method was first introduced in the <code>v0.5.7</code> release.
+
+== udpsock:send ==
+'''syntax:''' ''ok, err = udpsock:send(data)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Sends data on the current UDP or datagram unix domain socket object.
+
+In case of success, it returns <code>1</code>. Otherwise, it returns <code>nil</code> and a string describing the error.
+
+The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.
+
+This feature was first introduced in the <code>v0.5.7</code> release.
+
+== udpsock:receive ==
+'''syntax:''' ''data, err = udpsock:receive(size?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, <code>size</code>.
+
+This method is a synchronous operation and is 100% nonblocking.
+
+In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.
+
+If the <code>size</code> argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than <code>8192</code>, then <code>8192</code> will be used instead.
+
+If no argument is specified, then the maximal buffer size, <code>8192</code> is assumed.
+
+Timeout for the reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#udpsock:settimeout|settimeout]] method. And the latter takes priority. For example:
+
+<geshi lang="lua">
+    sock:settimeout(1000)  -- one second timeout
+    local data, err = sock:receive()
+    if not data then
+        ngx.say("failed to read a packet: ", data)
+        return
+    end
+    ngx.say("successfully read a packet: ", data)
+</geshi>
+
+It is important here to call the [[#udpsock:settimeout|settimeout]] method ''before'' calling this method.
+
+This feature was first introduced in the <code>v0.5.7</code> release.
+
+== udpsock:close ==
+'''syntax:''' ''ok, err = udpsock:close()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Closes the current UDP or datagram unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.
+
+Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.
+
+This feature was first introduced in the <code>v0.5.7</code> release.
+
+== udpsock:settimeout ==
+'''syntax:''' ''udpsock:settimeout(time)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Set the timeout value in milliseconds for subsequent socket operations (like [[#udpsock:receive|receive]]).
+
+Settings done by this method takes priority over those config directives, like [[#lua_socket_read_timeout|lua_socket_read_timeout]].
+
+This feature was first introduced in the <code>v0.5.7</code> release.
+
+== ngx.socket.tcp ==
+'''syntax:''' ''tcpsock = ngx.socket.tcp()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:
+
+* [[#tcpsock:connect|connect]]
+* [[#tcpsock:send|send]]
+* [[#tcpsock:receive|receive]]
+* [[#tcpsock:close|close]]
+* [[#tcpsock:settimeout|settimeout]]
+* [[#tcpsock:setoption|setoption]]
+* [[#tcpsock:receiveuntil|receiveuntil]]
+* [[#tcpsock:setkeepalive|setkeepalive]]
+* [[#tcpsock:getreusedtimes|getreusedtimes]]
+
+It is intended to be compatible with the TCP API of the [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+See also [[#ngx.socket.udp|ngx.socket.udp]].
+
+== tcpsock:connect ==
+'''syntax:''' ''ok, err = tcpsock:connect(host, port, options_table?)''
+
+'''syntax:''' ''ok, err = tcpsock:connect("unix:/path/to/unix-domain.socket", options_table?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.
+
+Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [[#ngx.socket.connect|ngx.socket.connect]] function).
+
+Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [[HttpCoreModule#resolver|resolver]] directive in the <code>nginx.conf</code> file like this:
+
+<geshi lang="nginx">
+    resolver 8.8.8.8;  # use Google's public DNS nameserver
+</geshi>
+
+If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.
+
+In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.
+
+Here is an example for connecting to a TCP server:
+
+<geshi lang="nginx">
+    location /test {
+        resolver 8.8.8.8;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("www.google.com", 80)
+            if not ok then
+                ngx.say("failed to connect to google: ", err)
+                return
+            end
+            ngx.say("successfully connected to google!")
+            sock:close()
+        ';
+    }
+</geshi>
+
+Connecting to a Unix Domain Socket file is also possible:
+
+<geshi lang="lua">
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("unix:/tmp/memcached.sock")
+    if not ok then
+        ngx.say("failed to connect to the memcached unix domain socket: ", err)
+        return
+    end
+</geshi>
+
+assuming memcached (or something else) is listening on the unix domain socket file <code>/tmp/memcached.sock</code>.
+
+Timeout for the connecting operation is controlled by the [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:
+
+<geshi lang="lua">
+    local sock = ngx.socket.tcp()
+    sock:settimeout(1000)  -- one second timeout
+    local ok, err = sock:connect(host, port)
+</geshi>
+
+It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.
+
+Calling this method on an already connected socket object will cause the original connection to be closed first.
+
+An optional Lua table can be specified as the last argument to this method to specify various connect options:
+
+* <code>pool</code>
+: specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template <code>"<host>:<port>"</code> or <code>"<unix-socket-path>"</code>.
+
+The support for the options table argument was first introduced in the <code>v0.5.7</code> release.
+
+This method was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:send ==
+'''syntax:''' ''bytes, err = tcpsock:send(data)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Sends data without blocking on the current TCP or Unix Domain Socket connection.
+
+This method is a synchronous operation that will not return until ''all'' the data has been flushed into the system socket send buffer or an error occurs.
+
+In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns <code>nil</code> and a string describing the error.
+
+The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.
+
+Timeout for the sending operation is controlled by the [[#lua_socket_send_timeout|lua_socket_send_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:
+
+<geshi lang="lua">
+    sock:settimeout(1000)  -- one second timeout
+    local bytes, err = sock:send(request)
+</geshi>
+
+It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.
+
+In case of any connection errors, this method always automatically closes the current connection.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:receive ==
+'''syntax:''' ''data, err, partial = tcpsock:receive(size)''
+
+'''syntax:''' ''data, err, partial = tcpsock:receive(pattern?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Receives data from the connected socket according to the reading pattern or size.
+
+This method is a synchronous operation just like the [[#tcpsock:send|send]] method and is 100% nonblocking.
+
+In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error and the partial data received so far.
+
+If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.
+
+If a non-number-like string argument is specified, then it is interpreted as a "pattern". The following patterns are supported:
+
+* <code>'*a'</code>: reads from the socket until the connection is closed. No end-of-line translation is performed;
+* <code>'*l'</code>: reads a line of text from the socket. The line is terminated by a <code>Line Feed</code> (LF) character (ASCII 10), optionally preceded by a <code>Carriage Return</code> (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.
+
+If no argument is specified, then it is assumed to be the pattern <code>'*l'</code>, that is, the line reading pattern.
+
+Timeout for the reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:
+
+<geshi lang="lua">
+    sock:settimeout(1000)  -- one second timeout
+    local line, err, partial = sock:receive()
+    if not line then
+        ngx.say("failed to read a line: ", err)
+        return
+    end
+    ngx.say("successfully read a line: ", line)
+</geshi>
+
+It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.
+
+Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:receiveuntil ==
+'''syntax:''' ''iterator = tcpsock:receiveuntil(pattern, options?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.
+
+Here is an example for using this method to read a data stream with the boundary sequence <code>--abcedhb</code>:
+
+<geshi lang="lua">
+    local reader = sock:receiveuntil("\r\n--abcedhb")
+    local data, err, partial = reader()
+    if not data then
+        ngx.say("failed to read the data stream: ", err)
+    end
+    ngx.say("read the data stream: ", data)
+</geshi>
+
+When called without any argument, the iterator function returns the received data right ''before'' the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, then the string <code>'hello, world! -agentzh'</code> will be returned.
+
+In case of error, the iterator function will return <code>nil</code> along with a string describing the error and the partial data bytes that have been read so far.
+
+The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.
+
+The iterator function behaves differently (i.e., like a real iterator) when it is called with a <code>size</code> argument. That is, it will read that <code>size</code> of data on each invocation and will return <code>nil</code> at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the <code>err</code> return value will be <code>nil</code> too. The iterator function will be reset after the last successful invocation that returns <code>nil</code> data and <code>nil</code> error. Consider the following example:
+
+<geshi lang="lua">
+    local reader = sock:receiveuntil("\r\n--abcedhb")
+
+    while true do
+        local data, err, partial = reader(4)
+        if not data then
+            if err then
+                ngx.say("failed to read the data stream: ", err)
+                break
+            end
+
+            ngx.say("read done")
+            break
+        end
+        ngx.say("read chunk: [", data, "]")
+    end
+</geshi>
+
+Then for the incoming data stream <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, we shall get the following output from the sample code above:
+
+<geshi lang="text">
+    read chunk: [hell]
+    read chunk: [o, w]
+    read chunk: [orld]
+    read chunk: [! -a]
+    read chunk: [gent]
+    read chunk: [zh]
+    read done
+</geshi>
+
+Note that, the actual data returned ''might'' be a little longer than the size limit specified by the <code>size</code> argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.
+
+Timeout for the iterator function's reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:
+
+<geshi lang="lua">
+    local readline = sock:receiveuntil("\r\n")
+
+    sock:settimeout(1000)  -- one second timeout
+    line, err, partial = readline()
+    if not line then
+        ngx.say("failed to read a line: ", err)
+        return
+    end
+    ngx.say("successfully read a line: ", line)
+</geshi>
+
+It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling the iterator function (note that the <code>receiveuntil</code> call is irrelevant here).
+
+As from the <code>v0.5.1</code> release, this method also takes an optional <code>options</code> table argument to control the behavior. The following options are supported:
+
+* <code>inclusive</code>
+
+The <code>inclusive</code> takes a boolean value to control whether to include the pattern string in the returned data string. Default to <code>false</code>. For example,
+
+<geshi lang="lua">
+    local reader = tcpsock:receiveuntil("_END_", { inclusive = true })
+    local data = reader()
+    ngx.say(data)
+</geshi>
+
+Then for the input data stream <code>"hello world _END_ blah blah blah"</code>, then the example above will output <code>hello world _END_</code>, including the pattern string <code>_END_</code> itself.
+
+Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.
+
+This method was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:close ==
+'''syntax:''' ''ok, err = tcpsock:close()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Closes the current TCP or stream unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.
+
+Note that there is no need to call this method on socket objects that have invoked the [[#tcpsock:setkeepalive|setkeepalive]] method because the socket object is already closed (and the current connection is saved into the built-in connection pool).
+
+Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:settimeout ==
+'''syntax:''' ''tcpsock:settimeout(time)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Set the timeout value in milliseconds for subsequent socket operations ([[#tcpsock:connect|connect]], [[#tcpsock:receive|receive]], and iterators returned from [[#tcpsock:receiveuntil|receiveuntil]]).
+
+Settings done by this method takes priority over those config directives, i.e., [[#lua_socket_connect_timeout|lua_socket_connect_timeout]], [[#lua_socket_send_timeout|lua_socket_send_timeout]], and [[#lua_socket_read_timeout|lua_socket_read_timeout]].
+
+Note that this method does ''not'' affect the [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] setting; the <code>timeout</code> argument to the [[#tcpsock:setkeepalive|setkeepalive]] method should be used for this purpose instead.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:setoption ==
+'''syntax:''' ''tcpsock:setoption(option, value?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+This function is added for [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] API compatibility and does nothing for now. Its functionality will be implemented in future.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:setkeepalive ==
+'''syntax:''' ''ok, err = tcpsock:setkeepalive(timeout?, size?)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other [[#tcpsock:connect|connect]] method calls request it or the associated maximal idle timeout is expired.
+
+The first optional argument, <code>timeout</code>, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] config directive will be used. If the <code>0</code> value is given, then the timeout interval is unlimited.
+
+The second optional argument, <code>size</code>, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path). Note that the size of the connection pool cannot be changed once the pool is created. When this argument is omitted, the default setting in the [[#lua_socket_pool_size|lua_socket_pool_size]] config directive will be used.
+
+When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.
+
+Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.
+
+Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.
+
+In case of success, this method returns <code>1</code>; otherwise, it returns <code>nil</code> and a string describing the error.
+
+This method also makes the current cosocket object enter the "closed" state, so there is no need to manually call the [[#tcpsock:close|close]] method on it afterwards.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== tcpsock:getreusedtimes ==
+'''syntax:''' ''count, err = tcpsock:getreusedtimes()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+This method returns the (successfully) reused times for the current connection. In case of error, it returns <code>nil</code> and a string describing the error.
+
+If the current connection does not come from the built-in connection pool, then this method always returns <code>0</code>, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== ngx.socket.connect ==
+'''syntax:''' ''tcpsock, err = ngx.socket.connect(host, port)''
+
+'''syntax:''' ''tcpsock, err = ngx.socket.connect("unix:/path/to/unix-domain.socket")''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+This function is a shortcut for combining [[#ngx.socket.tcp|ngx.socket.tcp()]] and the [[#tcpsock:connect|connect()]] method call in a single operation. It is actually implemented like this:
+
+<geshi lang="lua">
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect(...)
+    if not ok then
+        return nil, err
+    end
+    return sock
+</geshi>
+
+There is no way to use the [[#tcpsock:settimeout|settimeout]] method to specify connecting timeout for this method and the [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] directive must be set at configure time instead.
+
+This feature was first introduced in the <code>v0.5.0rc1</code> release.
+
+== ngx.get_phase ==
+'''syntax:''' ''str = ngx.get_phase()''
+
+'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Retrieves the current running phase name. Possible return values are
+
+* <code>init</code>
+: for the context of [[#init_by_lua|init_by_lua]] or [[#init_by_lua_file|init_by_lua_file]].
+* <code>set</code>
+: for the context of [[#set_by_lua|set_by_lua]] or [[#set_by_lua_file|set_by_lua_file]].
+* <code>rewrite</code>
+: for the context of [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]].
+* <code>access</code>
+: for the context of [[#access_by_lua|access_by_lua]] or [[#access_by_lua_file|access_by_lua_file]].
+* <code>content</code>
+: for the context of [[#content_by_lua|content_by_lua]] or [[#content_by_lua_file|content_by_lua_file]].
+* <code>header_filter</code>
+: for the context of [[#header_filter_by_lua|header_filter_by_lua]] or [[#header_filter_by_lua_file|header_filter_by_lua_file]].
+* <code>body_filter</code>
+: for the context of [[#body_filter_by_lua|body_filter_by_lua]] or [[#body_filter_by_lua_file|body_filter_by_lua_file]].
+* <code>log</code>
+: for the context of [[#log_by_lua|log_by_lua]] or [[#log_by_lua_file|log_by_lua_file]].
+* <code>timer</code>
+: for the context of user callback functions for [[#ngx.timer.at|ngx.timer.*]].
+
+This API was first introduced in the <code>v0.5.10</code> release.
+
+== ngx.thread.spawn ==
+'''syntax:''' ''co = ngx.thread.spawn(func, arg1, arg2, ...)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Spawns a new user "light thread" with the Lua function <code>func</code> as well as those optional arguments <code>arg1</code>, <code>arg2</code>, and etc. Returns a Lua thread (or Lua coroutine) object represents this "light thread".
+
+"Light threads" are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.
+
+Before <code>ngx.thread.spawn</code> returns, the <code>func</code> will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [[#Nginx API for Lua|Nginx API for Lua]] (like [[#tcpsock:receive|tcpsock:receive]]).
+
+After <code>ngx.thread.spawn</code> returns, the newly-created "light thread" will keep running asynchronously usually at various I/O events.
+
+All the Lua code chunks running by [[#rewrite_by_lua|rewrite_by_lua]], [[#access_by_lua|access_by_lua]], and [[#content_by_lua|content_by_lua]] are in a boilerplate "light thread" created automatically by ngx_lua. Such boilerplate "light thread" are also called "entry threads".
+
+By default, the corresponding Nginx handler (e.g., [[#rewrite_by_lua|rewrite_by_lua]] handler) will not terminate until
+# both the "entry thread" and all the user "light threads" terminates,
+# a "light thread" (either the "entry thread" or a user "light thread" aborts by calling [[#ngx.exit|ngx.exit]], [[#ngx.exec|ngx.exec]], [[#ngx.redirect|ngx.redirect]], or [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]], or
+# the "entry thread" terminates with a Lua error.
+
+When the user "light thread" terminates with a Lua error, however, it will not abort other running "light threads" like the "entry thread" does.
+
+Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running "light thread" that is pending on one ore more Nginx subrequests. You must call [[#ngx.thread.wait|ngx.thread.wait]] to wait for those "light thread" to terminate before quitting the "world". A notable exception here is that you can abort pending subrequests by calling [[#ngx.exit|ngx.exit]] with and only with the status code <code>ngx.ERROR</code> (-1), <code>408</code>, <code>444</code>, or <code>499</code>.
+
+The "light threads" are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A "light thread" will keep running exclusively on the CPU until
+# a (nonblocking) I/O operation cannot be completed in a single run,
+# it calls [[#coroutine.yield|coroutine.yield]] to actively give up execution, or
+# it is aborted by a Lua error or an invocation of [[#ngx.exit|ngx.exit]], [[#ngx.exec|ngx.exec]], [[#ngx.redirect|ngx.redirect]], or [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]].
+
+For the first two cases, the "light thread" will usually be resumed later by the ngx_lua scheduler unless a "stop-the-world" event happens.
+
+User "light threads" can create "light threads" themselves and normal user coroutiens created by [[#coroutine.create|coroutine.create]] can also create "light threads". The coroutine (be it a normal Lua coroutine or a "light thread") that directly spawns the "light thread" is called the "parent coroutine" for the "light thread" newly spawned.
+
+The "parent coroutine" can call [[#ngx.thread.wait|ngx.thread.wait]] to wait on the termination of its child "light thread".
+
+You can call coroutine.status() and coroutine.yield() on the "light thread" coroutines.
+
+The status of the "light thread" coroutine can be "zombie" if
+# the current "light thread" already terminates (either successfully or with an error),
+# its parent coroutine is still alive, and
+# its parent coroutine is not waiting on it with [[#ngx.thread.wait|ngx.thread.wait]].
+
+The following example demonstrates the use of coroutine.yield() in the "light thread" coroutines
+to do manual time-slicing:
+
+<geshi lang="lua">
+    local yield = coroutine.yield
+
+    function f()
+        local self = coroutine.running()
+        ngx.say("f 1")
+        yield(self)
+        ngx.say("f 2")
+        yield(self)
+        ngx.say("f 3")
+    end
+
+    local self = coroutine.running()
+    ngx.say("0")
+    yield(self)
+
+    ngx.say("1")
+    ngx.thread.spawn(f)
+
+    ngx.say("2")
+    yield(self)
+
+    ngx.say("3")
+    yield(self)
+
+    ngx.say("4")
+</geshi>
+
+Then it will generate the output
+
+<geshi lang="text">
+    0
+    1
+    f 1
+    2
+    f 2
+    3
+    f 3
+    4
+</geshi>
+
+"Light threads" are mostly useful for doing concurrent upstream requests in a single Nginx request handler, kinda like a generalized version of [[#ngx.location.capture_multi|ngx.location.capture_multi]] that can work with all the [[#Nginx API for Lua|Nginx API for Lua]]. The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (very much like the Facebook BigPipe model):
+
+<geshi lang="lua">
+    -- query mysql, memcached, and a remote http service at the same time,
+    -- output the results in the order that they
+    -- actually return the results.
+
+    local mysql = require "resty.mysql"
+    local memcached = require "resty.memcached"
+
+    local function query_mysql()
+        local db = mysql:new()
+        db:connect{
+                    host = "127.0.0.1",
+                    port = 3306,
+                    database = "test",
+                    user = "monty",
+                    password = "mypass"
+                  }
+        local res, err, errno, sqlstate =
+                db:query("select * from cats order by id asc")
+        db:set_keepalive(0, 100)
+        ngx.say("mysql done: ", cjson.encode(res))
+    end
+
+    local function query_memcached()
+        local memc = memcached:new()
+        memc:connect("127.0.0.1", 11211)
+        local res, err = memc:get("some_key")
+        ngx.say("memcached done: ", res)
+    end
+
+    local function query_http()
+        local res = ngx.location.capture("/my-http-proxy")
+        ngx.say("http done: ", res.body)
+    end
+
+    ngx.thread.spawn(query_mysql)      -- create thread 1
+    ngx.thread.spawn(query_memcached)  -- create thread 2
+    ngx.thread.spawn(query_http)       -- create thread 3 
+</geshi>
+
+This API was first enabled in the <code>v0.7.0</code> release.
+
+== ngx.thread.wait ==
+'''syntax:''' ''ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Waits on one or more child "light threads" and returns the results of the first "light thread" that terminates (either successfully or with an error).
+
+The arguments <code>thread1</code>, <code>thread2</code>, and etc are the Lua thread objects returned by earlier calls of [[#ngx.thread.spawn|ngx.thread.spawn]].
+
+The return values have exactly the same meaning as [[#coroutine.resume|coroutine.resume]], that is, the first value returned is a boolean value indicating whether the "light thread" terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the "light thread" (in case of success) or the error object (in case of failure).
+
+Only the direct "parent coroutine" can wait on its child "light thread", otherwise a Lua exception will be raised.
+
+The following example demonstrates the use of <code>ngx.thread.wait</code> and [[#ngx.location.capture|ngx.location.capture]] to emulate [[#ngx.location.capture_multi|ngx.location.capture_multi]]:
+
+<geshi lang="lua">
+    local capture = ngx.location.capture
+    local spawn = ngx.thread.spawn
+    local wait = ngx.thread.wait
+    local say = ngx.say
+
+    local function fetch(uri)
+        return capture(uri)
+    end
+
+    local threads = {
+        spawn(fetch, "/foo"),
+        spawn(fetch, "/bar"),
+        spawn(fetch, "/baz")
+    }
+
+    for i = 1, #threads do
+        local ok, res = wait(threads[i])
+        if not ok then
+            say(i, ": failed to run: ", res)
+        else
+            say(i, ": status: ", res.status)
+            say(i, ": body: ", res.body)
+        end
+    end
+</geshi>
+
+Here it essentially implements the "wait all" model.
+
+And below is an example demonstrating the "wait any" model:
+
+<geshi lang="lua">
+    function f()
+        ngx.sleep(0.2)
+        ngx.say("f: hello")
+        return "f done"
+    end
+
+    function g()
+        ngx.sleep(0.1)
+        ngx.say("g: hello")
+        return "g done"
+    end
+
+    local tf, err = ngx.thread.spawn(f)
+    if not tf then
+        ngx.say("failed to spawn thread f: ", err)
+        return
+    end
+
+    ngx.say("f thread created: ", coroutine.status(tf))
+
+    local tg, err = ngx.thread.spawn(g)
+    if not tg then
+        ngx.say("failed to spawn thread g: ", err)
+        return
+    end
+
+    ngx.say("g thread created: ", coroutine.status(tg))
+
+    ok, res = ngx.thread.wait(tf, tg)
+    if not ok then
+        ngx.say("failed to wait: ", res)
+        return
+    end
+
+    ngx.say("res: ", res)
+
+    -- stop the "world", aborting other running threads
+    ngx.exit(ngx.OK)
+</geshi>
+
+And it will generate the following output:
+
+<geshi lang="text">
+    f thread created: running
+    g thread created: running
+    g: hello
+    res: g done
+</geshi>
+
+This API was first enabled in the <code>v0.7.0</code> release.
+
+== ngx.on_abort ==
+'''syntax:''' ''ok, err = ngx.on_abort(callback)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
+
+Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.
+
+Returns <code>1</code> if the callback is registered successfully or returns <code>nil</code> and a string describing the error otherwise.
+
+All the [[#Nginx API for Lua|Nginx API for Lua]] can be used in the callback function because the function is run in a special "light thread", just as those "light threads" created by [[#ngx.thread.spawn|ngx.thread.spawn]].
+
+The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling [[#ngx.exit|ngx.exit]], for example,
+
+<geshi lang="lua">
+    local function my_cleanup()
+        -- custom cleanup work goes here, like cancelling a pending DB transaction
+
+        -- now abort all the "light threads" running in the current request handler
+        ngx.exit(499)
+    end
+
+    local ok, err = ngx.on_abort(my_cleanup)
+    if not ok then
+        ngx.log(ngx.ERR, "failed to register the on_abort callback: ", err)
+        ngx.exit(500)
+    end
+</geshi>
+
+When [[#lua_check_client_abort|lua_check_client_abort]] is set to <code>off</code> (which is the default), then this function call will always return the error message "lua_check_client_abort is off".
+
+According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message "duplicate call".
+
+This API was first introduced in the <code>v0.7.4</code> release.
+
+See also [[#lua_check_client_abort|lua_check_client_abort]].
+
+== ngx.timer.at ==
+'''syntax:''' ''ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+Creates an Nginx timer with a user callback function as well as optional user arguments.
+
+The first argument, <code>delay</code>, specifies the delay for the timer,
+in seconds. One can specify fractional seconds like <code>0.001</code> to mean 1
+millisecond here. <code>0</code> delay can also be specified, in which case the
+timer will immediately expire when the current handler yields
+execution.
+
+The second argument, <code>callback</code>, can
+be any Lua function, which will be invoked later in a background
+"light thread" after the delay specified. The user callback will be
+called automatically by the Nginx core with the arguments <code>premature</code>,
+<code>user_arg1</code>, <code>user_arg2</code>, and etc, where the <code>premature</code>
+argument takes a boolean value indicating whether it is a premature timer
+expiration or not, and <code>user_arg1</code>, <code>user_arg2</code>, and etc, are
+those (extra) user arguments specified when calling <code>ngx.timer.at</code>
+as the remaining arguments.
+
+Premature timer expiration happens when the Nginx worker process is
+trying to shut down, as in an Nginx configuration reload triggered by
+the <code>HUP</code> signal or in an Nginx server shutdown. When the Nginx worker
+is trying to shut down, one can no longer call <code>ngx.timer.at</code> to
+create new timers and in that case <code>ngx.timer.at</code> will return <code>nil</code> and
+a string describing the error, that is, "process exiting".
+
+When a timer expires, the user Lua code in the timer callback is
+running in a "light thread" detached completely from the original
+request creating the timer. So objects with the same lifetime as the
+request creating them, like [[#ngx.socket.tcp|cosockets]], cannot be shared between the
+original request and the timer user callback function.
+
+Here is a simple example:
+
+<geshi lang="nginx">
+    location / {
+        ...
+        log_by_lua '
+            local function push_data(premature, uri, args, status)
+                -- push the data uri, args, and status to the remote
+                -- via ngx.socket.tcp or ngx.socket.udp
+                -- (one may want to buffer the data in Lua a bit to
+                -- save I/O operations)
+            end
+            local ok, err = ngx.timer.at(0, push_data,
+                                         ngx.var.uri, ngx.var.args, ngx.header.status)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to create timer: ", err)
+                return
+            end
+        ';
+    }
+</geshi>
+
+One can also create infinite re-occuring timers, for instance, a timer getting triggered every <code>5</code> seconds, by calling <code>ngx.timer.at</code> recursively in the timer callback function. Here is such an example,
+
+<geshi lang="lua">
+    local delay = 5
+    local handler
+    handler = function (premature)
+        -- do some routine job in Lua just like a cron job
+        if premature then
+            return
+        end
+        local ok, err = ngx.timer.at(delay, handler)
+        if not ok then
+            ngx.log(ngx.ERR, "failed to create the timer: ", err)
+            return
+        end
+    end
+    
+    local ok, err = ngx.timer.at(delay, handler)
+    if not ok then
+        ngx.log(ngx.ERR, "failed to create the timer: ", err)
+        return
+    end
+</geshi>
+
+Because timer callbacks run in the background and their running time
+will not add to any client request's response time, they can easily
+accumulate in the server and exhaust system resources due to either
+Lua programming mistakes or just too much client traffic. To prevent
+extreme consequences like crashing the Nginx server, there are
+built-in limitations on both the number of "pending timers" and the
+number of "running timers" in an Nginx worker process. The "pending
+timers" here mean timers that have not yet been expired and "running
+timers" are those whose user callbacks are currently running.
+
+The maximal number of pending timers allowed in an Nginx
+worker is constrolled by the [[#lua_max_pending_timers|lua_max_pending_timers]]
+directive. The maximal number of running timers is controlled by the
+[[#lua_max_running_timers|lua_max_running_timers]] directive.
+
+According to the current implementation, each "running timer" will
+take one (fake) connection record from the global connection record
+list configured by the standard [[EventsModule#worker_connections|worker_connections]] directive in
+<code>nginx.conf</code>. So ensure that the
+[[EventsModule#worker_connections|worker_connections]] directive is set to
+a large enough value that takes into account both the real connections
+and fake connections required by timer callbacks (as limited by the
+[[#lua_max_running_timers|lua_max_running_timers]] directive).
+
+A lot of the Lua APIs for Nginx are enabled in the context of the timer
+callbacks, like stream/datagram cosockets ([[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.socket.udp|ngx.socket.udp]]), shared
+memory dictionaries ([[#ngx.shared.DICT|ngx.shared.DICT]]), user coroutines ([[#coroutine.create|coroutine.*]]),
+user "light threads" ([[#ngx.thread.spawn|ngx.thread.*]]), [[#ngx.exit|ngx.exit]], [[#ngx.now|ngx.now]]/[[#ngx.time|ngx.time]],
+[[#ngx.md5|ngx.md5]]/[[#ngx.sha1_bin|ngx.sha1_bin]], are all allowed. But the subrequest API (like
+[[#ngx.location.capture|ngx.location.capture]]), the [[#ngx.req.start_time|ngx.req.*]] API, the downstream output API
+(like [[#ngx.say|ngx.say]], [[#ngx.print|ngx.print]], and [[#ngx.flush|ngx.flush]]) are explicitly disabled in
+this context.
+
+This API was first introduced in the <code>v0.8.0</code> release.
+
+== ngx.config.debug ==
+'''syntax:''' ''debug = ngx.config.debug''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*''
+
+This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the <code>./configure</code> option <code>--with-debug</code>.
+
+This field was first introduced in the <code>0.8.7</code>.
+
+== ndk.set_var.DIRECTIVE ==
+'''syntax:''' ''res = ndk.set_var.DIRECTIVE_NAME''
+
+'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''
+
+This mechanism allows calling other nginx C modules' directives that are implemented by [https://github.com/simpl/ngx_devel_kit Nginx Devel Kit] (NDK)'s set_var submodule's <code>ndk_set_var_value</code>.
+
+For example, the following [[HttpSetMiscModule]] directives can be invoked this way:
+
+* [[HttpSetMiscModule#set_quote_sql_str|set_quote_sql_str]]
+* [[HttpSetMiscModule#set_quote_pgsql_str|set_quote_pgsql_str]]
+* [[HttpSetMiscModule#set_quote_json_str|set_quote_json_str]]
+* [[HttpSetMiscModule#set_unescape_uri|set_unescape_uri]]
+* [[HttpSetMiscModule#set_escape_uri|set_escape_uri]]
+* [[HttpSetMiscModule#set_encode_base32|set_encode_base32]]
+* [[HttpSetMiscModule#set_decode_base32|set_decode_base32]]
+* [[HttpSetMiscModule#set_encode_base64|set_encode_base64]]
+* [[HttpSetMiscModule#set_decode_base64|set_decode_base64]]
+* [[HttpSetMiscModule#set_encode_base64|set_encode_hex]]
+* [[HttpSetMiscModule#set_decode_base64|set_decode_hex]]
+* [[HttpSetMiscModule#set_encode_base64|set_sha1]]
+* [[HttpSetMiscModule#set_decode_base64|set_md5]]
+
+For instance,
+
+<geshi lang="lua">
+    local res = ndk.set_var.set_escape_uri('a/b');
+    -- now res == 'a%2fb'
+</geshi>
+
+Similarly, the following directives provided by [[HttpEncryptedSessionModule]] can be invoked from within Lua too:
+
+* [[HttpEncryptedSessionModule#set_encrypt_session|set_encrypt_session]]
+* [[HttpEncryptedSessionModule#set_decrypt_session|set_decrypt_session]]
+
+This feature requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.
+
+== coroutine.create ==
+'''syntax:''' ''co = coroutine.create(f)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Creates a user Lua coroutines with a Lua function, and returns a coroutine object.
+
+Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create coroutine.create] API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the <code>v0.6.0</code> release.
+
+== coroutine.resume ==
+'''syntax:''' ''ok, ... = coroutine.resume(co, ...)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Resumes the executation of a user Lua coroutine object previously yielded or just created.
+
+Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume coroutine.resume] API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the <code>v0.6.0</code> release.
+
+== coroutine.yield ==
+'''syntax:''' ''... = coroutine.yield(co, ...)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Yields the executation of the current user Lua coroutine.
+
+Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield coroutine.yield] API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the <code>v0.6.0</code> release.
+
+== coroutine.wrap ==
+'''syntax:''' ''co = coroutine.wrap(f)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap coroutine.wrap] API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the <code>v0.6.0</code> release.
+
+== coroutine.running ==
+'''syntax:''' ''co = coroutine.running()''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Identical to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running coroutine.running] API.
+
+This API was first enabled in the <code>v0.6.0</code> release.
+
+== coroutine.status ==
+'''syntax:''' ''status = coroutine.status(co)''
+
+'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''
+
+Identical to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status coroutine.status] API.
+
+This API was first enabled in the <code>v0.6.0</code> release.
+
+= Lua/LuaJIT bytecode support =
+
+As from the <code>v0.5.0rc32</code> release, all <code>*_by_lua_file</code> configure directives (such as [[#content_by_lua_file|content_by_lua_file]]) support loading Lua 5.1 and LuaJIT 2.0 raw bytecode files directly.
+
+Please note that the bytecode format used by LuaJIT 2.0 is not compatible with that used by the standard Lua 5.1 interpreter. So if using LuaJIT 2.0 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:
+
+<geshi lang="bash">
+    /path/to/luajit/bin/luajit -b /path/to/input_file.lua /path/to/output_file.luac
+</geshi>
+
+The <code>-bg</code> option can be used to include debug information in the LuaJIT bytecode file:
+
+<geshi lang="bash">
+    /path/to/luajit/bin/luajit -bg /path/to/input_file.lua /path/to/output_file.luac
+</geshi>
+
+Please refer to the official LuaJIT documentation on the <code>-b</code> option for more details:
+
+http://luajit.org/running.html#opt_b
+
+Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua compatible bytecode files must be generated using the <code>luac</code> commandline utility as shown:
+
+<geshi lang="bash">
+    luac -o /path/to/output_file.luac /path/to/input_file.lua
+</geshi>
+
+Unlike as with LuaJIT, debug information is included in standard Lua 5.1 bytecode files by default. This can be striped out by specifying the <code>-s</code> option as shown:
+
+<geshi lang="bash">
+    luac -s -o /path/to/output_file.luac /path/to/input_file.lua
+</geshi>
+
+Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0 or vice versa, will result in an error message, such as that below, being logged into the Nginx <code>error.log</code> file:
+
+<geshi lang="text">
+    [error] 13909#0: *1 failed to load Lua inlined code: bad byte-code header in /path/to/test_file.luac
+</geshi>
+
+Loading bytecode files via the Lua primitives like <code>require</code> and <code>dofile</code> should always work as expected.
+
+= HTTP 1.0 support =
+
+The HTTP 1.0 protocol does not support chunked output and requires an explicit <code>Content-Length</code> header when the response body is not empty in order to support the HTTP 1.0 keep-alive.
+So when a HTTP 1.0 request is made and the [[#lua_http10_buffering|lua_http10_buffering]] directive is turned <code>on</code>, ngx_lua will buffer the
+output of [[#ngx.say|ngx.say]] and [[#ngx.print|ngx.print]] calls and also postpone sending response headers until all the response body output is received.
+At that time ngx_lua can calculate the total length of the body and construct a proper <code>Content-Length</code> header to return to the HTTP 1.0 client.
+If the <code>Content-Length</code> response header is set in the running Lua code, however, this buffering will be disabled even if the [[#lua_http10_buffering|lua_http10_buffering]] directive is turned <code>on</code>.
+
+For large streaming output responses, it is important to disable the [[#lua_http10_buffering|lua_http10_buffering]] directive to minimise memory usage.
+
+Note that common HTTP benchmark tools such as <code>ab</code> and <code>http_load</code> issue HTTP 1.0 requests by default.
+To force <code>curl</code> to send HTTP 1.0 requests, use the <code>-0</code> option.
+
+= Data Sharing within an Nginx Worker =
+
+To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua <code>require</code> builtin to import the module, and then manipulate the shared data in Lua. This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module (both its code and data). Note however that Lua global variables (note, not module-level variables) WILL NOT persist between requests because of the one-coroutine-per-request isolation design.
+
+Here is a complete small example:
+
+<geshi lang="lua">
+    -- mydata.lua
+    local _M = {}
+
+    local data = {
+        dog = 3,
+        cat = 4,
+        pig = 5,
+    }
+ 
+    function _M.get_age(name)
+        return data[name]
+    end
+
+    return _M
+</geshi>
+
+and then accessing it from <code>nginx.conf</code>:
+
+<geshi lang="nginx">
+    location /lua {
+        content_by_lua '
+            local mydata = require "mydata"
+            ngx.say(mydata.get_age("dog"))
+        ';
+    }
+</geshi>
+
+The <code>mydata</code> module in this example will only be loaded and run on the first request to the location <code>/lua</code>,
+and all subsequent requests to the same nginx worker process will use the reloaded instance of the
+module as well as the same copy of the data in it, until a <code>HUP</code> signal is sent to the Nginx master process to force a reload.
+This data sharing technique is essential for high performance Lua applications based on this module.
+
+Note that this data sharing is on a ''per-worker'' basis and not on a ''per-server'' basis. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.
+
+If server-wide data sharing is required, then use one or more of the following approaches:
+# Use the [[#ngx.shared.DICT|ngx.shared.DICT]] API provided by this module.
+# Use only a single nginx worker and a single server (this is however not recommended when there is a multi core CPU or multiple CPUs in a single machine).
+# Use data storage mechanisms such as <code>memcached</code>, <code>redis</code>, <code>MySQL</code> or <code>PostgreSQL</code>. [http://openresty.org The ngx_openresty bundle] associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.
+
+= Known Issues =
+
+== TCP socket connect operation issues ==
+The [[#tcpsock:connect|tcpsock:connect]] method may indicate <code>success</code> despite connection failures such as with <code>Connection Refused</code> errors. 
+
+However, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation. 
+
+This issue is due to limitations in the Nginx event model and only appears to affect Mac OS X.
+
+== Lua Coroutine Yielding/Resuming ==
+* Lua's <code>dofile</code> builtin is implemented as a C function in both Lua 5.1 and LuaJIT 2.0 and when [[#ngx.location.capture|ngx.location.capture]] is called, [[#ngx.exec|ngx.exec]], [[#ngx.exit|ngx.exit]] or [[#ngx.req.read_body|ngx.req.read_body]] or similar in the file to be loaded by <code>dofile</code>, a coroutine yield across the C function boundary will be initiated. This however is not normally allowed within ngx_lua and will usually result in error messages like <code>lua handler aborted: runtime error: attempt to yield across C-call boundary</code>. To avoid this, define a real Lua module and use the Lua <code>require</code> builtin instead.
+* As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi]], [[#ngx.redirect|ngx.redirect]], [[#ngx.exec|ngx.exec]], and [[#ngx.exit|ngx.exit]] cannot be used within the context of a Lua [http://www.lua.org/manual/5.1/manual.html#pdf-pcall pcall()] or [http://www.lua.org/manual/5.1/manual.html#pdf-xpcall xpcall()] or even the first line of the <code>for ... in ...</code> statement when the standard Lua 5.1 interpreter is used and the <code>attempt to yield across metamethod/C-call boundary</code> error will be produced. Please use LuaJIT 2.0, which supports a fully resumable VM, to avoid this.
+
+== Lua Variable Scope ==
+Care must be taken when importing modules and this form should be used:
+
+<geshi lang="lua">
+    local xxx = require('xxx')
+</geshi>
+
+: instead of the old deprecated form:
+
+<geshi lang="lua">
+    require('xxx')
+</geshi>
+
+Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it. Each request handler has its own set of Lua global variables and that is the idea of request isolation. The Lua module is actually loaded by the first Nginx request handler and is cached by the <code>require()</code> built-in in the package.loaded table for later reference, and <code>require()</code> has the side effect of setting a global variable to the loaded module table. But this global variable will be cleared at the end of the request handler,  and every subsequent request handler all has its own (clean) global environment. So one will get Lua exception for accessing the <code>nil</code> value.
+
+Generally, use of Lua global variables is a really really bad idea in the context of ngx_lua because
+# misuse of Lua globals has very bad side effects for concurrent requests when these variables are actually supposed to be local only,
+# Lua global variables require Lua table look-up in the global environment (which is just a Lua table), which is kinda expensive, and
+# some Lua global variable references are just typos, which are hard to debug.
+
+It's *highly* recommended to always declare them via "local" in the scope that is reasonable.
+
+To find out all the uses of Lua global variables in your Lua code, you can run the [https://github.com/agentzh/nginx-devel-utils/blob/master/lua-releng lua-releng tool] across all your .lua source files:
+<geshi lang="text">
+$ lua-releng
+Checking use of Lua global variables in file lib/foo/bar.lua ...
+        1       [1489]  SETGLOBAL       7 -1    ; contains
+        55      [1506]  GETGLOBAL       7 -3    ; setvar
+        3       [1545]  GETGLOBAL       3 -4    ; varexpand
+</geshi>
+The output says that the line 1489 of file <code>lib/foo/bar.lua</code> writes to a global variable named <code>contains</code>, the line 1506 reads from the global variable <code>setvar</code>, and line 1545 reads the global <code>varexpand</code>.
+
+This tool will guarantee that local variables in the Lua module functions are all declared with the <code>local</code> keyword, otherwise a runtime exception will be thrown. It prevents undesirable race conditions while accessing such variables. See [[#Data_Sharing_within_an_Nginx_Worker|Data Sharing within an Nginx Worker]] for the reasons behind this.
+
+== Locations Configured by Subrequest Directives of Other Modules ==
+The [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] directives cannot capture locations that include the [[HttpEchoModule#echo_location|echo_location]], [[HttpEchoModule#echo_location_async|echo_location_async]], [[HttpEchoModule#echo_subrequest|echo_subrequest]], or [[HttpEchoModule#echo_subrequest_async|echo_subrequest_async]] directives.
+
+<geshi lang="nginx">
+    location /foo {
+        content_by_lua '
+            res = ngx.location.capture("/bar")
+        ';
+    }
+    location /bar {
+        echo_location /blah;
+    }
+    location /blah {
+        echo "Success!";
+    }
+</geshi>
+
+<geshi lang="nginx">
+    $ curl -i http://example.com/foo
+</geshi>
+
+will not work as expected.
+
+== Special PCRE Sequences ==
+PCRE sequences such as <code>\d</code>, <code>\s</code>, or <code>\w</code>, require special attention because in string literals, the backslash character, <code>\</code>, is stripped out by both the Lua language parser and by the Nginx config file parser before processing. So the following snippet will not work as expected:
+
+<geshi lang="nginx">
+    # nginx.conf
+    ? location /test {
+    ?     content_by_lua '
+    ?         local regex = "\d+"  -- THIS IS WRONG!!
+    ?         local m = ngx.re.match("hello, 1234", regex)
+    ?         if m then ngx.say(m[0]) else ngx.say("not matched!") end
+    ?     ';
+    ? }
+    # evaluates to "not matched!"
+</geshi>
+
+To avoid this, ''double'' escape the backslash:
+
+<geshi lang="nginx">
+    # nginx.conf
+    location /test {
+        content_by_lua '
+            local regex = "\\\\d+"
+            local m = ngx.re.match("hello, 1234", regex)
+            if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ';
+    }
+    # evaluates to "1234"
+</geshi>
+
+Here, <code>\\\\d+</code> is stripped down to <code>\\d+</code> by the Nginx config file parser and this is further stripped down to <code>\d+</code> by the Lua language parser before running.
+
+Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in "long brackets", <code>&#91;[...]]</code>, in which case backslashes have to only be escaped once for the Nginx config file parser. 
+
+<geshi lang="nginx">
+    # nginx.conf
+    location /test {
+        content_by_lua '
+            local regex = [[\\d+]]
+            local m = ngx.re.match("hello, 1234", regex)
+            if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ';
+    }
+    # evaluates to "1234"
+</geshi>
+
+Here, <code>&#91;[\\d+]]</code> is stripped down to <code>&#91;[\d+]]</code> by the Nginx config file parser and this is processed correctly.
+
+Note that a longer from of the long bracket, <code>[=[...]=]</code>, may be required if the regex pattern contains <code>&#91;...]</code> sequences. 
+The <code>[=[...]=]</code> form may be used as the default form if desired.
+
+<geshi lang="nginx">
+    # nginx.conf
+    location /test {
+        content_by_lua '
+            local regex = [=[[0-9]+]=]
+            local m = ngx.re.match("hello, 1234", regex)
+            if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ';
+    }
+    # evaluates to "1234"
+</geshi>
+
+An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various <code>*_by_lua_file</code> directives. 
+With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.
+
+<geshi lang="lua">
+    -- test.lua
+    local regex = "\\d+"
+    local m = ngx.re.match("hello, 1234", regex)
+    if m then ngx.say(m[0]) else ngx.say("not matched!") end
+    -- evaluates to "1234"
+</geshi>
+
+Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification. 
+ 
+<geshi lang="lua">
+    -- test.lua
+    local regex = [[\d+]]
+    local m = ngx.re.match("hello, 1234", regex)
+    if m then ngx.say(m[0]) else ngx.say("not matched!") end
+    -- evaluates to "1234"
+</geshi>
+
+== Mixing with SSI Not Supported ==
+
+Mixing SSI with ngx_lua in the same Nginx request is not supported at all. Just use ngx_lua exclusively. Everything you can do with SSI can be done atop ngx_lua anyway and it can be more efficient when using ngx_lua.
+
+== SPDY Mode Not Fully Supported ==
+
+Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode yet: [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi]], and [[#ngx.req.socket|ngx.req.socket]].
+
+= Typical Uses =
+
+Just to name a few:
+
+* Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,
+* doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends,
+* manipulating response headers in an arbitrary way (by Lua)
+* fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly,
+* coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage,
+* doing very complex URL dispatch in Lua at rewrite phase,
+* using Lua to implement advanced caching mechanism for Nginx's subrequests and arbitrary locations.
+
+The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user. The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint. This is particularly the case when LuaJIT 2.0 is enabled. 
+
+Other scripting language implementations typically struggle to match this performance level.
+
+The Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to minimize memory use.
+
+On a ThinkPad T400 2.80 GHz laptop, the Hello World example readily achieves 28k req/sec using <code>http_load -p 10</code>. By contrast, Nginx + php-fpm 5.2.8 + Unix Domain Socket yields 6k req/sec and [http://nodejs.org/ Node.js] v0.6.1 yields 10.2k req/sec for their Hello World equivalents.
+
+= Nginx Compatibility =
+The latest module is compatible with the following versions of Nginx:
+
+* 1.5.x (last tested: 1.5.4)
+* 1.4.x (last tested: 1.4.2)
+* 1.3.x (last tested: 1.3.11)
+* 1.2.x (last tested: 1.2.9)
+* 1.1.x (last tested: 1.1.5)
+* 1.0.x (last tested: 1.0.15)
+* 0.9.x (last tested: 0.9.4)
+* 0.8.x >= 0.8.54 (last tested: 0.8.54)
+
+= Code Repository =
+
+The code repository of this project is hosted on github at [http://github.com/chaoslawful/lua-nginx-module chaoslawful/lua-nginx-module].
+
+= Installation =
+
+The [http://openresty.org ngx_openresty bundle] can be used to install Nginx, ngx_lua, either one of the standard Lua 5.1 interpreter or LuaJIT 2.0, as well as a package of powerful companion Nginx modules. The basic installation step is a simple <code>./configure --with-luajit && make && make install</code>.
+
+Alternatively, ngx_lua can be manually compiled into Nginx:
+
+# Install LuaJIT 2.0 (recommended) or Lua 5.1 (Lua 5.2 is ''not'' supported yet). LuajIT can be downloaded from the [http://luajit.org/download.html the LuaJIT project website] and Lua 5.1, from the [http://www.lua.org/ Lua project website].  Some distribution package managers also distribute LuajIT and/or Lua.
+# Download the latest version of the ngx_devel_kit (NDK) module [http://github.com/simpl/ngx_devel_kit/tags HERE].
+# Download the latest version of ngx_lua [http://github.com/chaoslawful/lua-nginx-module/tags HERE].
+# Download the latest version of Nginx [http://nginx.org/ HERE] (See [[#Nginx Compatibility|Nginx Compatibility]])
+
+Build the source with this module:
+
+<geshi lang="bash">
+    wget 'http://nginx.org/download/nginx-1.4.2.tar.gz'
+    tar -xzvf nginx-1.4.2.tar.gz
+    cd nginx-1.4.2/
+
+    # tell nginx's build system where to find LuaJIT:
+    export LUAJIT_LIB=/path/to/luajit/lib
+    export LUAJIT_INC=/path/to/luajit/include/luajit-2.0
+ 
+    # or tell where to find Lua if using Lua instead:
+    #export LUA_LIB=/path/to/lua/lib
+    #export LUA_INC=/path/to/lua/include
+ 
+    # Here we assume Nginx is to be installed under /opt/nginx/.
+    ./configure --prefix=/opt/nginx \
+            --add-module=/path/to/ngx_devel_kit \
+            --add-module=/path/to/lua-nginx-module
+ 
+    make -j2
+    make install
+</geshi>
+
+== Installation on Ubuntu 11.10 ==
+
+Note that it is recommended to use LuaJIT 2.0 instead of the standard Lua 5.1 interpreter where possible. 
+
+If the standard Lua 5.1 interpreter is required however, run the following command to install it from the Ubuntu repository:
+
+<geshi lang="bash">
+apt-get install -y lua5.1 liblua5.1-0 liblua5.1-0-dev
+</geshi>
+
+Everything should be installed correctly, except for one small tweak. 
+
+Library name <code>liblua.so</code> has been changed in liblua5.1 package, it only comes with <code>liblua5.1.so</code>, which needs to be symlinked to <code>/usr/lib</code> so it could be found during the configuration process.
+
+<geshi lang="bash">
+ln -s /usr/lib/x86_64-linux-gnu/liblua5.1.so /usr/lib/liblua.so
+</geshi>
+
+= Community =
+
+== English Mailing List ==
+
+The [https://groups.google.com/group/openresty-en openresty-en] mailing list is for English speakers.
+
+== Chinese Mailing List ==
+
+The [https://groups.google.com/group/openresty openresty] mailing list is for Chinese speakers.
+
+= Bugs and Patches =
+
+Please submit bug reports, wishlists, or patches by
+
+# creating a ticket on the [http://github.com/chaoslawful/lua-nginx-module/issues GitHub Issue Tracker],
+# or posting to the [[#Community|OpenResty community]].
+
+= TODO =
+
+== Short Term ==
+* review and apply Brian Akin's patch for the new directive <code>lua_socket_log_errors</code>.
+* review and apply Brian Akin's patch for the new <code>shdict:flush_expired()</code> API.
+* implement the SSL cosocket API.
+* review and apply Jader H. Silva's patch for <code>ngx.re.split()</code>.
+* review and apply vadim-pavlov's patch for [[#ngx.location.capture|ngx.location.capture]]'s <code>extra_headers</code> option
+* use <code>ngx_hash_t</code> to optimize the built-in header look-up process for [[#ngx.req.set_header|ngx.req.set_header]], [[#ngx.header.HEADER|ngx.header.HEADER]], and etc.
+* add configure options for different strategies of handling the cosocket connection exceeding in the pools.
+* add directives to run Lua codes when nginx stops.
+* add APIs to access cookies as key/value pairs.
+* add <code>ignore_resp_headers</code>, <code>ignore_resp_body</code>, and <code>ignore_resp</code> options to [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] methods, to allow micro performance tuning on the user side.
+* implement new directive <code>lua_ignore_client_abort</code>.
+
+== Longer Term ==
+* add lightweight thread API (i.e., the <code>ngx.thread</code> API) as demonstrated in [http://agentzh.org/misc/nginx/lua-thread2.lua this sample code].
+* add automatic Lua code time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks.
+* add <code>stat</code> mode similar to [http://httpd.apache.org/docs/2.3/mod/mod_lua.html mod_lua].
+
+= Changes =
+
+The changes of every release of this module can be obtained from the ngx_openresty bundle's change logs:
+
+http://openresty.org/#Changes
+
+= Test Suite =
+
+The following dependencies are required to run the test suite:
+
+* Nginx version >= 1.4.2
+
+* Perl modules:
+** Test::Nginx: http://github.com/agentzh/test-nginx 
+
+* Nginx modules:
+** [https://github.com/simpl/ngx_devel_kit ngx_devel_kit]
+** [http://github.com/agentzh/set-misc-nginx-module ngx_set_misc]
+** [http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz ngx_auth_request] (this is not needed if you're using Nginx 1.5.4+.
+** [http://github.com/agentzh/echo-nginx-module ngx_echo]
+** [http://github.com/agentzh/memc-nginx-module ngx_memc]
+** [http://github.com/agentzh/srcache-nginx-module ngx_srcache]
+** ngx_lua (i.e., this module)
+** [http://github.com/agentzh/headers-more-nginx-module ngx_headers_more]
+** [http://github.com/chaoslawful/drizzle-nginx-module ngx_drizzle]
+** [http://github.com/agentzh/rds-json-nginx-module ngx_rds_json]
+** [https://github.com/FRiCKLE/ngx_coolkit ngx_coolkit]
+** [http://github.com/agentzh/redis2-nginx-module ngx_redis2]
+
+The order in which these modules are added during configuration is important because the position of any filter module in the
+filtering chain determines the final output, for example. The correct adding order is shown above.
+
+* 3rd-party Lua libraries:
+** [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson]
+
+* Applications:
+** mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
+** memcached: listening on the default port, 11211.
+** redis: listening on the default port, 6379.
+
+See also the [https://github.com/chaoslawful/lua-nginx-module/blob/master/util/build2.sh developer build script] for more details on setting up the testing environment.
+
+To run the whole test suite in the default testing mode:
+<geshi lang="text">
+    cd /path/to/lua-nginx-module
+    export PATH=/path/to/your/nginx/sbin:$PATH
+    prove -I/path/to/test-nginx/lib -r t
+</geshi>
+
+To run specific test files:
+<geshi lang="text">
+    cd /path/to/lua-nginx-module
+    export PATH=/path/to/your/nginx/sbin:$PATH
+    prove -I/path/to/test-nginx/lib t/002-content.t t/003-errors.t
+</geshi>
+
+To run a specific test block in a particular test file, add the line <code>--- ONLY</code> to the test block you want to run, and then use the `prove` utility to run that <code>.t</code> file.
+
+There are also various testing modes based on mockeagain, valgrind, and etc. Refer to the [http://search.cpan.org/perldoc?Test::Nginx Test::Nginx documentation] for more details for various advanced testing modes. See also the test reports for the Nginx test cluster running on Amazon EC2: http://qa.openresty.org.
+
+= Copyright and License =
+
+This module is licensed under the BSD license.
+
+Copyright (C) 2009-2013, by Xiaozhe Wang (chaoslawful) <chaoslawful@gmail.com>.
+
+Copyright (C) 2009-2013, by Yichun "agentzh" Zhang (章亦春) <agentzh@gmail.com>, CloudFlare Inc.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+= See Also =
+
+* [http://github.com/agentzh/lua-resty-memcached lua-resty-memcached] library based on ngx_lua cosocket.
+* [http://github.com/agentzh/lua-resty-redis lua-resty-redis] library based on ngx_lua cosocket.
+* [http://github.com/agentzh/lua-resty-mysql lua-resty-mysql] library based on ngx_lua cosocket.
+* [http://github.com/agentzh/lua-resty-upload lua-resty-upload] library based on ngx_lua cosocket.
+* [http://github.com/agentzh/lua-resty-dns lua-resty-dns] library based on ngx_lua cosocket.
+* [http://github.com/agentzh/lua-resty-websocket lua-resty-websocket] library for both WebSocket server and client, based on ngx_lua cosocket.
+* [http://github.com/agentzh/lua-resty-string lua-resty-string] library based on [http://luajit.org/ext_ffi.html LuaJIT FFI].
+* [http://github.com/agentzh/lua-resty-lock lua-resty-lock] library for a nonblocking simple lock API.
+* [http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs Routing requests to different MySQL queries based on URI arguments]
+* [http://openresty.org/#DynamicRoutingBasedOnRedis Dynamic Routing Based on Redis and Lua]
+* [http://openresty.org/#UsingLuaRocks Using LuaRocks with ngx_lua]
+* [https://github.com/chaoslawful/lua-nginx-module/wiki/Introduction Introduction to ngx_lua]
+* [http://github.com/simpl/ngx_devel_kit ngx_devel_kit]
+* [[HttpEchoModule]]
+* [[HttpDrizzleModule]]
+* [http://github.com/FRiCKLE/ngx_postgres postgres-nginx-module]
+* [[HttpMemcModule]]
+* [http://openresty.org The ngx_openresty bundle]
+* [https://github.com/agentzh/nginx-systemtap-toolkit Nginx Systemtap Toolkit]
+
diff -rNu a/src/lua/lua-nginx-module/dtrace/ngx_lua_provider.d b/src/lua/lua-nginx-module/dtrace/ngx_lua_provider.d
--- a/src/lua/lua-nginx-module/dtrace/ngx_lua_provider.d	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/dtrace/ngx_lua_provider.d	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,61 @@
+provider nginx_lua {
+    probe http__lua__info(char *s);
+
+    /* lua_State *L */
+    probe http__lua__register__preload__package(void *L, u_char *pkg);
+
+    probe http__lua__req__socket__consume__preread(ngx_http_request_t *r,
+            u_char *data, size_t len);
+
+    /* lua_State *parent, lua_State *child */
+    probe http__lua__user__coroutine__create(ngx_http_request_t *r,
+            void *parent, void *child);
+
+    /* lua_State *parent, lua_State *child */
+    probe http__lua__user__coroutine__resume(ngx_http_request_t *r,
+                                             void *parent, void *child);
+
+    /* lua_State *parent, lua_State *child */
+    probe http__lua__user__coroutine__yield(ngx_http_request_t *r,
+                                            void *parent, void *child);
+
+    /* lua_State *L */
+    probe http__lua__thread__yield(ngx_http_request_t *r, void *L);
+
+    /* ngx_http_lua_socket_tcp_upstream_t *u */
+    probe http__lua__socket__tcp__send__start(ngx_http_request_t *r,
+            void *u, u_char *data, size_t len);
+
+    /* ngx_http_lua_socket_tcp_upstream_t *u */
+    probe http__lua__socket__tcp__receive__done(ngx_http_request_t *r,
+            void *u, u_char *data, size_t len);
+
+    /* ngx_http_lua_socket_tcp_upstream_t *u */
+    probe http__lua__socket__tcp__setkeepalive__buf__unread(
+            ngx_http_request_t *r, void *u, u_char *data, size_t len);
+
+    /* lua_State *creator, lua_State *newthread */
+    probe http__lua__user__thread__spawn(ngx_http_request_t *r,
+            void *creator, void *newthread);
+
+    /* lua_State *thread, ngx_http_lua_ctx_t *ctx */
+    probe http__lua__thread__delete(ngx_http_request_t *r, void *thread, void *ctx);
+
+    /* lua_State *thread */
+    probe http__lua__run__posted__thread(ngx_http_request_t *r, void *thread,
+            int status);
+
+    probe http__lua__coroutine__done(ngx_http_request_t *r, void *co,
+            int success);
+
+    /* lua_State *parent, lua_State *child */
+    probe http__lua__user__thread__wait(void *parent, void *child);
+};
+
+
+#pragma D attributes Evolving/Evolving/Common      provider nginx_lua provider
+#pragma D attributes Private/Private/Unknown       provider nginx_lua module
+#pragma D attributes Private/Private/Unknown       provider nginx_lua function
+#pragma D attributes Private/Private/Common        provider nginx_lua name
+#pragma D attributes Evolving/Evolving/Common      provider nginx_lua args
+
diff -rNu a/src/lua/lua-nginx-module/.gitignore b/src/lua/lua-nginx-module/.gitignore
--- a/src/lua/lua-nginx-module/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/.gitignore	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,161 @@
+build/
+work/
+tags
+cscope.*
+*.mobi
+genmobi.sh
+.libs
+*.swp
+*.slo
+*.la
+*.swo
+*.lo
+*~
+*.o
+print.txt
+.rsync
+*.tar.gz
+dist
+build[789]
+build
+tags
+update-readme
+*.tmp
+test/Makefile
+test/blib
+test.sh
+t.sh
+t/t.sh
+test/t/servroot/
+releng
+reset
+*.t_
+src/handler.h
+src/util.c
+src/module.h
+src/module.c
+src/drizzle.c
+src/processor.h
+src/handler.c
+src/util.h
+src/drizzle.h
+src/processor.c
+src/output.c
+src/output.h
+libdrizzle
+ctags
+src/stream.h
+nginx
+keepalive
+reindex
+src/keepalive.c
+src/keepalive.h
+src/checker.h
+src/checker.c
+src/quoting.h
+src/quoting.c
+src/module.h
+src/module.c
+src/util.h
+src/util.c
+src/processor.h
+src/processor.c
+src/rds.h
+src/utils.h
+src/handler.c
+src/handler.h
+util/bench
+*.html
+trace.out*
+try.sh
+src/cache.c
+src/cache.h
+src/common.h
+src/directive.c
+src/directive.h
+src/consts.[ch]
+src/contentby.[ch]
+src/pcrefix.[ch]
+src/util.c
+src/clfactory.c
+src/directive.c
+src/conf.h
+src/setby.h
+src/cache.h
+src/hook.c
+src/util.h
+src/hook.h
+src/common.h
+src/directive.h
+src/conf.c
+src/setby.c
+src/cache.c
+src/module.c
+src/clfactory.h
+src/capturefilter.[ch]
+src/contentby.c
+pack
+b.sh
+src/in.[ch]
+src/out.[ch]
+go
+all.sh
+src/accessby.[ch]
+src/rewriteby.[ch]
+src/patch.[ch]
+src/ndk.[ch]
+src/control.[ch]
+src/output.[ch]
+src/variable.[ch]
+src/string.[ch]
+src/misc.[ch]
+src/log.[ch]
+src/exception.[ch]
+src/subrequest.[ch]
+src/time.[ch]
+src/regex.[ch]
+src/ctx.[ch]
+src/args.[ch]
+src/headers.[ch]
+src/script.[ch]
+src/filter.[ch]
+src/shdict.[ch]
+src/body.[ch]
+src/uri.[ch]
+src/api.[ch]
+src/coroutine.[ch]
+src/logby.[ch]
+src/sleep.[ch]
+a.patch
+all
+build1[0-9]
+g
+buildroot/
+src/headerfilterby.[ch]
+*.patch
+analyze
+tsock
+a.c
+test.lua
+build12
+ERRORS
+src/bodyfilterby.[ch]
+src/tcp.[ch]
+src/initby.[ch]
+src/socket.[ch]
+src/udp.[ch]
+src/method.[ch]
+tre
+src/phase.[ch]
+src/probe.h
+src/uthread.[ch]
+src/timer.[ch]
+*.plist
+lua
+ttimer
+Makefile
+tsubreq
+tthread
+addr2line
+hup
+theaders
diff -rNu a/src/lua/lua-nginx-module/.gitmodules b/src/lua/lua-nginx-module/.gitmodules
--- a/src/lua/lua-nginx-module/.gitmodules	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/.gitmodules	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,3 @@
+[submodule "deps/ngx_devel_kit"]
+	path = deps/ngx_devel_kit
+	url = git://github.com/simpl/ngx_devel_kit.git
diff -rNu a/src/lua/lua-nginx-module/misc/recv-until-pm/lib/RecvUntil.pm b/src/lua/lua-nginx-module/misc/recv-until-pm/lib/RecvUntil.pm
--- a/src/lua/lua-nginx-module/misc/recv-until-pm/lib/RecvUntil.pm	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/misc/recv-until-pm/lib/RecvUntil.pm	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,138 @@
+package RecvUntil;
+
+use strict;
+use warnings;
+
+sub recv_until {
+    my ($pat) = @_;
+
+    my $len = length $pat;
+    my @backtracks;
+
+    for (my $i = 1; $i <= $len - 1; $i++) {
+        my $matched_prefix_len = 1;
+        while ($matched_prefix_len <= $len - $i - 1) {
+            #while (1) {
+            #my $left = $len - $i;
+            #warn "left: $i: $len: ", $len - 1 - $i, "\n";
+            #warn "matched_prefix_len: $matched_prefix_len\n";
+
+            #while (1) {
+            my $prefix = substr($pat, 0, $matched_prefix_len);
+            my $next = substr($pat, $matched_prefix_len, 1);
+
+            my $prefix2 = substr($pat, $i, $matched_prefix_len);
+            my $next2 = substr($pat, $i + $matched_prefix_len, 1);
+
+            #warn "$i: global prefix $prefix $next\n";
+            #warn "$i: local prefix $prefix2 $next2\n";
+
+            if ($prefix2 eq $prefix) {
+                if ($next2 eq $next) {
+                    $matched_prefix_len++;
+                    next;
+                }
+
+                #warn "$matched_prefix_len: $prefix: found match at $i (next $next, next2 $next2)\n";
+                my $cur_state = $i + $matched_prefix_len;
+                my $new_state = $matched_prefix_len + 1;
+
+                my $matched = substr($pat, 0, $cur_state);
+
+                my $chain = $backtracks[$cur_state - 2];
+                if (!$chain) {
+                    $chain = [];
+                    $backtracks[$cur_state - 2] = $chain;
+                }
+
+                my $found = 0;
+                for my $rec (@$chain) {
+                    if ($rec->{char} eq $next) {
+                        $found = 1;
+
+                        if ($rec->{new_state} < $new_state) {
+                            warn "overriding...\n";
+                            $rec->{new_state} = $new_state;
+                        }
+                    }
+                }
+
+                if (!$found) {
+                    warn "on state $cur_state ($matched), if next is '$next', ",
+                        "then backtrack to state $new_state ($prefix$next)\n";
+
+                    push @$chain, { char => $next, new_state => $new_state };
+                }
+
+                #if ($matched_prefix_len > 1) {
+                #$i += $matched_prefix_len - 1;
+                #}
+
+                last;
+            }
+
+            last;
+        }
+    }
+
+    return sub {
+        my ($txt) = @_;
+
+        my $max_state = length $pat;
+        my $len = length $txt;
+        my $state = 0;
+        my $ret = '';
+
+        for (my $i = 0; $i < $len; $i++) {
+            # read the char
+            my $c = substr($txt, $i, 1);
+
+            #warn "$state: read char at $i: $c\n";
+            #warn "matched: $ret\n";
+
+            my $expected = substr($pat, $state, 1);
+            if ($expected eq $c) {
+                #warn "matched the char in pattern.\n";
+                $state++;
+
+                if ($state == $max_state) {
+                    last;
+                }
+
+                next;
+            }
+
+            if ($state == 0) {
+                #warn "did not match the first char in pattern\n";
+                $ret .= $c;
+                next;
+            }
+
+            my $old_state;
+            my $matched;
+            my $chain = $backtracks[$state - 2];
+            for my $rec (@$chain) {
+                if ($rec->{char} eq $c) {
+                    $old_state = $state;
+                    $state = $rec->{new_state};
+                    #warn "matched the char for backtracking to state $state\n";
+                    $matched = 1;
+                    last;
+                }
+            }
+
+            if (!$matched) {
+                $ret .= substr($pat, 0, $state);
+                $state = 0;
+                redo;
+            }
+
+            $ret .= substr($pat, 0, $old_state + 1 - $state);
+            next;
+        }
+
+        return $ret;
+    };
+}
+
+1;
diff -rNu a/src/lua/lua-nginx-module/misc/recv-until-pm/Makefile b/src/lua/lua-nginx-module/misc/recv-until-pm/Makefile
--- a/src/lua/lua-nginx-module/misc/recv-until-pm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/misc/recv-until-pm/Makefile	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,3 @@
+test:
+	prove -Ilib -r t
+
diff -rNu a/src/lua/lua-nginx-module/misc/recv-until-pm/t/sanity.t b/src/lua/lua-nginx-module/misc/recv-until-pm/t/sanity.t
--- a/src/lua/lua-nginx-module/misc/recv-until-pm/t/sanity.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/misc/recv-until-pm/t/sanity.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,140 @@
+# vi:ft=
+
+use 5.10.1;
+use Test::Base;
+use RecvUntil;
+
+plan tests => 1 * blocks();
+
+run {
+    my $block = shift;
+    my $name = $block->name;
+    my $pat = $block->pat // die "$name: No --- pat found";
+    my $txt = $block->txt // die "$name: No --- txt found";
+
+    my $expected = $block->out // die "$name: No --- out found";
+
+    my $it = RecvUntil::recv_until($pat);
+    is $it->($txt), $expected, "$name: output ok";
+};
+
+__DATA__
+
+=== TEST 1:
+--- pat: abcabd
+--- txt: abcabcabd
+--- out: abc
+
+
+
+=== TEST 2:
+--- pat: aa
+--- txt: abcabcaad
+--- out: abcabc
+
+
+
+=== TEST 3:
+--- pat: ab
+--- txt: bbcabcaad
+--- out: bbc
+
+
+
+=== TEST 4:
+--- pat: aaa
+--- txt: abaabcaaaef
+--- out: abaabc
+
+
+
+=== TEST 5:
+--- pat: aaaaad
+--- txt: baaaaaaaaeaaaaaaadf
+--- out: baaaaaaaaeaa
+
+
+
+=== TEST 6:
+--- pat: abacadae
+--- txt: a
+--- out:
+
+
+
+=== TEST 7:
+--- pat: abacadae
+--- txt: ababacadae
+--- out: ab
+
+
+
+=== TEST 8:
+--- pat: abacadae
+--- txt: abacabacadae
+--- out: abac
+
+
+
+=== TEST 9:
+--- pat: abacadae
+--- txt: abaabacadae
+--- out: aba
+
+
+
+=== TEST 10:
+--- pat: abacadae
+--- txt: abacadabacadae
+--- out: abacad
+
+
+
+=== TEST 11:
+--- pat: abcabdabcabe
+--- txt: abcabdabcabdabcabe
+--- out: abcabd
+
+
+
+=== TEST 12:
+--- pat: abcabdabcabe
+--- txt: abcabdabcabcabdabcabe
+--- out: abcabdabc
+
+
+
+=== TEST 13:
+--- pat: abcabdabcabe
+--- txt: abcabcabdabcabe
+--- out: abc
+
+
+
+=== TEST 14:
+--- pat: abcabdabcabe
+--- txt: ababcabdabcabe
+--- out: ab
+
+
+
+=== TEST 15:
+--- pat: abcdef
+--- txt: abcabcdef
+--- out: abc
+
+
+
+=== TEST 16:
+--- pat: -- abc
+--- txt: ---- abc
+--- out: --
+
+
+
+=== TEST 17:
+--- pat: yz--ababyz
+--- txt: 
+--- out: --
+--- SKIP
+
diff -rNu a/src/lua/lua-nginx-module/README b/src/lua/lua-nginx-module/README
--- a/src/lua/lua-nginx-module/README	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/README	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,6328 @@
+Name
+    ngx_lua - Embed the power of Lua into Nginx
+
+    *This module is not distributed with the Nginx source.* See the
+    installation instructions.
+
+Status
+    This module is under active development and is production ready.
+
+Version
+    This document describes ngx_lua v0.9.0
+    (<https://github.com/chaoslawful/lua-nginx-module/tags>) released on 29
+    September 2013.
+
+Synopsis
+        # set search paths for pure Lua external libraries (';;' is the default path):
+        lua_package_path '/foo/bar/?.lua;/blah/?.lua;;';
+
+        # set search paths for Lua external libraries written in C (can also use ';;'):
+        lua_package_cpath '/bar/baz/?.so;/blah/blah/?.so;;';
+
+        server {
+            location /inline_concat {
+                # MIME type determined by default_type:
+                default_type 'text/plain';
+
+                set $a "hello";
+                set $b "world";
+                # inline Lua script
+                set_by_lua $res "return ngx.arg[1]..ngx.arg[2]" $a $b;
+                echo $res;
+            }
+
+            location /rel_file_concat {
+                set $a "foo";
+                set $b "bar";
+                # script path relative to nginx prefix
+                # $ngx_prefix/conf/concat.lua contents:
+                #
+                #    return ngx.arg[1]..ngx.arg[2]
+                #
+                set_by_lua_file $res conf/concat.lua $a $b;
+                echo $res;
+            }
+
+            location /abs_file_concat {
+                set $a "fee";
+                set $b "baz";
+                # absolute script path not modified
+                set_by_lua_file $res /usr/nginx/conf/concat.lua $a $b;
+                echo $res;
+            }
+
+            location /lua_content {
+                # MIME type determined by default_type:
+                default_type 'text/plain';
+
+                content_by_lua "ngx.say('Hello,world!')";
+            }
+
+             location /nginx_var {
+                # MIME type determined by default_type:
+                default_type 'text/plain';
+
+                # try access /nginx_var?a=hello,world
+                content_by_lua "ngx.print(ngx.var['arg_a'], '\\n')";
+            }
+
+            location /request_body {
+                 # force reading request body (default off)
+                 lua_need_request_body on;
+                 client_max_body_size 50k;
+                 client_body_buffer_size 50k;
+
+                 content_by_lua 'ngx.print(ngx.var.request_body)';
+            }
+
+            # transparent non-blocking I/O in Lua via subrequests
+            location /lua {
+                # MIME type determined by default_type:
+                default_type 'text/plain';
+
+                content_by_lua '
+                    local res = ngx.location.capture("/some_other_location")
+                    if res.status == 200 then
+                        ngx.print(res.body)
+                    end';
+            }
+
+            # GET /recur?num=5
+            location /recur {
+                # MIME type determined by default_type:
+                default_type 'text/plain';
+
+                content_by_lua '
+                   local num = tonumber(ngx.var.arg_num) or 0
+
+                   if num > 50 then
+                       ngx.say("num too big")
+                       return
+                   end
+
+                   ngx.say("num is: ", num)
+
+                   if num > 0 then
+                       res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
+                       ngx.print("status=", res.status, " ")
+                       ngx.print("body=", res.body)
+                   else
+                       ngx.say("end")
+                   end
+                   ';
+            }
+
+            location /foo {
+                rewrite_by_lua '
+                    res = ngx.location.capture("/memc",
+                        { args = { cmd = "incr", key = ngx.var.uri } }
+                    )
+                ';
+
+                proxy_pass http://blah.blah.com;
+            }
+
+            location /blah {
+                access_by_lua '
+                    local res = ngx.location.capture("/auth")
+
+                    if res.status == ngx.HTTP_OK then
+                        return
+                    end
+
+                    if res.status == ngx.HTTP_FORBIDDEN then
+                        ngx.exit(res.status)
+                    end
+
+                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+                ';
+
+                # proxy_pass/fastcgi_pass/postgres_pass/...
+            }
+
+            location /mixed {
+                rewrite_by_lua_file /path/to/rewrite.lua;
+                access_by_lua_file /path/to/access.lua;
+                content_by_lua_file /path/to/content.lua;
+            }
+
+            # use nginx var in code path
+            # WARN: contents in nginx var must be carefully filtered,
+            # otherwise there'll be great security risk!
+            location ~ ^/app/(.+) {
+                    content_by_lua_file /path/to/lua/app/root/$1.lua;
+            }
+
+            location / {
+               lua_need_request_body on;
+
+               client_max_body_size 100k;
+               client_body_buffer_size 100k;
+
+               access_by_lua '
+                   -- check the client IP address is in our black list
+                   if ngx.var.remote_addr == "132.5.72.3" then
+                       ngx.exit(ngx.HTTP_FORBIDDEN)
+                   end
+
+                   -- check if the request body contains bad words
+                   if ngx.var.request_body and
+                            string.match(ngx.var.request_body, "fsck")
+                   then
+                       return ngx.redirect("/terms_of_use.html")
+                   end
+
+                   -- tests passed
+               ';
+
+               # proxy_pass/fastcgi_pass/etc settings
+            }
+        }
+
+Description
+    This module embeds Lua, via the standard Lua 5.1 interpreter or LuaJIT
+    2.0 (<http://luajit.org/luajit.html>), into Nginx and by leveraging
+    Nginx's subrequests, allows the integration of the powerful Lua threads
+    (Lua coroutines) into the Nginx event model.
+
+    Unlike Apache's mod_lua
+    (<http://httpd.apache.org/docs/2.3/mod/mod_lua.html>) and Lighttpd's
+    mod_magnet (<http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet>), Lua
+    code executed using this module can be *100% non-blocking* on network
+    traffic as long as the Nginx API for Lua provided by this module is used
+    to handle requests to upstream services such as MySQL, PostgreSQL,
+    Memcached, Redis, or upstream HTTP web services.
+
+    At least the following Lua libraries and Nginx modules can be used with
+    this ngx_lua module:
+
+    *   lua-resty-memcached
+        (<https://github.com/agentzh/lua-resty-memcached>)
+
+    *   lua-resty-mysql (<https://github.com/agentzh/lua-resty-mysql>)
+
+    *   lua-resty-redis (<https://github.com/agentzh/lua-resty-redis>)
+
+    *   lua-resty-dns (<https://github.com/agentzh/lua-resty-dns>)
+
+    *   lua-resty-upload (<https://github.com/agentzh/lua-resty-upload>)
+
+    *   ngx_memc
+
+    *   ngx_postgres (<https://github.com/FRiCKLE/ngx_postgres>)
+
+    *   ngx_redis2
+
+    *   ngx_redis
+
+    *   ngx_proxy
+
+    *   ngx_fastcgi
+
+    Almost all the Nginx modules can be used with this ngx_lua module by
+    means of ngx.location.capture or ngx.location.capture_multi but it is
+    recommended to use those "lua-resty-*" libraries instead of creating
+    subrequests to access the Nginx upstream modules because the former is
+    usually much more flexible and memory-efficient.
+
+    The Lua interpreter or LuaJIT instance is shared across all the requests
+    in a single nginx worker process but request contexts are segregated
+    using lightweight Lua coroutines.
+
+    Loaded Lua modules persist in the nginx worker process level resulting
+    in a small memory footprint in Lua even when under heavy loads.
+
+Directives
+  lua_code_cache
+    syntax: *lua_code_cache on | off*
+
+    default: *lua_code_cache on*
+
+    context: *main, server, location, location if*
+
+    Enables or disables the Lua code cache for set_by_lua_file,
+    content_by_lua_file, rewrite_by_lua_file, and access_by_lua_file, and
+    also force Lua module reloading on a per-request basis.
+
+    The Lua files referenced in set_by_lua_file, content_by_lua_file,
+    access_by_lua_file, and rewrite_by_lua_file will not be cached and the
+    Lua "package.loaded" table will be cleared at the entry point of every
+    request (such that Lua modules will not be cached either). With this in
+    place, developers can adopt an edit-and-refresh approach.
+
+    Please note however, that Lua code written inlined within nginx.conf
+    such as those specified by set_by_lua, content_by_lua, access_by_lua,
+    and rewrite_by_lua will *always* be cached because only the Nginx config
+    file parser can correctly parse the "nginx.conf" file and the only ways
+    to to reload the config file are to send a "HUP" signal or to restart
+    Nginx.
+
+    Also, Lua files which are loaded by "dofile" or "loadfile" in
+    *_by_lua_file will never be cached. To ensure code caching, you can
+    either use the init_by_lua or init_by_lua_file directives to load all
+    such files or just make these Lua files true Lua modules and load them
+    via "require".
+
+    The ngx_lua module does not currently support the "stat" mode available
+    with the Apache "mod_lua" module but this is planned for implementation
+    in the future.
+
+    Disabling the Lua code cache is strongly discouraged for production use
+    and should only be used during development as it has a significant
+    negative impact on overall performance. In addition, race conditions
+    when reloading Lua modules are common for concurrent requests when the
+    code cache is disabled.
+
+  lua_regex_cache_max_entries
+    syntax: *lua_regex_cache_max_entries <num>*
+
+    default: *lua_regex_cache_max_entries 1024*
+
+    context: *http*
+
+    Specifies the maximum number of entries allowed in the worker process
+    level compiled regex cache.
+
+    The regular expressions used in ngx.re.match, ngx.re.gmatch, ngx.re.sub,
+    and ngx.re.gsub will be cached within this cache if the regex option "o"
+    (i.e., compile-once flag) is specified.
+
+    The default number of entries allowed is 1024 and when this limit is
+    reached, new regular expressions will not be cached (as if the "o"
+    option was not specified) and there will be one, and only one, warning
+    in the "error.log" file:
+
+        2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...
+
+    Do not activate the "o" option for regular expressions (and/or "replace"
+    string arguments for ngx.re.sub and ngx.re.gsub) that are generated *on
+    the fly* and give rise to infinite variations to avoid hitting the
+    specified limit.
+
+  lua_regex_match_limit
+    syntax: *lua_regex_match_limit <num>*
+
+    default: *lua_regex_match_limit 0*
+
+    context: *http*
+
+    Specifies the "match limit" used by the PCRE library when executing the
+    ngx.re API. To quote the PCRE manpage, "the limit ... has the effect of
+    limiting the amount of backtracking that can take place."
+
+    When the limit is hit, the error string "pcre_exec() failed: -8" will be
+    returned by the ngx.re API functions on the Lua land.
+
+    When setting the limit to 0, the default "match limit" when compiling
+    the PCRE library is used. And this is the default value of this
+    directive.
+
+    This directive was first introduced in the "v0.8.5" release.
+
+  lua_package_path
+    syntax: *lua_package_path <lua-style-path-str>*
+
+    default: *The content of LUA_PATH environ variable or Lua's compiled-in
+    defaults.*
+
+    context: *main*
+
+    Sets the Lua module search path used by scripts specified by set_by_lua,
+    content_by_lua and others. The path string is in standard Lua path form,
+    and ";;" can be used to stand for the original search paths.
+
+    As from the "v0.5.0rc29" release, the special notation $prefix or
+    "${prefix}" can be used in the search path string to indicate the path
+    of the "server prefix" usually determined by the "-p PATH" command-line
+    option while starting the Nginx server.
+
+  lua_package_cpath
+    syntax: *lua_package_cpath <lua-style-cpath-str>*
+
+    default: *The content of LUA_CPATH environment variable or Lua's
+    compiled-in defaults.*
+
+    context: *main*
+
+    Sets the Lua C-module search path used by scripts specified by
+    set_by_lua, content_by_lua and others. The cpath string is in standard
+    Lua cpath form, and ";;" can be used to stand for the original cpath.
+
+    As from the "v0.5.0rc29" release, the special notation $prefix or
+    "${prefix}" can be used in the search path string to indicate the path
+    of the "server prefix" usually determined by the "-p PATH" command-line
+    option while starting the Nginx server.
+
+  init_by_lua
+    syntax: *init_by_lua <lua-script-str>*
+
+    context: *http*
+
+    phase: *loading-config*
+
+    Runs the Lua code specified by the argument "<lua-script-str>" on the
+    global Lua VM level when the Nginx master process (if any) is loading
+    the Nginx config file.
+
+    When Nginx receives the "HUP" signal and starts reloading the config
+    file, the Lua VM will also be re-created and "init_by_lua" will run
+    again on the new Lua VM.
+
+    Usually you can register (true) Lua global variables or pre-load Lua
+    modules at server start-up by means of this hook. Here is an example for
+    pre-loading Lua modules:
+
+        init_by_lua 'cjson = require "cjson"';
+
+        server {
+            location = /api {
+                content_by_lua '
+                    ngx.say(cjson.encode({dog = 5, cat = 6}))
+                ';
+            }
+        }
+
+    You can also initialize the lua_shared_dict shm storage at this phase.
+    Here is an example for this:
+
+        lua_shared_dict dogs 1m;
+
+        init_by_lua '
+            local dogs = ngx.shared.dogs;
+            dogs:set("Tom", 56)
+        ';
+
+        server {
+            location = /api {
+                content_by_lua '
+                    local dogs = ngx.shared.dogs;
+                    ngx.say(dogs:get("Tom"))
+                ';
+            }
+        }
+
+    But note that, the lua_shared_dict's shm storage will not be cleared
+    through a config reload (via the "HUP" signal, for example). So if you
+    do *not* want to re-initialize the shm storage in your "init_by_lua"
+    code in this case, then you just need to set a custom flag in the shm
+    storage and always check the flag in your "init_by_lua" code.
+
+    Because the Lua code in this context runs before Nginx forks its worker
+    processes (if any), data or code loaded here will enjoy the
+    Copy-on-write (COW) (<http://en.wikipedia.org/wiki/Copy-on-write>)
+    feature provided by many operating systems among all the worker
+    processes, thus saving a lot of memory.
+
+    Only a small set of the Nginx API for Lua is supported in this context:
+
+    *   Logging APIs: ngx.log and print,
+
+    *   Shared Dictionary API: ngx.shared.DICT.
+
+    More Nginx APIs for Lua may be supported in this context upon future
+    user requests.
+
+    Basically you can safely use Lua libraries that do blocking I/O in this
+    very context because blocking the master process during server start-up
+    is completely okay. Even the Nginx core does blocking I/O (at least on
+    resolving upstream's host names) at the configure-loading phase.
+
+    You should be very careful about potential security vulnerabilities in
+    your Lua code registered in this context because the Nginx master
+    process is often run under the "root" account.
+
+    This directive was first introduced in the "v0.5.5" release.
+
+  init_by_lua_file
+    syntax: *init_by_lua_file <path-to-lua-script-file>*
+
+    context: *http*
+
+    phase: *loading-config*
+
+    Equivalent to init_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code or Lua/LuaJIT bytecode
+    to be executed.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    This directive was first introduced in the "v0.5.5" release.
+
+  set_by_lua
+    syntax: *set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]*
+
+    context: *server, server if, location, location if*
+
+    phase: *server-rewrite, rewrite*
+
+    Executes code specified in "<lua-script-str>" with optional input
+    arguments "$arg1 $arg2 ...", and returns string output to $res. The code
+    in "<lua-script-str>" can make API calls and can retrieve input
+    arguments from the "ngx.arg" table (index starts from 1 and increases
+    sequentially).
+
+    This directive is designed to execute short, fast running code blocks as
+    the Nginx event loop is blocked during code execution. Time consuming
+    code sequences should therefore be avoided.
+
+    Note that the following API functions are currently disabled within this
+    context:
+
+    *   Output API functions (e.g., ngx.say and ngx.send_headers)
+
+    *   Control API functions (e.g., ngx.exit)
+
+    *   Subrequest API functions (e.g., ngx.location.capture and
+        ngx.location.capture_multi)
+
+    *   Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).
+
+    In addition, note that this directive can only write out a value to a
+    single Nginx variable at a time. However, a workaround is possible using
+    the ngx.var.VARIABLE interface.
+
+        location /foo {
+            set $diff ''; # we have to predefine the $diff variable here
+
+            set_by_lua $sum '
+                local a = 32
+                local b = 56
+
+                ngx.var.diff = a - b;  -- write to $diff directly
+                return a + b;          -- return the $sum value normally
+            ';
+
+            echo "sum = $sum, diff = $diff";
+        }
+
+    This directive can be freely mixed with all directives of the
+    [[HttpRewriteModule]], [[HttpSetMiscModule]], and [[HttpArrayVarModule]]
+    modules. All of these directives will run in the same order as they
+    appear in the config file.
+
+        set $foo 32;
+        set_by_lua $bar 'tonumber(ngx.var.foo) + 1';
+        set $baz "bar: $bar";  # $baz == "bar: 33"
+
+    As from the "v0.5.0rc29" release, Nginx variable interpolation is
+    disabled in the "<lua-script-str>" argument of this directive and
+    therefore, the dollar sign character ("$") can be used directly.
+
+    This directive requires the ngx_devel_kit
+    (<https://github.com/simpl/ngx_devel_kit>) module.
+
+  set_by_lua_file
+    syntax: *set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2
+    ...]*
+
+    context: *server, server if, location, location if*
+
+    phase: *server-rewrite, rewrite*
+
+    Equivalent to set_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or, as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    Nginx variable interpolation is supported in the
+    "<path-to-lua-script-file>" argument string of this directive. But
+    special care must be taken for injection attacks.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    When the Lua code cache is turned on (by default), the user code is
+    loaded once at the first request and cached and the Nginx config must be
+    reloaded each time the Lua source file is modified. The Lua code cache
+    can be temporarily disabled during development by switching
+    lua_code_cache "off" in "nginx.conf" to avoid reloading Nginx.
+
+    This directive requires the ngx_devel_kit
+    (<https://github.com/simpl/ngx_devel_kit>) module.
+
+  content_by_lua
+    syntax: *content_by_lua <lua-script-str>*
+
+    context: *location, location if*
+
+    phase: *content*
+
+    Acts as a "content handler" and executes Lua code string specified in
+    "<lua-script-str>" for every request. The Lua code may make API calls
+    and is executed as a new spawned coroutine in an independent global
+    environment (i.e. a sandbox).
+
+    Do not use this directive and other content handler directives in the
+    same location. For example, this directive and the proxy_pass directive
+    should not be used in the same location.
+
+  content_by_lua_file
+    syntax: *content_by_lua_file <path-to-lua-script-file>*
+
+    context: *location, location if*
+
+    phase: *content*
+
+    Equivalent to content_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or, as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    Nginx variables can be used in the "<path-to-lua-script-file>" string to
+    provide flexibility. This however carries some risks and is not
+    ordinarily recommended.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    When the Lua code cache is turned on (by default), the user code is
+    loaded once at the first request and cached and the Nginx config must be
+    reloaded each time the Lua source file is modified. The Lua code cache
+    can be temporarily disabled during development by switching
+    lua_code_cache "off" in "nginx.conf" to avoid reloading Nginx.
+
+  rewrite_by_lua
+    syntax: *rewrite_by_lua <lua-script-str>*
+
+    context: *http, server, location, location if*
+
+    phase: *rewrite tail*
+
+    Acts as a rewrite phase handler and executes Lua code string specified
+    in "<lua-script-str>" for every request. The Lua code may make API calls
+    and is executed as a new spawned coroutine in an independent global
+    environment (i.e. a sandbox).
+
+    Note that this handler always runs *after* the standard
+    [[HttpRewriteModule]]. So the following will work as expected:
+
+       location /foo {
+           set $a 12; # create and initialize $a
+           set $b ""; # create and initialize $b
+           rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
+           echo "res = $b";
+       }
+
+    because "set $a 12" and "set $b """ run *before* rewrite_by_lua.
+
+    On the other hand, the following will not work as expected:
+
+        ?  location /foo {
+        ?      set $a 12; # create and initialize $a
+        ?      set $b ''; # create and initialize $b
+        ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
+        ?      if ($b = '13') {
+        ?         rewrite ^ /bar redirect;
+        ?         break;
+        ?      }
+        ?
+        ?      echo "res = $b";
+        ?  }
+
+    because "if" runs *before* rewrite_by_lua even if it is placed after
+    rewrite_by_lua in the config.
+
+    The right way of doing this is as follows:
+
+        location /foo {
+            set $a 12; # create and initialize $a
+            set $b ''; # create and initialize $b
+            rewrite_by_lua '
+                ngx.var.b = tonumber(ngx.var.a) + 1
+                if tonumber(ngx.var.b) == 13 then
+                    return ngx.redirect("/bar");
+                end
+            ';
+
+            echo "res = $b";
+        }
+
+    Note that the ngx_eval (<http://www.grid.net.ru/nginx/eval.en.html>)
+    module can be approximated by using rewrite_by_lua. For example,
+
+        location / {
+            eval $res {
+                proxy_pass http://foo.com/check-spam;
+            }
+
+            if ($res = 'spam') {
+                rewrite ^ /terms-of-use.html redirect;
+            }
+
+            fastcgi_pass ...;
+        }
+
+    can be implemented in ngx_lua as:
+
+        location = /check-spam {
+            internal;
+            proxy_pass http://foo.com/check-spam;
+        }
+
+        location / {
+            rewrite_by_lua '
+                local res = ngx.location.capture("/check-spam")
+                if res.body == "spam" then
+                    return ngx.redirect("/terms-of-use.html")
+                end
+            ';
+
+            fastcgi_pass ...;
+        }
+
+    Just as any other rewrite phase handlers, rewrite_by_lua also runs in
+    subrequests.
+
+    Note that when calling "ngx.exit(ngx.OK)" within a rewrite_by_lua
+    handler, the nginx request processing control flow will still continue
+    to the content handler. To terminate the current request from within a
+    rewrite_by_lua handler, calling ngx.exit with status >= 200
+    ("ngx.HTTP_OK") and status < 300 ("ngx.HTTP_SPECIAL_RESPONSE") for
+    successful quits and "ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)" (or its
+    friends) for failures.
+
+    If the [[HttpRewriteModule]]'s rewrite directive is used to change the
+    URI and initiate location re-lookups (internal redirections), then any
+    rewrite_by_lua or rewrite_by_lua_file code sequences within the current
+    location will not be executed. For example,
+
+        location /foo {
+            rewrite ^ /bar;
+            rewrite_by_lua 'ngx.exit(503)';
+        }
+        location /bar {
+            ...
+        }
+
+    Here the Lua code "ngx.exit(503)" will never run. This will be the case
+    if "rewrite ^ /bar last" is used as this will similarly initiate an
+    internal redirection. If the "break" modifier is used instead, there
+    will be no internal redirection and the "rewrite_by_lua" code will be
+    executed.
+
+    The "rewrite_by_lua" code will always run at the end of the "rewrite"
+    request-processing phase unless rewrite_by_lua_no_postpone is turned on.
+
+  rewrite_by_lua_file
+    syntax: *rewrite_by_lua_file <path-to-lua-script-file>*
+
+    context: *http, server, location, location if*
+
+    phase: *rewrite tail*
+
+    Equivalent to rewrite_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or, as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    Nginx variables can be used in the "<path-to-lua-script-file>" string to
+    provide flexibility. This however carries some risks and is not
+    ordinarily recommended.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    When the Lua code cache is turned on (by default), the user code is
+    loaded once at the first request and cached and the Nginx config must be
+    reloaded each time the Lua source file is modified. The Lua code cache
+    can be temporarily disabled during development by switching
+    lua_code_cache "off" in "nginx.conf" to avoid reloading Nginx.
+
+    The "rewrite_by_lua_file" code will always run at the end of the
+    "rewrite" request-processing phase unless rewrite_by_lua_no_postpone is
+    turned on.
+
+  access_by_lua
+    syntax: *access_by_lua <lua-script-str>*
+
+    context: *http, server, location, location if*
+
+    phase: *access tail*
+
+    Acts as an access phase handler and executes Lua code string specified
+    in "<lua-script-str>" for every request. The Lua code may make API calls
+    and is executed as a new spawned coroutine in an independent global
+    environment (i.e. a sandbox).
+
+    Note that this handler always runs *after* the standard
+    [[HttpAccessModule]]. So the following will work as expected:
+
+        location / {
+            deny    192.168.1.1;
+            allow   192.168.1.0/24;
+            allow   10.1.1.0/16;
+            deny    all;
+
+            access_by_lua '
+                local res = ngx.location.capture("/mysql", { ... })
+                ...
+            ';
+
+            # proxy_pass/fastcgi_pass/...
+        }
+
+    That is, if a client IP address is in the blacklist, it will be denied
+    before the MySQL query for more complex authentication is executed by
+    access_by_lua.
+
+    Note that the ngx_auth_request
+    (<http://mdounin.ru/hg/ngx_http_auth_request_module/>) module can be
+    approximated by using access_by_lua:
+
+        location / {
+            auth_request /auth;
+
+            # proxy_pass/fastcgi_pass/postgres_pass/...
+        }
+
+    can be implemented in ngx_lua as:
+
+        location / {
+            access_by_lua '
+                local res = ngx.location.capture("/auth")
+
+                if res.status == ngx.HTTP_OK then
+                    return
+                end
+
+                if res.status == ngx.HTTP_FORBIDDEN then
+                    ngx.exit(res.status)
+                end
+
+                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+            ';
+
+            # proxy_pass/fastcgi_pass/postgres_pass/...
+        }
+
+    As with other access phase handlers, access_by_lua will *not* run in
+    subrequests.
+
+    Note that when calling "ngx.exit(ngx.OK)" within a access_by_lua
+    handler, the nginx request processing control flow will still continue
+    to the content handler. To terminate the current request from within a
+    access_by_lua handler, calling ngx.exit with status >= 200
+    ("ngx.HTTP_OK") and status < 300 ("ngx.HTTP_SPECIAL_RESPONSE") for
+    successful quits and "ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)" (or its
+    friends) for failures.
+
+  access_by_lua_file
+    syntax: *access_by_lua_file <path-to-lua-script-file>*
+
+    context: *http, server, location, location if*
+
+    phase: *access tail*
+
+    Equivalent to access_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or, as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    Nginx variables can be used in the "<path-to-lua-script-file>" string to
+    provide flexibility. This however carries some risks and is not
+    ordinarily recommended.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    When the Lua code cache is turned on (by default), the user code is
+    loaded once at the first request and cached and the Nginx config must be
+    reloaded each time the Lua source file is modified. The Lua code cache
+    can be temporarily disabled during development by switching
+    lua_code_cache "off" in "nginx.conf" to avoid repeatedly reloading
+    Nginx.
+
+  header_filter_by_lua
+    syntax: *header_filter_by_lua <lua-script-str>*
+
+    context: *http, server, location, location if*
+
+    phase: *output-header-filter*
+
+    Uses Lua code specified in "<lua-script-str>" to define an output header
+    filter.
+
+    Note that the following API functions are currently disabled within this
+    context:
+
+    *   Output API functions (e.g., ngx.say and ngx.send_headers)
+
+    *   Control API functions (e.g., ngx.exit and ngx.exec)
+
+    *   Subrequest API functions (e.g., ngx.location.capture and
+        ngx.location.capture_multi)
+
+    *   Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).
+
+    Here is an example of overriding a response header (or adding one if
+    absent) in our Lua header filter:
+
+        location / {
+            proxy_pass http://mybackend;
+            header_filter_by_lua 'ngx.header.Foo = "blah"';
+        }
+
+    This directive was first introduced in the "v0.2.1rc20" release.
+
+  header_filter_by_lua_file
+    syntax: *header_filter_by_lua_file <path-to-lua-script-file>*
+
+    context: *http, server, location, location if*
+
+    phase: *output-header-filter*
+
+    Equivalent to header_filter_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    This directive was first introduced in the "v0.2.1rc20" release.
+
+  body_filter_by_lua
+    syntax: *body_filter_by_lua <lua-script-str>*
+
+    context: *http, server, location, location if*
+
+    phase: *output-body-filter*
+
+    Uses Lua code specified in "<lua-script-str>" to define an output body
+    filter.
+
+    The input data chunk is passed via ngx.arg[1] (as a Lua string value)
+    and the "eof" flag indicating the end of the response body data stream
+    is passed via ngx.arg[2] (as a Lua boolean value).
+
+    Behind the scene, the "eof" flag is just the "last_buf" (for main
+    requests) or "last_in_chain" (for subrequests) flag of the Nginx chain
+    link buffers. (Before the "v0.7.14" release, the "eof" flag does not
+    work at all in subrequests.)
+
+    The output data stream can be aborted immediately by running the
+    following Lua statement:
+
+        return ngx.ERROR
+
+    This will truncate the response body and usually result in incomplete
+    and also invalid responses.
+
+    The Lua code can pass its own modified version of the input data chunk
+    to the downstream Nginx output body filters by overriding ngx.arg[1]
+    with a Lua string or a Lua table of strings. For example, to transform
+    all the lowercase letters in the response body, we can just write:
+
+        location / {
+            proxy_pass http://mybackend;
+            body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';
+        }
+
+    When setting "nil" or an empty Lua string value to "ngx.arg[1]", no data
+    chunk will be passed to the downstream Nginx output filters at all.
+
+    Likewise, new "eof" flag can also be specified by setting a boolean
+    value to ngx.arg[2]. For example,
+
+        location /t {
+            echo hello world;
+            echo hiya globe;
+
+            body_filter_by_lua '
+                local chunk = ngx.arg[1]
+                if string.match(chunk, "hello") then
+                    ngx.arg[2] = true  -- new eof
+                    return
+                end
+
+                -- just throw away any remaining chunk data
+                ngx.arg[1] = nil
+            ';
+        }
+
+    Then "GET /t" will just return the output
+
+        hello world
+
+    That is, when the body filter sees a chunk containing the word "hello",
+    then it will set the "eof" flag to true immediately, resulting in
+    truncated but still valid responses.
+
+    When the Lua code may change the length of the response body, then it is
+    required to always clear out the "Content-Length" response header (if
+    any) in a header filter to enforce streaming output, as in
+
+        location /foo {
+            # fastcgi_pass/proxy_pass/...
+
+            header_filter_by_lua 'ngx.header.content_length = nil';
+            body_filter_by_lua 'ngx.arg[1] = string.len(ngx.arg[1]) .. "\\n"';
+        }
+
+    Note that the following API functions are currently disabled within this
+    context:
+
+    *   Output API functions (e.g., ngx.say and ngx.send_headers)
+
+    *   Control API functions (e.g., ngx.exit and ngx.exec)
+
+    *   Subrequest API functions (e.g., ngx.location.capture and
+        ngx.location.capture_multi)
+
+    *   Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).
+
+    Nginx output filters may be called multiple times for a single request
+    because response body may be delivered in chunks. Thus, the Lua code
+    specified by in this directive may also run multiple times in the
+    lifetime of a single HTTP request.
+
+    This directive was first introduced in the "v0.5.0rc32" release.
+
+  body_filter_by_lua_file
+    syntax: *body_filter_by_lua_file <path-to-lua-script-file>*
+
+    context: *http, server, location, location if*
+
+    phase: *output-body-filter*
+
+    Equivalent to body_filter_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or, as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    This directive was first introduced in the "v0.5.0rc32" release.
+
+  log_by_lua
+    syntax: *log_by_lua <lua-script-str>*
+
+    context: *http, server, location, location if*
+
+    phase: *log*
+
+    Run the Lua source code inlined as the "<lua-script-str>" at the "log"
+    request processing phase. This does not replace the current access logs,
+    but runs after.
+
+    Note that the following API functions are currently disabled within this
+    context:
+
+    *   Output API functions (e.g., ngx.say and ngx.send_headers)
+
+    *   Control API functions (e.g., ngx.exit)
+
+    *   Subrequest API functions (e.g., ngx.location.capture and
+        ngx.location.capture_multi)
+
+    *   Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).
+
+    Here is an example of gathering average data for
+    $upstream_response_time:
+
+        lua_shared_dict log_dict 5M;
+
+        server {
+            location / {
+                proxy_pass http://mybackend;
+
+                log_by_lua '
+                    local log_dict = ngx.shared.log_dict
+                    local upstream_time = tonumber(ngx.var.upstream_response_time)
+
+                    local sum = log_dict:get("upstream_time-sum") or 0
+                    sum = sum + upstream_time
+                    log_dict:set("upstream_time-sum", sum)
+
+                    local newval, err = log_dict:incr("upstream_time-nb", 1)
+                    if not newval and err == "not found" then
+                        log_dict:add("upstream_time-nb", 0)
+                        log_dict:incr("upstream_time-nb", 1)
+                    end
+                ';
+            }
+
+            location = /status {
+                content_by_lua '
+                    local log_dict = ngx.shared.log_dict
+                    local sum = log_dict:get("upstream_time-sum")
+                    local nb = log_dict:get("upstream_time-nb")
+
+                    if nb and sum then
+                        ngx.say("average upstream response time: ", sum / nb,
+                                " (", nb, " reqs)")
+                    else
+                        ngx.say("no data yet")
+                    end
+                ';
+            }
+        }
+
+    This directive was first introduced in the "v0.5.0rc31" release.
+
+  log_by_lua_file
+    syntax: *log_by_lua_file <path-to-lua-script-file>*
+
+    context: *http, server, location, location if*
+
+    phase: *log*
+
+    Equivalent to log_by_lua, except that the file specified by
+    "<path-to-lua-script-file>" contains the Lua code, or, as from the
+    "v0.5.0rc32" release, the Lua/LuaJIT bytecode to be executed.
+
+    When a relative path like "foo/bar.lua" is given, they will be turned
+    into the absolute path relative to the "server prefix" path determined
+    by the "-p PATH" command-line option while starting the Nginx server.
+
+    This directive was first introduced in the "v0.5.0rc31" release.
+
+  lua_need_request_body
+    syntax: *lua_need_request_body <on|off>*
+
+    default: *off*
+
+    context: *main | server | location*
+
+    phase: *depends on usage*
+
+    Determines whether to force the request body data to be read before
+    running rewrite/access/access_by_lua* or not. The Nginx core does not
+    read the client request body by default and if request body data is
+    required, then this directive should be turned "on" or the
+    ngx.req.read_body function should be called within the Lua code.
+
+    To read the request body data within the $request_body variable,
+    client_body_buffer_size must have the same value as
+    client_max_body_size. Because when the content length exceeds
+    client_body_buffer_size but less than client_max_body_size, Nginx will
+    buffer the data into a temporary file on the disk, which will lead to
+    empty value in the $request_body variable.
+
+    If the current location includes rewrite_by_lua or rewrite_by_lua_file
+    directives, then the request body will be read just before the
+    rewrite_by_lua or rewrite_by_lua_file code is run (and also at the
+    "rewrite" phase). Similarly, if only content_by_lua is specified, the
+    request body will not be read until the content handler's Lua code is
+    about to run (i.e., the request body will be read during the content
+    phase).
+
+    It is recommended however, to use the ngx.req.read_body and
+    ngx.req.discard_body functions for finer control over the request body
+    reading process instead.
+
+    This also applies to access_by_lua and access_by_lua_file.
+
+  lua_shared_dict
+    syntax: *lua_shared_dict <name> <size>*
+
+    default: *no*
+
+    context: *http*
+
+    phase: *depends on usage*
+
+    Declares a shared memory zone, "<name>", to serve as storage for the shm
+    based Lua dictionary "ngx.shared.<name>".
+
+    The "<size>" argument accepts size units such as "k" and "m":
+
+        http {
+            lua_shared_dict dogs 10m;
+            ...
+        }
+
+    See ngx.shared.DICT for details.
+
+    This directive was first introduced in the "v0.3.1rc22" release.
+
+  lua_socket_connect_timeout
+    syntax: *lua_socket_connect_timeout <time>*
+
+    default: *lua_socket_connect_timeout 60s*
+
+    context: *http, server, location*
+
+    This directive controls the default timeout value used in
+    TCP/unix-domain socket object's connect method and can be overridden by
+    the settimeout method.
+
+    The "<time>" argument can be an integer, with an optional time unit,
+    like "s" (second), "ms" (millisecond), "m" (minute). The default time
+    unit is "s", i.e., "second". The default setting is "60s".
+
+    This directive was first introduced in the "v0.5.0rc1" release.
+
+  lua_socket_send_timeout
+    syntax: *lua_socket_send_timeout <time>*
+
+    default: *lua_socket_send_timeout 60s*
+
+    context: *http, server, location*
+
+    Controls the default timeout value used in TCP/unix-domain socket
+    object's send method and can be overridden by the settimeout method.
+
+    The "<time>" argument can be an integer, with an optional time unit,
+    like "s" (second), "ms" (millisecond), "m" (minute). The default time
+    unit is "s", i.e., "second". The default setting is "60s".
+
+    This directive was first introduced in the "v0.5.0rc1" release.
+
+  lua_socket_send_lowat
+    syntax: *lua_socket_send_lowat <size>*
+
+    default: *lua_socket_send_lowat 0*
+
+    context: *http, server, location*
+
+    Controls the "lowat" (low water) value for the cosocket send buffer.
+
+  lua_socket_read_timeout
+    syntax: *lua_socket_read_timeout <time>*
+
+    default: *lua_socket_read_timeout 60s*
+
+    context: *http, server, location*
+
+    phase: *depends on usage*
+
+    This directive controls the default timeout value used in
+    TCP/unix-domain socket object's receive method and iterator functions
+    returned by the receiveuntil method. This setting can be overridden by
+    the settimeout method.
+
+    The "<time>" argument can be an integer, with an optional time unit,
+    like "s" (second), "ms" (millisecond), "m" (minute). The default time
+    unit is "s", i.e., "second". The default setting is "60s".
+
+    This directive was first introduced in the "v0.5.0rc1" release.
+
+  lua_socket_buffer_size
+    syntax: *lua_socket_buffer_size <size>*
+
+    default: *lua_socket_buffer_size 4k/8k*
+
+    context: *http, server, location*
+
+    Specifies the buffer size used by cosocket reading operations.
+
+    This buffer does not have to be that big to hold everything at the same
+    time because cosocket supports 100% non-buffered reading and parsing. So
+    even 1 byte buffer size should still work everywhere but the performance
+    could be terrible.
+
+    This directive was first introduced in the "v0.5.0rc1" release.
+
+  lua_socket_pool_size
+    syntax: *lua_socket_pool_size <size>*
+
+    default: *lua_socket_pool_size 30*
+
+    context: *http, server, location*
+
+    Specifies the size limit (in terms of connection count) for every
+    cosocket connection pool associated with every remote server (i.e.,
+    identified by either the host-port pair or the unix domain socket file
+    path).
+
+    Default to 30 connections for every pool.
+
+    When the connection pool exceeds the available size limit, the least
+    recently used (idle) connection already in the pool will be closed to
+    make room for the current connection.
+
+    Note that the cosocket connection pool is per nginx worker process
+    rather than per nginx server instance, so size limit specified here also
+    applies to every single nginx worker process.
+
+    This directive was first introduced in the "v0.5.0rc1" release.
+
+  lua_socket_keepalive_timeout
+    syntax: *lua_socket_keepalive_timeout <time>*
+
+    default: *lua_socket_keepalive_timeout 60s*
+
+    context: *http, server, location*
+
+    This directive controls the default maximal idle time of the connections
+    in the cosocket built-in connection pool. When this timeout reaches,
+    idle connections will be closed and removed from the pool. This setting
+    can be overridden by cosocket objects' setkeepalive method.
+
+    The "<time>" argument can be an integer, with an optional time unit,
+    like "s" (second), "ms" (millisecond), "m" (minute). The default time
+    unit is "s", i.e., "second". The default setting is "60s".
+
+    This directive was first introduced in the "v0.5.0rc1" release.
+
+  lua_socket_log_errors
+    syntax: *lua_socket_log_errors on|off*
+
+    default: *lua_socket_log_errors on*
+
+    context: *http, server, location*
+
+    This directive can be used to toggle error logging when a failure occurs
+    for the TCP or UDP cosockets. If you are already doing proper error
+    handling and logging in your Lua code, then it is recommended to turn
+    this directive off to prevent data flushing in your nginx error log
+    files (which is usually rather expensive).
+
+    This directive was first introduced in the "v0.5.13" release.
+
+  lua_http10_buffering
+    syntax: *lua_http10_buffering on|off*
+
+    default: *lua_http10_buffering on*
+
+    context: *http, server, location, location-if*
+
+    Enables or disables automatic response buffering for HTTP 1.0 (or older)
+    requests. This buffering mechanism is mainly used for HTTP 1.0
+    keep-alive which replies on a proper "Content-Length" response header.
+
+    If the Lua code explicitly sets a "Content-Length" response header
+    before sending the headers (either explicitly via ngx.send_headers or
+    implicitly via the first ngx.say or ngx.print call), then the HTTP 1.0
+    response buffering will be disabled even when this directive is turned
+    on.
+
+    To output very large response data in a streaming fashion (via the
+    ngx.flush call, for example), this directive MUST be turned off to
+    minimize memory usage.
+
+    This directive is turned "on" by default.
+
+    This directive was first introduced in the "v0.5.0rc19" release.
+
+  rewrite_by_lua_no_postpone
+    syntax: *rewrite_by_lua_no_postpone on|off*
+
+    default: *rewrite_by_lua_no_postpone off*
+
+    context: *http*
+
+    Controls whether or not to disable postponing rewrite_by_lua and
+    rewrite_by_lua_file directives to run at the end of the "rewrite"
+    request-processing phase. By default, this directive is turned off and
+    the Lua code is postponed to run at the end of the "rewrite" phase.
+
+    This directive was first introduced in the "v0.5.0rc29" release.
+
+  lua_transform_underscores_in_response_headers
+    syntax: *lua_transform_underscores_in_response_headers on|off*
+
+    default: *lua_transform_underscores_in_response_headers on*
+
+    context: *http, server, location, location-if*
+
+    Controls whether to transform underscores ("_") in the response header
+    names specified in the ngx.header.HEADER API to hypens ("-").
+
+    This directive was first introduced in the "v0.5.0rc32" release.
+
+  lua_check_client_abort
+    syntax: *lua_check_client_abort on|off*
+
+    default: *lua_check_client_abort off*
+
+    context: *http, server, location, location-if*
+
+    This directive controls whether to check for premature client connection
+    abortion.
+
+    When this directive is turned on, the ngx_lua module will monitor the
+    premature connection close event on the downstream connections. And when
+    there is such an event, it will call the user Lua function callback
+    (registered by ngx.on_abort) or just stop and clean up all the Lua
+    "light threads" running in the current request's request handler when
+    there is no user callback function registered.
+
+    According to the current implementation, however, if the client closes
+    the connection before the Lua code finishes reading the request body
+    data via ngx.req.socket, then ngx_lua will neither stop all the running
+    "light threads" nor call the user callback (if ngx.on_abort has been
+    called). Instead, the reading operation on ngx.req.socket will just
+    return the error message "client aborted" as the second return value
+    (the first return value is surely "nil").
+
+    When TCP keepalive is disabled, it is relying on the client side to
+    close the socket gracefully (by sending a "FIN" packet or something like
+    that). For (soft) real-time web applications, it is highly recommended
+    to configure the TCP keepalive
+    (<http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html>) support in
+    your system's TCP stack implementation in order to detect "half-open"
+    TCP connections in time.
+
+    For example, on Linux, you can configure the standard listen directive
+    in your "nginx.conf" file like this:
+
+        listen 80 so_keepalive=2s:2s:8;
+
+    On FreeBSD, you can only tune the system-wide configuration for TCP
+    keepalive, for example:
+
+        # sysctl net.inet.tcp.keepintvl=2000
+        # sysctl net.inet.tcp.keepidle=2000
+
+    This directive was first introduced in the "v0.7.4" release.
+
+    See also ngx.on_abort.
+
+  lua_max_pending_timers
+    syntax: *lua_max_pending_timers <count>*
+
+    default: *lua_max_pending_timers 1024*
+
+    context: *http*
+
+    Controls the maximum number of pending timers allowed.
+
+    Pending timers are those timers that have not expired yet.
+
+    When exceeding this limit, the ngx.timer.at call will immediately return
+    "nil" and the error string "too many pending timers".
+
+    This directive was first introduced in the "v0.8.0" release.
+
+  lua_max_running_timers
+    syntax: *lua_max_running_timers <count>*
+
+    default: *lua_max_running_timers 256*
+
+    context: *http*
+
+    Controls the maximum number of "running timers" allowed.
+
+    Running timers are those timers whose user callback functions are still
+    running.
+
+    When exceeding this limit, Nginx will stop running the callbacks of
+    newly expired timers and log an error message "N lua_max_running_timers
+    are not enough" where "N" is the current value of this directive.
+
+    This directive was first introduced in the "v0.8.0" release.
+
+Nginx API for Lua
+  Introduction
+    The various *_by_lua and *_by_lua_file configuration directives serve as
+    gateways to the Lua API within the "nginx.conf" file. The Nginx Lua API
+    described below can only be called within the user Lua code run in the
+    context of these configuration directives.
+
+    The API is exposed to Lua in the form of two standard packages "ngx" and
+    "ndk". These packages are in the default global scope within ngx_lua and
+    are always available within ngx_lua directives.
+
+    The packages can be introduced into external Lua modules like this:
+
+        local say = ngx.say
+
+        local _M = {}
+
+        function _M.foo(a)
+            say(a)
+        end
+
+        return _M
+
+    Use of the package.seeall
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall>) flag is
+    strongly discouraged due to its various bad side-effects.
+
+    It is also possible to directly require the packages in external Lua
+    modules:
+
+        local ngx = require "ngx"
+        local ndk = require "ndk"
+
+    The ability to require these packages was introduced in the "v0.2.1rc19"
+    release.
+
+    Network I/O operations in user code should only be done through the
+    Nginx Lua API calls as the Nginx event loop may be blocked and
+    performance drop off dramatically otherwise. Disk operations with
+    relatively small amount of data can be done using the standard Lua "io"
+    library but huge file reading and writing should be avoided wherever
+    possible as they may block the Nginx process significantly. Delegating
+    all network and disk I/O operations to Nginx's subrequests (via the
+    ngx.location.capture method and similar) is strongly recommended for
+    maximum performance.
+
+  ngx.arg
+    syntax: *val = ngx.arg[index]*
+
+    context: *set_by_lua*, body_filter_by_lua**
+
+    When this is used in the context of the set_by_lua or set_by_lua_file
+    directives, this table is read-only and holds the input arguments to the
+    config directives:
+
+        value = ngx.arg[n]
+
+    Here is an example
+
+        location /foo {
+            set $a 32;
+            set $b 56;
+
+            set_by_lua $res
+                'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
+                $a $b;
+
+            echo $sum;
+        }
+
+    that writes out 88, the sum of 32 and 56.
+
+    When this table is used in the context of body_filter_by_lua or
+    body_filter_by_lua_file, the first element holds the input data chunk to
+    the output filter code and the second element holds the boolean flag for
+    the "eof" flag indicating the end of the whole output data stream.
+
+    The data chunk and "eof" flag passed to the downstream Nginx output
+    filters can also be overridden by assigning values directly to the
+    corresponding table elements. When setting "nil" or an empty Lua string
+    value to "ngx.arg[1]", no data chunk will be passed to the downstream
+    Nginx output filters at all.
+
+  ngx.var.VARIABLE
+    syntax: *ngx.var.VAR_NAME*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua**
+
+    Read and write Nginx variable values.
+
+        value = ngx.var.some_nginx_variable_name
+        ngx.var.some_nginx_variable_name = value
+
+    Note that only already defined nginx variables can be written to. For
+    example:
+
+        location /foo {
+            set $my_var ''; # this line is required to create $my_var at config time
+            content_by_lua '
+                ngx.var.my_var = 123;
+                ...
+            ';
+        }
+
+    That is, nginx variables cannot be created on-the-fly.
+
+    Some special nginx variables like $args and $limit_rate can be assigned
+    a value, some are not, like $arg_PARAMETER.
+
+    Nginx regex group capturing variables $1, $2, $3, and etc, can be read
+    by this interface as well, by writing "ngx.var[1]", "ngx.var[2]",
+    "ngx.var[3]", and etc.
+
+    Setting "ngx.var.Foo" to a "nil" value will unset the $Foo Nginx
+    variable.
+
+        ngx.var.args = nil
+
+    WARNING When reading from an Nginx variable, Nginx will allocate memory
+    in the per-request memory pool which is freed only at request
+    termination. So when you need to read from an Nginx variable repeatedly
+    in your Lua code, cache the Nginx variable value to your own Lua
+    variable, for example,
+
+        local val = ngx.var.some_var
+        --- use the val repeatedly later
+
+    to prevent (temporary) memory leaking within the current request's
+    lifetime.
+
+  Core constants
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua,
+    *log_by_lua*, ngx.timer.**
+
+      ngx.OK (0)
+      ngx.ERROR (-1)
+      ngx.AGAIN (-2)
+      ngx.DONE (-4)
+      ngx.DECLINED (-5)
+
+    Note that only three of these constants are utilized by the Nginx API
+    for Lua (i.e., ngx.exit accepts "NGX_OK", "NGX_ERROR", and
+    "NGX_DECLINED" as input).
+
+      ngx.null
+
+    The "ngx.null" constant is a "NULL" light userdata usually used to
+    represent nil values in Lua tables etc and is similar to the lua-cjson
+    (<http://www.kyne.com.au/~mark/software/lua-cjson.php>) library's
+    "cjson.null" constant. This constant was first introduced in the
+    "v0.5.0rc5" release.
+
+    The "ngx.DECLINED" constant was first introduced in the "v0.5.0rc19"
+    release.
+
+  HTTP method constants
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*,
+    ngx.timer.**
+
+      ngx.HTTP_GET
+      ngx.HTTP_HEAD
+      ngx.HTTP_PUT
+      ngx.HTTP_POST
+      ngx.HTTP_DELETE
+      ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)
+      ngx.HTTP_MKCOL     (added in the v0.8.2 release)
+      ngx.HTTP_COPY      (added in the v0.8.2 release)
+      ngx.HTTP_MOVE      (added in the v0.8.2 release)
+      ngx.HTTP_PROPFIND  (added in the v0.8.2 release)
+      ngx.HTTP_PROPPATCH (added in the v0.8.2 release)
+      ngx.HTTP_LOCK      (added in the v0.8.2 release)
+      ngx.HTTP_UNLOCK    (added in the v0.8.2 release)
+      ngx.HTTP_PATCH     (added in the v0.8.2 release)
+      ngx.HTTP_TRACE     (added in the v0.8.2 release)
+
+    These constants are usually used in ngx.location.capture and
+    ngx.location.capture_multi method calls.
+
+  HTTP status constants
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*,
+    ngx.timer.**
+
+      value = ngx.HTTP_OK (200)
+      value = ngx.HTTP_CREATED (201)
+      value = ngx.HTTP_SPECIAL_RESPONSE (300)
+      value = ngx.HTTP_MOVED_PERMANENTLY (301)
+      value = ngx.HTTP_MOVED_TEMPORARILY (302)
+      value = ngx.HTTP_SEE_OTHER (303)
+      value = ngx.HTTP_NOT_MODIFIED (304)
+      value = ngx.HTTP_BAD_REQUEST (400)
+      value = ngx.HTTP_UNAUTHORIZED (401)
+      value = ngx.HTTP_FORBIDDEN (403)
+      value = ngx.HTTP_NOT_FOUND (404)
+      value = ngx.HTTP_NOT_ALLOWED (405)
+      value = ngx.HTTP_GONE (410)
+      value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
+      value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)
+      value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
+      value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
+
+  Nginx log level constants
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+      ngx.STDERR
+      ngx.EMERG
+      ngx.ALERT
+      ngx.CRIT
+      ngx.ERR
+      ngx.WARN
+      ngx.NOTICE
+      ngx.INFO
+      ngx.DEBUG
+
+    These constants are usually used by the ngx.log method.
+
+  print
+    syntax: *print(...)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*,
+    ngx.timer.**
+
+    Writes argument values into the nginx "error.log" file with the
+    "ngx.NOTICE" log level.
+
+    It is equivalent to
+
+        ngx.log(ngx.NOTICE, ...)
+
+    Lua "nil" arguments are accepted and result in literal "nil" strings
+    while Lua booleans result in literal "true" or "false" strings. And the
+    "ngx.null" constant will yield the "null" string output.
+
+    There is a hard coded 2048 byte limitation on error message lengths in
+    the Nginx core. This limit includes trailing newlines and leading time
+    stamps. If the message size exceeds this limit, Nginx will truncate the
+    message text accordingly. This limit can be manually modified by editing
+    the "NGX_MAX_ERROR_STR" macro definition in the "src/core/ngx_log.h"
+    file in the Nginx source tree.
+
+  ngx.ctx
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+    This table can be used to store per-request Lua context data and has a
+    life time identical to the current request (as with the Nginx
+    variables).
+
+    Consider the following example,
+
+        location /test {
+            rewrite_by_lua '
+                ngx.say("foo = ", ngx.ctx.foo)
+                ngx.ctx.foo = 76
+            ';
+            access_by_lua '
+                ngx.ctx.foo = ngx.ctx.foo + 3
+            ';
+            content_by_lua '
+                ngx.say(ngx.ctx.foo)
+            ';
+        }
+
+    Then "GET /test" will yield the output
+
+        foo = nil
+        79
+
+    That is, the "ngx.ctx.foo" entry persists across the rewrite, access,
+    and content phases of a request.
+
+    Every request, including subrequests, has its own copy of the table. For
+    example:
+
+        location /sub {
+            content_by_lua '
+                ngx.say("sub pre: ", ngx.ctx.blah)
+                ngx.ctx.blah = 32
+                ngx.say("sub post: ", ngx.ctx.blah)
+            ';
+        }
+
+        location /main {
+            content_by_lua '
+                ngx.ctx.blah = 73
+                ngx.say("main pre: ", ngx.ctx.blah)
+                local res = ngx.location.capture("/sub")
+                ngx.print(res.body)
+                ngx.say("main post: ", ngx.ctx.blah)
+            ';
+        }
+
+    Then "GET /main" will give the output
+
+        main pre: 73
+        sub pre: nil
+        sub post: 32
+        main post: 73
+
+    Here, modification of the "ngx.ctx.blah" entry in the subrequest does
+    not affect the one in the parent request. This is because they have two
+    separate versions of "ngx.ctx.blah".
+
+    Internal redirection will destroy the original request "ngx.ctx" data
+    (if any) and the new request will have an empty "ngx.ctx" table. For
+    instance,
+
+        location /new {
+            content_by_lua '
+                ngx.say(ngx.ctx.foo)
+            ';
+        }
+
+        location /orig {
+            content_by_lua '
+                ngx.ctx.foo = "hello"
+                ngx.exec("/new")
+            ';
+        }
+
+    Then "GET /orig" will give
+
+        nil
+
+    rather than the original "hello" value.
+
+    Arbitrary data values, including Lua closures and nested tables, can be
+    inserted into this "magic" table. It also allows the registration of
+    custom meta methods.
+
+    Overriding "ngx.ctx" with a new Lua table is also supported, for
+    example,
+
+        ngx.ctx = { foo = 32, bar = 54 }
+
+  ngx.location.capture
+    syntax: *res = ngx.location.capture(uri, options?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Issue a synchronous but still non-blocking *Nginx Subrequest* using
+    "uri".
+
+    Nginx's subrequests provide a powerful way to make non-blocking internal
+    requests to other locations configured with disk file directory or *any*
+    other nginx C modules like "ngx_proxy", "ngx_fastcgi", "ngx_memc",
+    "ngx_postgres", "ngx_drizzle", and even ngx_lua itself and etc etc etc.
+
+    Also note that subrequests just mimic the HTTP interface but there is
+    *no* extra HTTP/TCP traffic *nor* IPC involved. Everything works
+    internally, efficiently, on the C level.
+
+    Subrequests are completely different from HTTP 301/302 redirection (via
+    ngx.redirect) and internal redirection (via ngx.exec).
+
+    Here is a basic example:
+
+        res = ngx.location.capture(uri)
+
+    Returns a Lua table with three slots ("res.status", "res.header",
+    "res.body", and "res.truncated").
+
+    "res.status" holds the response status code for the subrequest response.
+
+    "res.header" holds all the response headers of the subrequest and it is
+    a normal Lua table. For multi-value response headers, the value is a Lua
+    (array) table that holds all the values in the order that they appear.
+    For instance, if the subrequest response headers contain the following
+    lines:
+
+        Set-Cookie: a=3
+        Set-Cookie: foo=bar
+        Set-Cookie: baz=blah
+
+    Then "res.header["Set-Cookie"]" will be evaluated to the table value
+    "{"a=3", "foo=bar", "baz=blah"}".
+
+    "res.body" holds the subrequest's response body data, which might be
+    truncated. You always need to check the "res.truncated" boolean flag to
+    see if "res.body" contains truncated data.
+
+    URI query strings can be concatenated to URI itself, for instance,
+
+        res = ngx.location.capture('/foo/bar?a=3&b=4')
+
+    Named locations like @foo are not allowed due to a limitation in the
+    nginx core. Use normal locations combined with the "internal" directive
+    to prepare internal-only locations.
+
+    An optional option table can be fed as the second argument, which
+    supports the options:
+
+    *   "method" specify the subrequest's request method, which only accepts
+        constants like "ngx.HTTP_POST".
+
+    *   "body" specify the subrequest's request body (string value only).
+
+    *   "args" specify the subrequest's URI query arguments (both string
+        value and Lua tables are accepted)
+
+    *   "ctx" specify a Lua table to be the ngx.ctx table for the
+        subrequest. It can be the current request's ngx.ctx table, which
+        effectively makes the parent and its subrequest to share exactly the
+        same context table. This option was first introduced in the
+        "v0.3.1rc25" release.
+
+    *   "vars" take a Lua table which holds the values to set the specified
+        Nginx variables in the subrequest as this option's value. This
+        option was first introduced in the "v0.3.1rc31" release.
+
+    *   "copy_all_vars" specify whether to copy over all the Nginx variable
+        values of the current request to the subrequest in question.
+        modifications of the nginx variables in the subrequest will not
+        affect the current (parent) request. This option was first
+        introduced in the "v0.3.1rc31" release.
+
+    *   "share_all_vars" specify whether to share all the Nginx variables of
+        the subrequest with the current (parent) request. modifications of
+        the Nginx variables in the subrequest will affect the current
+        (parent) request.
+
+    *   "always_forward_body" when set to true, the current (parent)
+        request's request body will always be forwarded to the subrequest
+        being created if the "body" option is not specified. By default,
+        this option is false and when the "body" option is not specified,
+        the request body of the current (parent) request is only forwarded
+        when the subrequest takes the "PUT" or "POST" request method.
+
+    Issuing a POST subrequest, for example, can be done as follows
+
+        res = ngx.location.capture(
+            '/foo/bar',
+            { method = ngx.HTTP_POST, body = 'hello, world' }
+        )
+
+    See HTTP method constants methods other than POST. The "method" option
+    is "ngx.HTTP_GET" by default.
+
+    The "args" option can specify extra URI arguments, for instance,
+
+        ngx.location.capture('/foo?a=1',
+            { args = { b = 3, c = ':' } }
+        )
+
+    is equivalent to
+
+        ngx.location.capture('/foo?a=1&b=3&c=%3a')
+
+    that is, this method will escape argument keys and values according to
+    URI rules and concatenate them together into a complete query string.
+    The format for the Lua table passed as the "args" argument is identical
+    to the format used in the ngx.encode_args method.
+
+    The "args" option can also take plain query strings:
+
+        ngx.location.capture('/foo?a=1',
+            { args = 'b=3&c=%3a' } }
+        )
+
+    This is functionally identical to the previous examples.
+
+    The "share_all_vars" option controls whether to share nginx variables
+    among the current request and its subrequests. If this option is set to
+    "true", then the current request and associated subrequests will share
+    the same Nginx variable scope. Hence, changes to Nginx variables made by
+    a subrequest will affect the current request.
+
+    Care should be taken in using this option as variable scope sharing can
+    have unexpected side effects. The "args", "vars", or "copy_all_vars"
+    options are generally preferable instead.
+
+    This option is set to "false" by default
+
+        location /other {
+            set $dog "$dog world";
+            echo "$uri dog: $dog";
+        }
+
+        location /lua {
+            set $dog 'hello';
+            content_by_lua '
+                res = ngx.location.capture("/other",
+                    { share_all_vars = true });
+
+                ngx.print(res.body)
+                ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+            ';
+        }
+
+    Accessing location "/lua" gives
+
+        /other dog: hello world
+        /lua: hello world
+
+    The "copy_all_vars" option provides a copy of the parent request's Nginx
+    variables to subrequests when such subrequests are issued. Changes made
+    to these variables by such subrequests will not affect the parent
+    request or any other subrequests sharing the parent request's variables.
+
+        location /other {
+            set $dog "$dog world";
+            echo "$uri dog: $dog";
+        }
+
+        location /lua {
+            set $dog 'hello';
+            content_by_lua '
+                res = ngx.location.capture("/other",
+                    { copy_all_vars = true });
+
+                ngx.print(res.body)
+                ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+            ';
+        }
+
+    Request "GET /lua" will give the output
+
+        /other dog: hello world
+        /lua: hello
+
+    Note that if both "share_all_vars" and "copy_all_vars" are set to true,
+    then "share_all_vars" takes precedence.
+
+    In addition to the two settings above, it is possible to specify values
+    for variables in the subrequest using the "vars" option. These variables
+    are set after the sharing or copying of variables has been evaluated,
+    and provides a more efficient method of passing specific values to a
+    subrequest over encoding them as URL arguments and unescaping them in
+    the Nginx config file.
+
+        location /other {
+            content_by_lua '
+                ngx.say("dog = ", ngx.var.dog)
+                ngx.say("cat = ", ngx.var.cat)
+            ';
+        }
+
+        location /lua {
+            set $dog '';
+            set $cat '';
+            content_by_lua '
+                res = ngx.location.capture("/other",
+                    { vars = { dog = "hello", cat = 32 }});
+
+                ngx.print(res.body)
+            ';
+        }
+
+    Accessing "/lua" will yield the output
+
+        dog = hello
+        cat = 32
+
+    The "ctx" option can be used to specify a custom Lua table to serve as
+    the ngx.ctx table for the subrequest.
+
+        location /sub {
+            content_by_lua '
+                ngx.ctx.foo = "bar";
+            ';
+        }
+        location /lua {
+            content_by_lua '
+                local ctx = {}
+                res = ngx.location.capture("/sub", { ctx = ctx })
+
+                ngx.say(ctx.foo);
+                ngx.say(ngx.ctx.foo);
+            ';
+        }
+
+    Then request "GET /lua" gives
+
+        bar
+        nil
+
+    It is also possible to use this "ctx" option to share the same ngx.ctx
+    table between the current (parent) request and the subrequest:
+
+        location /sub {
+            content_by_lua '
+                ngx.ctx.foo = "bar";
+            ';
+        }
+        location /lua {
+            content_by_lua '
+                res = ngx.location.capture("/sub", { ctx = ngx.ctx })
+                ngx.say(ngx.ctx.foo);
+            ';
+        }
+
+    Request "GET /lua" yields the output
+
+        bar
+
+    Note that subrequests issued by ngx.location.capture inherit all the
+    request headers of the current request by default and that this may have
+    unexpected side effects on the subrequest responses. For example, when
+    using the standard "ngx_proxy" module to serve subrequests, an
+    "Accept-Encoding: gzip" header in the main request may result in gzipped
+    responses that cannot be handled properly in Lua code. Original request
+    headers should be ignored by setting proxy_pass_request_headers to "off"
+    in subrequest locations.
+
+    When the "body" option is not specified and the "always_forward_body"
+    option is false (the default value), the "POST" and "PUT" subrequests
+    will inherit the request bodies of the parent request (if any).
+
+    There is a hard-coded upper limit on the number of concurrent
+    subrequests possible for every main request. In older versions of Nginx,
+    the limit was 50 concurrent subrequests and in more recent versions,
+    Nginx "1.1.x" onwards, this was increased to 200 concurrent subrequests.
+    When this limit is exceeded, the following error message is added to the
+    "error.log" file:
+
+        [error] 13983#0: *1 subrequests cycle while processing "/uri"
+
+    The limit can be manually modified if required by editing the definition
+    of the "NGX_HTTP_MAX_SUBREQUESTS" macro in the
+    "nginx/src/http/ngx_http_request.h" file in the Nginx source tree.
+
+    Please also refer to restrictions on capturing locations configured by
+    subrequest directives of other modules.
+
+  ngx.location.capture_multi
+    syntax: *res1, res2, ... = ngx.location.capture_multi({ {uri, options?},
+    {uri, options?}, ... })*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Just like ngx.location.capture, but supports multiple subrequests
+    running in parallel.
+
+    This function issues several parallel subrequests specified by the input
+    table and returns their results in the same order. For example,
+
+        res1, res2, res3 = ngx.location.capture_multi{
+            { "/foo", { args = "a=3&b=4" } },
+            { "/bar" },
+            { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
+        }
+
+        if res1.status == ngx.HTTP_OK then
+            ...
+        end
+
+        if res2.body == "BLAH" then
+            ...
+        end
+
+    This function will not return until all the subrequests terminate. The
+    total latency is the longest latency of the individual subrequests
+    rather than the sum.
+
+    Lua tables can be used for both requests and responses when the number
+    of subrequests to be issued is not known in advance:
+
+        -- construct the requests table
+        local reqs = {}
+        table.insert(reqs, { "/mysql" })
+        table.insert(reqs, { "/postgres" })
+        table.insert(reqs, { "/redis" })
+        table.insert(reqs, { "/memcached" })
+
+        -- issue all the requests at once and wait until they all return
+        local resps = { ngx.location.capture_multi(reqs) }
+
+        -- loop over the responses table
+        for i, resp in ipairs(resps) do
+            -- process the response table "resp"
+        end
+
+    The ngx.location.capture function is just a special form of this
+    function. Logically speaking, the ngx.location.capture can be
+    implemented like this
+
+        ngx.location.capture =
+            function (uri, args)
+                return ngx.location.capture_multi({ {uri, args} })
+            end
+
+    Please also refer to restrictions on capturing locations configured by
+    subrequest directives of other modules.
+
+  ngx.status
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+    Read and write the current request's response status. This should be
+    called before sending out the response headers.
+
+        ngx.status = ngx.HTTP_CREATED
+        status = ngx.status
+
+    Setting "ngx.status" after the response header is sent out has no effect
+    but leaving an error message in your nginx's error log file:
+
+        attempt to set ngx.status after sending out response headers
+
+  ngx.header.HEADER
+    syntax: *ngx.header.HEADER = VALUE*
+
+    syntax: *value = ngx.header.HEADER*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+    Set, add to, or clear the current request's "HEADER" response header
+    that is to be sent.
+
+    Underscores ("_") in the header names will be replaced by hyphens ("-")
+    by default. This transformation can be turned off via the
+    lua_transform_underscores_in_response_headers directive.
+
+    The header names are matched case-insensitively.
+
+        -- equivalent to ngx.header["Content-Type"] = 'text/plain'
+        ngx.header.content_type = 'text/plain';
+
+        ngx.header["X-My-Header"] = 'blah blah';
+
+    Multi-value headers can be set this way:
+
+        ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
+
+    will yield
+
+        Set-Cookie: a=32; path=/
+        Set-Cookie: b=4; path=/
+
+    in the response headers.
+
+    Only Lua tables are accepted (Only the last element in the table will
+    take effect for standard headers such as "Content-Type" that only accept
+    a single value).
+
+        ngx.header.content_type = {'a', 'b'}
+
+    is equivalent to
+
+        ngx.header.content_type = 'b'
+
+    Setting a slot to "nil" effectively removes it from the response
+    headers:
+
+        ngx.header["X-My-Header"] = nil;
+
+    The same applies to assigning an empty table:
+
+        ngx.header["X-My-Header"] = {};
+
+    Setting "ngx.header.HEADER" after sending out response headers (either
+    explicitly with ngx.send_headers or implicitly with ngx.print and
+    similar) will throw out a Lua exception.
+
+    Reading "ngx.header.HEADER" will return the value of the response header
+    named "HEADER".
+
+    Underscores ("_") in the header names will also be replaced by dashes
+    ("-") and the header names will be matched case-insensitively. If the
+    response header is not present at all, "nil" will be returned.
+
+    This is particularly useful in the context of header_filter_by_lua and
+    header_filter_by_lua_file, for example,
+
+        location /test {
+            set $footer '';
+
+            proxy_pass http://some-backend;
+
+            header_filter_by_lua '
+                if ngx.header["X-My-Header"] == "blah" then
+                    ngx.var.footer = "some value"
+                end
+            ';
+
+            echo_after_body $footer;
+        }
+
+    For multi-value headers, all of the values of header will be collected
+    in order and returned as a Lua table. For example, response headers
+
+        Foo: bar
+        Foo: baz
+
+    will result in
+
+        {"bar", "baz"}
+
+    to be returned when reading "ngx.header.Foo".
+
+    Note that "ngx.header" is not a normal Lua table and as such, it is not
+    possible to iterate through it using the Lua "ipairs" function.
+
+    For reading *request* headers, use the ngx.req.get_headers function
+    instead.
+
+  ngx.req.start_time
+    syntax: *secs = ngx.req.start_time()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua**
+
+    Returns a floating-point number representing the timestamp (including
+    milliseconds as the decimal part) when the current request was created.
+
+    The following example emulates the $request_time variable value
+    (provided by [[HttpLogModule]]) in pure Lua:
+
+        local request_time = ngx.now() - ngx.req.start_time()
+
+    This function was first introduced in the "v0.7.7" release.
+
+    See also ngx.now and ngx.update_time.
+
+  ngx.req.http_version
+    syntax: *num = ngx.req.http_version()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua**
+
+    Returns the HTTP version number for the current request as a Lua number.
+
+    Current possible values are 1.0, 1.1, and 0.9. Returns "nil" for
+    unrecognized values.
+
+    This method was first introduced in the "v0.7.17" release.
+
+  ngx.req.raw_header
+    syntax: *str = ngx.req.raw_header(no_request_line?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua**
+
+    Returns the original raw HTTP protocol header received by the Nginx
+    server.
+
+    By default, the request line and trailing "CR LF" terminator will also
+    be included. For example,
+
+        ngx.print(ngx.req.raw_header())
+
+    gives something like this:
+
+        GET /t HTTP/1.1
+        Host: localhost
+        Connection: close
+        Foo: bar
+
+    You can specify the optional "no_request_line" argument as a "true"
+    value to exclude the request line from the result. For example,
+
+        ngx.print(ngx.req.raw_header(true))
+
+    outputs something like this:
+
+        Host: localhost
+        Connection: close
+        Foo: bar
+
+    This method was first introduced in the "v0.7.17" release.
+
+  ngx.req.get_method
+    syntax: *method_name = ngx.req.get_method()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua**
+
+    Retrieves the current request's request method name. Strings like "GET"
+    and "POST" are returned instead of numerical method constants.
+
+    If the current request is an Nginx subrequest, then the subrequest's
+    method name will be returned.
+
+    This method was first introduced in the "v0.5.6" release.
+
+    See also ngx.req.set_method.
+
+  ngx.req.set_method
+    syntax: *ngx.req.set_method(method_id)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua**
+
+    Overrides the current request's request method with the "request_id"
+    argument. Currently only numerical method constants are supported, like
+    "ngx.HTTP_POST" and "ngx.HTTP_GET".
+
+    If the current request is an Nginx subrequest, then the subrequest's
+    method will be overridden.
+
+    This method was first introduced in the "v0.5.6" release.
+
+    See also ngx.req.get_method.
+
+  ngx.req.set_uri
+    syntax: *ngx.req.set_uri(uri, jump?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua**
+
+    Rewrite the current request's (parsed) URI by the "uri" argument. The
+    "uri" argument must be a Lua string and cannot be of zero length, or a
+    Lua exception will be thrown.
+
+    The optional boolean "jump" argument can trigger location rematch (or
+    location jump) as [[HttpRewriteModule]]'s rewrite directive, that is,
+    when "jump" is "true" (default to "false"), this function will never
+    return and it will tell Nginx to try re-searching locations with the new
+    URI value at the later "post-rewrite" phase and jumping to the new
+    location.
+
+    Location jump will not be triggered otherwise, and only the current
+    request's URI will be modified, which is also the default behavior. This
+    function will return but with no returned values when the "jump"
+    argument is "false" or absent altogether.
+
+    For example, the following nginx config snippet
+
+        rewrite ^ /foo last;
+
+    can be coded in Lua like this:
+
+        ngx.req.set_uri("/foo", true)
+
+    Similarly, Nginx config
+
+        rewrite ^ /foo break;
+
+    can be coded in Lua as
+
+        ngx.req.set_uri("/foo", false)
+
+    or equivalently,
+
+        ngx.req.set_uri("/foo")
+
+    The "jump" can only be set to "true" in rewrite_by_lua and
+    rewrite_by_lua_file. Use of jump in other contexts is prohibited and
+    will throw out a Lua exception.
+
+    A more sophisticated example involving regex substitutions is as follows
+
+        location /test {
+            rewrite_by_lua '
+                local uri = ngx.re.sub(ngx.var.uri, "^/test/(.*)", "$1", "o")
+                ngx.req.set_uri(uri)
+            ';
+            proxy_pass http://my_backend;
+        }
+
+    which is functionally equivalent to
+
+        location /test {
+            rewrite ^/test/(.*) /$1 break;
+            proxy_pass http://my_backend;
+        }
+
+    Note that it is not possible to use this interface to rewrite URI
+    arguments and that ngx.req.set_uri_args should be used for this instead.
+    For instance, Nginx config
+
+        rewrite ^ /foo?a=3? last;
+
+    can be coded as
+
+        ngx.req.set_uri_args("a=3")
+        ngx.req.set_uri("/foo", true)
+
+    or
+
+        ngx.req.set_uri_args({a = 3})
+        ngx.req.set_uri("/foo", true)
+
+    This interface was first introduced in the "v0.3.1rc14" release.
+
+  ngx.req.set_uri_args
+    syntax: *ngx.req.set_uri_args(args)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua**
+
+    Rewrite the current request's URI query arguments by the "args"
+    argument. The "args" argument can be either a Lua string, as in
+
+        ngx.req.set_uri_args("a=3&b=hello%20world")
+
+    or a Lua table holding the query arguments' key-value pairs, as in
+
+        ngx.req.set_uri_args({ a = 3, b = "hello world" })
+
+    where in the latter case, this method will escape argument keys and
+    values according to the URI escaping rule.
+
+    Multi-value arguments are also supported:
+
+        ngx.req.set_uri_args({ a = 3, b = {5, 6} })
+
+    which will result in a query string like "a=3&b=5&b=6".
+
+    This interface was first introduced in the "v0.3.1rc13" release.
+
+    See also ngx.req.set_uri.
+
+  ngx.req.get_uri_args
+    syntax: *args = ngx.req.get_uri_args(max_args?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+    Returns a Lua table holding all the current request URL query arguments.
+
+        location = /test {
+            content_by_lua '
+                local args = ngx.req.get_uri_args()
+                for key, val in pairs(args) do
+                    if type(val) == "table" then
+                        ngx.say(key, ": ", table.concat(val, ", "))
+                    else
+                        ngx.say(key, ": ", val)
+                    end
+                end
+            ';
+        }
+
+    Then "GET /test?foo=bar&bar=baz&bar=blah" will yield the response body
+
+        foo: bar
+        bar: baz, blah
+
+    Multiple occurrences of an argument key will result in a table value
+    holding all the values for that key in order.
+
+    Keys and values are unescaped according to URI escaping rules. In the
+    settings above, "GET /test?a%20b=1%61+2" will yield:
+
+        a b: 1a 2
+
+    Arguments without the "=<value>" parts are treated as boolean arguments.
+    "GET /test?foo&bar" will yield:
+
+        foo: true
+        bar: true
+
+    That is, they will take Lua boolean values "true". However, they are
+    different from arguments taking empty string values. "GET
+    /test?foo=&bar=" will give something like
+
+        foo: 
+        bar:
+
+    Empty key arguments are discarded. "GET /test?=hello&=world" will yield
+    an empty output for instance.
+
+    Updating query arguments via the nginx variable $args (or "ngx.var.args"
+    in Lua) at runtime is also supported:
+
+        ngx.var.args = "a=3&b=42"
+        local args = ngx.req.get_uri_args()
+
+    Here the "args" table will always look like
+
+        {a = 3, b = 42}
+
+    regardless of the actual request query string.
+
+    Note that a maximum of 100 request arguments are parsed by default
+    (including those with the same name) and that additional request
+    arguments are silently discarded to guard against potential denial of
+    service attacks.
+
+    However, the optional "max_args" function argument can be used to
+    override this limit:
+
+        local args = ngx.req.get_uri_args(10)
+
+    This argument can be set to zero to remove the limit and to process all
+    request arguments received:
+
+        local args = ngx.req.get_uri_args(0)
+
+    Removing the "max_args" cap is strongly discouraged.
+
+  ngx.req.get_post_args
+    syntax: *args, err = ngx.req.get_post_args(max_args?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+    Returns a Lua table holding all the current request POST query arguments
+    (of the MIME type "application/x-www-form-urlencoded"). Call
+    ngx.req.read_body to read the request body first or turn on the
+    lua_need_request_body directive to avoid errors.
+
+        location = /test {
+            content_by_lua '
+                ngx.req.read_body()
+                local args = ngx.req.get_post_args()
+                if not args then
+                    ngx.say("failed to get post args: ", err)
+                    return
+                end
+                for key, val in pairs(args) do
+                    if type(val) == "table" then
+                        ngx.say(key, ": ", table.concat(val, ", "))
+                    else
+                        ngx.say(key, ": ", val)
+                    end
+                end
+            ';
+        }
+
+    Then
+
+        # Post request with the body 'foo=bar&bar=baz&bar=blah'
+        $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
+
+    will yield the response body like
+
+        foo: bar
+        bar: baz, blah
+
+    Multiple occurrences of an argument key will result in a table value
+    holding all of the values for that key in order.
+
+    Keys and values will be unescaped according to URI escaping rules.
+
+    With the settings above,
+
+        # POST request with body 'a%20b=1%61+2'
+        $ curl -d 'a%20b=1%61+2' localhost/test
+
+    will yield:
+
+        a b: 1a 2
+
+    Arguments without the "=<value>" parts are treated as boolean arguments.
+    "GET /test?foo&bar" will yield:
+
+        foo: true
+        bar: true
+
+    That is, they will take Lua boolean values "true". However, they are
+    different from arguments taking empty string values. "POST /test" with
+    request body "foo=&bar=" will return something like
+
+        foo: 
+        bar:
+
+    Empty key arguments are discarded. "POST /test" with body
+    "=hello&=world" will yield empty outputs for instance.
+
+    Note that a maximum of 100 request arguments are parsed by default
+    (including those with the same name) and that additional request
+    arguments are silently discarded to guard against potential denial of
+    service attacks.
+
+    However, the optional "max_args" function argument can be used to
+    override this limit:
+
+        local args = ngx.req.get_post_args(10)
+
+    This argument can be set to zero to remove the limit and to process all
+    request arguments received:
+
+        local args = ngx.req.get_post_args(0)
+
+    Removing the "max_args" cap is strongly discouraged.
+
+  ngx.req.get_headers
+    syntax: *headers = ngx.req.get_headers(max_headers?, raw?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+    Returns a Lua table holding all the current request headers.
+
+        local h = ngx.req.get_headers()
+        for k, v in pairs(h) do
+            ...
+        end
+
+    To read an individual header:
+
+        ngx.say("Host: ", ngx.req.get_headers()["Host"])
+
+    Note that the ngx.var.HEADER API call, which uses core $http_HEADER
+    variables, may be more preferable for reading individual request
+    headers.
+
+    For multiple instances of request headers such as:
+
+        Foo: foo
+        Foo: bar
+        Foo: baz
+
+    the value of "ngx.req.get_headers()["Foo"]" will be a Lua (array) table
+    such as:
+
+        {"foo", "bar", "baz"}
+
+    Note that a maximum of 100 request headers are parsed by default
+    (including those with the same name) and that additional request headers
+    are silently discarded to guard against potential denial of service
+    attacks.
+
+    However, the optional "max_headers" function argument can be used to
+    override this limit:
+
+        local args = ngx.req.get_headers(10)
+
+    This argument can be set to zero to remove the limit and to process all
+    request headers received:
+
+        local args = ngx.req.get_headers(0)
+
+    Removing the "max_headers" cap is strongly discouraged.
+
+    Since the 0.6.9 release, all the header names in the Lua table returned
+    are converted to the pure lower-case form by default, unless the "raw"
+    argument is set to "true" (default to "false").
+
+    Also, by default, an "__index" metamethod is added to the resulting Lua
+    table and will normalize the keys to a pure lowercase form with all
+    underscores converted to dashes in case of a lookup miss. For example,
+    if a request header "My-Foo-Header" is present, then the following
+    invocations will all pick up the value of this header correctly:
+
+        ngx.say(headers.my_foo_header)
+        ngx.say(headers["My-Foo-Header"])
+        ngx.say(headers["my-foo-header"])
+
+    The "__index" metamethod will not be added when the "raw" argument is
+    set to "true".
+
+  ngx.req.set_header
+    syntax: *ngx.req.set_header(header_name, header_value)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*
+
+    Set the current request's request header named "header_name" to value
+    "header_value", overriding any existing ones.
+
+    By default, all the subrequests subsequently initiated by
+    ngx.location.capture and ngx.location.capture_multi will inherit the new
+    header.
+
+    Here is an example of setting the "Content-Length" header:
+
+        ngx.req.set_header("Content-Type", "text/css")
+
+    The "header_value" can take an array list of values, for example,
+
+        ngx.req.set_header("Foo", {"a", "abc"})
+
+    will produce two new request headers:
+
+        Foo: a
+        Foo: abc
+
+    and old "Foo" headers will be overridden if there is any.
+
+    When the "header_value" argument is "nil", the request header will be
+    removed. So
+
+        ngx.req.set_header("X-Foo", nil)
+
+    is equivalent to
+
+        ngx.req.clear_header("X-Foo")
+
+  ngx.req.clear_header
+    syntax: *ngx.req.clear_header(header_name)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua**
+
+    Clear the current request's request header named "header_name". None of
+    the current request's subrequests will be affected.
+
+  ngx.req.read_body
+    syntax: *ngx.req.read_body()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Reads the client request body synchronously without blocking the Nginx
+    event loop.
+
+        ngx.req.read_body()
+        local args = ngx.req.get_post_args()
+
+    If the request body is already read previously by turning on
+    lua_need_request_body or by using other modules, then this function does
+    not run and returns immediately.
+
+    If the request body has already been explicitly discarded, either by the
+    ngx.req.discard_body function or other modules, this function does not
+    run and returns immediately.
+
+    In case of errors, such as connection errors while reading the data,
+    this method will throw out a Lua exception *or* terminate the current
+    request with a 500 status code immediately.
+
+    The request body data read using this function can be retrieved later
+    via ngx.req.get_body_data or, alternatively, the temporary file name for
+    the body data cached to disk using ngx.req.get_body_file. This depends
+    on
+
+    1.  whether the current request body is already larger than the
+        client_body_buffer_size,
+
+    2.  and whether client_body_in_file_only has been switched on.
+
+    In cases where current request may have a request body and the request
+    body data is not required, The ngx.req.discard_body function must be
+    used to explicitly discard the request body to avoid breaking things
+    under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
+
+    This function was first introduced in the "v0.3.1rc17" release.
+
+  ngx.req.discard_body
+    syntax: *ngx.req.discard_body()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Explicitly discard the request body, i.e., read the data on the
+    connection and throw it away immediately. Please note that ignoring
+    request body is not the right way to discard it, and that this function
+    must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP
+    1.1 pipelining.
+
+    This function is an asynchronous call and returns immediately.
+
+    If the request body has already been read, this function does nothing
+    and returns immediately.
+
+    This function was first introduced in the "v0.3.1rc17" release.
+
+    See also ngx.req.read_body.
+
+  ngx.req.get_body_data
+    syntax: *data = ngx.req.get_body_data()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Retrieves in-memory request body data. It returns a Lua string rather
+    than a Lua table holding all the parsed query arguments. Use the
+    ngx.req.get_post_args function instead if a Lua table is required.
+
+    This function returns "nil" if
+
+    1.  the request body has not been read,
+
+    2.  the request body has been read into disk temporary files,
+
+    3.  or the request body has zero size.
+
+    If the request body has not been read yet, call ngx.req.read_body first
+    (or turned on lua_need_request_body to force this module to read the
+    request body. This is not recommended however).
+
+    If the request body has been read into disk files, try calling the
+    ngx.req.get_body_file function instead.
+
+    To force in-memory request bodies, try setting client_body_buffer_size
+    to the same size value in client_max_body_size.
+
+    Note that calling this function instead of using "ngx.var.request_body"
+    or "ngx.var.echo_request_body" is more efficient because it can save one
+    dynamic memory allocation and one data copy.
+
+    This function was first introduced in the "v0.3.1rc17" release.
+
+    See also ngx.req.get_body_file.
+
+  ngx.req.get_body_file
+    syntax: *file_name = ngx.req.get_body_file()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Retrieves the file name for the in-file request body data. Returns "nil"
+    if the request body has not been read or has been read into memory.
+
+    The returned file is read only and is usually cleaned up by Nginx's
+    memory pool. It should not be manually modified, renamed, or removed in
+    Lua code.
+
+    If the request body has not been read yet, call ngx.req.read_body first
+    (or turned on lua_need_request_body to force this module to read the
+    request body. This is not recommended however).
+
+    If the request body has been read into memory, try calling the
+    ngx.req.get_body_data function instead.
+
+    To force in-file request bodies, try turning on
+    client_body_in_file_only.
+
+    This function was first introduced in the "v0.3.1rc17" release.
+
+    See also ngx.req.get_body_data.
+
+  ngx.req.set_body_data
+    syntax: *ngx.req.set_body_data(data)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Set the current request's request body using the in-memory data
+    specified by the "data" argument.
+
+    If the current request's request body has not been read, then it will be
+    properly discarded. When the current request's request body has been
+    read into memory or buffered into a disk file, then the old request
+    body's memory will be freed or the disk file will be cleaned up
+    immediately, respectively.
+
+    This function was first introduced in the "v0.3.1rc18" release.
+
+    See also ngx.req.set_body_file.
+
+  ngx.req.set_body_file
+    syntax: *ngx.req.set_body_file(file_name, auto_clean?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Set the current request's request body using the in-file data specified
+    by the "file_name" argument.
+
+    If the optional "auto_clean" argument is given a "true" value, then this
+    file will be removed at request completion or the next time this
+    function or ngx.req.set_body_data are called in the same request. The
+    "auto_clean" is default to "false".
+
+    Please ensure that the file specified by the "file_name" argument exists
+    and is readable by an Nginx worker process by setting its permission
+    properly to avoid Lua exception errors.
+
+    If the current request's request body has not been read, then it will be
+    properly discarded. When the current request's request body has been
+    read into memory or buffered into a disk file, then the old request
+    body's memory will be freed or the disk file will be cleaned up
+    immediately, respectively.
+
+    This function was first introduced in the "v0.3.1rc18" release.
+
+    See also ngx.req.set_body_data.
+
+  ngx.req.init_body
+    syntax: *ngx.req.init_body(buffer_size?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Creates a new blank request body for the current request and inializes
+    the buffer for later request body data writing via the
+    ngx.req.append_body and ngx.req.finish_body APIs.
+
+    If the "buffer_size" argument is specified, then its value will be used
+    for the size of the memory buffer for body writing with
+    ngx.req.append_body. If the argument is omitted, then the value
+    specified by the standard client_body_buffer_size directive will be used
+    instead.
+
+    When the data can no longer be hold in the memory buffer for the request
+    body, then the data will be flushed onto a temporary file just like the
+    standard request body reader in the Nginx core.
+
+    It is important to always call the ngx.req.finish_body after all the
+    data has been appended onto the current request body. Also, when this
+    function is used together with ngx.req.socket, it is required to call
+    ngx.req.socket *before* this function, or you will get the "request body
+    already exists" error message.
+
+    The usage of this function is often like this:
+
+        ngx.req.init_body(128 * 1024)  -- buffer is 128KB
+        for chunk in next_data_chunk() do
+            ngx.req.append_body(chunk) -- each chunk can be 4KB
+        end
+        ngx.req.finish_body()
+
+    This function can be used with ngx.req.append_body, ngx.req.finish_body,
+    and ngx.req.socket to implement efficient input filters in pure Lua (in
+    the context of rewrite_by_lua* or access_by_lua*), which can be used
+    with other Nginx content handler or upstream modules like
+    [[HttpProxyModule]] and [[HttpFastcgiModule]].
+
+    This function was first introduced in the "v0.5.11" release.
+
+  ngx.req.append_body
+    syntax: *ngx.req.append_body(data_chunk)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Append new data chunk specified by the "data_chunk" argument onto the
+    existing request body created by the ngx.req.init_body call.
+
+    When the data can no longer be hold in the memory buffer for the request
+    body, then the data will be flushed onto a temporary file just like the
+    standard request body reader in the Nginx core.
+
+    It is important to always call the ngx.req.finish_body after all the
+    data has been appended onto the current request body.
+
+    This function can be used with ngx.req.init_body, ngx.req.finish_body,
+    and ngx.req.socket to implement efficient input filters in pure Lua (in
+    the context of rewrite_by_lua* or access_by_lua*), which can be used
+    with other Nginx content handler or upstream modules like
+    [[HttpProxyModule]] and [[HttpFastcgiModule]].
+
+    This function was first introduced in the "v0.5.11" release.
+
+    See also ngx.req.init_body.
+
+  ngx.req.finish_body
+    syntax: *ngx.req.finish_body()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Completes the construction process of the new request body created by
+    the ngx.req.init_body and ngx.req.append_body calls.
+
+    This function can be used with ngx.req.init_body, ngx.req.append_body,
+    and ngx.req.socket to implement efficient input filters in pure Lua (in
+    the context of rewrite_by_lua* or access_by_lua*), which can be used
+    with other Nginx content handler or upstream modules like
+    [[HttpProxyModule]] and [[HttpFastcgiModule]].
+
+    This function was first introduced in the "v0.5.11" release.
+
+    See also ngx.req.init_body.
+
+  ngx.req.socket
+    syntax: *tcpsock, err = ngx.req.socket()*
+
+    syntax: *tcpsock, err = ngx.req.socket(raw)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Returns a read-only cosocket object that wraps the downstream
+    connection. Only receive and receiveuntil methods are supported on this
+    object.
+
+    In case of error, "nil" will be returned as well as a string describing
+    the error.
+
+    The socket object returned by this method is usually used to read the
+    current request's body in a streaming fashion. Do not turn on the
+    lua_need_request_body directive, and do not mix this call with
+    ngx.req.read_body and ngx.req.discard_body.
+
+    If any request body data has been pre-read into the Nginx core request
+    header buffer, the resulting cosocket object will take care of this to
+    avoid potential data loss resulting from such pre-reading. Chunked
+    request bodies are not yet supported in this API.
+
+    Since the "v0.9.0" release, this function accepts an optional boolean
+    "raw" argument. When this argument is "true", this function returns a
+    full duplex cosocket object wrapping around the raw downstream
+    connection socket, upon which you can call the receive, receiveuntil,
+    and send methods.
+
+    When the "raw" argument is "true", it is required that no pending data
+    from any previous ngx.say, ngx.print, or ngx.send_headers calls exists.
+    So if you have these downstream output calls previously, you should call
+    ngx.flush(true) before calling "ngx.req.socket(true)" to ensure that
+    there is no pending output data. Another requirement for this case is
+    that the request body must have already been read completely.
+
+    You can use the "raw request socket" returned by "ngx.req.socket(true)"
+    to implement fancy protocols like WebSocket
+    (<http://en.wikipedia.org/wiki/WebSocket>), or just emit your own raw
+    HTTP response header or body data. You can refer to the
+    lua-resty-websocket library
+    (<https://github.com/agentzh/lua-resty-websocket>) for a real world
+    example.
+
+    This function was first introduced in the "v0.5.0rc1" release.
+
+  ngx.exec
+    syntax: *ngx.exec(uri, args?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Does an internal redirect to "uri" with "args".
+
+        ngx.exec('/some-location');
+        ngx.exec('/some-location', 'a=3&b=5&c=6');
+        ngx.exec('/some-location?a=3&b=5', 'c=6');
+
+    Named locations are also supported, but query strings are ignored. For
+    example,
+
+        location /foo {
+            content_by_lua '
+                ngx.exec("@bar");
+            ';
+        }
+
+        location @bar {
+            ...
+        }
+
+    The optional second "args" can be used to specify extra URI query
+    arguments, for example:
+
+        ngx.exec("/foo", "a=3&b=hello%20world")
+
+    Alternatively, a Lua table can be passed for the "args" argument for
+    ngx_lua to carry out URI escaping and string concatenation.
+
+        ngx.exec("/foo", { a = 3, b = "hello world" })
+
+    The result is exactly the same as the previous example. The format for
+    the Lua table passed as the "args" argument is identical to the format
+    used in the ngx.encode_args method.
+
+    Note that this is very different from ngx.redirect in that it is just an
+    internal redirect and no new HTTP traffic is involved.
+
+    This method never returns.
+
+    This method *must* be called before ngx.send_headers or explicit
+    response body outputs by either ngx.print or ngx.say.
+
+    It is strongly recommended to combine the "return" statement with this
+    call, i.e., "return ngx.exec(...)".
+
+    This method is similar to the echo_exec directive of the
+    [[HttpEchoModule]].
+
+  ngx.redirect
+    syntax: *ngx.redirect(uri, status?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Issue an "HTTP 301" or 302 redirection to "uri".
+
+    The optional "status" parameter specifies whether 301 or 302 to be used.
+    It is 302 ("ngx.HTTP_MOVED_TEMPORARILY") by default.
+
+    Here is an example assuming the current server name is "localhost" and
+    that it is listening on Port 1984:
+
+        return ngx.redirect("/foo")
+
+    which is equivalent to
+
+        return ngx.redirect("http://localhost:1984/foo", ngx.HTTP_MOVED_TEMPORARILY)
+
+    Redirecting arbitrary external URLs is also supported, for example:
+
+        return ngx.redirect("http://www.google.com")
+
+    We can also use the numerical code directly as the second "status"
+    argument:
+
+        return ngx.redirect("/foo", 301)
+
+    This method *must* be called before ngx.send_headers or explicit
+    response body outputs by either ngx.print or ngx.say.
+
+    This method is very much like the rewrite directive with the "redirect"
+    modifier in the standard [[HttpRewriteModule]], for example, this
+    "nginx.conf" snippet
+
+        rewrite ^ /foo? redirect;  # nginx config
+
+    is equivalent to the following Lua code
+
+        return ngx.redirect('/foo');  -- Lua code
+
+    while
+
+        rewrite ^ /foo? permanent;  # nginx config
+
+    is equivalent to
+
+        return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
+
+    URI arguments can be specified as well, for example:
+
+        return ngx.redirect('/foo?a=3&b=4')
+
+    This method call terminates the current request's processing and never
+    returns. It is recommended to combine the "return" statement with this
+    call, i.e., "return ngx.redirect(...)", so as to be more explicit.
+
+  ngx.send_headers
+    syntax: *ok, err = ngx.send_headers()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Explicitly send out the response headers.
+
+    Since "v0.8.3" this function returns 1 on success, or returns "nil" and
+    a string describing the error otherwise.
+
+    Note that there is normally no need to manually send out response
+    headers as ngx_lua will automatically send headers out before content is
+    output with ngx.say or ngx.print or when content_by_lua exits normally.
+
+  ngx.headers_sent
+    syntax: *value = ngx.headers_sent*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Returns "true" if the response headers have been sent (by ngx_lua), and
+    "false" otherwise.
+
+    This API was first introduced in ngx_lua v0.3.1rc6.
+
+  ngx.print
+    syntax: *ok, err = ngx.print(...)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Emits arguments concatenated to the HTTP client (as response body). If
+    response headers have not been sent, this function will send headers out
+    first and then output body data.
+
+    Since "v0.8.3" this function returns 1 on success, or returns "nil" and
+    a string describing the error otherwise.
+
+    Lua "nil" values will output "nil" strings and Lua boolean values will
+    output "true" and "false" literal strings respectively.
+
+    Nested arrays of strings are permitted and the elements in the arrays
+    will be sent one by one:
+
+        local table = {
+            "hello, ",
+            {"world: ", true, " or ", false,
+                {": ", nil}}
+        }
+        ngx.print(table)
+
+    will yield the output
+
+        hello, world: true or false: nil
+
+    Non-array table arguments will cause a Lua exception to be thrown.
+
+    The "ngx.null" constant will yield the "null" string output.
+
+    This is an asynchronous call and will return immediately without waiting
+    for all the data to be written into the system send buffer. To run in
+    synchronous mode, call "ngx.flush(true)" after calling "ngx.print". This
+    can be particularly useful for streaming output. See ngx.flush for more
+    details.
+
+    Please note that both "ngx.print" and ngx.say will always invoke the
+    whole Nginx output body filter chain, which is an expensive operation.
+    So be careful when calling either of these two in a tight loop; buffer
+    the data yourself in Lua and save the calls.
+
+  ngx.say
+    syntax: *ok, err = ngx.say(...)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Just as ngx.print but also emit a trailing newline.
+
+  ngx.log
+    syntax: *ngx.log(log_level, ...)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Log arguments concatenated to error.log with the given logging level.
+
+    Lua "nil" arguments are accepted and result in literal "nil" string
+    while Lua booleans result in literal "true" or "false" string outputs.
+    And the "ngx.null" constant will yield the "null" string output.
+
+    The "log_level" argument can take constants like "ngx.ERR" and
+    "ngx.WARN". Check out Nginx log level constants for details.
+
+    There is a hard coded 2048 byte limitation on error message lengths in
+    the Nginx core. This limit includes trailing newlines and leading time
+    stamps. If the message size exceeds this limit, Nginx will truncate the
+    message text accordingly. This limit can be manually modified by editing
+    the "NGX_MAX_ERROR_STR" macro definition in the "src/core/ngx_log.h"
+    file in the Nginx source tree.
+
+  ngx.flush
+    syntax: *ok, err = ngx.flush(wait?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Flushes response output to the client.
+
+    "ngx.flush" accepts an optional boolean "wait" argument (Default:
+    "false") first introduced in the "v0.3.1rc34" release. When called with
+    the default argument, it issues an asynchronous call (Returns
+    immediately without waiting for output data to be written into the
+    system send buffer). Calling the function with the "wait" argument set
+    to "true" switches to synchronous mode.
+
+    In synchronous mode, the function will not return until all output data
+    has been written into the system send buffer or until the send_timeout
+    setting has expired. Note that using the Lua coroutine mechanism means
+    that this function does not block the Nginx event loop even in the
+    synchronous mode.
+
+    When "ngx.flush(true)" is called immediately after ngx.print or ngx.say,
+    it causes the latter functions to run in synchronous mode. This can be
+    particularly useful for streaming output.
+
+    Note that "ngx.flush" is non functional when in the HTTP 1.0 output
+    buffering mode. See HTTP 1.0 support.
+
+    Since "v0.8.3" this function returns 1 on success, or returns "nil" and
+    a string describing the error otherwise.
+
+  ngx.exit
+    syntax: *ngx.exit(status)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    When "status >= 200" (i.e., "ngx.HTTP_OK" and above), it will interrupt
+    the execution of the current request and return status code to nginx.
+
+    When "status == 0" (i.e., "ngx.OK"), it will only quit the current phase
+    handler (or the content handler if the content_by_lua directive is used)
+    and continue to run later phases (if any) for the current request.
+
+    The "status" argument can be "ngx.OK", "ngx.ERROR",
+    "ngx.HTTP_NOT_FOUND", "ngx.HTTP_MOVED_TEMPORARILY", or other HTTP status
+    constants.
+
+    To return an error page with custom contents, use code snippets like
+    this:
+
+        ngx.status = ngx.HTTP_GONE
+        ngx.say("This is our own content")
+        -- to cause quit the whole request rather than the current phase handler
+        ngx.exit(ngx.HTTP_OK)
+
+    The effect in action:
+
+        $ curl -i http://localhost/test
+        HTTP/1.1 410 Gone
+        Server: nginx/1.0.6
+        Date: Thu, 15 Sep 2011 00:51:48 GMT
+        Content-Type: text/plain
+        Transfer-Encoding: chunked
+        Connection: keep-alive
+
+        This is our own content
+
+    Number literals can be used directly as the argument, for instance,
+
+        ngx.exit(501)
+
+    Note that while this method accepts all HTTP status constants as input,
+    it only accepts "NGX_OK" and "NGX_ERROR" of the core constants.
+
+    It is recommended, though not necessary, to combine the "return"
+    statement with this call, i.e., "return ngx.exit(...)", to give a visual
+    hint to others reading the code.
+
+  ngx.eof
+    syntax: *ok, err = ngx.eof()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Explicitly specify the end of the response output stream. In the case of
+    HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to
+    send out the "last chunk".
+
+    When you disable the HTTP 1.1 keep-alive feature for your downstream
+    connections, you can rely on descent HTTP clients to close the
+    connection actively for you when you call this method. This trick can be
+    used do back-ground jobs without letting the HTTP clients to wait on the
+    connection, as in the following example:
+
+        location = /async {
+            keepalive_timeout 0;
+            content_by_lua '
+                ngx.say("got the task!")
+                ngx.eof()  -- descent HTTP client will close the connection at this point
+                -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...
+            ';
+        }
+
+    But if you create subrequests to access other locations configured by
+    Nginx upstream modules, then you should configure those upstream modules
+    to ignore client connection abortions if they are not by default. For
+    example, by default the standard [[HttpProxyModule]] will terminate both
+    the subrequest and the main request as soon as the client closes the
+    connection, so it is important to turn on the proxy_ignore_client_abort
+    directive in your location block configured by [[HttpProxyModule]]:
+
+        proxy_ignore_client_abort on;
+
+    Since "v0.8.3" this function returns 1 on success, or returns "nil" and
+    a string describing the error otherwise.
+
+  ngx.sleep
+    syntax: *ngx.sleep(seconds)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Sleeps for the specified seconds without blocking. One can specify time
+    resolution up to 0.001 seconds (i.e., one milliseconds).
+
+    Behind the scene, this method makes use of the Nginx timers.
+
+    Since the 0.7.20 release, The 0 time argument can also be specified.
+
+    This method was introduced in the "0.5.0rc30" release.
+
+  ngx.escape_uri
+    syntax: *newstr = ngx.escape_uri(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Escape "str" as a URI component.
+
+  ngx.unescape_uri
+    syntax: *newstr = ngx.unescape_uri(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Unescape "str" as an escaped URI component.
+
+    For example,
+
+        ngx.say(ngx.unescape_uri("b%20r56+7"))
+
+    gives the output
+
+        b r56 7
+
+  ngx.encode_args
+    syntax: *str = ngx.encode_args(table)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Encode the Lua table to a query args string according to the URI encoded
+    rules.
+
+    For example,
+
+        ngx.encode_args({foo = 3, ["b r"] = "hello world"})
+
+    yields
+
+        foo=3&b%20r=hello%20world
+
+    The table keys must be Lua strings.
+
+    Multi-value query args are also supported. Just use a Lua table for the
+    argument's value, for example:
+
+        ngx.encode_args({baz = {32, "hello"}})
+
+    gives
+
+        baz=32&baz=hello
+
+    If the value table is empty and the effect is equivalent to the "nil"
+    value.
+
+    Boolean argument values are also supported, for instance,
+
+        ngx.encode_args({a = true, b = 1})
+
+    yields
+
+        a&b=1
+
+    If the argument value is "false", then the effect is equivalent to the
+    "nil" value.
+
+    This method was first introduced in the "v0.3.1rc27" release.
+
+  ngx.decode_args
+    syntax: *table = ngx.decode_args(str, max_args?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Decodes a URI encoded query-string into a Lua table. This is the inverse
+    function of ngx.encode_args.
+
+    The optional "max_args" argument can be used to specify the maximum
+    number of arguments parsed from the "str" argument. By default, a
+    maximum of 100 request arguments are parsed (including those with the
+    same name) and that additional URI arguments are silently discarded to
+    guard against potential denial of service attacks.
+
+    This argument can be set to zero to remove the limit and to process all
+    request arguments received:
+
+        local args = ngx.decode_args(str, 0)
+
+    Removing the "max_args" cap is strongly discouraged.
+
+    This method was introduced in the "v0.5.0rc29".
+
+  ngx.encode_base64
+    syntax: *newstr = ngx.encode_base64(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Encode "str" to a base64 digest.
+
+  ngx.decode_base64
+    syntax: *newstr = ngx.decode_base64(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Decodes the "str" argument as a base64 digest to the raw form. Returns
+    "nil" if "str" is not well formed.
+
+  ngx.crc32_short
+    syntax: *intval = ngx.crc32_short(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Calculates the CRC-32 (Cyclic Redundancy Code) digest for the "str"
+    argument.
+
+    This method performs better on relatively short "str" inputs (i.e., less
+    than 30 ~ 60 bytes), as compared to ngx.crc32_long. The result is
+    exactly the same as ngx.crc32_long.
+
+    Behind the scene, it is just a thin wrapper around the "ngx_crc32_short"
+    function defined in the Nginx core.
+
+    This API was first introduced in the "v0.3.1rc8" release.
+
+  ngx.crc32_long
+    syntax: *intval = ngx.crc32_long(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Calculates the CRC-32 (Cyclic Redundancy Code) digest for the "str"
+    argument.
+
+    This method performs better on relatively long "str" inputs (i.e.,
+    longer than 30 ~ 60 bytes), as compared to ngx.crc32_short. The result
+    is exactly the same as ngx.crc32_short.
+
+    Behind the scene, it is just a thin wrapper around the "ngx_crc32_long"
+    function defined in the Nginx core.
+
+    This API was first introduced in the "v0.3.1rc8" release.
+
+  ngx.hmac_sha1
+    syntax: *digest = ngx.hmac_sha1(secret_key, str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Computes the HMAC-SHA1 (<http://en.wikipedia.org/wiki/HMAC>) digest of
+    the argument "str" and turns the result using the secret key
+    "<secret_key>".
+
+    The raw binary form of the "HMAC-SHA1" digest will be generated, use
+    ngx.encode_base64, for example, to encode the result to a textual
+    representation if desired.
+
+    For example,
+
+        local key = "thisisverysecretstuff"
+        local src = "some string we want to sign"
+        local digest = ngx.hmac_sha1(key, src)
+        ngx.say(ngx.encode_base64(digest))
+
+    yields the output
+
+        R/pvxzHC4NLtj7S+kXFg/NePTmk=
+
+    This API requires the OpenSSL library enabled in the Nginx build
+    (usually by passing the "--with-http_ssl_module" option to the
+    "./configure" script).
+
+    This function was first introduced in the "v0.3.1rc29" release.
+
+  ngx.md5
+    syntax: *digest = ngx.md5(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns the hexadecimal representation of the MD5 digest of the "str"
+    argument.
+
+    For example,
+
+        location = /md5 {
+            content_by_lua 'ngx.say(ngx.md5("hello"))';
+        }
+
+    yields the output
+
+        5d41402abc4b2a76b9719d911017c592
+
+    See ngx.md5_bin if the raw binary MD5 digest is required.
+
+  ngx.md5_bin
+    syntax: *digest = ngx.md5_bin(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns the binary form of the MD5 digest of the "str" argument.
+
+    See ngx.md5 if the hexadecimal form of the MD5 digest is required.
+
+  ngx.sha1_bin
+    syntax: *digest = ngx.sha1_bin(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns the binary form of the SHA-1 digest of the "str" argument.
+
+    This function requires SHA-1 support in the Nginx build. (This usually
+    just means OpenSSL should be installed while building Nginx).
+
+    This function was first introduced in the "v0.5.0rc6".
+
+  ngx.quote_sql_str
+    syntax: *quoted_value = ngx.quote_sql_str(raw_value)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns a quoted SQL string literal according to the MySQL quoting
+    rules.
+
+  ngx.today
+    syntax: *str = ngx.today()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns current date (in the format "yyyy-mm-dd") from the nginx cached
+    time (no syscall involved unlike Lua's date library).
+
+    This is the local time.
+
+  ngx.time
+    syntax: *secs = ngx.time()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns the elapsed seconds from the epoch for the current time stamp
+    from the nginx cached time (no syscall involved unlike Lua's date
+    library).
+
+    Updates of the Nginx time cache an be forced by calling ngx.update_time
+    first.
+
+  ngx.now
+    syntax: *secs = ngx.now()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns a floating-point number for the elapsed time in seconds
+    (including milliseconds as the decimal part) from the epoch for the
+    current time stamp from the nginx cached time (no syscall involved
+    unlike Lua's date library).
+
+    You can forcibly update the Nginx time cache by calling ngx.update_time
+    first.
+
+    This API was first introduced in "v0.3.1rc32".
+
+  ngx.update_time
+    syntax: *ngx.update_time()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Forcibly updates the Nginx current time cache. This call involves a
+    syscall and thus has some overhead, so do not abuse it.
+
+    This API was first introduced in "v0.3.1rc32".
+
+  ngx.localtime
+    syntax: *str = ngx.localtime()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns the current time stamp (in the format "yyyy-mm-dd hh:mm:ss") of
+    the nginx cached time (no syscall involved unlike Lua's os.date
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-os.date>) function).
+
+    This is the local time.
+
+  ngx.utctime
+    syntax: *str = ngx.utctime()*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns the current time stamp (in the format "yyyy-mm-dd hh:mm:ss") of
+    the nginx cached time (no syscall involved unlike Lua's os.date
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-os.date>) function).
+
+    This is the UTC time.
+
+  ngx.cookie_time
+    syntax: *str = ngx.cookie_time(sec)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns a formated string can be used as the cookie expiration time. The
+    parameter "sec" is the time stamp in seconds (like those returned from
+    ngx.time).
+
+        ngx.say(ngx.cookie_time(1290079655))
+            -- yields "Thu, 18-Nov-10 11:27:35 GMT"
+
+  ngx.http_time
+    syntax: *str = ngx.http_time(sec)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Returns a formated string can be used as the http header time (for
+    example, being used in "Last-Modified" header). The parameter "sec" is
+    the time stamp in seconds (like those returned from ngx.time).
+
+        ngx.say(ngx.http_time(1290079655))
+            -- yields "Thu, 18 Nov 2010 11:27:35 GMT"
+
+  ngx.parse_http_time
+    syntax: *sec = ngx.parse_http_time(str)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Parse the http time string (as returned by ngx.http_time) into seconds.
+    Returns the seconds or "nil" if the input string is in bad forms.
+
+        local time = ngx.parse_http_time("Thu, 18 Nov 2010 11:27:35 GMT")
+        if time == nil then
+            ...
+        end
+
+  ngx.is_subrequest
+    syntax: *value = ngx.is_subrequest*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua**
+
+    Returns "true" if the current request is an nginx subrequest, or "false"
+    otherwise.
+
+  ngx.re.match
+    syntax: *captures, err = ngx.re.match(subject, regex, options?, ctx?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Matches the "subject" string using the Perl compatible regular
+    expression "regex" with the optional "options".
+
+    Only the first occurrence of the match is returned, or "nil" if no match
+    is found. In case of errors, like seeing a bad regular expression or
+    exceeding the PCRE stack limit, "nil" and a string describing the error
+    will be returned.
+
+    When a match is found, a Lua table "captures" is returned, where
+    "captures[0]" holds the whole substring being matched, and "captures[1]"
+    holds the first parenthesized sub-pattern's capturing, "captures[2]" the
+    second, and so on.
+
+        local m, err = ngx.re.match("hello, 1234", "[0-9]+")
+        if m then
+            -- m[0] == "1234"
+
+        else
+            if err then
+                ngx.log(ngx.ERR, "error: ", err)
+                return
+            end
+
+            ngx.say("match not found")
+        end
+
+        local m, err = ngx.re.match("hello, 1234", "([0-9])[0-9]+")
+        -- m[0] == "1234"
+        -- m[1] == "1"
+
+    Named captures are also supported since the "v0.7.14" release and are
+    returned in the same Lua table as key-value pairs as the numbered
+    captures.
+
+        local m, err = ngx.re.match("hello, 1234", "([0-9])(?<remaining>[0-9]+)")
+        -- m[0] == "1234"
+        -- m[1] == "1"
+        -- m[2] == "234"
+        -- m["remaining"] == "234"
+
+    Unmatched subpatterns will have "nil" values in their "captures" table
+    fields.
+
+        local m, err = ngx.re.match("hello, world", "(world)|(hello)|(?<named>howdy)")
+        -- m[0] == "hello"
+        -- m[1] == nil
+        -- m[2] == "hello"
+        -- m[3] == nil
+        -- m["named"] == nil
+
+    Specify "options" to control how the match operation will be performed.
+    The following option characters are supported:
+
+        a             anchored mode (only match from the beginning)
+
+        d             enable the DFA mode (or the longest token match semantics).
+                      this requires PCRE 6.0+ or else a Lua exception will be thrown.
+                      first introduced in ngx_lua v0.3.1rc30.
+
+        D             enable duplicate named pattern support. This allows named
+                      subpattern names to be repeated, returning the captures in
+                      an array-like Lua table. for example,
+                        local m = ngx.re.match("hello, world",
+                                               "(?<named>\w+), (?<named>\w+)",
+                                               "D")
+                        -- m["named"] == {"hello", "world"}
+                      this option was first introduced in the v0.7.14 release.
+                      this option requires at least PCRE 8.12.
+
+        i             case insensitive mode (similar to Perl's /i modifier)
+
+        j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
+                      must be built with the --enable-jit option. for optimum performance,
+                      this option should always be used together with the 'o' option.
+                      first introduced in ngx_lua v0.3.1rc30.
+
+        J             enable the PCRE Javascript compatible mode. this option was
+                      first introduced in the v0.7.14 release. this option requires
+                      at least PCRE 8.12.
+
+        m             multi-line mode (similar to Perl's /m modifier)
+
+        o             compile-once mode (similar to Perl's /o modifier),
+                      to enable the worker-process-level compiled-regex cache
+
+        s             single-line mode (similar to Perl's /s modifier)
+
+        u             UTF-8 mode. this requires PCRE to be built with
+                      the --enable-utf8 option or else a Lua exception will be thrown.
+
+        U             similar to "u" but disables PCRE's UTF-8 validity check on
+                      the subject string. first introduced in ngx_lua v0.8.1.
+
+        x             extended mode (similar to Perl's /x modifier)
+
+    These options can be combined:
+
+        local m, err = ngx.re.match("hello, world", "HEL LO", "ix")
+        -- m[0] == "hello"
+
+        local m, err = ngx.re.match("hello, 美好生活", "HELLO, (.{2})", "iu")
+        -- m[0] == "hello, 美好"
+        -- m[1] == "美好"
+
+    The "o" option is useful for performance tuning, because the regex
+    pattern in question will only be compiled once, cached in the
+    worker-process level, and shared among all requests in the current Nginx
+    worker process. The upper limit of the regex cache can be tuned via the
+    lua_regex_cache_max_entries directive.
+
+    The optional fourth argument, "ctx", can be a Lua table holding an
+    optional "pos" field. When the "pos" field in the "ctx" table argument
+    is specified, "ngx.re.match" will start matching from that offset.
+    Regardless of the presence of the "pos" field in the "ctx" table,
+    "ngx.re.match" will always set this "pos" field to the position *after*
+    the substring matched by the whole pattern in case of a successful
+    match. When match fails, the "ctx" table will be left intact.
+
+        local ctx = {}
+        local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
+             -- m[0] = "1234"
+             -- ctx.pos == 4
+
+        local ctx = { pos = 2 }
+        local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
+             -- m[0] = "34"
+             -- ctx.pos == 4
+
+    The "ctx" table argument combined with the "a" regex modifier can be
+    used to construct a lexer atop "ngx.re.match".
+
+    Note that, the "options" argument is not optional when the "ctx"
+    argument is specified and that the empty Lua string ("") must be used as
+    placeholder for "options" if no meaningful regex options are required.
+
+    This method requires the PCRE library enabled in Nginx. (Known Issue
+    With Special PCRE Sequences).
+
+    To confirm that PCRE JIT is enabled, activate the Nginx debug log by
+    adding the "--with-debug" option to Nginx or ngx_openresty's
+    "./configure" script. Then, enable the "debug" error log level in
+    "error_log" directive. The following message will be generated if PCRE
+    JIT is enabled:
+
+        pcre JIT compiling result: 1
+
+    This feature was introduced in the "v0.2.1rc11" release.
+
+  ngx.re.gmatch
+    syntax: *iterator, err = ngx.re.gmatch(subject, regex, options?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Similar to ngx.re.match, but returns a Lua iterator instead, so as to
+    let the user programmer iterate all the matches over the "<subject>"
+    string argument with the PCRE "regex".
+
+    In case of errors, like seeing an ill-formed regular expression, "nil"
+    and a string describing the error will be returned.
+
+    Here is a small example to demonstrate its basic usage:
+
+        local iterator, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
+        if not iterator then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        local m
+        m, err = iterator()    -- m[0] == m[1] == "hello"
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        m, err = iterator()    -- m[0] == m[1] == "world"
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        m, err = iterator()    -- m == nil
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+    More often we just put it into a Lua loop:
+
+        local it, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
+        if not it then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        while true do
+            local m, err = it()
+            if err then
+                ngx.log(ngx.ERR, "error: ", err)
+                return
+            end
+
+            if not m then
+                -- no match found (any more)
+                break
+            end
+
+            -- found a match
+            ngx.say(m[0])
+            ngx.say(m[1])
+        end
+
+    The optional "options" argument takes exactly the same semantics as the
+    ngx.re.match method.
+
+    The current implementation requires that the iterator returned should
+    only be used in a single request. That is, one should *not* assign it to
+    a variable belonging to persistent namespace like a Lua package.
+
+    This method requires the PCRE library enabled in Nginx. (Known Issue
+    With Special PCRE Sequences).
+
+    This feature was first introduced in the "v0.2.1rc12" release.
+
+  ngx.re.sub
+    syntax: *newstr, n, err = ngx.re.sub(subject, regex, replace, options?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Substitutes the first match of the Perl compatible regular expression
+    "regex" on the "subject" argument string with the string or function
+    argument "replace". The optional "options" argument has exactly the same
+    meaning as in ngx.re.match.
+
+    This method returns the resulting new string as well as the number of
+    successful substitutions. In case of failures, like syntax errors in the
+    regular expressions or the "<replace>" string argument, it will return
+    "nil" and a string describing the error.
+
+    When the "replace" is a string, then it is treated as a special template
+    for string replacement. For example,
+
+        local newstr, n, err = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")
+        if newstr then
+            -- newstr == "hello, [12][1]34"
+            -- n == 1
+        else
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+    where $0 referring to the whole substring matched by the pattern and $1
+    referring to the first parenthesized capturing substring.
+
+    Curly braces can also be used to disambiguate variable names from the
+    background string literals:
+
+        local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")
+            -- newstr == "hello, 10034"
+            -- n == 1
+
+    Literal dollar sign characters ("$") in the "replace" string argument
+    can be escaped by another dollar sign, for instance,
+
+        local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "$$")
+            -- newstr == "hello, $234"
+            -- n == 1
+
+    Do not use backlashes to escape dollar signs; it will not work as
+    expected.
+
+    When the "replace" argument is of type "function", then it will be
+    invoked with the "match table" as the argument to generate the replace
+    string literal for substitution. The "match table" fed into the
+    "replace" function is exactly the same as the return value of
+    ngx.re.match. Here is an example:
+
+        local func = function (m)
+            return "[" .. m[0] .. "][" .. m[1] .. "]"
+        end
+        local newstr, n, err = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")
+            -- newstr == "hello, [12][1]34"
+            -- n == 1
+
+    The dollar sign characters in the return value of the "replace" function
+    argument are not special at all.
+
+    This method requires the PCRE library enabled in Nginx. (Known Issue
+    With Special PCRE Sequences).
+
+    This feature was first introduced in the "v0.2.1rc13" release.
+
+  ngx.re.gsub
+    syntax: *newstr, n, err = ngx.re.gsub(subject, regex, replace,
+    options?)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Just like ngx.re.sub, but does global substitution.
+
+    Here is some examples:
+
+        local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "i")
+        if newstr then
+            -- newstr == "[hello,h], [world,w]"
+            -- n == 2
+        else
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        local func = function (m)
+            return "[" .. m[0] .. "," .. m[1] .. "]"
+        end
+        local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", func, "i")
+            -- newstr == "[hello,h], [world,w]"
+            -- n == 2
+
+    This method requires the PCRE library enabled in Nginx. (Known Issue
+    With Special PCRE Sequences).
+
+    This feature was first introduced in the "v0.2.1rc15" release.
+
+  ngx.shared.DICT
+    syntax: *dict = ngx.shared.DICT*
+
+    syntax: *dict = ngx.shared[name_var]*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Fetching the shm-based Lua dictionary object for the shared memory zone
+    named "DICT" defined by the lua_shared_dict directive.
+
+    The resulting object "dict" has the following methods:
+
+    *   get
+
+    *   get_stale
+
+    *   set
+
+    *   safe_set
+
+    *   add
+
+    *   safe_add
+
+    *   replace
+
+    *   incr
+
+    *   delete
+
+    *   flush_all
+
+    *   flush_expired
+
+    Here is an example:
+
+        http {
+            lua_shared_dict dogs 10m;
+            server {
+                location /set {
+                    content_by_lua '
+                        local dogs = ngx.shared.dogs
+                        dogs:set("Jim", 8)
+                        ngx.say("STORED")
+                    ';
+                }
+                location /get {
+                    content_by_lua '
+                        local dogs = ngx.shared.dogs
+                        ngx.say(dogs:get("Jim"))
+                    ';
+                }
+            }
+        }
+
+    Let us test it:
+
+        $ curl localhost/set
+        STORED
+
+        $ curl localhost/get
+        8
+
+        $ curl localhost/get
+        8
+
+    The number 8 will be consistently output when accessing "/get"
+    regardless of how many Nginx workers there are because the "dogs"
+    dictionary resides in the shared memory and visible to *all* of the
+    worker processes.
+
+    The shared dictionary will retain its contents through a server config
+    reload (either by sending the "HUP" signal to the Nginx process or by
+    using the "-s reload" command-line option).
+
+    The contents in the dictionary storage will be lost, however, when the
+    Nginx server quits.
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+  ngx.shared.DICT.get
+    syntax: *value, flags = ngx.shared.DICT:get(key)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Retrieving the value in the dictionary ngx.shared.DICT for the key
+    "key". If the key does not exist or has been expired, then "nil" will be
+    returned.
+
+    The value returned will have the original data type when they were
+    inserted into the dictionary, for example, Lua booleans, numbers, or
+    strings.
+
+    The first argument to this method must be the dictionary object itself,
+    for example,
+
+        local cats = ngx.shared.cats
+        local value, flags = cats.get(cats, "Marry")
+
+    or use Lua's syntactic sugar for method calls:
+
+        local cats = ngx.shared.cats
+        local value, flags = cats:get("Marry")
+
+    These two forms are fundamentally equivalent.
+
+    If the user flags is 0 (the default), then no flags value will be
+    returned.
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.get_stale
+    syntax: *value, flags, stale = ngx.shared.DICT:get_stale(key)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Similar to the get method but returns the value even if the key has
+    already expired.
+
+    Returns a 3rd value, "stale", indicating whether the key has expired or
+    not.
+
+    Note that the value of an expired key is not guaranteed to be available
+    so one should never rely on the availability of expired items.
+
+    This method was first introduced in the 0.8.6 release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.set
+    syntax: *success, err, forcible = ngx.shared.DICT:set(key, value,
+    exptime?, flags?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Unconditionally sets a key-value pair into the shm-based dictionary
+    ngx.shared.DICT. Returns three values:
+
+    *   "success": boolean value to indicate whether the key-value pair is
+        stored or not.
+
+    *   "err": textual error message, can be "no memory".
+
+    *   "forcible": a boolean value to indicate whether other valid items
+        have been removed forcibly when out of storage in the shared memory
+        zone.
+
+    The "value" argument inserted can be Lua booleans, numbers, strings, or
+    "nil". Their value type will also be stored into the dictionary and the
+    same data type can be retrieved later via the get method.
+
+    The optional "exptime" argument specifies expiration time (in seconds)
+    for the inserted key-value pair. The time resolution is 0.001 seconds.
+    If the "exptime" takes the value 0 (which is the default), then the item
+    will never be expired.
+
+    The optional "flags" argument specifies a user flags value associated
+    with the entry to be stored. It can also be retrieved later with the
+    value. The user flags is stored as an unsigned 32-bit integer
+    internally. Defaults to 0. The user flags argument was first introduced
+    in the "v0.5.0rc2" release.
+
+    When it fails to allocate memory for the current key-value item, then
+    "set" will try removing existing items in the storage according to the
+    Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over
+    expiration time here. If up to tens of existing items have been removed
+    and the storage left is still insufficient (either due to the total
+    capacity limit specified by lua_shared_dict or memory segmentation),
+    then the "err" return value will be "no memory" and "success" will be
+    "false".
+
+    If this method succeeds in storing the current item by forcibly removing
+    other not-yet-expired items in the dictionary via LRU, the "forcible"
+    return value will be "true". If it stores the item without forcibly
+    removing other valid items, then the return value "forcible" will be
+    "false".
+
+    The first argument to this method must be the dictionary object itself,
+    for example,
+
+        local cats = ngx.shared.cats
+        local succ, err, forcible = cats.set(cats, "Marry", "it is a nice cat!")
+
+    or use Lua's syntactic sugar for method calls:
+
+        local cats = ngx.shared.cats
+        local succ, err, forcible = cats:set("Marry", "it is a nice cat!")
+
+    These two forms are fundamentally equivalent.
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+    Please note that while internally the key-value pair is set atomically,
+    the atomicity does not go across the method call boundary.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.safe_set
+    syntax: *ok, err = ngx.shared.DICT:safe_set(key, value, exptime?,
+    flags?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Similar to the set method, but never overrides the (least recently used)
+    unexpired items in the store when running out of storage in the shared
+    memory zone. In this case, it will immediately return "nil" and the
+    string "no memory".
+
+    This feature was first introduced in the "v0.7.18" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.add
+    syntax: *success, err, forcible = ngx.shared.DICT:add(key, value,
+    exptime?, flags?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Just like the set method, but only stores the key-value pair into the
+    dictionary ngx.shared.DICT if the key does *not* exist.
+
+    If the "key" argument already exists in the dictionary (and not expired
+    for sure), the "success" return value will be "false" and the "err"
+    return value will be "exists".
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.safe_add
+    syntax: *ok, err = ngx.shared.DICT:safe_add(key, value, exptime?,
+    flags?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Similar to the add method, but never overrides the (least recently used)
+    unexpired items in the store when running out of storage in the shared
+    memory zone. In this case, it will immediately return "nil" and the
+    string "no memory".
+
+    This feature was first introduced in the "v0.7.18" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.replace
+    syntax: *success, err, forcible = ngx.shared.DICT:replace(key, value,
+    exptime?, flags?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Just like the set method, but only stores the key-value pair into the
+    dictionary ngx.shared.DICT if the key *does* exist.
+
+    If the "key" argument does *not* exist in the dictionary (or expired
+    already), the "success" return value will be "false" and the "err"
+    return value will be "not found".
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.delete
+    syntax: *ngx.shared.DICT:delete(key)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Unconditionally removes the key-value pair from the shm-based dictionary
+    ngx.shared.DICT.
+
+    It is equivalent to "ngx.shared.DICT:set(key, nil)".
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.incr
+    syntax: *newval, err = ngx.shared.DICT:incr(key, value)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Increments the (numerical) value for "key" in the shm-based dictionary
+    ngx.shared.DICT by the step value "value". Returns the new resulting
+    number if the operation is successfully completed or "nil" and an error
+    message otherwise.
+
+    The key must already exist in the dictionary, otherwise it will return
+    "nil" and "not found".
+
+    If the original value is not a valid Lua number in the dictionary, it
+    will return "nil" and "not a number".
+
+    The "value" argument can be any valid Lua numbers, like negative numbers
+    or floating-point numbers.
+
+    This feature was first introduced in the "v0.3.1rc22" release.
+
+    See also ngx.shared.DICT.
+
+  ngx.shared.DICT.flush_all
+    syntax: *ngx.shared.DICT:flush_all()*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Flushes out all the items in the dictionary. This method does not
+    actuall free up all the memory blocks in the dictionary but just marks
+    all the existing items as expired.
+
+    This feature was first introduced in the "v0.5.0rc17" release.
+
+    See also ngx.shared.DICT.flush_expired and ngx.shared.DICT.
+
+  ngx.shared.DICT.flush_expired
+    syntax: *flushed = ngx.shared.DICT:flush_expired(max_count?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Flushes out the expired items in the dictionary, up to the maximal
+    number specified by the optional "max_count" argument. When the
+    "max_count" argument is given 0 or not given at all, then it means
+    unlimited. Returns the number of items that have actually been flushed.
+
+    Unlike the flush_all method, this method actually free up the memory
+    used by the expired items.
+
+    This feature was first introduced in the "v0.6.3" release.
+
+    See also ngx.shared.DICT.flush_all and ngx.shared.DICT.
+
+  ngx.shared.DICT.get_keys
+    syntax: *keys = ngx.shared.DICT:get_keys(max_count?)*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Fetch a list of the keys from the dictionary, up to "<max_count>".
+
+    By default, only the first 1024 keys (if any) are returned. When the
+    "<max_count>" argument is given the value 0, then all the keys will be
+    returned even there is more than 1024 keys in the dictionary.
+
+    WARNING Be careful when calling this method on dictionaries with a
+    really huge number of keys. This method may lock the dictionary for
+    quite a while and block all the nginx worker processes that are trying
+    to access the dictionary.
+
+    This feature was first introduced in the "v0.7.3" release.
+
+  ngx.socket.udp
+    syntax: *udpsock = ngx.socket.udp()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Creates and returns a UDP or datagram-oriented unix domain socket object
+    (also known as one type of the "cosocket" objects). The following
+    methods are supported on this object:
+
+    *   setpeername
+
+    *   send
+
+    *   receive
+
+    *   close
+
+    *   settimeout
+
+    It is intended to be compatible with the UDP API of the LuaSocket
+    (<http://w3.impa.br/~diego/software/luasocket/udp.html>) library but is
+    100% nonblocking out of the box.
+
+    This feature was first introduced in the "v0.5.7" release.
+
+    See also ngx.socket.tcp.
+
+  udpsock:setpeername
+    syntax: *ok, err = udpsock:setpeername(host, port)*
+
+    syntax: *ok, err =
+    udpsock:setpeername("unix:/path/to/unix-domain.socket")*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Attempts to connect a UDP socket object to a remote server or to a
+    datagram unix domain socket file. Because the datagram protocol is
+    actually connection-less, this method does not really establish a
+    "connection", but only just set the name of the remote peer for
+    subsequent read/write operations.
+
+    Both IP addresses and domain names can be specified as the "host"
+    argument. In case of domain names, this method will use Nginx core's
+    dynamic resolver to parse the domain name without blocking and it is
+    required to configure the resolver directive in the "nginx.conf" file
+    like this:
+
+        resolver 8.8.8.8;  # use Google's public DNS nameserver
+
+    If the nameserver returns multiple IP addresses for the host name, this
+    method will pick up one randomly.
+
+    In case of error, the method returns "nil" followed by a string
+    describing the error. In case of success, the method returns 1.
+
+    Here is an example for connecting to a UDP (memcached) server:
+
+        location /test {
+            resolver 8.8.8.8;
+
+            content_by_lua '
+                local sock = ngx.socket.udp()
+                local ok, err = sock:setpeername("my.memcached.server.domain", 11211)
+                if not ok then
+                    ngx.say("failed to connect to memcached: ", err)
+                    return
+                end
+                ngx.say("successfully connected to memcached!")
+                sock:close()
+            ';
+        }
+
+    Since the "v0.7.18" release, connecting to a datagram unix domain socket
+    file is also possible on Linux:
+
+        local sock = ngx.socket.udp()
+        local ok, err = sock:setpeername("unix:/tmp/some-datagram-service.sock")
+        if not ok then
+            ngx.say("failed to connect to the datagram unix domain socket: ", err)
+            return
+        end
+
+    assuming the datagram service is listening on the unix domain socket
+    file "/tmp/some-datagram-service.sock" and the client socket will use
+    the "autobind" feature on Linux.
+
+    Calling this method on an already connected socket object will cause the
+    original connection to be closed first.
+
+    This method was first introduced in the "v0.5.7" release.
+
+  udpsock:send
+    syntax: *ok, err = udpsock:send(data)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Sends data on the current UDP or datagram unix domain socket object.
+
+    In case of success, it returns 1. Otherwise, it returns "nil" and a
+    string describing the error.
+
+    The input argument "data" can either be a Lua string or a (nested) Lua
+    table holding string fragments. In case of table arguments, this method
+    will copy all the string elements piece by piece to the underlying Nginx
+    socket send buffers, which is usually optimal than doing string
+    concatenation operations on the Lua land.
+
+    This feature was first introduced in the "v0.5.7" release.
+
+  udpsock:receive
+    syntax: *data, err = udpsock:receive(size?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Receives data from the UDP or datagram unix domain socket object with an
+    optional receive buffer size argument, "size".
+
+    This method is a synchronous operation and is 100% nonblocking.
+
+    In case of success, it returns the data received; in case of error, it
+    returns "nil" with a string describing the error.
+
+    If the "size" argument is specified, then this method will use this size
+    as the receive buffer size. But when this size is greater than 8192,
+    then 8192 will be used instead.
+
+    If no argument is specified, then the maximal buffer size, 8192 is
+    assumed.
+
+    Timeout for the reading operation is controlled by the
+    lua_socket_read_timeout config directive and the settimeout method. And
+    the latter takes priority. For example:
+
+        sock:settimeout(1000)  -- one second timeout
+        local data, err = sock:receive()
+        if not data then
+            ngx.say("failed to read a packet: ", data)
+            return
+        end
+        ngx.say("successfully read a packet: ", data)
+
+    It is important here to call the settimeout method *before* calling this
+    method.
+
+    This feature was first introduced in the "v0.5.7" release.
+
+  udpsock:close
+    syntax: *ok, err = udpsock:close()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Closes the current UDP or datagram unix domain socket. It returns the 1
+    in case of success and returns "nil" with a string describing the error
+    otherwise.
+
+    Socket objects that have not invoked this method (and associated
+    connections) will be closed when the socket object is released by the
+    Lua GC (Garbage Collector) or the current client HTTP request finishes
+    processing.
+
+    This feature was first introduced in the "v0.5.7" release.
+
+  udpsock:settimeout
+    syntax: *udpsock:settimeout(time)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Set the timeout value in milliseconds for subsequent socket operations
+    (like receive).
+
+    Settings done by this method takes priority over those config
+    directives, like lua_socket_read_timeout.
+
+    This feature was first introduced in the "v0.5.7" release.
+
+  ngx.socket.tcp
+    syntax: *tcpsock = ngx.socket.tcp()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Creates and returns a TCP or stream-oriented unix domain socket object
+    (also known as one type of the "cosocket" objects). The following
+    methods are supported on this object:
+
+    *   connect
+
+    *   send
+
+    *   receive
+
+    *   close
+
+    *   settimeout
+
+    *   setoption
+
+    *   receiveuntil
+
+    *   setkeepalive
+
+    *   getreusedtimes
+
+    It is intended to be compatible with the TCP API of the LuaSocket
+    (<http://w3.impa.br/~diego/software/luasocket/tcp.html>) library but is
+    100% nonblocking out of the box. Also, we introduce some new APIs to
+    provide more functionalities.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+    See also ngx.socket.udp.
+
+  tcpsock:connect
+    syntax: *ok, err = tcpsock:connect(host, port, options_table?)*
+
+    syntax: *ok, err = tcpsock:connect("unix:/path/to/unix-domain.socket",
+    options_table?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Attempts to connect a TCP socket object to a remote server or to a
+    stream unix domain socket file without blocking.
+
+    Before actually resolving the host name and connecting to the remote
+    backend, this method will always look up the connection pool for matched
+    idle connections created by previous calls of this method (or the
+    ngx.socket.connect function).
+
+    Both IP addresses and domain names can be specified as the "host"
+    argument. In case of domain names, this method will use Nginx core's
+    dynamic resolver to parse the domain name without blocking and it is
+    required to configure the resolver directive in the "nginx.conf" file
+    like this:
+
+        resolver 8.8.8.8;  # use Google's public DNS nameserver
+
+    If the nameserver returns multiple IP addresses for the host name, this
+    method will pick up one randomly.
+
+    In case of error, the method returns "nil" followed by a string
+    describing the error. In case of success, the method returns 1.
+
+    Here is an example for connecting to a TCP server:
+
+        location /test {
+            resolver 8.8.8.8;
+
+            content_by_lua '
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("www.google.com", 80)
+                if not ok then
+                    ngx.say("failed to connect to google: ", err)
+                    return
+                end
+                ngx.say("successfully connected to google!")
+                sock:close()
+            ';
+        }
+
+    Connecting to a Unix Domain Socket file is also possible:
+
+        local sock = ngx.socket.tcp()
+        local ok, err = sock:connect("unix:/tmp/memcached.sock")
+        if not ok then
+            ngx.say("failed to connect to the memcached unix domain socket: ", err)
+            return
+        end
+
+    assuming memcached (or something else) is listening on the unix domain
+    socket file "/tmp/memcached.sock".
+
+    Timeout for the connecting operation is controlled by the
+    lua_socket_connect_timeout config directive and the settimeout method.
+    And the latter takes priority. For example:
+
+        local sock = ngx.socket.tcp()
+        sock:settimeout(1000)  -- one second timeout
+        local ok, err = sock:connect(host, port)
+
+    It is important here to call the settimeout method *before* calling this
+    method.
+
+    Calling this method on an already connected socket object will cause the
+    original connection to be closed first.
+
+    An optional Lua table can be specified as the last argument to this
+    method to specify various connect options:
+
+    *   "pool" specify a custom name for the connection pool being used. If
+        omitted, then the connection pool name will be generated from the
+        string template "<host>:<port>" or "<unix-socket-path>".
+
+    The support for the options table argument was first introduced in the
+    "v0.5.7" release.
+
+    This method was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:send
+    syntax: *bytes, err = tcpsock:send(data)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Sends data without blocking on the current TCP or Unix Domain Socket
+    connection.
+
+    This method is a synchronous operation that will not return until *all*
+    the data has been flushed into the system socket send buffer or an error
+    occurs.
+
+    In case of success, it returns the total number of bytes that have been
+    sent. Otherwise, it returns "nil" and a string describing the error.
+
+    The input argument "data" can either be a Lua string or a (nested) Lua
+    table holding string fragments. In case of table arguments, this method
+    will copy all the string elements piece by piece to the underlying Nginx
+    socket send buffers, which is usually optimal than doing string
+    concatenation operations on the Lua land.
+
+    Timeout for the sending operation is controlled by the
+    lua_socket_send_timeout config directive and the settimeout method. And
+    the latter takes priority. For example:
+
+        sock:settimeout(1000)  -- one second timeout
+        local bytes, err = sock:send(request)
+
+    It is important here to call the settimeout method *before* calling this
+    method.
+
+    In case of any connection errors, this method always automatically
+    closes the current connection.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:receive
+    syntax: *data, err, partial = tcpsock:receive(size)*
+
+    syntax: *data, err, partial = tcpsock:receive(pattern?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Receives data from the connected socket according to the reading pattern
+    or size.
+
+    This method is a synchronous operation just like the send method and is
+    100% nonblocking.
+
+    In case of success, it returns the data received; in case of error, it
+    returns "nil" with a string describing the error and the partial data
+    received so far.
+
+    If a number-like argument is specified (including strings that look like
+    numbers), then it is interpreted as a size. This method will not return
+    until it reads exactly this size of data or an error occurs.
+
+    If a non-number-like string argument is specified, then it is
+    interpreted as a "pattern". The following patterns are supported:
+
+    *   '*a': reads from the socket until the connection is closed. No
+        end-of-line translation is performed;
+
+    *   '*l': reads a line of text from the socket. The line is terminated
+        by a "Line Feed" (LF) character (ASCII 10), optionally preceded by a
+        "Carriage Return" (CR) character (ASCII 13). The CR and LF
+        characters are not included in the returned line. In fact, all CR
+        characters are ignored by the pattern.
+
+    If no argument is specified, then it is assumed to be the pattern '*l',
+    that is, the line reading pattern.
+
+    Timeout for the reading operation is controlled by the
+    lua_socket_read_timeout config directive and the settimeout method. And
+    the latter takes priority. For example:
+
+        sock:settimeout(1000)  -- one second timeout
+        local line, err, partial = sock:receive()
+        if not line then
+            ngx.say("failed to read a line: ", err)
+            return
+        end
+        ngx.say("successfully read a line: ", line)
+
+    It is important here to call the settimeout method *before* calling this
+    method.
+
+    Since the "v0.8.8" release, this method no longer automatically closes
+    the current connection when the read timeout error happens. For other
+    connection errors, this method always automatically closes the
+    connection.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:receiveuntil
+    syntax: *iterator = tcpsock:receiveuntil(pattern, options?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    This method returns an iterator Lua function that can be called to read
+    the data stream until it sees the specified pattern or an error occurs.
+
+    Here is an example for using this method to read a data stream with the
+    boundary sequence "--abcedhb":
+
+        local reader = sock:receiveuntil("\r\n--abcedhb")
+        local data, err, partial = reader()
+        if not data then
+            ngx.say("failed to read the data stream: ", err)
+        end
+        ngx.say("read the data stream: ", data)
+
+    When called without any argument, the iterator function returns the
+    received data right *before* the specified pattern string in the
+    incoming data stream. So for the example above, if the incoming data
+    stream is 'hello, world! -agentzh\r\n--abcedhb blah blah', then the
+    string 'hello, world! -agentzh' will be returned.
+
+    In case of error, the iterator function will return "nil" along with a
+    string describing the error and the partial data bytes that have been
+    read so far.
+
+    The iterator function can be called multiple times and can be mixed
+    safely with other cosocket method calls or other iterator function
+    calls.
+
+    The iterator function behaves differently (i.e., like a real iterator)
+    when it is called with a "size" argument. That is, it will read that
+    "size" of data on each invocation and will return "nil" at the last
+    invocation (either sees the boundary pattern or meets an error). For the
+    last successful invocation of the iterator function, the "err" return
+    value will be "nil" too. The iterator function will be reset after the
+    last successful invocation that returns "nil" data and "nil" error.
+    Consider the following example:
+
+        local reader = sock:receiveuntil("\r\n--abcedhb")
+
+        while true do
+            local data, err, partial = reader(4)
+            if not data then
+                if err then
+                    ngx.say("failed to read the data stream: ", err)
+                    break
+                end
+
+                ngx.say("read done")
+                break
+            end
+            ngx.say("read chunk: [", data, "]")
+        end
+
+    Then for the incoming data stream 'hello, world! -agentzh\r\n--abcedhb
+    blah blah', we shall get the following output from the sample code
+    above:
+
+        read chunk: [hell]
+        read chunk: [o, w]
+        read chunk: [orld]
+        read chunk: [! -a]
+        read chunk: [gent]
+        read chunk: [zh]
+        read done
+
+    Note that, the actual data returned *might* be a little longer than the
+    size limit specified by the "size" argument when the boundary pattern
+    has ambiguity for streaming parsing. Near the boundary of the data
+    stream, the data string actually returned could also be shorter than the
+    size limit.
+
+    Timeout for the iterator function's reading operation is controlled by
+    the lua_socket_read_timeout config directive and the settimeout method.
+    And the latter takes priority. For example:
+
+        local readline = sock:receiveuntil("\r\n")
+
+        sock:settimeout(1000)  -- one second timeout
+        line, err, partial = readline()
+        if not line then
+            ngx.say("failed to read a line: ", err)
+            return
+        end
+        ngx.say("successfully read a line: ", line)
+
+    It is important here to call the settimeout method *before* calling the
+    iterator function (note that the "receiveuntil" call is irrelevant
+    here).
+
+    As from the "v0.5.1" release, this method also takes an optional
+    "options" table argument to control the behavior. The following options
+    are supported:
+
+    *   "inclusive"
+
+    The "inclusive" takes a boolean value to control whether to include the
+    pattern string in the returned data string. Default to "false". For
+    example,
+
+        local reader = tcpsock:receiveuntil("_END_", { inclusive = true })
+        local data = reader()
+        ngx.say(data)
+
+    Then for the input data stream "hello world _END_ blah blah blah", then
+    the example above will output "hello world _END_", including the pattern
+    string "_END_" itself.
+
+    Since the "v0.8.8" release, this method no longer automatically closes
+    the current connection when the read timeout error happens. For other
+    connection errors, this method always automatically closes the
+    connection.
+
+    This method was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:close
+    syntax: *ok, err = tcpsock:close()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Closes the current TCP or stream unix domain socket. It returns the 1 in
+    case of success and returns "nil" with a string describing the error
+    otherwise.
+
+    Note that there is no need to call this method on socket objects that
+    have invoked the setkeepalive method because the socket object is
+    already closed (and the current connection is saved into the built-in
+    connection pool).
+
+    Socket objects that have not invoked this method (and associated
+    connections) will be closed when the socket object is released by the
+    Lua GC (Garbage Collector) or the current client HTTP request finishes
+    processing.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:settimeout
+    syntax: *tcpsock:settimeout(time)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Set the timeout value in milliseconds for subsequent socket operations
+    (connect, receive, and iterators returned from receiveuntil).
+
+    Settings done by this method takes priority over those config
+    directives, i.e., lua_socket_connect_timeout, lua_socket_send_timeout,
+    and lua_socket_read_timeout.
+
+    Note that this method does *not* affect the lua_socket_keepalive_timeout
+    setting; the "timeout" argument to the setkeepalive method should be
+    used for this purpose instead.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:setoption
+    syntax: *tcpsock:setoption(option, value?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    This function is added for LuaSocket
+    (<http://w3.impa.br/~diego/software/luasocket/tcp.html>) API
+    compatibility and does nothing for now. Its functionality will be
+    implemented in future.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:setkeepalive
+    syntax: *ok, err = tcpsock:setkeepalive(timeout?, size?)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Puts the current socket's connection immediately into the cosocket
+    built-in connection pool and keep it alive until other connect method
+    calls request it or the associated maximal idle timeout is expired.
+
+    The first optional argument, "timeout", can be used to specify the
+    maximal idle timeout (in milliseconds) for the current connection. If
+    omitted, the default setting in the lua_socket_keepalive_timeout config
+    directive will be used. If the 0 value is given, then the timeout
+    interval is unlimited.
+
+    The second optional argument, "size", can be used to specify the maximal
+    number of connections allowed in the connection pool for the current
+    server (i.e., the current host-port pair or the unix domain socket file
+    path). Note that the size of the connection pool cannot be changed once
+    the pool is created. When this argument is omitted, the default setting
+    in the lua_socket_pool_size config directive will be used.
+
+    When the connection pool exceeds the available size limit, the least
+    recently used (idle) connection already in the pool will be closed to
+    make room for the current connection.
+
+    Note that the cosocket connection pool is per Nginx worker process
+    rather than per Nginx server instance, so the size limit specified here
+    also applies to every single Nginx worker process.
+
+    Idle connections in the pool will be monitored for any exceptional
+    events like connection abortion or unexpected incoming data on the line,
+    in which cases the connection in question will be closed and removed
+    from the pool.
+
+    In case of success, this method returns 1; otherwise, it returns "nil"
+    and a string describing the error.
+
+    This method also makes the current cosocket object enter the "closed"
+    state, so there is no need to manually call the close method on it
+    afterwards.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  tcpsock:getreusedtimes
+    syntax: *count, err = tcpsock:getreusedtimes()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    This method returns the (successfully) reused times for the current
+    connection. In case of error, it returns "nil" and a string describing
+    the error.
+
+    If the current connection does not come from the built-in connection
+    pool, then this method always returns 0, that is, the connection has
+    never been reused (yet). If the connection comes from the connection
+    pool, then the return value is always non-zero. So this method can also
+    be used to determine if the current connection comes from the pool.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  ngx.socket.connect
+    syntax: *tcpsock, err = ngx.socket.connect(host, port)*
+
+    syntax: *tcpsock, err =
+    ngx.socket.connect("unix:/path/to/unix-domain.socket")*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    This function is a shortcut for combining ngx.socket.tcp() and the
+    connect() method call in a single operation. It is actually implemented
+    like this:
+
+        local sock = ngx.socket.tcp()
+        local ok, err = sock:connect(...)
+        if not ok then
+            return nil, err
+        end
+        return sock
+
+    There is no way to use the settimeout method to specify connecting
+    timeout for this method and the lua_socket_connect_timeout directive
+    must be set at configure time instead.
+
+    This feature was first introduced in the "v0.5.0rc1" release.
+
+  ngx.get_phase
+    syntax: *str = ngx.get_phase()*
+
+    context: *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*,
+    content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
+    log_by_lua*, ngx.timer.**
+
+    Retrieves the current running phase name. Possible return values are
+
+    *   "init" for the context of init_by_lua or init_by_lua_file.
+
+    *   "set" for the context of set_by_lua or set_by_lua_file.
+
+    *   "rewrite" for the context of rewrite_by_lua or rewrite_by_lua_file.
+
+    *   "access" for the context of access_by_lua or access_by_lua_file.
+
+    *   "content" for the context of content_by_lua or content_by_lua_file.
+
+    *   "header_filter" for the context of header_filter_by_lua or
+        header_filter_by_lua_file.
+
+    *   "body_filter" for the context of body_filter_by_lua or
+        body_filter_by_lua_file.
+
+    *   "log" for the context of log_by_lua or log_by_lua_file.
+
+    *   "timer" for the context of user callback functions for ngx.timer.*.
+
+    This API was first introduced in the "v0.5.10" release.
+
+  ngx.thread.spawn
+    syntax: *co = ngx.thread.spawn(func, arg1, arg2, ...)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Spawns a new user "light thread" with the Lua function "func" as well as
+    those optional arguments "arg1", "arg2", and etc. Returns a Lua thread
+    (or Lua coroutine) object represents this "light thread".
+
+    "Light threads" are just a special kind of Lua coroutines that are
+    scheduled by the ngx_lua module.
+
+    Before "ngx.thread.spawn" returns, the "func" will be called with those
+    optional arguments until it returns, aborts with an error, or gets
+    yielded due to I/O operations via the Nginx API for Lua (like
+    <tcpsock:receive|/"tcpsock:receive">).
+
+    After "ngx.thread.spawn" returns, the newly-created "light thread" will
+    keep running asynchronously usually at various I/O events.
+
+    All the Lua code chunks running by rewrite_by_lua, access_by_lua, and
+    content_by_lua are in a boilerplate "light thread" created automatically
+    by ngx_lua. Such boilerplate "light thread" are also called "entry
+    threads".
+
+    By default, the corresponding Nginx handler (e.g., rewrite_by_lua
+    handler) will not terminate until
+
+    1.  both the "entry thread" and all the user "light threads" terminates,
+
+    2.  a "light thread" (either the "entry thread" or a user "light thread"
+        aborts by calling ngx.exit, ngx.exec, ngx.redirect, or
+        ngx.req.set_uri(uri, true), or
+
+    3.  the "entry thread" terminates with a Lua error.
+
+    When the user "light thread" terminates with a Lua error, however, it
+    will not abort other running "light threads" like the "entry thread"
+    does.
+
+    Due to the limitation in the Nginx subrequest model, it is not allowed
+    to abort a running Nginx subrequest in general. So it is also prohibited
+    to abort a running "light thread" that is pending on one ore more Nginx
+    subrequests. You must call ngx.thread.wait to wait for those "light
+    thread" to terminate before quitting the "world". A notable exception
+    here is that you can abort pending subrequests by calling ngx.exit with
+    and only with the status code "ngx.ERROR" (-1), 408, 444, or 499.
+
+    The "light threads" are not scheduled in a pre-emptive way. In other
+    words, no time-slicing is performed automatically. A "light thread" will
+    keep running exclusively on the CPU until
+
+    1.  a (nonblocking) I/O operation cannot be completed in a single run,
+
+    2.  it calls coroutine.yield to actively give up execution, or
+
+    3.  it is aborted by a Lua error or an invocation of ngx.exit, ngx.exec,
+        ngx.redirect, or ngx.req.set_uri(uri, true).
+
+    For the first two cases, the "light thread" will usually be resumed
+    later by the ngx_lua scheduler unless a "stop-the-world" event happens.
+
+    User "light threads" can create "light threads" themselves and normal
+    user coroutiens created by coroutine.create can also create "light
+    threads". The coroutine (be it a normal Lua coroutine or a "light
+    thread") that directly spawns the "light thread" is called the "parent
+    coroutine" for the "light thread" newly spawned.
+
+    The "parent coroutine" can call ngx.thread.wait to wait on the
+    termination of its child "light thread".
+
+    You can call coroutine.status() and coroutine.yield() on the "light
+    thread" coroutines.
+
+    The status of the "light thread" coroutine can be "zombie" if
+
+    1.  the current "light thread" already terminates (either successfully
+        or with an error),
+
+    2.  its parent coroutine is still alive, and
+
+    3.  its parent coroutine is not waiting on it with ngx.thread.wait.
+
+    The following example demonstrates the use of coroutine.yield() in the
+    "light thread" coroutines to do manual time-slicing:
+
+        local yield = coroutine.yield
+
+        function f()
+            local self = coroutine.running()
+            ngx.say("f 1")
+            yield(self)
+            ngx.say("f 2")
+            yield(self)
+            ngx.say("f 3")
+        end
+
+        local self = coroutine.running()
+        ngx.say("0")
+        yield(self)
+
+        ngx.say("1")
+        ngx.thread.spawn(f)
+
+        ngx.say("2")
+        yield(self)
+
+        ngx.say("3")
+        yield(self)
+
+        ngx.say("4")
+
+    Then it will generate the output
+
+        0
+        1
+        f 1
+        2
+        f 2
+        3
+        f 3
+        4
+
+    "Light threads" are mostly useful for doing concurrent upstream requests
+    in a single Nginx request handler, kinda like a generalized version of
+    ngx.location.capture_multi that can work with all the Nginx API for Lua.
+    The following example demonstrates parallel requests to MySQL,
+    Memcached, and upstream HTTP services in a single Lua handler, and
+    outputting the results in the order that they actually return (very much
+    like the Facebook BigPipe model):
+
+        -- query mysql, memcached, and a remote http service at the same time,
+        -- output the results in the order that they
+        -- actually return the results.
+
+        local mysql = require "resty.mysql"
+        local memcached = require "resty.memcached"
+
+        local function query_mysql()
+            local db = mysql:new()
+            db:connect{
+                        host = "127.0.0.1",
+                        port = 3306,
+                        database = "test",
+                        user = "monty",
+                        password = "mypass"
+                      }
+            local res, err, errno, sqlstate =
+                    db:query("select * from cats order by id asc")
+            db:set_keepalive(0, 100)
+            ngx.say("mysql done: ", cjson.encode(res))
+        end
+
+        local function query_memcached()
+            local memc = memcached:new()
+            memc:connect("127.0.0.1", 11211)
+            local res, err = memc:get("some_key")
+            ngx.say("memcached done: ", res)
+        end
+
+        local function query_http()
+            local res = ngx.location.capture("/my-http-proxy")
+            ngx.say("http done: ", res.body)
+        end
+
+        ngx.thread.spawn(query_mysql)      -- create thread 1
+        ngx.thread.spawn(query_memcached)  -- create thread 2
+        ngx.thread.spawn(query_http)       -- create thread 3
+
+    This API was first enabled in the "v0.7.0" release.
+
+  ngx.thread.wait
+    syntax: *ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Waits on one or more child "light threads" and returns the results of
+    the first "light thread" that terminates (either successfully or with an
+    error).
+
+    The arguments "thread1", "thread2", and etc are the Lua thread objects
+    returned by earlier calls of ngx.thread.spawn.
+
+    The return values have exactly the same meaning as coroutine.resume,
+    that is, the first value returned is a boolean value indicating whether
+    the "light thread" terminates successfully or not, and subsequent values
+    returned are the return values of the user Lua function that was used to
+    spawn the "light thread" (in case of success) or the error object (in
+    case of failure).
+
+    Only the direct "parent coroutine" can wait on its child "light thread",
+    otherwise a Lua exception will be raised.
+
+    The following example demonstrates the use of "ngx.thread.wait" and
+    ngx.location.capture to emulate ngx.location.capture_multi:
+
+        local capture = ngx.location.capture
+        local spawn = ngx.thread.spawn
+        local wait = ngx.thread.wait
+        local say = ngx.say
+
+        local function fetch(uri)
+            return capture(uri)
+        end
+
+        local threads = {
+            spawn(fetch, "/foo"),
+            spawn(fetch, "/bar"),
+            spawn(fetch, "/baz")
+        }
+
+        for i = 1, #threads do
+            local ok, res = wait(threads[i])
+            if not ok then
+                say(i, ": failed to run: ", res)
+            else
+                say(i, ": status: ", res.status)
+                say(i, ": body: ", res.body)
+            end
+        end
+
+    Here it essentially implements the "wait all" model.
+
+    And below is an example demonstrating the "wait any" model:
+
+        function f()
+            ngx.sleep(0.2)
+            ngx.say("f: hello")
+            return "f done"
+        end
+
+        function g()
+            ngx.sleep(0.1)
+            ngx.say("g: hello")
+            return "g done"
+        end
+
+        local tf, err = ngx.thread.spawn(f)
+        if not tf then
+            ngx.say("failed to spawn thread f: ", err)
+            return
+        end
+
+        ngx.say("f thread created: ", coroutine.status(tf))
+
+        local tg, err = ngx.thread.spawn(g)
+        if not tg then
+            ngx.say("failed to spawn thread g: ", err)
+            return
+        end
+
+        ngx.say("g thread created: ", coroutine.status(tg))
+
+        ok, res = ngx.thread.wait(tf, tg)
+        if not ok then
+            ngx.say("failed to wait: ", res)
+            return
+        end
+
+        ngx.say("res: ", res)
+
+        -- stop the "world", aborting other running threads
+        ngx.exit(ngx.OK)
+
+    And it will generate the following output:
+
+        f thread created: running
+        g thread created: running
+        g: hello
+        res: g done
+
+    This API was first enabled in the "v0.7.0" release.
+
+  ngx.on_abort
+    syntax: *ok, err = ngx.on_abort(callback)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+    Registers a user Lua function as the callback which gets called
+    automatically when the client closes the (downstream) connection
+    prematurely.
+
+    Returns 1 if the callback is registered successfully or returns "nil"
+    and a string describing the error otherwise.
+
+    All the Nginx API for Lua can be used in the callback function because
+    the function is run in a special "light thread", just as those "light
+    threads" created by ngx.thread.spawn.
+
+    The callback function can decide what to do with the client abortion
+    event all by itself. For example, it can simply ignore the event by
+    doing nothing and the current Lua request handler will continue
+    executing without interruptions. And the callback function can also
+    decide to terminate everything by calling ngx.exit, for example,
+
+        local function my_cleanup()
+            -- custom cleanup work goes here, like cancelling a pending DB transaction
+
+            -- now abort all the "light threads" running in the current request handler
+            ngx.exit(499)
+        end
+
+        local ok, err = ngx.on_abort(my_cleanup)
+        if not ok then
+            ngx.log(ngx.ERR, "failed to register the on_abort callback: ", err)
+            ngx.exit(500)
+        end
+
+    When lua_check_client_abort is set to "off" (which is the default), then
+    this function call will always return the error message
+    "lua_check_client_abort is off".
+
+    According to the current implementation, this function can only be
+    called once in a single request handler; subsequent calls will return
+    the error message "duplicate call".
+
+    This API was first introduced in the "v0.7.4" release.
+
+    See also lua_check_client_abort.
+
+  ngx.timer.at
+    syntax: *ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2,
+    ...)*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    Creates an Nginx timer with a user callback function as well as optional
+    user arguments.
+
+    The first argument, "delay", specifies the delay for the timer, in
+    seconds. One can specify fractional seconds like 0.001 to mean 1
+    millisecond here. 0 delay can also be specified, in which case the timer
+    will immediately expire when the current handler yields execution.
+
+    The second argument, "callback", can be any Lua function, which will be
+    invoked later in a background "light thread" after the delay specified.
+    The user callback will be called automatically by the Nginx core with
+    the arguments "premature", "user_arg1", "user_arg2", and etc, where the
+    "premature" argument takes a boolean value indicating whether it is a
+    premature timer expiration or not, and "user_arg1", "user_arg2", and
+    etc, are those (extra) user arguments specified when calling
+    "ngx.timer.at" as the remaining arguments.
+
+    Premature timer expiration happens when the Nginx worker process is
+    trying to shut down, as in an Nginx configuration reload triggered by
+    the "HUP" signal or in an Nginx server shutdown. When the Nginx worker
+    is trying to shut down, one can no longer call "ngx.timer.at" to create
+    new timers and in that case "ngx.timer.at" will return "nil" and a
+    string describing the error, that is, "process exiting".
+
+    When a timer expires, the user Lua code in the timer callback is running
+    in a "light thread" detached completely from the original request
+    creating the timer. So objects with the same lifetime as the request
+    creating them, like cosockets, cannot be shared between the original
+    request and the timer user callback function.
+
+    Here is a simple example:
+
+        location / {
+            ...
+            log_by_lua '
+                local function push_data(premature, uri, args, status)
+                    -- push the data uri, args, and status to the remote
+                    -- via ngx.socket.tcp or ngx.socket.udp
+                    -- (one may want to buffer the data in Lua a bit to
+                    -- save I/O operations)
+                end
+                local ok, err = ngx.timer.at(0, push_data,
+                                             ngx.var.uri, ngx.var.args, ngx.header.status)
+                if not ok then
+                    ngx.log(ngx.ERR, "failed to create timer: ", err)
+                    return
+                end
+            ';
+        }
+
+    One can also create infinite re-occuring timers, for instance, a timer
+    getting triggered every 5 seconds, by calling "ngx.timer.at" recursively
+    in the timer callback function. Here is such an example,
+
+        local delay = 5
+        local handler
+        handler = function (premature)
+            -- do some routine job in Lua just like a cron job
+            if premature then
+                return
+            end
+            local ok, err = ngx.timer.at(delay, handler)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to create the timer: ", err)
+                return
+            end
+        end
+
+        local ok, err = ngx.timer.at(delay, handler)
+        if not ok then
+            ngx.log(ngx.ERR, "failed to create the timer: ", err)
+            return
+        end
+
+    Because timer callbacks run in the background and their running time
+    will not add to any client request's response time, they can easily
+    accumulate in the server and exhaust system resources due to either Lua
+    programming mistakes or just too much client traffic. To prevent extreme
+    consequences like crashing the Nginx server, there are built-in
+    limitations on both the number of "pending timers" and the number of
+    "running timers" in an Nginx worker process. The "pending timers" here
+    mean timers that have not yet been expired and "running timers" are
+    those whose user callbacks are currently running.
+
+    The maximal number of pending timers allowed in an Nginx worker is
+    constrolled by the lua_max_pending_timers directive. The maximal number
+    of running timers is controlled by the lua_max_running_timers directive.
+
+    According to the current implementation, each "running timer" will take
+    one (fake) connection record from the global connection record list
+    configured by the standard worker_connections directive in "nginx.conf".
+    So ensure that the worker_connections directive is set to a large enough
+    value that takes into account both the real connections and fake
+    connections required by timer callbacks (as limited by the
+    lua_max_running_timers directive).
+
+    A lot of the Lua APIs for Nginx are enabled in the context of the timer
+    callbacks, like stream/datagram cosockets (ngx.socket.tcp and
+    ngx.socket.udp), shared memory dictionaries (ngx.shared.DICT), user
+    coroutines (coroutine.*), user "light threads" (ngx.thread.*), ngx.exit,
+    ngx.now/ngx.time, ngx.md5/ngx.sha1_bin, are all allowed. But the
+    subrequest API (like ngx.location.capture), the ngx.req.* API, the
+    downstream output API (like ngx.say, ngx.print, and ngx.flush) are
+    explicitly disabled in this context.
+
+    This API was first introduced in the "v0.8.0" release.
+
+  ngx.config.debug
+    syntax: *debug = ngx.config.debug*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
+    init_by_lua**
+
+    This boolean field indicates whether the current Nginx is a debug build,
+    i.e., being built by the "./configure" option "--with-debug".
+
+    This field was first introduced in the 0.8.7.
+
+  ndk.set_var.DIRECTIVE
+    syntax: *res = ndk.set_var.DIRECTIVE_NAME*
+
+    context: *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
+    header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+    This mechanism allows calling other nginx C modules' directives that are
+    implemented by Nginx Devel Kit
+    (<https://github.com/simpl/ngx_devel_kit>) (NDK)'s set_var submodule's
+    "ndk_set_var_value".
+
+    For example, the following [[HttpSetMiscModule]] directives can be
+    invoked this way:
+
+    *   set_quote_sql_str
+
+    *   set_quote_pgsql_str
+
+    *   set_quote_json_str
+
+    *   set_unescape_uri
+
+    *   set_escape_uri
+
+    *   set_encode_base32
+
+    *   set_decode_base32
+
+    *   set_encode_base64
+
+    *   set_decode_base64
+
+    *   set_encode_hex
+
+    *   set_decode_hex
+
+    *   set_sha1
+
+    *   set_md5
+
+    For instance,
+
+        local res = ndk.set_var.set_escape_uri('a/b');
+        -- now res == 'a%2fb'
+
+    Similarly, the following directives provided by
+    [[HttpEncryptedSessionModule]] can be invoked from within Lua too:
+
+    *   set_encrypt_session
+
+    *   set_decrypt_session
+
+    This feature requires the ngx_devel_kit
+    (<https://github.com/simpl/ngx_devel_kit>) module.
+
+  coroutine.create
+    syntax: *co = coroutine.create(f)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Creates a user Lua coroutines with a Lua function, and returns a
+    coroutine object.
+
+    Similar to the standard Lua coroutine.create
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create>) API,
+    but works in the context of the Lua coroutines created by ngx_lua.
+
+    This API was first introduced in the "v0.6.0" release.
+
+  coroutine.resume
+    syntax: *ok, ... = coroutine.resume(co, ...)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Resumes the executation of a user Lua coroutine object previously
+    yielded or just created.
+
+    Similar to the standard Lua coroutine.resume
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume>) API,
+    but works in the context of the Lua coroutines created by ngx_lua.
+
+    This API was first introduced in the "v0.6.0" release.
+
+  coroutine.yield
+    syntax: *... = coroutine.yield(co, ...)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Yields the executation of the current user Lua coroutine.
+
+    Similar to the standard Lua coroutine.yield
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield>) API,
+    but works in the context of the Lua coroutines created by ngx_lua.
+
+    This API was first introduced in the "v0.6.0" release.
+
+  coroutine.wrap
+    syntax: *co = coroutine.wrap(f)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Similar to the standard Lua coroutine.wrap
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap>) API,
+    but works in the context of the Lua coroutines created by ngx_lua.
+
+    This API was first introduced in the "v0.6.0" release.
+
+  coroutine.running
+    syntax: *co = coroutine.running()*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Identical to the standard Lua coroutine.running
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running>) API.
+
+    This API was first enabled in the "v0.6.0" release.
+
+  coroutine.status
+    syntax: *status = coroutine.status(co)*
+
+    context: *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+    Identical to the standard Lua coroutine.status
+    (<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status>) API.
+
+    This API was first enabled in the "v0.6.0" release.
+
+Lua/LuaJIT bytecode support
+    As from the "v0.5.0rc32" release, all *_by_lua_file configure directives
+    (such as content_by_lua_file) support loading Lua 5.1 and LuaJIT 2.0 raw
+    bytecode files directly.
+
+    Please note that the bytecode format used by LuaJIT 2.0 is not
+    compatible with that used by the standard Lua 5.1 interpreter. So if
+    using LuaJIT 2.0 with ngx_lua, LuaJIT compatible bytecode files must be
+    generated as shown:
+
+        /path/to/luajit/bin/luajit -b /path/to/input_file.lua /path/to/output_file.luac
+
+    The "-bg" option can be used to include debug information in the LuaJIT
+    bytecode file:
+
+        /path/to/luajit/bin/luajit -bg /path/to/input_file.lua /path/to/output_file.luac
+
+    Please refer to the official LuaJIT documentation on the "-b" option for
+    more details:
+
+    http://luajit.org/running.html#opt_b
+
+    Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua
+    compatible bytecode files must be generated using the "luac" commandline
+    utility as shown:
+
+        luac -o /path/to/output_file.luac /path/to/input_file.lua
+
+    Unlike as with LuaJIT, debug information is included in standard Lua 5.1
+    bytecode files by default. This can be striped out by specifying the
+    "-s" option as shown:
+
+        luac -s -o /path/to/output_file.luac /path/to/input_file.lua
+
+    Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances
+    linked to LuaJIT 2.0 or vice versa, will result in an error message,
+    such as that below, being logged into the Nginx "error.log" file:
+
+        [error] 13909#0: *1 failed to load Lua inlined code: bad byte-code header in /path/to/test_file.luac
+
+    Loading bytecode files via the Lua primitives like "require" and
+    "dofile" should always work as expected.
+
+HTTP 1.0 support
+    The HTTP 1.0 protocol does not support chunked output and requires an
+    explicit "Content-Length" header when the response body is not empty in
+    order to support the HTTP 1.0 keep-alive. So when a HTTP 1.0 request is
+    made and the lua_http10_buffering directive is turned "on", ngx_lua will
+    buffer the output of ngx.say and ngx.print calls and also postpone
+    sending response headers until all the response body output is received.
+    At that time ngx_lua can calculate the total length of the body and
+    construct a proper "Content-Length" header to return to the HTTP 1.0
+    client. If the "Content-Length" response header is set in the running
+    Lua code, however, this buffering will be disabled even if the
+    lua_http10_buffering directive is turned "on".
+
+    For large streaming output responses, it is important to disable the
+    lua_http10_buffering directive to minimise memory usage.
+
+    Note that common HTTP benchmark tools such as "ab" and "http_load" issue
+    HTTP 1.0 requests by default. To force "curl" to send HTTP 1.0 requests,
+    use the -0 option.
+
+Data Sharing within an Nginx Worker
+    To globally share data among all the requests handled by the same nginx
+    worker process, encapsulate the shared data into a Lua module, use the
+    Lua "require" builtin to import the module, and then manipulate the
+    shared data in Lua. This works because required Lua modules are loaded
+    only once and all coroutines will share the same copy of the module
+    (both its code and data). Note however that Lua global variables (note,
+    not module-level variables) WILL NOT persist between requests because of
+    the one-coroutine-per-request isolation design.
+
+    Here is a complete small example:
+
+        -- mydata.lua
+        local _M = {}
+
+        local data = {
+            dog = 3,
+            cat = 4,
+            pig = 5,
+        }
+
+        function _M.get_age(name)
+            return data[name]
+        end
+
+        return _M
+
+    and then accessing it from "nginx.conf":
+
+        location /lua {
+            content_by_lua '
+                local mydata = require "mydata"
+                ngx.say(mydata.get_age("dog"))
+            ';
+        }
+
+    The "mydata" module in this example will only be loaded and run on the
+    first request to the location "/lua", and all subsequent requests to the
+    same nginx worker process will use the reloaded instance of the module
+    as well as the same copy of the data in it, until a "HUP" signal is sent
+    to the Nginx master process to force a reload. This data sharing
+    technique is essential for high performance Lua applications based on
+    this module.
+
+    Note that this data sharing is on a *per-worker* basis and not on a
+    *per-server* basis. That is, when there are multiple nginx worker
+    processes under an Nginx master, data sharing cannot cross the process
+    boundary between these workers.
+
+    If server-wide data sharing is required, then use one or more of the
+    following approaches:
+
+    1.  Use the ngx.shared.DICT API provided by this module.
+
+    2.  Use only a single nginx worker and a single server (this is however
+        not recommended when there is a multi core CPU or multiple CPUs in a
+        single machine).
+
+    3.  Use data storage mechanisms such as "memcached", "redis", "MySQL" or
+        "PostgreSQL". The ngx_openresty bundle (<http://openresty.org>)
+        associated with this module comes with a set of companion Nginx
+        modules and Lua libraries that provide interfaces with these data
+        storage mechanisms.
+
+Known Issues
+  TCP socket connect operation issues
+    The <tcpsock:connect|/"tcpsock:connect"> method may indicate "success"
+    despite connection failures such as with "Connection Refused" errors.
+
+    However, later attempts to manipulate the cosocket object will fail and
+    return the actual error status message generated by the failed connect
+    operation.
+
+    This issue is due to limitations in the Nginx event model and only
+    appears to affect Mac OS X.
+
+  Lua Coroutine Yielding/Resuming
+    *   Lua's "dofile" builtin is implemented as a C function in both Lua
+        5.1 and LuaJIT 2.0 and when ngx.location.capture is called,
+        ngx.exec, ngx.exit or ngx.req.read_body or similar in the file to be
+        loaded by "dofile", a coroutine yield across the C function boundary
+        will be initiated. This however is not normally allowed within
+        ngx_lua and will usually result in error messages like "lua handler
+        aborted: runtime error: attempt to yield across C-call boundary". To
+        avoid this, define a real Lua module and use the Lua "require"
+        builtin instead.
+
+    *   As the standard Lua 5.1 interpreter's VM is not fully resumable, the
+        methods ngx.location.capture, ngx.location.capture_multi,
+        ngx.redirect, ngx.exec, and ngx.exit cannot be used within the
+        context of a Lua pcall()
+        (<http://www.lua.org/manual/5.1/manual.html#pdf-pcall>) or xpcall()
+        (<http://www.lua.org/manual/5.1/manual.html#pdf-xpcall>) or even the
+        first line of the "for ... in ..." statement when the standard Lua
+        5.1 interpreter is used and the "attempt to yield across
+        metamethod/C-call boundary" error will be produced. Please use
+        LuaJIT 2.0, which supports a fully resumable VM, to avoid this.
+
+  Lua Variable Scope
+    Care must be taken when importing modules and this form should be used:
+
+        local xxx = require('xxx')
+
+    instead of the old deprecated form: require('xxx')
+
+    Here is the reason: by design, the global environment has exactly the
+    same lifetime as the Nginx request handler associated with it. Each
+    request handler has its own set of Lua global variables and that is the
+    idea of request isolation. The Lua module is actually loaded by the
+    first Nginx request handler and is cached by the "require()" built-in in
+    the package.loaded table for later reference, and "require()" has the
+    side effect of setting a global variable to the loaded module table. But
+    this global variable will be cleared at the end of the request handler,
+    and every subsequent request handler all has its own (clean) global
+    environment. So one will get Lua exception for accessing the "nil"
+    value.
+
+    Generally, use of Lua global variables is a really really bad idea in
+    the context of ngx_lua because
+
+    1.  misuse of Lua globals has very bad side effects for concurrent
+        requests when these variables are actually supposed to be local
+        only,
+
+    2.  Lua global variables require Lua table look-up in the global
+        environment (which is just a Lua table), which is kinda expensive,
+        and
+
+    3.  some Lua global variable references are just typos, which are hard
+        to debug.
+
+    It's *highly* recommended to always declare them via "local" in the
+    scope that is reasonable.
+
+    To find out all the uses of Lua global variables in your Lua code, you
+    can run the lua-releng tool
+    (<https://github.com/agentzh/nginx-devel-utils/blob/master/lua-releng>)
+    across all your .lua source files: $ lua-releng Checking use of Lua
+    global variables in file lib/foo/bar.lua ... 1 [1489] SETGLOBAL 7 -1 ;
+    contains 55 [1506] GETGLOBAL 7 -3 ; setvar 3 [1545] GETGLOBAL 3 -4 ;
+    varexpand The output says that the line 1489 of file "lib/foo/bar.lua"
+    writes to a global variable named "contains", the line 1506 reads from
+    the global variable "setvar", and line 1545 reads the global
+    "varexpand".
+
+    This tool will guarantee that local variables in the Lua module
+    functions are all declared with the "local" keyword, otherwise a runtime
+    exception will be thrown. It prevents undesirable race conditions while
+    accessing such variables. See Data Sharing within an Nginx Worker for
+    the reasons behind this.
+
+  Locations Configured by Subrequest Directives of Other Modules
+    The ngx.location.capture and ngx.location.capture_multi directives
+    cannot capture locations that include the echo_location,
+    echo_location_async, echo_subrequest, or echo_subrequest_async
+    directives.
+
+        location /foo {
+            content_by_lua '
+                res = ngx.location.capture("/bar")
+            ';
+        }
+        location /bar {
+            echo_location /blah;
+        }
+        location /blah {
+            echo "Success!";
+        }
+
+        $ curl -i http://example.com/foo
+
+    will not work as expected.
+
+  Special PCRE Sequences
+    PCRE sequences such as "\d", "\s", or "\w", require special attention
+    because in string literals, the backslash character, "\", is stripped
+    out by both the Lua language parser and by the Nginx config file parser
+    before processing. So the following snippet will not work as expected:
+
+        # nginx.conf
+        ? location /test {
+        ?     content_by_lua '
+        ?         local regex = "\d+"  -- THIS IS WRONG!!
+        ?         local m = ngx.re.match("hello, 1234", regex)
+        ?         if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ?     ';
+        ? }
+        # evaluates to "not matched!"
+
+    To avoid this, *double* escape the backslash:
+
+        # nginx.conf
+        location /test {
+            content_by_lua '
+                local regex = "\\\\d+"
+                local m = ngx.re.match("hello, 1234", regex)
+                if m then ngx.say(m[0]) else ngx.say("not matched!") end
+            ';
+        }
+        # evaluates to "1234"
+
+    Here, "\\\\d+" is stripped down to "\\d+" by the Nginx config file
+    parser and this is further stripped down to "\d+" by the Lua language
+    parser before running.
+
+    Alternatively, the regex pattern can be presented as a long-bracketed
+    Lua string literal by encasing it in "long brackets", "[[...]]", in
+    which case backslashes have to only be escaped once for the Nginx config
+    file parser.
+
+        # nginx.conf
+        location /test {
+            content_by_lua '
+                local regex = [[\\d+]]
+                local m = ngx.re.match("hello, 1234", regex)
+                if m then ngx.say(m[0]) else ngx.say("not matched!") end
+            ';
+        }
+        # evaluates to "1234"
+
+    Here, "[[\\d+]]" is stripped down to "[[\d+]]" by the Nginx config file
+    parser and this is processed correctly.
+
+    Note that a longer from of the long bracket, "[=[...]=]", may be
+    required if the regex pattern contains "[...]" sequences. The
+    "[=[...]=]" form may be used as the default form if desired.
+
+        # nginx.conf
+        location /test {
+            content_by_lua '
+                local regex = [=[[0-9]+]=]
+                local m = ngx.re.match("hello, 1234", regex)
+                if m then ngx.say(m[0]) else ngx.say("not matched!") end
+            ';
+        }
+        # evaluates to "1234"
+
+    An alternative approach to escaping PCRE sequences is to ensure that Lua
+    code is placed in external script files and executed using the various
+    *_by_lua_file directives. With this approach, the backslashes are only
+    stripped by the Lua language parser and therefore only need to be
+    escaped once each.
+
+        -- test.lua
+        local regex = "\\d+"
+        local m = ngx.re.match("hello, 1234", regex)
+        if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        -- evaluates to "1234"
+
+    Within external script files, PCRE sequences presented as long-bracketed
+    Lua string literals do not require modification.
+
+        -- test.lua
+        local regex = [[\d+]]
+        local m = ngx.re.match("hello, 1234", regex)
+        if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        -- evaluates to "1234"
+
+  Mixing with SSI Not Supported
+    Mixing SSI with ngx_lua in the same Nginx request is not supported at
+    all. Just use ngx_lua exclusively. Everything you can do with SSI can be
+    done atop ngx_lua anyway and it can be more efficient when using
+    ngx_lua.
+
+  SPDY Mode Not Fully Supported
+    Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode
+    yet: ngx.location.capture, ngx.location.capture_multi, and
+    ngx.req.socket.
+
+Typical Uses
+    Just to name a few:
+
+    *   Mashup'ing and processing outputs of various nginx upstream outputs
+        (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,
+
+    *   doing arbitrarily complex access control and security checks in Lua
+        before requests actually reach the upstream backends,
+
+    *   manipulating response headers in an arbitrary way (by Lua)
+
+    *   fetching backend information from external storage backends (like
+        redis, memcached, mysql, postgresql) and use that information to
+        choose which upstream backend to access on-the-fly,
+
+    *   coding up arbitrarily complex web applications in a content handler
+        using synchronous but still non-blocking access to the database
+        backends and other storage,
+
+    *   doing very complex URL dispatch in Lua at rewrite phase,
+
+    *   using Lua to implement advanced caching mechanism for Nginx's
+        subrequests and arbitrary locations.
+
+    The possibilities are unlimited as the module allows bringing together
+    various elements within Nginx as well as exposing the power of the Lua
+    language to the user. The module provides the full flexibility of
+    scripting while offering performance levels comparable with native C
+    language programs both in terms of CPU time as well as memory footprint.
+    This is particularly the case when LuaJIT 2.0 is enabled.
+
+    Other scripting language implementations typically struggle to match
+    this performance level.
+
+    The Lua state (Lua VM instance) is shared across all the requests
+    handled by a single nginx worker process to minimize memory use.
+
+    On a ThinkPad T400 2.80 GHz laptop, the Hello World example readily
+    achieves 28k req/sec using "http_load -p 10". By contrast, Nginx +
+    php-fpm 5.2.8 + Unix Domain Socket yields 6k req/sec and Node.js
+    (<http://nodejs.org/>) v0.6.1 yields 10.2k req/sec for their Hello World
+    equivalents.
+
+Nginx Compatibility
+    The latest module is compatible with the following versions of Nginx:
+
+    *   1.5.x (last tested: 1.5.4)
+
+    *   1.4.x (last tested: 1.4.2)
+
+    *   1.3.x (last tested: 1.3.11)
+
+    *   1.2.x (last tested: 1.2.9)
+
+    *   1.1.x (last tested: 1.1.5)
+
+    *   1.0.x (last tested: 1.0.15)
+
+    *   0.9.x (last tested: 0.9.4)
+
+    *   0.8.x >= 0.8.54 (last tested: 0.8.54)
+
+Code Repository
+    The code repository of this project is hosted on github at
+    chaoslawful/lua-nginx-module
+    (<http://github.com/chaoslawful/lua-nginx-module>).
+
+Installation
+    The ngx_openresty bundle (<http://openresty.org>) can be used to install
+    Nginx, ngx_lua, either one of the standard Lua 5.1 interpreter or LuaJIT
+    2.0, as well as a package of powerful companion Nginx modules. The basic
+    installation step is a simple "./configure --with-luajit && make && make
+    install".
+
+    Alternatively, ngx_lua can be manually compiled into Nginx:
+
+    1.  Install LuaJIT 2.0 (recommended) or Lua 5.1 (Lua 5.2 is *not*
+        supported yet). LuajIT can be downloaded from the the LuaJIT project
+        website (<http://luajit.org/download.html>) and Lua 5.1, from the
+        Lua project website (<http://www.lua.org/>). Some distribution
+        package managers also distribute LuajIT and/or Lua.
+
+    2.  Download the latest version of the ngx_devel_kit (NDK) module HERE
+        (<http://github.com/simpl/ngx_devel_kit/tags>).
+
+    3.  Download the latest version of ngx_lua HERE
+        (<http://github.com/chaoslawful/lua-nginx-module/tags>).
+
+    4.  Download the latest version of Nginx HERE (<http://nginx.org/>) (See
+        Nginx Compatibility)
+
+    Build the source with this module:
+
+        wget 'http://nginx.org/download/nginx-1.4.2.tar.gz'
+        tar -xzvf nginx-1.4.2.tar.gz
+        cd nginx-1.4.2/
+
+        # tell nginx's build system where to find LuaJIT:
+        export LUAJIT_LIB=/path/to/luajit/lib
+        export LUAJIT_INC=/path/to/luajit/include/luajit-2.0
+
+        # or tell where to find Lua if using Lua instead:
+        #export LUA_LIB=/path/to/lua/lib
+        #export LUA_INC=/path/to/lua/include
+
+        # Here we assume Nginx is to be installed under /opt/nginx/.
+        ./configure --prefix=/opt/nginx \
+                --add-module=/path/to/ngx_devel_kit \
+                --add-module=/path/to/lua-nginx-module
+
+        make -j2
+        make install
+
+  Installation on Ubuntu 11.10
+    Note that it is recommended to use LuaJIT 2.0 instead of the standard
+    Lua 5.1 interpreter where possible.
+
+    If the standard Lua 5.1 interpreter is required however, run the
+    following command to install it from the Ubuntu repository:
+
+    apt-get install -y lua5.1 liblua5.1-0 liblua5.1-0-dev
+
+    Everything should be installed correctly, except for one small tweak.
+
+    Library name "liblua.so" has been changed in liblua5.1 package, it only
+    comes with "liblua5.1.so", which needs to be symlinked to "/usr/lib" so
+    it could be found during the configuration process.
+
+    ln -s /usr/lib/x86_64-linux-gnu/liblua5.1.so /usr/lib/liblua.so
+
+Community
+  English Mailing List
+    The openresty-en (<https://groups.google.com/group/openresty-en>)
+    mailing list is for English speakers.
+
+  Chinese Mailing List
+    The openresty (<https://groups.google.com/group/openresty>) mailing list
+    is for Chinese speakers.
+
+Bugs and Patches
+    Please submit bug reports, wishlists, or patches by
+
+    1.  creating a ticket on the GitHub Issue Tracker
+        (<http://github.com/chaoslawful/lua-nginx-module/issues>),
+
+    2.  or posting to the OpenResty community.
+
+TODO
+  Short Term
+    *   review and apply Brian Akin's patch for the new directive
+        "lua_socket_log_errors".
+
+    *   review and apply Brian Akin's patch for the new
+        "shdict:flush_expired()" API.
+
+    *   implement the SSL cosocket API.
+
+    *   review and apply Jader H. Silva's patch for "ngx.re.split()".
+
+    *   review and apply vadim-pavlov's patch for ngx.location.capture's
+        "extra_headers" option
+
+    *   use "ngx_hash_t" to optimize the built-in header look-up process for
+        ngx.req.set_header, ngx.header.HEADER, and etc.
+
+    *   add configure options for different strategies of handling the
+        cosocket connection exceeding in the pools.
+
+    *   add directives to run Lua codes when nginx stops.
+
+    *   add APIs to access cookies as key/value pairs.
+
+    *   add "ignore_resp_headers", "ignore_resp_body", and "ignore_resp"
+        options to ngx.location.capture and ngx.location.capture_multi
+        methods, to allow micro performance tuning on the user side.
+
+    *   implement new directive "lua_ignore_client_abort".
+
+  Longer Term
+    *   add lightweight thread API (i.e., the "ngx.thread" API) as
+        demonstrated in this sample code
+        (<http://agentzh.org/misc/nginx/lua-thread2.lua>).
+
+    *   add automatic Lua code time slicing support by yielding and resuming
+        the Lua VM actively via Lua's debug hooks.
+
+    *   add "stat" mode similar to mod_lua
+        (<http://httpd.apache.org/docs/2.3/mod/mod_lua.html>).
+
+Changes
+    The changes of every release of this module can be obtained from the
+    ngx_openresty bundle's change logs:
+
+    http://openresty.org/#Changes
+
+Test Suite
+    The following dependencies are required to run the test suite:
+
+    *   Nginx version >= 1.4.2
+
+    *   Perl modules:
+
+        *   Test::Nginx: http://github.com/agentzh/test-nginx
+
+    *   Nginx modules:
+
+        *   ngx_devel_kit (<https://github.com/simpl/ngx_devel_kit>)
+
+        *   ngx_set_misc (<http://github.com/agentzh/set-misc-nginx-module>)
+
+        *   ngx_auth_request
+            (<http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.g
+            z>) (this is not needed if you're using Nginx 1.5.4+.
+
+        *   ngx_echo (<http://github.com/agentzh/echo-nginx-module>)
+
+        *   ngx_memc (<http://github.com/agentzh/memc-nginx-module>)
+
+        *   ngx_srcache (<http://github.com/agentzh/srcache-nginx-module>)
+
+        *   ngx_lua (i.e., this module)
+
+        *   ngx_headers_more
+            (<http://github.com/agentzh/headers-more-nginx-module>)
+
+        *   ngx_drizzle
+            (<http://github.com/chaoslawful/drizzle-nginx-module>)
+
+        *   ngx_rds_json (<http://github.com/agentzh/rds-json-nginx-module>)
+
+        *   ngx_coolkit (<https://github.com/FRiCKLE/ngx_coolkit>)
+
+        *   ngx_redis2 (<http://github.com/agentzh/redis2-nginx-module>)
+
+    The order in which these modules are added during configuration is
+    important because the position of any filter module in the filtering
+    chain determines the final output, for example. The correct adding order
+    is shown above.
+
+    *   3rd-party Lua libraries:
+
+        *   lua-cjson
+            (<http://www.kyne.com.au/~mark/software/lua-cjson.php>)
+
+    *   Applications:
+
+        *   mysql: create database 'ngx_test', grant all privileges to user
+            'ngx_test', password is 'ngx_test'
+
+        *   memcached: listening on the default port, 11211.
+
+        *   redis: listening on the default port, 6379.
+
+    See also the developer build script
+    (<https://github.com/chaoslawful/lua-nginx-module/blob/master/util/build
+    2.sh>) for more details on setting up the testing environment.
+
+    To run the whole test suite in the default testing mode: cd
+    /path/to/lua-nginx-module export PATH=/path/to/your/nginx/sbin:$PATH
+    prove -I/path/to/test-nginx/lib -r t
+
+    To run specific test files: cd /path/to/lua-nginx-module export
+    PATH=/path/to/your/nginx/sbin:$PATH prove -I/path/to/test-nginx/lib
+    t/002-content.t t/003-errors.t
+
+    To run a specific test block in a particular test file, add the line
+    "--- ONLY" to the test block you want to run, and then use the `prove`
+    utility to run that ".t" file.
+
+    There are also various testing modes based on mockeagain, valgrind, and
+    etc. Refer to the Test::Nginx documentation
+    (<http://search.cpan.org/perldoc?Test::Nginx>) for more details for
+    various advanced testing modes. See also the test reports for the Nginx
+    test cluster running on Amazon EC2: http://qa.openresty.org.
+
+Copyright and License
+    This module is licensed under the BSD license.
+
+    Copyright (C) 2009-2013, by Xiaozhe Wang (chaoslawful)
+    <chaoslawful@gmail.com>.
+
+    Copyright (C) 2009-2013, by Yichun "agentzh" Zhang (章亦春)
+    <agentzh@gmail.com>, CloudFlare Inc.
+
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+    *   Redistributions of source code must retain the above copyright
+        notice, this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+See Also
+    *   lua-resty-memcached
+        (<http://github.com/agentzh/lua-resty-memcached>) library based on
+        ngx_lua cosocket.
+
+    *   lua-resty-redis (<http://github.com/agentzh/lua-resty-redis>)
+        library based on ngx_lua cosocket.
+
+    *   lua-resty-mysql (<http://github.com/agentzh/lua-resty-mysql>)
+        library based on ngx_lua cosocket.
+
+    *   lua-resty-upload (<http://github.com/agentzh/lua-resty-upload>)
+        library based on ngx_lua cosocket.
+
+    *   lua-resty-dns (<http://github.com/agentzh/lua-resty-dns>) library
+        based on ngx_lua cosocket.
+
+    *   lua-resty-websocket
+        (<http://github.com/agentzh/lua-resty-websocket>) library for both
+        WebSocket server and client, based on ngx_lua cosocket.
+
+    *   lua-resty-string (<http://github.com/agentzh/lua-resty-string>)
+        library based on LuaJIT FFI (<http://luajit.org/ext_ffi.html>).
+
+    *   lua-resty-lock (<http://github.com/agentzh/lua-resty-lock>) library
+        for a nonblocking simple lock API.
+
+    *   Routing requests to different MySQL queries based on URI arguments
+        (<http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs>)
+
+    *   Dynamic Routing Based on Redis and Lua
+        (<http://openresty.org/#DynamicRoutingBasedOnRedis>)
+
+    *   Using LuaRocks with ngx_lua (<http://openresty.org/#UsingLuaRocks>)
+
+    *   Introduction to ngx_lua
+        (<https://github.com/chaoslawful/lua-nginx-module/wiki/Introduction>
+        )
+
+    *   ngx_devel_kit (<http://github.com/simpl/ngx_devel_kit>)
+
+    *   [[HttpEchoModule]]
+
+    *   [[HttpDrizzleModule]]
+
+    *   postgres-nginx-module (<http://github.com/FRiCKLE/ngx_postgres>)
+
+    *   [[HttpMemcModule]]
+
+    *   The ngx_openresty bundle (<http://openresty.org>)
+
+    *   Nginx Systemtap Toolkit
+        (<https://github.com/agentzh/nginx-systemtap-toolkit>)
+
diff -rNu a/src/lua/lua-nginx-module/README.markdown b/src/lua/lua-nginx-module/README.markdown
--- a/src/lua/lua-nginx-module/README.markdown	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/README.markdown	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,5526 @@
+<!---
+Don't edit this file manually! Instead you should generate it by using:
+    wiki2markdown.pl doc/HttpLuaModule.wiki
+-->
+
+Name
+====
+
+ngx_lua - Embed the power of Lua into Nginx
+
+*This module is not distributed with the Nginx source.* See [the installation instructions](http://wiki.nginx.org/HttpLuaModule#Installation).
+
+Status
+======
+
+This module is under active development and is production ready.
+
+Version
+=======
+
+This document describes ngx_lua [v0.9.0](https://github.com/chaoslawful/lua-nginx-module/tags) released on 29 September 2013.
+
+Synopsis
+========
+
+    # set search paths for pure Lua external libraries (';;' is the default path):
+    lua_package_path '/foo/bar/?.lua;/blah/?.lua;;';
+ 
+    # set search paths for Lua external libraries written in C (can also use ';;'):
+    lua_package_cpath '/bar/baz/?.so;/blah/blah/?.so;;';
+ 
+    server {
+        location /inline_concat {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            set $a "hello";
+            set $b "world";
+            # inline Lua script
+            set_by_lua $res "return ngx.arg[1]..ngx.arg[2]" $a $b;
+            echo $res;
+        }
+ 
+        location /rel_file_concat {
+            set $a "foo";
+            set $b "bar";
+            # script path relative to nginx prefix
+            # $ngx_prefix/conf/concat.lua contents:
+            #
+            #    return ngx.arg[1]..ngx.arg[2]
+            #
+            set_by_lua_file $res conf/concat.lua $a $b;
+            echo $res;
+        }
+ 
+        location /abs_file_concat {
+            set $a "fee";
+            set $b "baz";
+            # absolute script path not modified
+            set_by_lua_file $res /usr/nginx/conf/concat.lua $a $b;
+            echo $res;
+        }
+ 
+        location /lua_content {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            content_by_lua "ngx.say('Hello,world!')";
+        }
+ 
+         location /nginx_var {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            # try access /nginx_var?a=hello,world
+            content_by_lua "ngx.print(ngx.var['arg_a'], '\\n')";
+        }
+ 
+        location /request_body {
+             # force reading request body (default off)
+             lua_need_request_body on;
+             client_max_body_size 50k;
+             client_body_buffer_size 50k;
+ 
+             content_by_lua 'ngx.print(ngx.var.request_body)';
+        }
+ 
+        # transparent non-blocking I/O in Lua via subrequests
+        location /lua {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            content_by_lua '
+                local res = ngx.location.capture("/some_other_location")
+                if res.status == 200 then
+                    ngx.print(res.body)
+                end';
+        }
+ 
+        # GET /recur?num=5
+        location /recur {
+            # MIME type determined by default_type:
+            default_type 'text/plain';
+ 
+            content_by_lua '
+               local num = tonumber(ngx.var.arg_num) or 0
+
+               if num > 50 then
+                   ngx.say("num too big")
+                   return
+               end
+
+               ngx.say("num is: ", num)
+ 
+               if num > 0 then
+                   res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
+                   ngx.print("status=", res.status, " ")
+                   ngx.print("body=", res.body)
+               else
+                   ngx.say("end")
+               end
+               ';
+        }
+ 
+        location /foo {
+            rewrite_by_lua '
+                res = ngx.location.capture("/memc",
+                    { args = { cmd = "incr", key = ngx.var.uri } }
+                )
+            ';
+ 
+            proxy_pass http://blah.blah.com;
+        }
+ 
+        location /blah {
+            access_by_lua '
+                local res = ngx.location.capture("/auth")
+ 
+                if res.status == ngx.HTTP_OK then
+                    return
+                end
+ 
+                if res.status == ngx.HTTP_FORBIDDEN then
+                    ngx.exit(res.status)
+                end
+ 
+                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+            ';
+ 
+            # proxy_pass/fastcgi_pass/postgres_pass/...
+        }
+ 
+        location /mixed {
+            rewrite_by_lua_file /path/to/rewrite.lua;
+            access_by_lua_file /path/to/access.lua;
+            content_by_lua_file /path/to/content.lua;
+        }
+ 
+        # use nginx var in code path
+        # WARN: contents in nginx var must be carefully filtered,
+        # otherwise there'll be great security risk!
+        location ~ ^/app/(.+) {
+                content_by_lua_file /path/to/lua/app/root/$1.lua;
+        }
+ 
+        location / {
+           lua_need_request_body on;
+ 
+           client_max_body_size 100k;
+           client_body_buffer_size 100k;
+ 
+           access_by_lua '
+               -- check the client IP address is in our black list
+               if ngx.var.remote_addr == "132.5.72.3" then
+                   ngx.exit(ngx.HTTP_FORBIDDEN)
+               end
+ 
+               -- check if the request body contains bad words
+               if ngx.var.request_body and
+                        string.match(ngx.var.request_body, "fsck")
+               then
+                   return ngx.redirect("/terms_of_use.html")
+               end
+ 
+               -- tests passed
+           ';
+ 
+           # proxy_pass/fastcgi_pass/etc settings
+        }
+    }
+
+
+Description
+===========
+
+This module embeds Lua, via the standard Lua 5.1 interpreter or [LuaJIT 2.0](http://luajit.org/luajit.html), into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.
+
+Unlike [Apache's mod_lua](http://httpd.apache.org/docs/2.3/mod/mod_lua.html) and [Lighttpd's mod_magnet](http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet), Lua code executed using this module can be *100% non-blocking* on network traffic as long as the [Nginx API for Lua](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) provided by this module is used to handle
+requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.
+
+At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:
+
+* [lua-resty-memcached](https://github.com/agentzh/lua-resty-memcached)
+* [lua-resty-mysql](https://github.com/agentzh/lua-resty-mysql)
+* [lua-resty-redis](https://github.com/agentzh/lua-resty-redis)
+* [lua-resty-dns](https://github.com/agentzh/lua-resty-dns)
+* [lua-resty-upload](https://github.com/agentzh/lua-resty-upload)
+* [ngx_memc](http://wiki.nginx.org/HttpMemcModule)
+* [ngx_postgres](https://github.com/FRiCKLE/ngx_postgres)
+* [ngx_redis2](http://wiki.nginx.org/HttpRedis2Module)
+* [ngx_redis](http://wiki.nginx.org/HttpRedisModule)
+* [ngx_proxy](http://wiki.nginx.org/HttpProxyModule)
+* [ngx_fastcgi](http://wiki.nginx.org/HttpFastcgiModule)
+
+Almost all the Nginx modules can be used with this ngx_lua module by means of [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) or [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi) but it is recommended to use those `lua-resty-*` libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.
+
+The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.
+
+Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.
+
+Directives
+==========
+
+lua_code_cache
+--------------
+**syntax:** *lua_code_cache on | off*
+
+**default:** *lua_code_cache on*
+
+**context:** *main, server, location, location if*
+
+Enables or disables the Lua code cache for [set_by_lua_file](http://wiki.nginx.org/HttpLuaModule#set_by_lua_file),
+[content_by_lua_file](http://wiki.nginx.org/HttpLuaModule#content_by_lua_file), [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file), and
+[access_by_lua_file](http://wiki.nginx.org/HttpLuaModule#access_by_lua_file), and also force Lua module reloading on a per-request basis.
+
+The Lua files referenced in [set_by_lua_file](http://wiki.nginx.org/HttpLuaModule#set_by_lua_file),
+[content_by_lua_file](http://wiki.nginx.org/HttpLuaModule#content_by_lua_file), [access_by_lua_file](http://wiki.nginx.org/HttpLuaModule#access_by_lua_file),
+and [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file) will not be cached
+and the Lua `package.loaded` table will be cleared
+at the entry point of every request (such that Lua modules
+will not be cached either). With this in place, developers can adopt an edit-and-refresh approach.
+
+Please note however, that Lua code written inlined within nginx.conf
+such as those specified by [set_by_lua](http://wiki.nginx.org/HttpLuaModule#set_by_lua), [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua),
+[access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua), and [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) will *always* be
+cached because only the Nginx config file parser can correctly parse the `nginx.conf`
+file and the only ways to to reload the config file
+are to send a `HUP` signal or to restart Nginx.
+
+Also, Lua files which are loaded by `dofile` or `loadfile`
+in *_by_lua_file will never be cached. To ensure code caching, you can either use the [init_by_lua](http://wiki.nginx.org/HttpLuaModule#init_by_lua)
+or [init_by_lua_file](http://wiki.nginx.org/HttpLuaModule#init-by_lua_file) directives to load all such files or just make these Lua files true Lua modules
+and load them via `require`.
+
+The ngx_lua module does not currently support the `stat` mode available with the
+Apache `mod_lua` module but this is planned for implementation in the future.
+
+Disabling the Lua code cache is strongly
+discouraged for production use and should only be used during 
+development as it has a significant negative impact on overall performance.
+In addition, race conditions when reloading Lua modules are common for concurrent requests
+when the code cache is disabled.
+
+lua_regex_cache_max_entries
+---------------------------
+**syntax:** *lua_regex_cache_max_entries &lt;num&gt;*
+
+**default:** *lua_regex_cache_max_entries 1024*
+
+**context:** *http*
+
+Specifies the maximum number of entries allowed in the worker process level compiled regex cache.
+
+The regular expressions used in [ngx.re.match](http://wiki.nginx.org/HttpLuaModule#ngx.re.match), [ngx.re.gmatch](http://wiki.nginx.org/HttpLuaModule#ngx.re.gmatch), [ngx.re.sub](http://wiki.nginx.org/HttpLuaModule#ngx.re.sub), and [ngx.re.gsub](http://wiki.nginx.org/HttpLuaModule#ngx.re.gsub) will be cached within this cache if the regex option `o` (i.e., compile-once flag) is specified.
+
+The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the `o` option was not specified) and there will be one, and only one, warning in the `error.log` file:
+
+
+    2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...
+
+
+Do not activate the `o` option for regular expressions (and/or `replace` string arguments for [ngx.re.sub](http://wiki.nginx.org/HttpLuaModule#ngx.re.sub) and [ngx.re.gsub](http://wiki.nginx.org/HttpLuaModule#ngx.re.gsub)) that are generated *on the fly* and give rise to infinite variations to avoid hitting the specified limit.
+
+lua_regex_match_limit
+---------------------
+**syntax:** *lua_regex_match_limit &lt;num&gt;*
+
+**default:** *lua_regex_match_limit 0*
+
+**context:** *http*
+
+Specifies the "match limit" used by the PCRE library when executing the [ngx.re API](http://wiki.nginx.org/HttpLuaModule#ngx.re.match). To quote the PCRE manpage, "the limit ... has the effect of limiting the amount of backtracking that can take place."
+
+When the limit is hit, the error string "pcre_exec() failed: -8" will be returned by the [ngx.re API](http://wiki.nginx.org/HttpLuaModule#ngx.re.match) functions on the Lua land.
+
+When setting the limit to 0, the default "match limit" when compiling the PCRE library is used. And this is the default value of this directive.
+
+This directive was first introduced in the `v0.8.5` release.
+
+lua_package_path
+----------------
+
+**syntax:** *lua_package_path &lt;lua-style-path-str&gt;*
+
+**default:** *The content of LUA_PATH environ variable or Lua's compiled-in defaults.*
+
+**context:** *main*
+
+Sets the Lua module search path used by scripts specified by [set_by_lua](http://wiki.nginx.org/HttpLuaModule#set_by_lua),
+[content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) and others. The path string is in standard Lua path form, and `;;`
+can be used to stand for the original search paths.
+
+As from the `v0.5.0rc29` release, the special notation `$prefix` or `${prefix}` can be used in the search path string to indicate the path of the `server prefix` usually determined by the `-p PATH` command-line option while starting the Nginx server.
+
+lua_package_cpath
+-----------------
+
+**syntax:** *lua_package_cpath &lt;lua-style-cpath-str&gt;*
+
+**default:** *The content of LUA_CPATH environment variable or Lua's compiled-in defaults.*
+
+**context:** *main*
+
+Sets the Lua C-module search path used by scripts specified by [set_by_lua](http://wiki.nginx.org/HttpLuaModule#set_by_lua),
+[content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) and others. The cpath string is in standard Lua cpath form, and `;;`
+can be used to stand for the original cpath.
+
+As from the `v0.5.0rc29` release, the special notation `$prefix` or `${prefix}` can be used in the search path string to indicate the path of the `server prefix` usually determined by the `-p PATH` command-line option while starting the Nginx server.
+
+init_by_lua
+-----------
+
+**syntax:** *init_by_lua &lt;lua-script-str&gt;*
+
+**context:** *http*
+
+**phase:** *loading-config*
+
+Runs the Lua code specified by the argument `<lua-script-str>` on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.
+
+When Nginx receives the `HUP` signal and starts reloading the config file, the Lua VM will also be re-created and `init_by_lua` will run again on the new Lua VM.
+
+Usually you can register (true) Lua global variables or pre-load Lua modules at server start-up by means of this hook. Here is an example for pre-loading Lua modules:
+
+
+    init_by_lua 'cjson = require "cjson"';
+
+    server {
+        location = /api {
+            content_by_lua '
+                ngx.say(cjson.encode({dog = 5, cat = 6}))
+            ';
+        }
+    }
+
+
+You can also initialize the [lua_shared_dict](http://wiki.nginx.org/HttpLuaModule#lua_shared_dict) shm storage at this phase. Here is an example for this:
+
+
+    lua_shared_dict dogs 1m;
+
+    init_by_lua '
+        local dogs = ngx.shared.dogs;
+        dogs:set("Tom", 56)
+    ';
+
+    server {
+        location = /api {
+            content_by_lua '
+                local dogs = ngx.shared.dogs;
+                ngx.say(dogs:get("Tom"))
+            ';
+        }
+    }
+
+
+But note that, the [lua_shared_dict](http://wiki.nginx.org/HttpLuaModule#lua_shared_dict)'s shm storage will not be cleared through a config reload (via the `HUP` signal, for example). So if you do *not* want to re-initialize the shm storage in your `init_by_lua` code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your `init_by_lua` code.
+
+Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the [Copy-on-write (COW)](http://en.wikipedia.org/wiki/Copy-on-write) feature provided by many operating systems among all the worker processes, thus saving a lot of memory.
+
+Only a small set of the [Nginx API for Lua](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) is supported in this context:
+
+* Logging APIs: [ngx.log](http://wiki.nginx.org/HttpLuaModule#ngx.log) and [print](http://wiki.nginx.org/HttpLuaModule#print),
+* Shared Dictionary API: [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+More Nginx APIs for Lua may be supported in this context upon future user requests.
+
+Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.
+
+You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the `root` account.
+
+This directive was first introduced in the `v0.5.5` release.
+
+init_by_lua_file
+----------------
+
+**syntax:** *init_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *http*
+
+**phase:** *loading-config*
+
+Equivalent to [init_by_lua](http://wiki.nginx.org/HttpLuaModule#init_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code or [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+This directive was first introduced in the `v0.5.5` release.
+
+set_by_lua
+----------
+
+**syntax:** *set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]*
+
+**context:** *server, server if, location, location if*
+
+**phase:** *server-rewrite, rewrite*
+
+Executes code specified in `<lua-script-str>` with optional input arguments `$arg1 $arg2 ...`, and returns string output to `$res`. 
+The code in `<lua-script-str>` can make [API calls](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) and can retrieve input arguments from the `ngx.arg` table (index starts from `1` and increases sequentially).
+
+This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) and [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers))
+* Control API functions (e.g., [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit)) 
+* Subrequest API functions (e.g., [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi))
+* Cosocket API functions (e.g., [ngx.socket.tcp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp) and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket)).
+
+In addition, note that this directive can only write out a value to a single Nginx variable at
+a time. However, a workaround is possible using the [ngx.var.VARIABLE](http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE) interface.
+
+
+    location /foo {
+        set $diff ''; # we have to predefine the $diff variable here
+ 
+        set_by_lua $sum '
+            local a = 32
+            local b = 56
+ 
+            ngx.var.diff = a - b;  -- write to $diff directly
+            return a + b;          -- return the $sum value normally
+        ';
+ 
+        echo "sum = $sum, diff = $diff";
+    }
+
+
+This directive can be freely mixed with all directives of the [HttpRewriteModule](http://wiki.nginx.org/HttpRewriteModule), [HttpSetMiscModule](http://wiki.nginx.org/HttpSetMiscModule), and [HttpArrayVarModule](http://wiki.nginx.org/HttpArrayVarModule) modules. All of these directives will run in the same order as they appear in the config file.
+
+
+    set $foo 32;
+    set_by_lua $bar 'tonumber(ngx.var.foo) + 1';
+    set $baz "bar: $bar";  # $baz == "bar: 33"
+
+
+As from the `v0.5.0rc29` release, Nginx variable interpolation is disabled in the `<lua-script-str>` argument of this directive and therefore, the dollar sign character (`$`) can be used directly.
+
+This directive requires the [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) module.
+
+set_by_lua_file
+---------------
+**syntax:** *set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]*
+
+**context:** *server, server if, location, location if*
+
+**phase:** *server-rewrite, rewrite*
+
+Equivalent to [set_by_lua](http://wiki.nginx.org/HttpLuaModule#set_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed. 
+
+Nginx variable interpolation is supported in the `<path-to-lua-script-file>` argument string of this directive. But special care must be taken for injection attacks.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
+and the Nginx config must be reloaded each time the Lua source file is modified.
+The Lua code cache can be temporarily disabled during development by 
+switching [lua_code_cache](http://wiki.nginx.org/HttpLuaModule#lua_code_cache) `off` in `nginx.conf` to avoid reloading Nginx.
+
+This directive requires the [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) module.
+
+content_by_lua
+--------------
+
+**syntax:** *content_by_lua &lt;lua-script-str&gt;*
+
+**context:** *location, location if*
+
+**phase:** *content*
+
+Acts as a "content handler" and executes Lua code string specified in `<lua-script-str>` for every request. 
+The Lua code may make [API calls](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
+
+Do not use this directive and other content handler directives in the same location. For example, this directive and the [proxy_pass](http://wiki.nginx.org/HttpProxyModule#proxy_pass) directive should not be used in the same location.
+
+content_by_lua_file
+-------------------
+
+**syntax:** *content_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *location, location if*
+
+**phase:** *content*
+
+Equivalent to [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+Nginx variables can be used in the `<path-to-lua-script-file>` string to provide flexibility. This however carries some risks and is not ordinarily recommended.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
+and the Nginx config must be reloaded each time the Lua source file is modified.
+The Lua code cache can be temporarily disabled during development by 
+switching [lua_code_cache](http://wiki.nginx.org/HttpLuaModule#lua_code_cache) `off` in `nginx.conf` to avoid reloading Nginx.
+
+rewrite_by_lua
+--------------
+
+**syntax:** *rewrite_by_lua &lt;lua-script-str&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *rewrite tail*
+
+Acts as a rewrite phase handler and executes Lua code string specified in `<lua-script-str>` for every request.
+The Lua code may make [API calls](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
+
+Note that this handler always runs *after* the standard [HttpRewriteModule](http://wiki.nginx.org/HttpRewriteModule). So the following will work as expected:
+
+
+       location /foo {
+           set $a 12; # create and initialize $a
+           set $b ""; # create and initialize $b
+           rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
+           echo "res = $b";
+       }
+
+
+because `set $a 12` and `set $b ""` run *before* [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua).
+
+On the other hand, the following will not work as expected:
+
+
+    ?  location /foo {
+    ?      set $a 12; # create and initialize $a
+    ?      set $b ''; # create and initialize $b
+    ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
+    ?      if ($b = '13') {
+    ?         rewrite ^ /bar redirect;
+    ?         break;
+    ?      }
+    ?
+    ?      echo "res = $b";
+    ?  }
+
+
+because `if` runs *before* [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) even if it is placed after [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) in the config.
+
+The right way of doing this is as follows:
+
+
+    location /foo {
+        set $a 12; # create and initialize $a
+        set $b ''; # create and initialize $b
+        rewrite_by_lua '
+            ngx.var.b = tonumber(ngx.var.a) + 1
+            if tonumber(ngx.var.b) == 13 then
+                return ngx.redirect("/bar");
+            end
+        ';
+ 
+        echo "res = $b";
+    }
+
+
+Note that the [ngx_eval](http://www.grid.net.ru/nginx/eval.en.html) module can be approximated by using [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua). For example,
+
+
+    location / {
+        eval $res {
+            proxy_pass http://foo.com/check-spam;
+        }
+ 
+        if ($res = 'spam') {
+            rewrite ^ /terms-of-use.html redirect;
+        }
+ 
+        fastcgi_pass ...;
+    }
+
+
+can be implemented in ngx_lua as:
+
+
+    location = /check-spam {
+        internal;
+        proxy_pass http://foo.com/check-spam;
+    }
+ 
+    location / {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/check-spam")
+            if res.body == "spam" then
+                return ngx.redirect("/terms-of-use.html")
+            end
+        ';
+ 
+        fastcgi_pass ...;
+    }
+
+
+Just as any other rewrite phase handlers, [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) also runs in subrequests.
+
+Note that when calling `ngx.exit(ngx.OK)` within a [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) handler, calling [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) with status >= 200 (`ngx.HTTP_OK`) and status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`) for successful quits and `ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (or its friends) for failures.
+
+If the [HttpRewriteModule](http://wiki.nginx.org/HttpRewriteModule)'s [rewrite](http://wiki.nginx.org/HttpRewriteModule#rewrite) directive is used to change the URI and initiate location re-lookups (internal redirections), then any [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) or [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file) code sequences within the current location will not be executed. For example,
+
+
+    location /foo {
+        rewrite ^ /bar;
+        rewrite_by_lua 'ngx.exit(503)';
+    }
+    location /bar {
+        ...
+    }
+
+
+Here the Lua code `ngx.exit(503)` will never run. This will be the case if `rewrite ^ /bar last` is used as this will similarly initiate an internal redirection. If the `break` modifier is used instead, there will be no internal redirection and the `rewrite_by_lua` code will be executed.
+
+The `rewrite_by_lua` code will always run at the end of the `rewrite` request-processing phase unless [rewrite_by_lua_no_postpone](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_no_postpone) is turned on.
+
+rewrite_by_lua_file
+-------------------
+
+**syntax:** *rewrite_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *rewrite tail*
+
+Equivalent to [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+Nginx variables can be used in the `<path-to-lua-script-file>` string to provide flexibility. This however carries some risks and is not ordinarily recommended.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching [lua_code_cache](http://wiki.nginx.org/HttpLuaModule#lua_code_cache) `off` in `nginx.conf` to avoid reloading Nginx.
+
+The `rewrite_by_lua_file` code will always run at the end of the `rewrite` request-processing phase unless [rewrite_by_lua_no_postpone](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_no_postpone) is turned on.
+
+access_by_lua
+-------------
+
+**syntax:** *access_by_lua &lt;lua-script-str&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *access tail*
+
+Acts as an access phase handler and executes Lua code string specified in `<lua-script-str>` for every request.
+The Lua code may make [API calls](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
+
+Note that this handler always runs *after* the standard [HttpAccessModule](http://wiki.nginx.org/HttpAccessModule). So the following will work as expected:
+
+
+    location / {
+        deny    192.168.1.1;
+        allow   192.168.1.0/24;
+        allow   10.1.1.0/16;
+        deny    all;
+ 
+        access_by_lua '
+            local res = ngx.location.capture("/mysql", { ... })
+            ...
+        ';
+ 
+        # proxy_pass/fastcgi_pass/...
+    }
+
+
+That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua).
+
+Note that the [ngx_auth_request](http://mdounin.ru/hg/ngx_http_auth_request_module/) module can be approximated by using [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua):
+
+
+    location / {
+        auth_request /auth;
+ 
+        # proxy_pass/fastcgi_pass/postgres_pass/...
+    }
+
+
+can be implemented in ngx_lua as:
+
+
+    location / {
+        access_by_lua '
+            local res = ngx.location.capture("/auth")
+ 
+            if res.status == ngx.HTTP_OK then
+                return
+            end
+ 
+            if res.status == ngx.HTTP_FORBIDDEN then
+                ngx.exit(res.status)
+            end
+ 
+            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+        ';
+ 
+        # proxy_pass/fastcgi_pass/postgres_pass/...
+    }
+
+
+As with other access phase handlers, [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua) will *not* run in subrequests.
+
+Note that when calling `ngx.exit(ngx.OK)` within a [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua) handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua) handler, calling [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) with status >= 200 (`ngx.HTTP_OK`) and status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`) for successful quits and `ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (or its friends) for failures.
+
+access_by_lua_file
+------------------
+
+**syntax:** *access_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *access tail*
+
+Equivalent to [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+Nginx variables can be used in the `<path-to-lua-script-file>` string to provide flexibility. This however carries some risks and is not ordinarily recommended.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
+and the Nginx config must be reloaded each time the Lua source file is modified.
+The Lua code cache can be temporarily disabled during development by switching [lua_code_cache](http://wiki.nginx.org/HttpLuaModule#lua_code_cache) `off` in `nginx.conf` to avoid repeatedly reloading Nginx.
+
+header_filter_by_lua
+--------------------
+
+**syntax:** *header_filter_by_lua &lt;lua-script-str&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *output-header-filter*
+
+Uses Lua code specified in `<lua-script-str>` to define an output header filter.
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) and [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers))
+* Control API functions (e.g., [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) and [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec))
+* Subrequest API functions (e.g., [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi))
+* Cosocket API functions (e.g., [ngx.socket.tcp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp) and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket)).
+
+Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:
+
+
+    location / {
+        proxy_pass http://mybackend;
+        header_filter_by_lua 'ngx.header.Foo = "blah"';
+    }
+
+
+This directive was first introduced in the `v0.2.1rc20` release.
+
+header_filter_by_lua_file
+-------------------------
+
+**syntax:** *header_filter_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *output-header-filter*
+
+Equivalent to [header_filter_by_lua](http://wiki.nginx.org/HttpLuaModule#header_filter_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+This directive was first introduced in the `v0.2.1rc20` release.
+
+body_filter_by_lua
+------------------
+
+**syntax:** *body_filter_by_lua &lt;lua-script-str&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *output-body-filter*
+
+Uses Lua code specified in `<lua-script-str>` to define an output body filter.
+
+The input data chunk is passed via [ngx.arg](http://wiki.nginx.org/HttpLuaModule#ngx.arg)[1] (as a Lua string value) and the "eof" flag indicating the end of the response body data stream is passed via [ngx.arg](http://wiki.nginx.org/HttpLuaModule#ngx.arg)[2] (as a Lua boolean value).
+
+Behind the scene, the "eof" flag is just the `last_buf` (for main requests) or `last_in_chain` (for subrequests) flag of the Nginx chain link buffers. (Before the `v0.7.14` release, the "eof" flag does not work at all in subrequests.)
+
+The output data stream can be aborted immediately by running the following Lua statement:
+
+
+    return ngx.ERROR
+
+
+This will truncate the response body and usually result in incomplete and also invalid responses.
+
+The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding [ngx.arg](http://wiki.nginx.org/HttpLuaModule#ngx.arg)[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:
+
+
+    location / {
+        proxy_pass http://mybackend;
+        body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';
+    }
+
+
+When setting `nil` or an empty Lua string value to `ngx.arg[1]`, no data chunk will be passed to the downstream Nginx output filters at all.
+
+Likewise, new "eof" flag can also be specified by setting a boolean value to [ngx.arg](http://wiki.nginx.org/HttpLuaModule#ngx.arg)[2]. For example,
+
+
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk = ngx.arg[1]
+            if string.match(chunk, "hello") then
+                ngx.arg[2] = true  -- new eof
+                return
+            end
+
+            -- just throw away any remaining chunk data
+            ngx.arg[1] = nil
+        ';
+    }
+
+
+Then `GET /t` will just return the output
+
+
+    hello world
+
+
+That is, when the body filter sees a chunk containing the word "hello", then it will set the "eof" flag to true immediately, resulting in truncated but still valid responses.
+
+When the Lua code may change the length of the response body, then it is required to always clear out the `Content-Length` response header (if any) in a header filter to enforce streaming output, as in
+
+
+    location /foo {
+        # fastcgi_pass/proxy_pass/...
+
+        header_filter_by_lua 'ngx.header.content_length = nil';
+        body_filter_by_lua 'ngx.arg[1] = string.len(ngx.arg[1]) .. "\\n"';
+    }
+
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) and [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers))
+* Control API functions (e.g., [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) and [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec))
+* Subrequest API functions (e.g., [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi))
+* Cosocket API functions (e.g., [ngx.socket.tcp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp) and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket)).
+
+Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.
+
+This directive was first introduced in the `v0.5.0rc32` release.
+
+body_filter_by_lua_file
+-----------------------
+
+**syntax:** *body_filter_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *output-body-filter*
+
+Equivalent to [body_filter_by_lua](http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+This directive was first introduced in the `v0.5.0rc32` release.
+
+log_by_lua
+----------
+
+**syntax:** *log_by_lua &lt;lua-script-str&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *log*
+
+Run the Lua source code inlined as the `<lua-script-str>` at the `log` request processing phase. This does not replace the current access logs, but runs after.
+
+Note that the following API functions are currently disabled within this context:
+
+* Output API functions (e.g., [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) and [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers))
+* Control API functions (e.g., [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit)) 
+* Subrequest API functions (e.g., [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi))
+* Cosocket API functions (e.g., [ngx.socket.tcp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp) and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket)).
+
+Here is an example of gathering average data for [$upstream_response_time](http://wiki.nginx.org/HttpUpstreamModule#.24upstream_response_time):
+
+
+    lua_shared_dict log_dict 5M;
+
+    server {
+        location / {
+            proxy_pass http://mybackend;
+
+            log_by_lua '
+                local log_dict = ngx.shared.log_dict
+                local upstream_time = tonumber(ngx.var.upstream_response_time)
+
+                local sum = log_dict:get("upstream_time-sum") or 0
+                sum = sum + upstream_time
+                log_dict:set("upstream_time-sum", sum)
+
+                local newval, err = log_dict:incr("upstream_time-nb", 1)
+                if not newval and err == "not found" then
+                    log_dict:add("upstream_time-nb", 0)
+                    log_dict:incr("upstream_time-nb", 1)
+                end
+            ';
+        }
+
+        location = /status {
+            content_by_lua '
+                local log_dict = ngx.shared.log_dict
+                local sum = log_dict:get("upstream_time-sum")
+                local nb = log_dict:get("upstream_time-nb")
+    
+                if nb and sum then
+                    ngx.say("average upstream response time: ", sum / nb,
+                            " (", nb, " reqs)")
+                else
+                    ngx.say("no data yet")
+                end
+            ';
+        }
+    }
+
+
+This directive was first introduced in the `v0.5.0rc31` release.
+
+log_by_lua_file
+---------------
+
+**syntax:** *log_by_lua_file &lt;path-to-lua-script-file&gt;*
+
+**context:** *http, server, location, location if*
+
+**phase:** *log*
+
+Equivalent to [log_by_lua](http://wiki.nginx.org/HttpLuaModule#log_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](http://wiki.nginx.org/HttpLuaModule#Lua/LuaJIT_bytecode_support) to be executed.
+
+When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.
+
+This directive was first introduced in the `v0.5.0rc31` release.
+
+lua_need_request_body
+---------------------
+
+**syntax:** *lua_need_request_body &lt;on|off&gt;*
+
+**default:** *off*
+
+**context:** *main | server | location*
+
+**phase:** *depends on usage*
+
+Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned `on` or the [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) function should be called within the Lua code.
+
+To read the request body data within the [$request_body](http://wiki.nginx.org/HttpCoreModule#.24request_body) variable, 
+[client_body_buffer_size](http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size) must have the same value as [client_max_body_size](http://wiki.nginx.org/HttpCoreModule#client_max_body_size). Because when the content length exceeds [client_body_buffer_size](http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size) but less than [client_max_body_size](http://wiki.nginx.org/HttpCoreModule#client_max_body_size), Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the [$request_body](http://wiki.nginx.org/HttpCoreModule#.24request_body) variable.
+
+If the current location includes [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) or [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file) directives,
+then the request body will be read just before the [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) or [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file) code is run (and also at the
+`rewrite` phase). Similarly, if only [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) is specified,
+the request body will not be read until the content handler's Lua code is
+about to run (i.e., the request body will be read during the content phase).
+
+It is recommended however, to use the [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) and [ngx.req.discard_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.discard_body) functions for finer control over the request body reading process instead.
+
+This also applies to [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua) and [access_by_lua_file](http://wiki.nginx.org/HttpLuaModule#access_by_lua_file).
+
+lua_shared_dict
+---------------
+
+**syntax:** *lua_shared_dict &lt;name&gt; &lt;size&gt;*
+
+**default:** *no*
+
+**context:** *http*
+
+**phase:** *depends on usage*
+
+Declares a shared memory zone, `<name>`, to serve as storage for the shm based Lua dictionary `ngx.shared.<name>`.
+
+The `<size>` argument accepts size units such as `k` and `m`:
+
+
+    http {
+        lua_shared_dict dogs 10m;
+        ...
+    }
+
+
+See [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT) for details.
+
+This directive was first introduced in the `v0.3.1rc22` release.
+
+lua_socket_connect_timeout
+--------------------------
+
+**syntax:** *lua_socket_connect_timeout &lt;time&gt;*
+
+**default:** *lua_socket_connect_timeout 60s*
+
+**context:** *http, server, location*
+
+This directive controls the default timeout value used in TCP/unix-domain socket object's [connect](http://wiki.nginx.org/HttpLuaModule#tcpsock:connect) method and can be overridden by the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method.
+
+The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.
+
+This directive was first introduced in the `v0.5.0rc1` release.
+
+lua_socket_send_timeout
+-----------------------
+
+**syntax:** *lua_socket_send_timeout &lt;time&gt;*
+
+**default:** *lua_socket_send_timeout 60s*
+
+**context:** *http, server, location*
+
+Controls the default timeout value used in TCP/unix-domain socket object's [send](http://wiki.nginx.org/HttpLuaModule#tcpsock:send) method and can be overridden by the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method.
+
+The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.
+
+This directive was first introduced in the `v0.5.0rc1` release.
+
+lua_socket_send_lowat
+---------------------
+
+**syntax:** *lua_socket_send_lowat &lt;size&gt;*
+
+**default:** *lua_socket_send_lowat 0*
+
+**context:** *http, server, location*
+
+Controls the `lowat` (low water) value for the cosocket send buffer.
+
+lua_socket_read_timeout
+-----------------------
+
+**syntax:** *lua_socket_read_timeout &lt;time&gt;*
+
+**default:** *lua_socket_read_timeout 60s*
+
+**context:** *http, server, location*
+
+**phase:** *depends on usage*
+
+This directive controls the default timeout value used in TCP/unix-domain socket object's [receive](http://wiki.nginx.org/HttpLuaModule#tcpsock:receive) method and iterator functions returned by the [receiveuntil](http://wiki.nginx.org/HttpLuaModule#tcpsock:receiveuntil) method. This setting can be overridden by the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method.
+
+The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.
+
+This directive was first introduced in the `v0.5.0rc1` release.
+
+lua_socket_buffer_size
+----------------------
+
+**syntax:** *lua_socket_buffer_size &lt;size&gt;*
+
+**default:** *lua_socket_buffer_size 4k/8k*
+
+**context:** *http, server, location*
+
+Specifies the buffer size used by cosocket reading operations.
+
+This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even `1` byte buffer size should still work everywhere but the performance could be terrible.
+
+This directive was first introduced in the `v0.5.0rc1` release.
+
+lua_socket_pool_size
+--------------------
+
+**syntax:** *lua_socket_pool_size &lt;size&gt;*
+
+**default:** *lua_socket_pool_size 30*
+
+**context:** *http, server, location*
+
+Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).
+
+Default to 30 connections for every pool.
+
+When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.
+
+Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.
+
+This directive was first introduced in the `v0.5.0rc1` release.
+
+lua_socket_keepalive_timeout
+----------------------------
+
+**syntax:** *lua_socket_keepalive_timeout &lt;time&gt;*
+
+**default:** *lua_socket_keepalive_timeout 60s*
+
+**context:** *http, server, location*
+
+This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' [setkeepalive](http://wiki.nginx.org/HttpLuaModule#tcpsock:setkeepalive) method.
+
+The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.
+
+This directive was first introduced in the `v0.5.0rc1` release.
+
+lua_socket_log_errors
+---------------------
+
+**syntax:** *lua_socket_log_errors on|off*
+
+**default:** *lua_socket_log_errors on*
+
+**context:** *http, server, location*
+
+This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).
+
+This directive was first introduced in the `v0.5.13` release.
+
+lua_http10_buffering
+--------------------
+
+**syntax:** *lua_http10_buffering on|off*
+
+**default:** *lua_http10_buffering on*
+
+**context:** *http, server, location, location-if*
+
+Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which replies on a proper `Content-Length` response header.
+
+If the Lua code explicitly sets a `Content-Length` response header before sending the headers (either explicitly via [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers) or implicitly via the first [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) or [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.
+
+To output very large response data in a streaming fashion (via the [ngx.flush](http://wiki.nginx.org/HttpLuaModule#ngx.flush) call, for example), this directive MUST be turned off to minimize memory usage.
+
+This directive is turned `on` by default.
+
+This directive was first introduced in the `v0.5.0rc19` release.
+
+rewrite_by_lua_no_postpone
+--------------------------
+
+**syntax:** *rewrite_by_lua_no_postpone on|off*
+
+**default:** *rewrite_by_lua_no_postpone off*
+
+**context:** *http*
+
+Controls whether or not to disable postponing [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) and [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file) directives to run at the end of the `rewrite` request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the `rewrite` phase.
+
+This directive was first introduced in the `v0.5.0rc29` release.
+
+lua_transform_underscores_in_response_headers
+---------------------------------------------
+
+**syntax:** *lua_transform_underscores_in_response_headers on|off*
+
+**default:** *lua_transform_underscores_in_response_headers on*
+
+**context:** *http, server, location, location-if*
+
+Controls whether to transform underscores (`_`) in the response header names specified in the [ngx.header.HEADER](http://wiki.nginx.org/HttpLuaModule#ngx.header.HEADER) API to hypens (`-`).
+
+This directive was first introduced in the `v0.5.0rc32` release.
+
+lua_check_client_abort
+----------------------
+
+**syntax:** *lua_check_client_abort on|off*
+
+**default:** *lua_check_client_abort off*
+
+**context:** *http, server, location, location-if*
+
+This directive controls whether to check for premature client connection abortion.
+
+When this directive is turned on, the ngx_lua module will monitor the premature connection close event on the downstream connections. And when there is such an event, it will call the user Lua function callback (registered by [ngx.on_abort](http://wiki.nginx.org/HttpLuaModule#ngx.on_abort)) or just stop and clean up all the Lua "light threads" running in the current request's request handler when there is no user callback function registered.
+
+According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket), then ngx_lua will neither stop all the running "light threads" nor call the user callback (if [ngx.on_abort](http://wiki.nginx.org/HttpLuaModule#ngx.on_abort) has been called). Instead, the reading operation on [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket) will just return the error message "client aborted" as the second return value (the first return value is surely `nil`).
+
+When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a `FIN` packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the [TCP keepalive](http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html) support in your system's TCP stack implementation in order to detect "half-open" TCP connections in time.
+
+For example, on Linux, you can configure the standard [listen](http://wiki.nginx.org/HttpCoreModule#listen) directive in your `nginx.conf` file like this:
+
+
+    listen 80 so_keepalive=2s:2s:8;
+
+
+On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:
+
+    # sysctl net.inet.tcp.keepintvl=2000
+    # sysctl net.inet.tcp.keepidle=2000
+
+This directive was first introduced in the `v0.7.4` release.
+
+See also [ngx.on_abort](http://wiki.nginx.org/HttpLuaModule#ngx.on_abort).
+
+lua_max_pending_timers
+----------------------
+
+**syntax:** *lua_max_pending_timers &lt;count&gt;*
+
+**default:** *lua_max_pending_timers 1024*
+
+**context:** *http*
+
+Controls the maximum number of pending timers allowed.
+
+Pending timers are those timers that have not expired yet.
+
+When exceeding this limit, the [ngx.timer.at](http://wiki.nginx.org/HttpLuaModule#ngx.timer.at) call will immediately return `nil` and the error string "too many pending timers".
+
+This directive was first introduced in the `v0.8.0` release.
+
+lua_max_running_timers
+----------------------
+
+**syntax:** *lua_max_running_timers &lt;count&gt;*
+
+**default:** *lua_max_running_timers 256*
+
+**context:** *http*
+
+Controls the maximum number of "running timers" allowed.
+
+Running timers are those timers whose user callback functions are still running.
+
+When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message "N lua_max_running_timers are not enough" where "N" is the current value of this directive.
+
+This directive was first introduced in the `v0.8.0` release.
+
+Nginx API for Lua
+=================
+Introduction
+------------
+The various `*_by_lua` and `*_by_lua_file` configuration directives serve as gateways to the Lua API within the `nginx.conf` file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.
+
+The API is exposed to Lua in the form of two standard packages `ngx` and `ndk`. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.
+
+The packages can be introduced into external Lua modules like this:
+
+
+    local say = ngx.say
+
+    local _M = {}
+
+    function _M.foo(a)
+        say(a)
+    end
+
+    return _M
+
+
+Use of the [package.seeall](http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall) flag is strongly discouraged due to its various bad side-effects.
+
+It is also possible to directly require the packages in external Lua modules:
+
+
+    local ngx = require "ngx"
+    local ndk = require "ndk"
+
+
+The ability to require these packages was introduced in the `v0.2.1rc19` release.
+
+Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua `io` library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) method and similar) is strongly recommended for maximum performance.
+
+ngx.arg
+-------
+**syntax:** *val = ngx.arg[index]*
+
+**context:** *set_by_lua*, body_filter_by_lua**
+
+When this is used in the context of the [set_by_lua](http://wiki.nginx.org/HttpLuaModule#set_by_lua) or [set_by_lua_file](http://wiki.nginx.org/HttpLuaModule#set_by_lua_file) directives, this table is read-only and holds the input arguments to the config directives:
+
+
+    value = ngx.arg[n]
+
+
+Here is an example
+
+
+    location /foo {
+        set $a 32;
+        set $b 56;
+ 
+        set_by_lua $res
+            'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
+            $a $b;
+ 
+        echo $sum;
+    }
+
+
+that writes out `88`, the sum of `32` and `56`.
+
+When this table is used in the context of [body_filter_by_lua](http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua) or [body_filter_by_lua_file](http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua_file), the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the "eof" flag indicating the end of the whole output data stream.
+
+The data chunk and "eof" flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting `nil` or an empty Lua string value to `ngx.arg[1]`, no data chunk will be passed to the downstream Nginx output filters at all.
+
+ngx.var.VARIABLE
+----------------
+**syntax:** *ngx.var.VAR_NAME*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**
+
+Read and write Nginx variable values.
+
+
+    value = ngx.var.some_nginx_variable_name
+    ngx.var.some_nginx_variable_name = value
+
+
+Note that only already defined nginx variables can be written to.
+For example:
+
+
+    location /foo {
+        set $my_var ''; # this line is required to create $my_var at config time
+        content_by_lua '
+            ngx.var.my_var = 123;
+            ...
+        ';
+    }
+
+
+That is, nginx variables cannot be created on-the-fly.
+
+Some special nginx variables like `$args` and `$limit_rate` can be assigned a value,
+some are not, like `$arg_PARAMETER`.
+
+Nginx regex group capturing variables `$1`, `$2`, `$3`, and etc, can be read by this
+interface as well, by writing `ngx.var[1]`, `ngx.var[2]`, `ngx.var[3]`, and etc.
+
+Setting `ngx.var.Foo` to a `nil` value will unset the `$Foo` Nginx variable. 
+
+
+    ngx.var.args = nil
+
+
+**WARNING** When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,
+
+
+    local val = ngx.var.some_var
+    --- use the val repeatedly later
+
+
+to prevent (temporary) memory leaking within the current request's lifetime.
+
+Core constants
+--------------
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.**
+
+
+      ngx.OK (0)
+      ngx.ERROR (-1)
+      ngx.AGAIN (-2)
+      ngx.DONE (-4)
+      ngx.DECLINED (-5)
+
+
+Note that only three of these constants are utilized by the [Nginx API for Lua](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) (i.e., [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) accepts `NGX_OK`, `NGX_ERROR`, and `NGX_DECLINED` as input).
+
+
+      ngx.null
+
+
+The `ngx.null` constant is a `NULL` light userdata usually used to represent nil values in Lua tables etc and is similar to the [lua-cjson](http://www.kyne.com.au/~mark/software/lua-cjson.php) library's `cjson.null` constant. This constant was first introduced in the `v0.5.0rc5` release.
+
+The `ngx.DECLINED` constant was first introduced in the `v0.5.0rc19` release.
+
+HTTP method constants
+---------------------
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+
+      ngx.HTTP_GET
+      ngx.HTTP_HEAD
+      ngx.HTTP_PUT
+      ngx.HTTP_POST
+      ngx.HTTP_DELETE
+      ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)
+      ngx.HTTP_MKCOL     (added in the v0.8.2 release)
+      ngx.HTTP_COPY      (added in the v0.8.2 release)
+      ngx.HTTP_MOVE      (added in the v0.8.2 release)
+      ngx.HTTP_PROPFIND  (added in the v0.8.2 release)
+      ngx.HTTP_PROPPATCH (added in the v0.8.2 release)
+      ngx.HTTP_LOCK      (added in the v0.8.2 release)
+      ngx.HTTP_UNLOCK    (added in the v0.8.2 release)
+      ngx.HTTP_PATCH     (added in the v0.8.2 release)
+      ngx.HTTP_TRACE     (added in the v0.8.2 release)
+
+
+These constants are usually used in [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi) method calls.
+
+HTTP status constants
+---------------------
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+
+      value = ngx.HTTP_OK (200)
+      value = ngx.HTTP_CREATED (201)
+      value = ngx.HTTP_SPECIAL_RESPONSE (300)
+      value = ngx.HTTP_MOVED_PERMANENTLY (301)
+      value = ngx.HTTP_MOVED_TEMPORARILY (302)
+      value = ngx.HTTP_SEE_OTHER (303)
+      value = ngx.HTTP_NOT_MODIFIED (304)
+      value = ngx.HTTP_BAD_REQUEST (400)
+      value = ngx.HTTP_UNAUTHORIZED (401)
+      value = ngx.HTTP_FORBIDDEN (403)
+      value = ngx.HTTP_NOT_FOUND (404)
+      value = ngx.HTTP_NOT_ALLOWED (405)
+      value = ngx.HTTP_GONE (410)
+      value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
+      value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)
+      value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
+      value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
+
+
+Nginx log level constants
+-------------------------
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+
+      ngx.STDERR
+      ngx.EMERG
+      ngx.ALERT
+      ngx.CRIT
+      ngx.ERR
+      ngx.WARN
+      ngx.NOTICE
+      ngx.INFO
+      ngx.DEBUG
+
+
+These constants are usually used by the [ngx.log](http://wiki.nginx.org/HttpLuaModule#ngx.log) method.
+
+print
+-----
+**syntax:** *print(...)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+Writes argument values into the nginx `error.log` file with the `ngx.NOTICE` log level.
+
+It is equivalent to
+
+
+    ngx.log(ngx.NOTICE, ...)
+
+
+Lua `nil` arguments are accepted and result in literal `"nil"` strings while Lua booleans result in literal `"true"` or `"false"` strings. And the `ngx.null` constant will yield the `"null"` string output.
+
+There is a hard coded `2048` byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the `NGX_MAX_ERROR_STR` macro definition in the `src/core/ngx_log.h` file in the Nginx source tree.
+
+ngx.ctx
+-------
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.**
+
+This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables). 
+
+Consider the following example,
+
+
+    location /test {
+        rewrite_by_lua '
+            ngx.say("foo = ", ngx.ctx.foo)
+            ngx.ctx.foo = 76
+        ';
+        access_by_lua '
+            ngx.ctx.foo = ngx.ctx.foo + 3
+        ';
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+
+
+Then `GET /test` will yield the output
+
+
+    foo = nil
+    79
+
+
+That is, the `ngx.ctx.foo` entry persists across the rewrite, access, and content phases of a request.
+
+Every request, including subrequests, has its own copy of the table. For example:
+
+
+    location /sub {
+        content_by_lua '
+            ngx.say("sub pre: ", ngx.ctx.blah)
+            ngx.ctx.blah = 32
+            ngx.say("sub post: ", ngx.ctx.blah)
+        ';
+    }
+ 
+    location /main {
+        content_by_lua '
+            ngx.ctx.blah = 73
+            ngx.say("main pre: ", ngx.ctx.blah)
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+            ngx.say("main post: ", ngx.ctx.blah)
+        ';
+    }
+
+
+Then `GET /main` will give the output
+
+
+    main pre: 73
+    sub pre: nil
+    sub post: 32
+    main post: 73
+
+
+Here, modification of the `ngx.ctx.blah` entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of `ngx.ctx.blah`.
+
+Internal redirection will destroy the original request `ngx.ctx` data (if any) and the new request will have an empty `ngx.ctx` table. For instance,
+
+
+    location /new {
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+ 
+    location /orig {
+        content_by_lua '
+            ngx.ctx.foo = "hello"
+            ngx.exec("/new")
+        ';
+    }
+
+
+Then `GET /orig` will give
+
+
+    nil
+
+
+rather than the original `"hello"` value.
+
+Arbitrary data values, including Lua closures and nested tables, can be inserted into this "magic" table. It also allows the registration of custom meta methods.
+
+Overriding `ngx.ctx` with a new Lua table is also supported, for example,
+
+
+    ngx.ctx = { foo = 32, bar = 54 }
+
+
+ngx.location.capture
+--------------------
+**syntax:** *res = ngx.location.capture(uri, options?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Issue a synchronous but still non-blocking *Nginx Subrequest* using `uri`.
+
+Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or *any* other nginx C modules like `ngx_proxy`, `ngx_fastcgi`, `ngx_memc`,
+`ngx_postgres`, `ngx_drizzle`, and even ngx_lua itself and etc etc etc.
+
+Also note that subrequests just mimic the HTTP interface but there is *no* extra HTTP/TCP traffic *nor* IPC involved. Everything works internally, efficiently, on the C level.
+
+Subrequests are completely different from HTTP 301/302 redirection (via [ngx.redirect](http://wiki.nginx.org/HttpLuaModule#ngx.redirect)) and internal redirection (via [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec)).
+
+Here is a basic example:
+
+
+    res = ngx.location.capture(uri)
+
+
+Returns a Lua table with three slots (`res.status`, `res.header`, `res.body`, and `res.truncated`).
+
+`res.status` holds the response status code for the subrequest response.
+
+`res.header` holds all the response headers of the
+subrequest and it is a normal Lua table. For multi-value response headers,
+the value is a Lua (array) table that holds all the values in the order that
+they appear. For instance, if the subrequest response headers contain the following
+lines:
+
+
+    Set-Cookie: a=3
+    Set-Cookie: foo=bar
+    Set-Cookie: baz=blah
+
+
+Then `res.header["Set-Cookie"]` will be evaluated to the table value
+`{"a=3", "foo=bar", "baz=blah"}`.
+
+`res.body` holds the subrequest's response body data, which might be truncated. You always need to check the `res.truncated` boolean flag to see if `res.body` contains truncated data.
+
+URI query strings can be concatenated to URI itself, for instance,
+
+
+    res = ngx.location.capture('/foo/bar?a=3&b=4')
+
+
+Named locations like `@foo` are not allowed due to a limitation in
+the nginx core. Use normal locations combined with the `internal` directive to
+prepare internal-only locations.
+
+An optional option table can be fed as the second
+argument, which supports the options:
+
+* `method`
+	specify the subrequest's request method, which only accepts constants like `ngx.HTTP_POST`.
+* `body`
+	specify the subrequest's request body (string value only).
+* `args`
+	specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
+* `ctx`
+	specify a Lua table to be the [ngx.ctx](http://wiki.nginx.org/HttpLuaModule#ngx.ctx) table for the subrequest. It can be the current request's [ngx.ctx](http://wiki.nginx.org/HttpLuaModule#ngx.ctx) table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the `v0.3.1rc25` release.
+* `vars`
+	take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the `v0.3.1rc31` release.
+* `copy_all_vars`
+	specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the `v0.3.1rc31` release.
+* `share_all_vars`
+	specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request.
+* `always_forward_body`
+	when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the `body` option is not specified. By default, this option is false and when the `body` option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the `PUT` or `POST` request method.
+
+Issuing a POST subrequest, for example, can be done as follows
+
+
+    res = ngx.location.capture(
+        '/foo/bar',
+        { method = ngx.HTTP_POST, body = 'hello, world' }
+    )
+
+
+See HTTP method constants methods other than POST.
+The `method` option is `ngx.HTTP_GET` by default.
+
+The `args` option can specify extra URI arguments, for instance,
+
+
+    ngx.location.capture('/foo?a=1',
+        { args = { b = 3, c = ':' } }
+    )
+
+
+is equivalent to
+
+
+    ngx.location.capture('/foo?a=1&b=3&c=%3a')
+
+
+that is, this method will escape argument keys and values according to URI rules and
+concatenate them together into a complete query string. The format for the Lua table passed as the `args` argument is identical to the format used in the [ngx.encode_args](http://wiki.nginx.org/HttpLuaModule#ngx.encode_args) method.
+
+The `args` option can also take plain query strings:
+
+
+    ngx.location.capture('/foo?a=1',
+        { args = 'b=3&c=%3a' } }
+    )
+
+
+This is functionally identical to the previous examples.
+
+The `share_all_vars` option controls whether to share nginx variables among the current request and its subrequests. 
+If this option is set to `true`, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.
+
+Care should be taken in using this option as variable scope sharing can have unexpected side effects. The `args`, `vars`, or `copy_all_vars` options are generally preferable instead.
+
+This option is set to `false` by default
+
+
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { share_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+
+
+Accessing location `/lua` gives
+
+
+    /other dog: hello world
+    /lua: hello world
+
+
+The `copy_all_vars` option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.
+
+
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { copy_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+
+
+Request `GET /lua` will give the output
+
+
+    /other dog: hello world
+    /lua: hello
+
+
+Note that if both `share_all_vars` and `copy_all_vars` are set to true, then `share_all_vars` takes precedence.
+
+In addition to the two settings above, it is possible to specify
+values for variables in the subrequest using the `vars` option. These
+variables are set after the sharing or copying of variables has been
+evaluated, and provides a more efficient method of passing specific
+values to a subrequest over encoding them as URL arguments and 
+unescaping them in the Nginx config file.
+
+
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog '';
+        set $cat '';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { dog = "hello", cat = 32 }});
+
+            ngx.print(res.body)
+        ';
+    }
+
+
+Accessing `/lua` will yield the output
+
+
+    dog = hello
+    cat = 32
+
+
+The `ctx` option can be used to specify a custom Lua table to serve as the [ngx.ctx](http://wiki.nginx.org/HttpLuaModule#ngx.ctx) table for the subrequest.
+
+
+    location /sub {
+        content_by_lua '
+            ngx.ctx.foo = "bar";
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            local ctx = {}
+            res = ngx.location.capture("/sub", { ctx = ctx })
+
+            ngx.say(ctx.foo);
+            ngx.say(ngx.ctx.foo);
+        ';
+    }
+
+
+Then request `GET /lua` gives
+
+
+    bar
+    nil
+
+
+It is also possible to use this `ctx` option to share the same [ngx.ctx](http://wiki.nginx.org/HttpLuaModule#ngx.ctx) table between the current (parent) request and the subrequest:
+
+
+    location /sub {
+        content_by_lua '
+            ngx.ctx.foo = "bar";
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/sub", { ctx = ngx.ctx })
+            ngx.say(ngx.ctx.foo);
+        ';
+    }
+
+
+Request `GET /lua` yields the output
+
+
+    bar
+
+
+Note that subrequests issued by [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) inherit all the
+request headers of the current request by default and that this may have unexpected side effects on the
+subrequest responses. For example, when using the standard `ngx_proxy` module to serve
+subrequests, an "Accept-Encoding: gzip" header in the main request may result
+in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting 
+[proxy_pass_request_headers](http://wiki.nginx.org/HttpProxyModule#proxy_pass_request_headers) to `off` in subrequest locations.
+
+When the `body` option is not specified and the `always_forward_body` option is false (the default value), the `POST` and `PUT` subrequests will inherit the request bodies of the parent request (if any).
+
+There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was `50` concurrent subrequests and in more recent versions, Nginx `1.1.x` onwards, this was increased to `200` concurrent subrequests. When this limit is exceeded, the following error message is added to the `error.log` file:
+
+
+    [error] 13983#0: *1 subrequests cycle while processing "/uri"
+
+
+The limit can be manually modified if required by editing the definition of the `NGX_HTTP_MAX_SUBREQUESTS` macro in the `nginx/src/http/ngx_http_request.h` file in the Nginx source tree.
+
+Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules](http://wiki.nginx.org/HttpLuaModule#Locations_Configured_by_Subrequest_Directives_of_Other_Modules).
+
+ngx.location.capture_multi
+--------------------------
+**syntax:** *res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Just like [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture), but supports multiple subrequests running in parallel.
+
+This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,
+
+
+    res1, res2, res3 = ngx.location.capture_multi{
+        { "/foo", { args = "a=3&b=4" } },
+        { "/bar" },
+        { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
+    }
+ 
+    if res1.status == ngx.HTTP_OK then
+        ...
+    end
+ 
+    if res2.body == "BLAH" then
+        ...
+    end
+
+
+This function will not return until all the subrequests terminate.
+The total latency is the longest latency of the individual subrequests rather than the sum.
+
+Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:
+
+
+    -- construct the requests table
+    local reqs = {}
+    table.insert(reqs, { "/mysql" })
+    table.insert(reqs, { "/postgres" })
+    table.insert(reqs, { "/redis" })
+    table.insert(reqs, { "/memcached" })
+ 
+    -- issue all the requests at once and wait until they all return
+    local resps = { ngx.location.capture_multi(reqs) }
+ 
+    -- loop over the responses table
+    for i, resp in ipairs(resps) do
+        -- process the response table "resp"
+    end
+
+
+The [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) function is just a special form
+of this function. Logically speaking, the [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) can be implemented like this
+
+
+    ngx.location.capture =
+        function (uri, args)
+            return ngx.location.capture_multi({ {uri, args} })
+        end
+
+
+Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules](http://wiki.nginx.org/HttpLuaModule#Locations_Configured_by_Subrequest_Directives_of_Other_Modules).
+
+ngx.status
+----------
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+Read and write the current request's response status. This should be called
+before sending out the response headers.
+
+
+    ngx.status = ngx.HTTP_CREATED
+    status = ngx.status
+
+
+Setting `ngx.status` after the response header is sent out has no effect but leaving an error message in your nginx's error log file:
+
+
+    attempt to set ngx.status after sending out response headers
+
+
+ngx.header.HEADER
+-----------------
+**syntax:** *ngx.header.HEADER = VALUE*
+
+**syntax:** *value = ngx.header.HEADER*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+Set, add to, or clear the current request's `HEADER` response header that is to be sent.
+
+Underscores (`_`) in the header names will be replaced by hyphens (`-`) by default. This transformation can be turned off via the [lua_transform_underscores_in_response_headers](http://wiki.nginx.org/HttpLuaModule#lua_transform_underscores_in_response_headers) directive.
+
+The header names are matched case-insensitively.
+
+
+    -- equivalent to ngx.header["Content-Type"] = 'text/plain'
+    ngx.header.content_type = 'text/plain';
+ 
+    ngx.header["X-My-Header"] = 'blah blah';
+
+
+Multi-value headers can be set this way:
+
+
+    ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
+
+
+will yield
+
+
+    Set-Cookie: a=32; path=/
+    Set-Cookie: b=4; path=/
+
+
+in the response headers. 
+
+Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as `Content-Type` that only accept a single value).
+
+
+    ngx.header.content_type = {'a', 'b'}
+
+
+is equivalent to
+
+
+    ngx.header.content_type = 'b'
+
+
+Setting a slot to `nil` effectively removes it from the response headers:
+
+
+    ngx.header["X-My-Header"] = nil;
+
+
+The same applies to assigning an empty table:
+
+
+    ngx.header["X-My-Header"] = {};
+
+
+Setting `ngx.header.HEADER` after sending out response headers (either explicitly with [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers) or implicitly with [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) and similar) will throw out a Lua exception.
+
+Reading `ngx.header.HEADER` will return the value of the response header named `HEADER`. 
+
+Underscores (`_`) in the header names will also be replaced by dashes (`-`) and the header names will be matched case-insensitively. If the response header is not present at all, `nil` will be returned.
+
+This is particularly useful in the context of [header_filter_by_lua](http://wiki.nginx.org/HttpLuaModule#header_filter_by_lua) and [header_filter_by_lua_file](http://wiki.nginx.org/HttpLuaModule#header_filter_by_lua_file), for example,
+
+
+    location /test {
+        set $footer '';
+
+        proxy_pass http://some-backend;
+
+        header_filter_by_lua '
+            if ngx.header["X-My-Header"] == "blah" then
+                ngx.var.footer = "some value"
+            end
+        ';
+
+        echo_after_body $footer;
+    }
+
+
+For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers
+
+
+    Foo: bar
+    Foo: baz
+
+
+will result in
+
+
+    {"bar", "baz"}
+
+
+to be returned when reading `ngx.header.Foo`.
+
+Note that `ngx.header` is not a normal Lua table and as such, it is not possible to iterate through it using the Lua `ipairs` function.
+
+For reading *request* headers, use the [ngx.req.get_headers](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_headers) function instead.
+
+ngx.req.start_time
+------------------
+**syntax:** *secs = ngx.req.start_time()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**
+
+Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.
+
+The following example emulates the `$request_time` variable value (provided by [HttpLogModule](http://wiki.nginx.org/HttpLogModule)) in pure Lua:
+
+
+    local request_time = ngx.now() - ngx.req.start_time()
+
+
+This function was first introduced in the `v0.7.7` release.
+
+See also [ngx.now](http://wiki.nginx.org/HttpLuaModule#ngx.now) and [ngx.update_time](http://wiki.nginx.org/HttpLuaModule#ngx.update_time).
+
+ngx.req.http_version
+--------------------
+**syntax:** *num = ngx.req.http_version()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**
+
+Returns the HTTP version number for the current request as a Lua number.
+
+Current possible values are 1.0, 1.1, and 0.9. Returns `nil` for unrecognized values.
+
+This method was first introduced in the `v0.7.17` release.
+
+ngx.req.raw_header
+------------------
+**syntax:** *str = ngx.req.raw_header(no_request_line?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**
+
+Returns the original raw HTTP protocol header received by the Nginx server.
+
+By default, the request line and trailing `CR LF` terminator will also be included. For example,
+
+
+    ngx.print(ngx.req.raw_header())
+
+
+gives something like this:
+
+
+    GET /t HTTP/1.1
+    Host: localhost
+    Connection: close
+    Foo: bar
+
+
+
+You can specify the optional
+`no_request_line` argument as a `true` value to exclude the request line from the result. For example,
+
+
+    ngx.print(ngx.req.raw_header(true))
+
+
+outputs something like this:
+
+
+    Host: localhost
+    Connection: close
+    Foo: bar
+
+
+
+This method was first introduced in the `v0.7.17` release.
+
+ngx.req.get_method
+------------------
+**syntax:** *method_name = ngx.req.get_method()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**
+
+Retrieves the current request's request method name. Strings like `"GET"` and `"POST"` are returned instead of numerical [method constants](http://wiki.nginx.org/HttpLuaModule#HTTP_method_constants).
+
+If the current request is an Nginx subrequest, then the subrequest's method name will be returned.
+
+This method was first introduced in the `v0.5.6` release.
+
+See also [ngx.req.set_method](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_method).
+
+ngx.req.set_method
+------------------
+**syntax:** *ngx.req.set_method(method_id)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**
+
+Overrides the current request's request method with the `request_id` argument. Currently only numerical [method constants](http://wiki.nginx.org/HttpLuaModule#HTTP_method_constants) are supported, like `ngx.HTTP_POST` and `ngx.HTTP_GET`.
+
+If the current request is an Nginx subrequest, then the subrequest's method will be overridden.
+
+This method was first introduced in the `v0.5.6` release.
+
+See also [ngx.req.get_method](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_method).
+
+ngx.req.set_uri
+---------------
+**syntax:** *ngx.req.set_uri(uri, jump?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**
+
+Rewrite the current request's (parsed) URI by the `uri` argument. The `uri` argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.
+
+The optional boolean `jump` argument can trigger location rematch (or location jump) as [HttpRewriteModule](http://wiki.nginx.org/HttpRewriteModule)'s [rewrite](http://wiki.nginx.org/HttpRewriteModule#rewrite) directive, that is, when `jump` is `true` (default to `false`), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later `post-rewrite` phase and jumping to the new location.
+
+Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the `jump` argument is `false` or absent altogether.
+
+For example, the following nginx config snippet
+
+
+    rewrite ^ /foo last;
+
+
+can be coded in Lua like this:
+
+
+    ngx.req.set_uri("/foo", true)
+
+
+Similarly, Nginx config
+
+
+    rewrite ^ /foo break;
+
+
+can be coded in Lua as
+
+
+    ngx.req.set_uri("/foo", false)
+
+
+or equivalently,
+
+
+    ngx.req.set_uri("/foo")
+
+
+The `jump` can only be set to `true` in [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) and [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file). Use of jump in other contexts is prohibited and will throw out a Lua exception.
+
+A more sophisticated example involving regex substitutions is as follows
+
+
+    location /test {
+        rewrite_by_lua '
+            local uri = ngx.re.sub(ngx.var.uri, "^/test/(.*)", "$1", "o")
+            ngx.req.set_uri(uri)
+        ';
+        proxy_pass http://my_backend;
+    }
+
+
+which is functionally equivalent to
+
+
+    location /test {
+        rewrite ^/test/(.*) /$1 break;
+        proxy_pass http://my_backend;
+    }
+
+
+Note that it is not possible to use this interface to rewrite URI arguments and that [ngx.req.set_uri_args](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_uri_args) should be used for this instead. For instance, Nginx config
+
+
+    rewrite ^ /foo?a=3? last;
+
+
+can be coded as
+
+
+    ngx.req.set_uri_args("a=3")
+    ngx.req.set_uri("/foo", true)
+
+
+or
+
+
+    ngx.req.set_uri_args({a = 3})
+    ngx.req.set_uri("/foo", true)
+
+
+This interface was first introduced in the `v0.3.1rc14` release.
+
+ngx.req.set_uri_args
+--------------------
+**syntax:** *ngx.req.set_uri_args(args)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**
+
+Rewrite the current request's URI query arguments by the `args` argument. The `args` argument can be either a Lua string, as in
+
+
+    ngx.req.set_uri_args("a=3&b=hello%20world")
+
+
+or a Lua table holding the query arguments' key-value pairs, as in
+
+
+    ngx.req.set_uri_args({ a = 3, b = "hello world" })
+
+
+where in the latter case, this method will escape argument keys and values according to the URI escaping rule.
+
+Multi-value arguments are also supported:
+
+
+    ngx.req.set_uri_args({ a = 3, b = {5, 6} })
+
+
+which will result in a query string like `a=3&b=5&b=6`.
+
+This interface was first introduced in the `v0.3.1rc13` release.
+
+See also [ngx.req.set_uri](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_uri).
+
+ngx.req.get_uri_args
+--------------------
+**syntax:** *args = ngx.req.get_uri_args(max_args?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+Returns a Lua table holding all the current request URL query arguments.
+
+
+    location = /test {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            for key, val in pairs(args) do
+                if type(val) == "table" then
+                    ngx.say(key, ": ", table.concat(val, ", "))
+                else
+                    ngx.say(key, ": ", val)
+                end
+            end
+        ';
+    }
+
+
+Then `GET /test?foo=bar&bar=baz&bar=blah` will yield the response body
+
+
+    foo: bar
+    bar: baz, blah
+
+
+Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.
+
+Keys and values are unescaped according to URI escaping rules. In the settings above, `GET /test?a%20b=1%61+2` will yield:
+
+
+    a b: 1a 2
+
+
+Arguments without the `=<value>` parts are treated as boolean arguments. `GET /test?foo&bar` will yield:
+
+
+    foo: true
+    bar: true
+
+
+That is, they will take Lua boolean values `true`. However, they are different from arguments taking empty string values. `GET /test?foo=&bar=` will give something like
+
+
+    foo: 
+    bar: 
+
+
+Empty key arguments are discarded. `GET /test?=hello&=world` will yield an empty output for instance.
+
+Updating query arguments via the nginx variable `$args` (or `ngx.var.args` in Lua) at runtime is also supported:
+
+
+    ngx.var.args = "a=3&b=42"
+    local args = ngx.req.get_uri_args()
+
+
+Here the `args` table will always look like
+
+
+    {a = 3, b = 42}
+
+
+regardless of the actual request query string.
+
+Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.
+
+However, the optional `max_args` function argument can be used to override this limit:
+
+
+    local args = ngx.req.get_uri_args(10)
+
+
+This argument can be set to zero to remove the limit and to process all request arguments received:
+
+
+    local args = ngx.req.get_uri_args(0)
+
+
+Removing the `max_args` cap is strongly discouraged.
+
+ngx.req.get_post_args
+---------------------
+**syntax:** *args, err = ngx.req.get_post_args(max_args?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+Returns a Lua table holding all the current request POST query arguments (of the MIME type `application/x-www-form-urlencoded`). Call [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) to read the request body first or turn on the [lua_need_request_body](http://wiki.nginx.org/HttpLuaModule#lua_need_request_body) directive to avoid errors.
+
+
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            local args = ngx.req.get_post_args()
+            if not args then
+                ngx.say("failed to get post args: ", err)
+                return
+            end
+            for key, val in pairs(args) do
+                if type(val) == "table" then
+                    ngx.say(key, ": ", table.concat(val, ", "))
+                else
+                    ngx.say(key, ": ", val)
+                end
+            end
+        ';
+    }
+
+
+Then
+
+
+    # Post request with the body 'foo=bar&bar=baz&bar=blah'
+    $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
+
+
+will yield the response body like
+
+
+    foo: bar
+    bar: baz, blah
+
+
+Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.
+
+Keys and values will be unescaped according to URI escaping rules.
+
+With the settings above,
+
+
+    # POST request with body 'a%20b=1%61+2'
+    $ curl -d 'a%20b=1%61+2' localhost/test
+
+
+will yield:
+
+
+    a b: 1a 2
+
+
+Arguments without the `=<value>` parts are treated as boolean arguments. `GET /test?foo&bar` will yield:
+
+
+    foo: true
+    bar: true
+
+
+That is, they will take Lua boolean values `true`. However, they are different from arguments taking empty string values. `POST /test` with request body `foo=&bar=` will return something like
+
+
+    foo: 
+    bar: 
+
+
+Empty key arguments are discarded. `POST /test` with body `=hello&=world` will yield empty outputs for instance.
+
+Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.  
+
+However, the optional `max_args` function argument can be used to override this limit:
+
+
+    local args = ngx.req.get_post_args(10)
+
+
+This argument can be set to zero to remove the limit and to process all request arguments received:
+
+
+    local args = ngx.req.get_post_args(0)
+
+
+Removing the `max_args` cap is strongly discouraged.
+
+ngx.req.get_headers
+-------------------
+**syntax:** *headers = ngx.req.get_headers(max_headers?, raw?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua**
+
+Returns a Lua table holding all the current request headers.
+
+
+    local h = ngx.req.get_headers()
+    for k, v in pairs(h) do
+        ...
+    end
+
+
+To read an individual header:
+
+
+    ngx.say("Host: ", ngx.req.get_headers()["Host"])
+
+
+Note that the [ngx.var.HEADER](http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE) API call, which uses core [$http_HEADER](http://wiki.nginx.org/HttpCoreModule#.24http_HEADER) variables, may be more preferable for reading individual request headers.
+
+For multiple instances of request headers such as:
+
+
+    Foo: foo
+    Foo: bar
+    Foo: baz
+
+
+the value of `ngx.req.get_headers()["Foo"]` will be a Lua (array) table such as:
+
+
+    {"foo", "bar", "baz"}
+
+
+Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.  
+
+However, the optional `max_headers` function argument can be used to override this limit:
+
+
+    local args = ngx.req.get_headers(10)
+
+
+This argument can be set to zero to remove the limit and to process all request headers received:
+
+
+    local args = ngx.req.get_headers(0)
+
+
+Removing the `max_headers` cap is strongly discouraged.
+
+Since the `0.6.9` release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the `raw` argument is set to `true` (default to `false`).
+
+Also, by default, an `__index` metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header `My-Foo-Header` is present, then the following invocations will all pick up the value of this header correctly:
+
+
+    ngx.say(headers.my_foo_header)
+    ngx.say(headers["My-Foo-Header"])
+    ngx.say(headers["my-foo-header"])
+
+
+The `__index` metamethod will not be added when the `raw` argument is set to `true`.
+
+ngx.req.set_header
+------------------
+**syntax:** *ngx.req.set_header(header_name, header_value)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*
+
+Set the current request's request header named `header_name` to value `header_value`, overriding any existing ones.
+
+By default, all the subrequests subsequently initiated by [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi) will inherit the new header.
+
+Here is an example of setting the `Content-Length` header:
+
+
+    ngx.req.set_header("Content-Type", "text/css")
+
+
+The `header_value` can take an array list of values,
+for example,
+
+
+    ngx.req.set_header("Foo", {"a", "abc"})
+
+
+will produce two new request headers:
+
+
+    Foo: a
+    Foo: abc
+
+
+and old `Foo` headers will be overridden if there is any.
+
+When the `header_value` argument is `nil`, the request header will be removed. So
+
+
+    ngx.req.set_header("X-Foo", nil)
+
+
+is equivalent to
+
+
+    ngx.req.clear_header("X-Foo")
+
+
+ngx.req.clear_header
+--------------------
+**syntax:** *ngx.req.clear_header(header_name)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**
+
+Clear the current request's request header named `header_name`. None of the current request's subrequests will be affected.
+
+ngx.req.read_body
+-----------------
+**syntax:** *ngx.req.read_body()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Reads the client request body synchronously without blocking the Nginx event loop.
+
+
+    ngx.req.read_body()
+    local args = ngx.req.get_post_args()
+
+
+If the request body is already read previously by turning on [lua_need_request_body](http://wiki.nginx.org/HttpLuaModule#lua_need_request_body) or by using other modules, then this function does not run and returns immediately.
+
+If the request body has already been explicitly discarded, either by the [ngx.req.discard_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.discard_body) function or other modules, this function does not run and returns immediately.
+
+In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception *or* terminate the current request with a 500 status code immediately.
+
+The request body data read using this function can be retrieved later via [ngx.req.get_body_data](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_body_data) or, alternatively, the temporary file name for the body data cached to disk using [ngx.req.get_body_file](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_body_file). This depends on
+
+1. whether the current request body is already larger than the [client_body_buffer_size](http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size),
+1. and whether [client_body_in_file_only](http://wiki.nginx.org/HttpCoreModule#client_body_in_file_only) has been switched on.
+
+In cases where current request may have a request body and the request body data is not required, The [ngx.req.discard_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.discard_body) function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
+
+This function was first introduced in the `v0.3.1rc17` release.
+
+ngx.req.discard_body
+--------------------
+**syntax:** *ngx.req.discard_body()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately. Please note that ignoring request body is not the right way to discard it, and that this function must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
+
+This function is an asynchronous call and returns immediately.
+
+If the request body has already been read, this function does nothing and returns immediately.
+
+This function was first introduced in the `v0.3.1rc17` release.
+
+See also [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body).
+
+ngx.req.get_body_data
+---------------------
+**syntax:** *data = ngx.req.get_body_data()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [ngx.req.get_post_args](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_post_args) function instead if a Lua table is required.
+
+This function returns `nil` if
+1. the request body has not been read,
+1. the request body has been read into disk temporary files,
+1. or the request body has zero size.
+
+If the request body has not been read yet, call [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) first (or turned on [lua_need_request_body](http://wiki.nginx.org/HttpLuaModule#lua_need_request_body) to force this module to read the request body. This is not recommended however).
+
+If the request body has been read into disk files, try calling the [ngx.req.get_body_file](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_body_file) function instead.
+
+To force in-memory request bodies, try setting [client_body_buffer_size](http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size) to the same size value in [client_max_body_size](http://wiki.nginx.org/HttpCoreModule#client_max_body_size).
+
+Note that calling this function instead of using `ngx.var.request_body` or `ngx.var.echo_request_body` is more efficient because it can save one dynamic memory allocation and one data copy.
+
+This function was first introduced in the `v0.3.1rc17` release.
+
+See also [ngx.req.get_body_file](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_body_file).
+
+ngx.req.get_body_file
+---------------------
+**syntax:** *file_name = ngx.req.get_body_file()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Retrieves the file name for the in-file request body data. Returns `nil` if the request body has not been read or has been read into memory.
+
+The returned file is read only and is usually cleaned up by Nginx's memory pool. It should not be manually modified, renamed, or removed in Lua code.
+
+If the request body has not been read yet, call [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) first (or turned on [lua_need_request_body](http://wiki.nginx.org/HttpLuaModule#lua_need_request_body) to force this module to read the request body. This is not recommended however).
+
+If the request body has been read into memory, try calling the [ngx.req.get_body_data](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_body_data) function instead.
+
+To force in-file request bodies, try turning on [client_body_in_file_only](http://wiki.nginx.org/HttpCoreModule#client_body_in_file_only).
+
+This function was first introduced in the `v0.3.1rc17` release.
+
+See also [ngx.req.get_body_data](http://wiki.nginx.org/HttpLuaModule#ngx.req.get_body_data).
+
+ngx.req.set_body_data
+---------------------
+**syntax:** *ngx.req.set_body_data(data)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Set the current request's request body using the in-memory data specified by the `data` argument.
+
+If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.
+
+This function was first introduced in the `v0.3.1rc18` release.
+
+See also [ngx.req.set_body_file](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_body_file).
+
+ngx.req.set_body_file
+---------------------
+**syntax:** *ngx.req.set_body_file(file_name, auto_clean?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Set the current request's request body using the in-file data specified by the `file_name` argument.
+
+If the optional `auto_clean` argument is given a `true` value, then this file will be removed at request completion or the next time this function or [ngx.req.set_body_data](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_body_data) are called in the same request. The `auto_clean` is default to `false`.
+
+Please ensure that the file specified by the `file_name` argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.
+
+If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.
+
+This function was first introduced in the `v0.3.1rc18` release.
+
+See also [ngx.req.set_body_data](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_body_data).
+
+ngx.req.init_body
+-----------------
+**syntax:** *ngx.req.init_body(buffer_size?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [ngx.req.append_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.append_body) and [ngx.req.finish_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.finish_body) APIs.
+
+If the `buffer_size` argument is specified, then its value will be used for the size of the memory buffer for body writing with [ngx.req.append_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.append_body). If the argument is omitted, then the value specified by the standard [client_body_buffer_size](http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size) directive will be used instead.
+
+When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.
+
+It is important to always call the [ngx.req.finish_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.finish_body) after all the data has been appended onto the current request body. Also, when this function is used together with [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket), it is required to call [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket) *before* this function, or you will get the "request body already exists" error message.
+
+The usage of this function is often like this:
+
+
+    ngx.req.init_body(128 * 1024)  -- buffer is 128KB
+    for chunk in next_data_chunk() do
+        ngx.req.append_body(chunk) -- each chunk can be 4KB
+    end
+    ngx.req.finish_body()
+
+
+This function can be used with [ngx.req.append_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.append_body), [ngx.req.finish_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.finish_body), and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket) to implement efficient input filters in pure Lua (in the context of [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua)* or [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua)*), which can be used with other Nginx content handler or upstream modules like [HttpProxyModule](http://wiki.nginx.org/HttpProxyModule) and [HttpFastcgiModule](http://wiki.nginx.org/HttpFastcgiModule).
+
+This function was first introduced in the `v0.5.11` release.
+
+ngx.req.append_body
+-------------------
+**syntax:** *ngx.req.append_body(data_chunk)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Append new data chunk specified by the `data_chunk` argument onto the existing request body created by the [ngx.req.init_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.init_body) call.
+
+When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.
+
+It is important to always call the [ngx.req.finish_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.finish_body) after all the data has been appended onto the current request body.
+
+This function can be used with [ngx.req.init_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.init_body), [ngx.req.finish_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.finish_body), and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket) to implement efficient input filters in pure Lua (in the context of [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua)* or [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua)*), which can be used with other Nginx content handler or upstream modules like [HttpProxyModule](http://wiki.nginx.org/HttpProxyModule) and [HttpFastcgiModule](http://wiki.nginx.org/HttpFastcgiModule).
+
+This function was first introduced in the `v0.5.11` release.
+
+See also [ngx.req.init_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.init_body).
+
+ngx.req.finish_body
+-------------------
+**syntax:** *ngx.req.finish_body()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Completes the construction process of the new request body created by the [ngx.req.init_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.init_body) and [ngx.req.append_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.append_body) calls.
+
+This function can be used with [ngx.req.init_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.init_body), [ngx.req.append_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.append_body), and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket) to implement efficient input filters in pure Lua (in the context of [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua)* or [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua)*), which can be used with other Nginx content handler or upstream modules like [HttpProxyModule](http://wiki.nginx.org/HttpProxyModule) and [HttpFastcgiModule](http://wiki.nginx.org/HttpFastcgiModule).
+
+This function was first introduced in the `v0.5.11` release.
+
+See also [ngx.req.init_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.init_body).
+
+ngx.req.socket
+--------------
+**syntax:** *tcpsock, err = ngx.req.socket()*
+
+**syntax:** *tcpsock, err = ngx.req.socket(raw)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Returns a read-only cosocket object that wraps the downstream connection. Only [receive](http://wiki.nginx.org/HttpLuaModule#tcpsock:receive) and [receiveuntil](http://wiki.nginx.org/HttpLuaModule#tcpsock:receiveuntil) methods are supported on this object.
+
+In case of error, `nil` will be returned as well as a string describing the error.
+
+The socket object returned by this method is usually used to read the current request's body in a streaming fashion. Do not turn on the [lua_need_request_body](http://wiki.nginx.org/HttpLuaModule#lua_need_request_body) directive, and do not mix this call with [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) and [ngx.req.discard_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.discard_body).
+
+If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading.
+Chunked request bodies are not yet supported in this API.
+
+Since the `v0.9.0` release, this function accepts an optional boolean `raw` argument. When this argument is `true`, this function returns a full duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the [receive](http://wiki.nginx.org/HttpLuaModule#tcpsock:receive), [receiveuntil](http://wiki.nginx.org/HttpLuaModule#tcpsock:receiveuntil), and [send](http://wiki.nginx.org/HttpLuaModule#tcpsock:send) methods.
+
+When the `raw` argument is `true`, it is required that no pending data from any previous [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say), [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print), or [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers) calls exists. So if you have these downstream output calls previously, you should call [ngx.flush(true)](http://wiki.nginx.org/HttpLuaModule#ngx.flush) before calling `ngx.req.socket(true)` to ensure that there is no pending output data. Another requirement for this case is that the request body must have already been read completely.
+
+You can use the "raw request socket" returned by `ngx.req.socket(true)` to implement fancy protocols like [WebSocket](http://en.wikipedia.org/wiki/WebSocket), or just emit your own raw HTTP response header or body data. You can refer to the [lua-resty-websocket library](https://github.com/agentzh/lua-resty-websocket) for a real world example.
+
+This function was first introduced in the `v0.5.0rc1` release.
+
+ngx.exec
+--------
+**syntax:** *ngx.exec(uri, args?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Does an internal redirect to `uri` with `args`.
+
+
+    ngx.exec('/some-location');
+    ngx.exec('/some-location', 'a=3&b=5&c=6');
+    ngx.exec('/some-location?a=3&b=5', 'c=6');
+
+
+Named locations are also supported, but query strings are ignored. For example,
+
+
+    location /foo {
+        content_by_lua '
+            ngx.exec("@bar");
+        ';
+    }
+ 
+    location @bar {
+        ...
+    }
+
+
+The optional second `args` can be used to specify extra URI query arguments, for example:
+
+
+    ngx.exec("/foo", "a=3&b=hello%20world")
+
+
+Alternatively, a Lua table can be passed for the `args` argument for ngx_lua to carry out URI escaping and string concatenation.
+
+
+    ngx.exec("/foo", { a = 3, b = "hello world" })
+
+
+The result is exactly the same as the previous example. The format for the Lua table passed as the `args` argument is identical to the format used in the [ngx.encode_args](http://wiki.nginx.org/HttpLuaModule#ngx.encode_args) method.
+
+Note that this is very different from [ngx.redirect](http://wiki.nginx.org/HttpLuaModule#ngx.redirect) in that
+it is just an internal redirect and no new HTTP traffic is involved.
+
+This method never returns.
+
+This method *must* be called before [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers) or explicit response body
+outputs by either [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) or [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say).
+
+It is strongly recommended to combine the `return` statement with this call, i.e., `return ngx.exec(...)`.
+
+This method is similar to the [echo_exec](http://wiki.nginx.org/HttpEchoModule#echo_exec) directive of the [HttpEchoModule](http://wiki.nginx.org/HttpEchoModule).
+
+ngx.redirect
+------------
+**syntax:** *ngx.redirect(uri, status?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Issue an `HTTP 301` or `302` redirection to `uri`.
+
+The optional `status` parameter specifies whether
+`301` or `302` to be used. It is `302` (`ngx.HTTP_MOVED_TEMPORARILY`) by default.
+
+Here is an example assuming the current server name is `localhost` and that it is listening on Port 1984:
+
+
+    return ngx.redirect("/foo")
+
+
+which is equivalent to
+
+
+    return ngx.redirect("http://localhost:1984/foo", ngx.HTTP_MOVED_TEMPORARILY)
+
+
+Redirecting arbitrary external URLs is also supported, for example:
+
+
+    return ngx.redirect("http://www.google.com")
+
+
+We can also use the numerical code directly as the second `status` argument:
+
+
+    return ngx.redirect("/foo", 301)
+
+
+This method *must* be called before [ngx.send_headers](http://wiki.nginx.org/HttpLuaModule#ngx.send_headers) or explicit response body outputs by either [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) or [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say).
+
+This method is very much like the [rewrite](http://wiki.nginx.org/HttpRewriteModule#rewrite) directive with the `redirect` modifier in the standard
+[HttpRewriteModule](http://wiki.nginx.org/HttpRewriteModule), for example, this `nginx.conf` snippet
+
+
+    rewrite ^ /foo? redirect;  # nginx config
+
+
+is equivalent to the following Lua code
+
+
+    return ngx.redirect('/foo');  -- Lua code
+
+
+while
+
+
+    rewrite ^ /foo? permanent;  # nginx config
+
+
+is equivalent to
+
+
+    return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
+
+
+URI arguments can be specified as well, for example:
+
+
+    return ngx.redirect('/foo?a=3&b=4')
+
+
+This method call terminates the current request's processing and never returns. It is recommended to combine the `return` statement with this call, i.e., `return ngx.redirect(...)`, so as to be more explicit.
+
+ngx.send_headers
+----------------
+**syntax:** *ok, err = ngx.send_headers()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Explicitly send out the response headers.
+
+Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.
+
+Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out
+before content is output with [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) or [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) or when [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) exits normally.
+
+ngx.headers_sent
+----------------
+**syntax:** *value = ngx.headers_sent*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Returns `true` if the response headers have been sent (by ngx_lua), and `false` otherwise.
+
+This API was first introduced in ngx_lua v0.3.1rc6.
+
+ngx.print
+---------
+**syntax:** *ok, err = ngx.print(...)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.
+
+Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.
+
+Lua `nil` values will output `"nil"` strings and Lua boolean values will output `"true"` and `"false"` literal strings respectively.
+
+Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:
+
+
+    local table = {
+        "hello, ",
+        {"world: ", true, " or ", false,
+            {": ", nil}}
+    }
+    ngx.print(table)
+
+
+will yield the output
+
+
+    hello, world: true or false: nil
+
+
+Non-array table arguments will cause a Lua exception to be thrown.
+
+The `ngx.null` constant will yield the `"null"` string output.
+
+This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call `ngx.flush(true)` after calling `ngx.print`. This can be particularly useful for streaming output. See [ngx.flush](http://wiki.nginx.org/HttpLuaModule#ngx.flush) for more details.
+
+Please note that both `ngx.print` and [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.
+
+ngx.say
+-------
+**syntax:** *ok, err = ngx.say(...)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Just as [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) but also emit a trailing newline.
+
+ngx.log
+-------
+**syntax:** *ngx.log(log_level, ...)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Log arguments concatenated to error.log with the given logging level.
+
+Lua `nil` arguments are accepted and result in literal `"nil"` string while Lua booleans result in literal `"true"` or `"false"` string outputs. And the `ngx.null` constant will yield the `"null"` string output.
+
+The `log_level` argument can take constants like `ngx.ERR` and `ngx.WARN`. Check out [Nginx log level constants](http://wiki.nginx.org/HttpLuaModule#Nginx_log_level_constants) for details.
+
+There is a hard coded `2048` byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the `NGX_MAX_ERROR_STR` macro definition in the `src/core/ngx_log.h` file in the Nginx source tree.
+
+ngx.flush
+---------
+**syntax:** *ok, err = ngx.flush(wait?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Flushes response output to the client. 
+
+`ngx.flush` accepts an optional boolean `wait` argument (Default: `false`) first introduced in the `v0.3.1rc34` release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the `wait` argument set to `true` switches to synchronous mode. 
+
+In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the [send_timeout](http://wiki.nginx.org/HttpCoreModule#send_timeout) setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.
+
+When `ngx.flush(true)` is called immediately after [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) or [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say), it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.
+
+Note that `ngx.flush` is non functional when in the HTTP 1.0 output buffering mode. See [HTTP 1.0 support](http://wiki.nginx.org/HttpLuaModule#HTTP_1.0_support).
+
+Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.
+
+ngx.exit
+--------
+**syntax:** *ngx.exit(status)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+When `status >= 200` (i.e., `ngx.HTTP_OK` and above), it will interrupt the execution of the current request and return status code to nginx.
+
+When `status == 0` (i.e., `ngx.OK`), it will only quit the current phase handler (or the content handler if the [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) directive is used) and continue to run later phases (if any) for the current request.
+
+The `status` argument can be `ngx.OK`, `ngx.ERROR`, `ngx.HTTP_NOT_FOUND`,
+`ngx.HTTP_MOVED_TEMPORARILY`, or other [HTTP status constants](http://wiki.nginx.org/HttpLuaModule#HTTP_status_constants).
+
+To return an error page with custom contents, use code snippets like this:
+
+
+    ngx.status = ngx.HTTP_GONE
+    ngx.say("This is our own content")
+    -- to cause quit the whole request rather than the current phase handler
+    ngx.exit(ngx.HTTP_OK)
+
+
+The effect in action:
+
+
+    $ curl -i http://localhost/test
+    HTTP/1.1 410 Gone
+    Server: nginx/1.0.6
+    Date: Thu, 15 Sep 2011 00:51:48 GMT
+    Content-Type: text/plain
+    Transfer-Encoding: chunked
+    Connection: keep-alive
+
+    This is our own content
+
+
+Number literals can be used directly as the argument, for instance,
+
+
+    ngx.exit(501)
+
+
+Note that while this method accepts all [HTTP status constants](http://wiki.nginx.org/HttpLuaModule#HTTP_status_constants) as input, it only accepts `NGX_OK` and `NGX_ERROR` of the [core constants](http://wiki.nginx.org/HttpLuaModule#core_constants).
+
+It is recommended, though not necessary, to combine the `return` statement with this call, i.e., `return ngx.exit(...)`, to give a visual hint to others reading the code.
+
+ngx.eof
+-------
+**syntax:** *ok, err = ngx.eof()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the "last chunk".
+
+When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on descent HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:
+
+
+    location = /async {
+        keepalive_timeout 0;
+        content_by_lua '
+            ngx.say("got the task!")
+            ngx.eof()  -- descent HTTP client will close the connection at this point
+            -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...
+        ';
+    }
+
+
+But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard [HttpProxyModule](http://wiki.nginx.org/HttpProxyModule) will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the [proxy_ignore_client_abort](http://wiki.nginx.org/HttpProxyModule#proxy_ignore_client_abort) directive in your location block configured by [HttpProxyModule](http://wiki.nginx.org/HttpProxyModule):
+
+
+    proxy_ignore_client_abort on;
+
+
+Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.
+
+ngx.sleep
+---------
+**syntax:** *ngx.sleep(seconds)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).
+
+Behind the scene, this method makes use of the Nginx timers.
+
+Since the `0.7.20` release, The `0` time argument can also be specified.
+
+This method was introduced in the `0.5.0rc30` release.
+
+ngx.escape_uri
+--------------
+**syntax:** *newstr = ngx.escape_uri(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Escape `str` as a URI component.
+
+ngx.unescape_uri
+----------------
+**syntax:** *newstr = ngx.unescape_uri(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Unescape `str` as an escaped URI component.
+
+For example,
+
+
+    ngx.say(ngx.unescape_uri("b%20r56+7"))
+
+
+gives the output
+
+
+    b r56 7
+
+
+ngx.encode_args
+---------------
+**syntax:** *str = ngx.encode_args(table)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Encode the Lua table to a query args string according to the URI encoded rules.
+
+For example,
+
+
+    ngx.encode_args({foo = 3, ["b r"] = "hello world"})
+
+
+yields
+
+
+    foo=3&b%20r=hello%20world
+
+
+The table keys must be Lua strings.
+
+Multi-value query args are also supported. Just use a Lua table for the argument's value, for example:
+
+
+    ngx.encode_args({baz = {32, "hello"}})
+
+
+gives
+
+
+    baz=32&baz=hello
+
+
+If the value table is empty and the effect is equivalent to the `nil` value.
+
+Boolean argument values are also supported, for instance,
+
+
+    ngx.encode_args({a = true, b = 1})
+
+
+yields
+
+
+    a&b=1
+
+
+If the argument value is `false`, then the effect is equivalent to the `nil` value.
+
+This method was first introduced in the `v0.3.1rc27` release.
+
+ngx.decode_args
+---------------
+**syntax:** *table = ngx.decode_args(str, max_args?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Decodes a URI encoded query-string into a Lua table. This is the inverse function of [ngx.encode_args](http://wiki.nginx.org/HttpLuaModule#ngx.encode_args).
+
+The optional `max_args` argument can be used to specify the maximum number of arguments parsed from the `str` argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks.
+
+This argument can be set to zero to remove the limit and to process all request arguments received:
+
+
+    local args = ngx.decode_args(str, 0)
+
+
+Removing the `max_args` cap is strongly discouraged.
+
+This method was introduced in the `v0.5.0rc29`.
+
+ngx.encode_base64
+-----------------
+**syntax:** *newstr = ngx.encode_base64(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Encode `str` to a base64 digest.
+
+ngx.decode_base64
+-----------------
+**syntax:** *newstr = ngx.decode_base64(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Decodes the `str` argument as a base64 digest to the raw form. Returns `nil` if `str` is not well formed.
+
+ngx.crc32_short
+---------------
+**syntax:** *intval = ngx.crc32_short(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Calculates the CRC-32 (Cyclic Redundancy Code) digest for the `str` argument.
+
+This method performs better on relatively short `str` inputs (i.e., less than 30 ~ 60 bytes), as compared to [ngx.crc32_long](http://wiki.nginx.org/HttpLuaModule#ngx.crc32_long). The result is exactly the same as [ngx.crc32_long](http://wiki.nginx.org/HttpLuaModule#ngx.crc32_long).
+
+Behind the scene, it is just a thin wrapper around the `ngx_crc32_short` function defined in the Nginx core.
+
+This API was first introduced in the `v0.3.1rc8` release.
+
+ngx.crc32_long
+--------------
+**syntax:** *intval = ngx.crc32_long(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Calculates the CRC-32 (Cyclic Redundancy Code) digest for the `str` argument.
+
+This method performs better on relatively long `str` inputs (i.e., longer than 30 ~ 60 bytes), as compared to [ngx.crc32_short](http://wiki.nginx.org/HttpLuaModule#ngx.crc32_short).  The result is exactly the same as [ngx.crc32_short](http://wiki.nginx.org/HttpLuaModule#ngx.crc32_short).
+
+Behind the scene, it is just a thin wrapper around the `ngx_crc32_long` function defined in the Nginx core.
+
+This API was first introduced in the `v0.3.1rc8` release.
+
+ngx.hmac_sha1
+-------------
+**syntax:** *digest = ngx.hmac_sha1(secret_key, str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Computes the [HMAC-SHA1](http://en.wikipedia.org/wiki/HMAC) digest of the argument `str` and turns the result using the secret key `<secret_key>`.
+
+The raw binary form of the `HMAC-SHA1` digest will be generated, use [ngx.encode_base64](http://wiki.nginx.org/HttpLuaModule#ngx.encode_base64), for example, to encode the result to a textual representation if desired.
+
+For example,
+
+
+    local key = "thisisverysecretstuff"
+    local src = "some string we want to sign"
+    local digest = ngx.hmac_sha1(key, src)
+    ngx.say(ngx.encode_base64(digest))
+
+
+yields the output
+
+
+    R/pvxzHC4NLtj7S+kXFg/NePTmk=
+
+
+This API requires the OpenSSL library enabled in the Nginx build (usually by passing the `--with-http_ssl_module` option to the `./configure` script).
+
+This function was first introduced in the `v0.3.1rc29` release.
+
+ngx.md5
+-------
+**syntax:** *digest = ngx.md5(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns the hexadecimal representation of the MD5 digest of the `str` argument.
+
+For example,
+
+
+    location = /md5 {
+        content_by_lua 'ngx.say(ngx.md5("hello"))';
+    }
+
+
+yields the output
+
+
+    5d41402abc4b2a76b9719d911017c592
+
+
+See [ngx.md5_bin](http://wiki.nginx.org/HttpLuaModule#ngx.md5_bin) if the raw binary MD5 digest is required.
+
+ngx.md5_bin
+-----------
+**syntax:** *digest = ngx.md5_bin(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns the binary form of the MD5 digest of the `str` argument.
+
+See [ngx.md5](http://wiki.nginx.org/HttpLuaModule#ngx.md5) if the hexadecimal form of the MD5 digest is required.
+
+ngx.sha1_bin
+------------
+**syntax:** *digest = ngx.sha1_bin(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns the binary form of the SHA-1 digest of the `str` argument.
+
+This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).
+
+This function was first introduced in the `v0.5.0rc6`.
+
+ngx.quote_sql_str
+-----------------
+**syntax:** *quoted_value = ngx.quote_sql_str(raw_value)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns a quoted SQL string literal according to the MySQL quoting rules.
+
+ngx.today
+---------
+**syntax:** *str = ngx.today()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns current date (in the format `yyyy-mm-dd`) from the nginx cached time (no syscall involved unlike Lua's date library).
+
+This is the local time.
+
+ngx.time
+--------
+**syntax:** *secs = ngx.time()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).
+
+Updates of the Nginx time cache an be forced by calling [ngx.update_time](http://wiki.nginx.org/HttpLuaModule#ngx.update_time) first.
+
+ngx.now
+-------
+**syntax:** *secs = ngx.now()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).
+
+You can forcibly update the Nginx time cache by calling [ngx.update_time](http://wiki.nginx.org/HttpLuaModule#ngx.update_time) first.
+
+This API was first introduced in `v0.3.1rc32`.
+
+ngx.update_time
+---------------
+**syntax:** *ngx.update_time()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.
+
+This API was first introduced in `v0.3.1rc32`.
+
+ngx.localtime
+-------------
+**syntax:** *str = ngx.localtime()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns the current time stamp (in the format `yyyy-mm-dd hh:mm:ss`) of the nginx cached time (no syscall involved unlike Lua's [os.date](http://www.lua.org/manual/5.1/manual.html#pdf-os.date) function).
+
+This is the local time.
+
+ngx.utctime
+-----------
+**syntax:** *str = ngx.utctime()*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns the current time stamp (in the format `yyyy-mm-dd hh:mm:ss`) of the nginx cached time (no syscall involved unlike Lua's [os.date](http://www.lua.org/manual/5.1/manual.html#pdf-os.date) function).
+
+This is the UTC time.
+
+ngx.cookie_time
+---------------
+**syntax:** *str = ngx.cookie_time(sec)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns a formated string can be used as the cookie expiration time. The parameter `sec` is the time stamp in seconds (like those returned from [ngx.time](http://wiki.nginx.org/HttpLuaModule#ngx.time)).
+
+
+    ngx.say(ngx.cookie_time(1290079655))
+        -- yields "Thu, 18-Nov-10 11:27:35 GMT"
+
+
+ngx.http_time
+-------------
+**syntax:** *str = ngx.http_time(sec)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Returns a formated string can be used as the http header time (for example, being used in `Last-Modified` header). The parameter `sec` is the time stamp in seconds (like those returned from [ngx.time](http://wiki.nginx.org/HttpLuaModule#ngx.time)).
+
+
+    ngx.say(ngx.http_time(1290079655))
+        -- yields "Thu, 18 Nov 2010 11:27:35 GMT"
+
+
+ngx.parse_http_time
+-------------------
+**syntax:** *sec = ngx.parse_http_time(str)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Parse the http time string (as returned by [ngx.http_time](http://wiki.nginx.org/HttpLuaModule#ngx.http_time)) into seconds. Returns the seconds or `nil` if the input string is in bad forms.
+
+
+    local time = ngx.parse_http_time("Thu, 18 Nov 2010 11:27:35 GMT")
+    if time == nil then
+        ...
+    end
+
+
+ngx.is_subrequest
+-----------------
+**syntax:** *value = ngx.is_subrequest*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**
+
+Returns `true` if the current request is an nginx subrequest, or `false` otherwise.
+
+ngx.re.match
+------------
+**syntax:** *captures, err = ngx.re.match(subject, regex, options?, ctx?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Matches the `subject` string using the Perl compatible regular expression `regex` with the optional `options`.
+
+Only the first occurrence of the match is returned, or `nil` if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, `nil` and a string describing the error will be returned.
+
+When a match is found, a Lua table `captures` is returned, where `captures[0]` holds the whole substring being matched, and `captures[1]` holds the first parenthesized sub-pattern's capturing, `captures[2]` the second, and so on.
+
+
+    local m, err = ngx.re.match("hello, 1234", "[0-9]+")
+    if m then
+        -- m[0] == "1234"
+
+    else
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        ngx.say("match not found")
+    end
+
+
+
+    local m, err = ngx.re.match("hello, 1234", "([0-9])[0-9]+")
+    -- m[0] == "1234"
+    -- m[1] == "1"
+
+
+Named captures are also supported since the `v0.7.14` release
+and are returned in the same Lua table as key-value pairs as the numbered captures.
+
+
+    local m, err = ngx.re.match("hello, 1234", "([0-9])(?<remaining>[0-9]+)")
+    -- m[0] == "1234"
+    -- m[1] == "1"
+    -- m[2] == "234"
+    -- m["remaining"] == "234"
+
+
+Unmatched subpatterns will have `nil` values in their `captures` table fields.
+
+
+    local m, err = ngx.re.match("hello, world", "(world)|(hello)|(?<named>howdy)")
+    -- m[0] == "hello"
+    -- m[1] == nil
+    -- m[2] == "hello"
+    -- m[3] == nil
+    -- m["named"] == nil
+
+
+Specify `options` to control how the match operation will be performed. The following option characters are supported:
+
+
+    a             anchored mode (only match from the beginning)
+
+    d             enable the DFA mode (or the longest token match semantics).
+                  this requires PCRE 6.0+ or else a Lua exception will be thrown.
+                  first introduced in ngx_lua v0.3.1rc30.
+
+    D             enable duplicate named pattern support. This allows named
+                  subpattern names to be repeated, returning the captures in
+                  an array-like Lua table. for example,
+                    local m = ngx.re.match("hello, world",
+                                           "(?<named>\w+), (?<named>\w+)",
+                                           "D")
+                    -- m["named"] == {"hello", "world"}
+                  this option was first introduced in the v0.7.14 release.
+                  this option requires at least PCRE 8.12.
+
+    i             case insensitive mode (similar to Perl's /i modifier)
+
+    j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
+                  must be built with the --enable-jit option. for optimum performance,
+                  this option should always be used together with the 'o' option.
+                  first introduced in ngx_lua v0.3.1rc30.
+
+    J             enable the PCRE Javascript compatible mode. this option was
+                  first introduced in the v0.7.14 release. this option requires
+                  at least PCRE 8.12.
+
+    m             multi-line mode (similar to Perl's /m modifier)
+
+    o             compile-once mode (similar to Perl's /o modifier),
+                  to enable the worker-process-level compiled-regex cache
+
+    s             single-line mode (similar to Perl's /s modifier)
+
+    u             UTF-8 mode. this requires PCRE to be built with
+                  the --enable-utf8 option or else a Lua exception will be thrown.
+
+    U             similar to "u" but disables PCRE's UTF-8 validity check on
+                  the subject string. first introduced in ngx_lua v0.8.1.
+
+    x             extended mode (similar to Perl's /x modifier)
+
+
+These options can be combined:
+
+
+    local m, err = ngx.re.match("hello, world", "HEL LO", "ix")
+    -- m[0] == "hello"
+
+
+
+    local m, err = ngx.re.match("hello, 美好生活", "HELLO, (.{2})", "iu")
+    -- m[0] == "hello, 美好"
+    -- m[1] == "美好"
+
+
+The `o` option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [lua_regex_cache_max_entries](http://wiki.nginx.org/HttpLuaModule#lua_regex_cache_max_entries) directive.
+
+The optional fourth argument, `ctx`, can be a Lua table holding an optional `pos` field. When the `pos` field in the `ctx` table argument is specified, `ngx.re.match` will start matching from that offset. Regardless of the presence of the `pos` field in the `ctx` table, `ngx.re.match` will always set this `pos` field to the position *after* the substring matched by the whole pattern in case of a successful match. When match fails, the `ctx` table will be left intact.
+
+
+    local ctx = {}
+    local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
+         -- m[0] = "1234"
+         -- ctx.pos == 4
+
+
+
+    local ctx = { pos = 2 }
+    local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
+         -- m[0] = "34"
+         -- ctx.pos == 4
+
+
+The `ctx` table argument combined with the `a` regex modifier can be used to construct a lexer atop `ngx.re.match`.
+
+Note that, the `options` argument is not optional when the `ctx` argument is specified and that the empty Lua string (`""`) must be used as placeholder for `options` if no meaningful regex options are required.
+
+This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special PCRE Sequences](http://wiki.nginx.org/HttpLuaModule#Special_PCRE_Sequences)).
+
+To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the `--with-debug` option to Nginx or ngx_openresty's `./configure` script. Then, enable the "debug" error log level in `error_log` directive. The following message will be generated if PCRE JIT is enabled:
+
+
+    pcre JIT compiling result: 1
+
+
+This feature was introduced in the `v0.2.1rc11` release.
+
+ngx.re.gmatch
+-------------
+**syntax:** *iterator, err = ngx.re.gmatch(subject, regex, options?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Similar to [ngx.re.match](http://wiki.nginx.org/HttpLuaModule#ngx.re.match), but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the `<subject>` string argument with the PCRE `regex`.
+
+In case of errors, like seeing an ill-formed regular expression, `nil` and a string describing the error will be returned.
+
+Here is a small example to demonstrate its basic usage:
+
+
+    local iterator, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
+    if not iterator then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    local m
+    m, err = iterator()    -- m[0] == m[1] == "hello"
+    if err then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    m, err = iterator()    -- m[0] == m[1] == "world"
+    if err then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    m, err = iterator()    -- m == nil
+    if err then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+
+More often we just put it into a Lua loop:
+
+
+    local it, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
+    if not it then
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+    while true do
+        local m, err = it()
+        if err then
+            ngx.log(ngx.ERR, "error: ", err)
+            return
+        end
+
+        if not m then
+            -- no match found (any more)
+            break
+        end
+
+        -- found a match
+        ngx.say(m[0])
+        ngx.say(m[1])
+    end
+
+
+The optional `options` argument takes exactly the same semantics as the [ngx.re.match](http://wiki.nginx.org/HttpLuaModule#ngx.re.match) method.
+
+The current implementation requires that the iterator returned should only be used in a single request. That is, one should *not* assign it to a variable belonging to persistent namespace like a Lua package.
+
+This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special PCRE Sequences](http://wiki.nginx.org/HttpLuaModule#Special_PCRE_Sequences)).
+
+This feature was first introduced in the `v0.2.1rc12` release.
+
+ngx.re.sub
+----------
+**syntax:** *newstr, n, err = ngx.re.sub(subject, regex, replace, options?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Substitutes the first match of the Perl compatible regular expression `regex` on the `subject` argument string with the string or function argument `replace`. The optional `options` argument has exactly the same meaning as in [ngx.re.match](http://wiki.nginx.org/HttpLuaModule#ngx.re.match).
+
+This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the `<replace>` string argument, it will return `nil` and a string describing the error.
+
+When the `replace` is a string, then it is treated as a special template for string replacement. For example,
+
+
+    local newstr, n, err = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")
+    if newstr then
+        -- newstr == "hello, [12][1]34"
+        -- n == 1
+    else
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+
+where `$0` referring to the whole substring matched by the pattern and `$1` referring to the first parenthesized capturing substring.
+
+Curly braces can also be used to disambiguate variable names from the background string literals: 
+
+
+    local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")
+        -- newstr == "hello, 10034"
+        -- n == 1
+
+
+Literal dollar sign characters (`$`) in the `replace` string argument can be escaped by another dollar sign, for instance,
+
+
+    local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "$$")
+        -- newstr == "hello, $234"
+        -- n == 1
+
+
+Do not use backlashes to escape dollar signs; it will not work as expected.
+
+When the `replace` argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the `replace` function is exactly the same as the return value of [ngx.re.match](http://wiki.nginx.org/HttpLuaModule#ngx.re.match). Here is an example:
+
+
+    local func = function (m)
+        return "[" .. m[0] .. "][" .. m[1] .. "]"
+    end
+    local newstr, n, err = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")
+        -- newstr == "hello, [12][1]34"
+        -- n == 1
+
+
+The dollar sign characters in the return value of the `replace` function argument are not special at all.
+
+This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special PCRE Sequences](http://wiki.nginx.org/HttpLuaModule#Special_PCRE_Sequences)).
+
+This feature was first introduced in the `v0.2.1rc13` release.
+
+ngx.re.gsub
+-----------
+**syntax:** *newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Just like [ngx.re.sub](http://wiki.nginx.org/HttpLuaModule#ngx.re.sub), but does global substitution.
+
+Here is some examples:
+
+
+    local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "i")
+    if newstr then
+        -- newstr == "[hello,h], [world,w]"
+        -- n == 2
+    else
+        ngx.log(ngx.ERR, "error: ", err)
+        return
+    end
+
+
+
+    local func = function (m)
+        return "[" .. m[0] .. "," .. m[1] .. "]"
+    end
+    local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", func, "i")
+        -- newstr == "[hello,h], [world,w]"
+        -- n == 2
+
+
+This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special PCRE Sequences](http://wiki.nginx.org/HttpLuaModule#Special_PCRE_Sequences)).
+
+This feature was first introduced in the `v0.2.1rc15` release.
+
+ngx.shared.DICT
+---------------
+**syntax:** *dict = ngx.shared.DICT*
+
+**syntax:** *dict = ngx.shared[name_var]*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Fetching the shm-based Lua dictionary object for the shared memory zone named `DICT` defined by the [lua_shared_dict](http://wiki.nginx.org/HttpLuaModule#lua_shared_dict) directive.
+
+The resulting object `dict` has the following methods:
+
+* [get](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.get)
+* [get_stale](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.get_stale)
+* [set](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.set)
+* [safe_set](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.safe_set)
+* [add](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.add)
+* [safe_add](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.safe_add)
+* [replace](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.replace)
+* [incr](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.incr)
+* [delete](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.delete)
+* [flush_all](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.flush_all)
+* [flush_expired](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.flush_expired)
+
+Here is an example:
+
+
+    http {
+        lua_shared_dict dogs 10m;
+        server {
+            location /set {
+                content_by_lua '
+                    local dogs = ngx.shared.dogs
+                    dogs:set("Jim", 8)
+                    ngx.say("STORED")
+                ';
+            }
+            location /get {
+                content_by_lua '
+                    local dogs = ngx.shared.dogs
+                    ngx.say(dogs:get("Jim"))
+                ';
+            }
+        }
+    }
+
+
+Let us test it:
+
+
+    $ curl localhost/set
+    STORED
+
+    $ curl localhost/get
+    8
+
+    $ curl localhost/get
+    8
+
+
+The number `8` will be consistently output when accessing `/get` regardless of how many Nginx workers there are because the `dogs` dictionary resides in the shared memory and visible to *all* of the worker processes.
+
+The shared dictionary will retain its contents through a server config reload (either by sending the `HUP` signal to the Nginx process or by using the `-s reload` command-line option).
+
+The contents in the dictionary storage will be lost, however, when the Nginx server quits.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+ngx.shared.DICT.get
+-------------------
+**syntax:** *value, flags = ngx.shared.DICT:get(key)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Retrieving the value in the dictionary [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT) for the key `key`. If the key does not exist or has been expired, then `nil` will be returned.
+
+The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.
+
+The first argument to this method must be the dictionary object itself, for example,
+
+
+    local cats = ngx.shared.cats
+    local value, flags = cats.get(cats, "Marry")
+
+
+or use Lua's syntactic sugar for method calls:
+
+
+    local cats = ngx.shared.cats
+    local value, flags = cats:get("Marry")
+
+
+These two forms are fundamentally equivalent.
+
+If the user flags is `0` (the default), then no flags value will be returned.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.get_stale
+-------------------------
+**syntax:** *value, flags, stale = ngx.shared.DICT:get_stale(key)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Similar to the [get](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.get) method but returns the value even if the key has already expired.
+
+Returns a 3rd value, `stale`, indicating whether the key has expired or not.
+
+Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.
+
+This method was first introduced in the `0.8.6` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.set
+-------------------
+**syntax:** *success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Unconditionally sets a key-value pair into the shm-based dictionary [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT). Returns three values:
+
+* `success`: boolean value to indicate whether the key-value pair is stored or not.
+* `err`: textual error message, can be `"no memory"`.
+* `forcible`: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.
+
+The `value` argument inserted can be Lua booleans, numbers, strings, or `nil`. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [get](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.get) method.
+
+The optional `exptime` argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is `0.001` seconds. If the `exptime` takes the value `0` (which is the default), then the item will never be expired.
+
+The optional `flags` argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to `0`. The user flags argument was first introduced in the `v0.5.0rc2` release.
+
+When it fails to allocate memory for the current key-value item, then `set` will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [lua_shared_dict](http://wiki.nginx.org/HttpLuaModule#lua_shared_dict) or memory segmentation), then the `err` return value will be `no memory` and `success` will be `false`.
+
+If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the `forcible` return value will be `true`. If it stores the item without forcibly removing other valid items, then the return value `forcible` will be `false`.
+
+The first argument to this method must be the dictionary object itself, for example,
+
+
+    local cats = ngx.shared.cats
+    local succ, err, forcible = cats.set(cats, "Marry", "it is a nice cat!")
+
+
+or use Lua's syntactic sugar for method calls:
+
+
+    local cats = ngx.shared.cats
+    local succ, err, forcible = cats:set("Marry", "it is a nice cat!")
+
+
+These two forms are fundamentally equivalent.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.safe_set
+------------------------
+**syntax:** *ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Similar to the [set](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.set) method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return `nil` and the string "no memory".
+
+This feature was first introduced in the `v0.7.18` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.add
+-------------------
+**syntax:** *success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Just like the [set](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.set) method, but only stores the key-value pair into the dictionary [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT) if the key does *not* exist.
+
+If the `key` argument already exists in the dictionary (and not expired for sure), the `success` return value will be `false` and the `err` return value will be `"exists"`.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.safe_add
+------------------------
+**syntax:** *ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Similar to the [add](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.add) method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return `nil` and the string "no memory".
+
+This feature was first introduced in the `v0.7.18` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.replace
+-----------------------
+**syntax:** *success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Just like the [set](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.set) method, but only stores the key-value pair into the dictionary [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT) if the key *does* exist.
+
+If the `key` argument does *not* exist in the dictionary (or expired already), the `success` return value will be `false` and the `err` return value will be `"not found"`.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.delete
+----------------------
+**syntax:** *ngx.shared.DICT:delete(key)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Unconditionally removes the key-value pair from the shm-based dictionary [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+It is equivalent to `ngx.shared.DICT:set(key, nil)`.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.incr
+--------------------
+**syntax:** *newval, err = ngx.shared.DICT:incr(key, value)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Increments the (numerical) value for `key` in the shm-based dictionary [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT) by the step value `value`. Returns the new resulting number if the operation is successfully completed or `nil` and an error message otherwise.
+
+The key must already exist in the dictionary, otherwise it will return `nil` and `"not found"`.
+
+If the original value is not a valid Lua number in the dictionary, it will return `nil` and `"not a number"`.
+
+The `value` argument can be any valid Lua numbers, like negative numbers or floating-point numbers.
+
+This feature was first introduced in the `v0.3.1rc22` release.
+
+See also [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.flush_all
+-------------------------
+**syntax:** *ngx.shared.DICT:flush_all()*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.
+
+This feature was first introduced in the `v0.5.0rc17` release.
+
+See also [ngx.shared.DICT.flush_expired](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.flush_expired) and [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.flush_expired
+-----------------------------
+**syntax:** *flushed = ngx.shared.DICT:flush_expired(max_count?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Flushes out the expired items in the dictionary, up to the maximal number specified by the optional `max_count` argument. When the `max_count` argument is given `0` or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.
+
+Unlike the [flush_all](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.flush_all) method, this method actually free up the memory used by the expired items.
+
+This feature was first introduced in the `v0.6.3` release.
+
+See also [ngx.shared.DICT.flush_all](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT.flush_all) and [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT).
+
+ngx.shared.DICT.get_keys
+------------------------
+**syntax:** *keys = ngx.shared.DICT:get_keys(max_count?)*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Fetch a list of the keys from the dictionary, up to `<max_count>`.
+
+By default, only the first 1024 keys (if any) are returned. When the `<max_count>` argument is given the value `0`, then all the keys will be returned even there is more than 1024 keys in the dictionary.
+
+**WARNING** Be careful when calling this method on dictionaries with a really huge number of keys. This method may lock the dictionary for quite a while and block all the nginx worker processes that are trying to access the dictionary.
+
+This feature was first introduced in the `v0.7.3` release.
+
+ngx.socket.udp
+--------------
+**syntax:** *udpsock = ngx.socket.udp()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:
+
+* [setpeername](http://wiki.nginx.org/HttpLuaModule#udpsock:setpeername)
+* [send](http://wiki.nginx.org/HttpLuaModule#udpsock:send)
+* [receive](http://wiki.nginx.org/HttpLuaModule#udpsock:receive)
+* [close](http://wiki.nginx.org/HttpLuaModule#udpsock:close)
+* [settimeout](http://wiki.nginx.org/HttpLuaModule#udpsock:settimeout)
+
+It is intended to be compatible with the UDP API of the [LuaSocket](http://w3.impa.br/~diego/software/luasocket/udp.html) library but is 100% nonblocking out of the box.
+
+This feature was first introduced in the `v0.5.7` release.
+
+See also [ngx.socket.tcp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp).
+
+udpsock:setpeername
+-------------------
+**syntax:** *ok, err = udpsock:setpeername(host, port)*
+
+**syntax:** *ok, err = udpsock:setpeername("unix:/path/to/unix-domain.socket")*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a "connection", but only just set the name of the remote peer for subsequent read/write operations.
+
+Both IP addresses and domain names can be specified as the `host` argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [resolver](http://wiki.nginx.org/HttpCoreModule#resolver) directive in the `nginx.conf` file like this:
+
+
+    resolver 8.8.8.8;  # use Google's public DNS nameserver
+
+
+If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.
+
+In case of error, the method returns `nil` followed by a string describing the error. In case of success, the method returns `1`.
+
+Here is an example for connecting to a UDP (memcached) server:
+
+
+    location /test {
+        resolver 8.8.8.8;
+
+        content_by_lua '
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("my.memcached.server.domain", 11211)
+            if not ok then
+                ngx.say("failed to connect to memcached: ", err)
+                return
+            end
+            ngx.say("successfully connected to memcached!")
+            sock:close()
+        ';
+    }
+
+
+Since the `v0.7.18` release, connecting to a datagram unix domain socket file is also possible on Linux:
+
+
+    local sock = ngx.socket.udp()
+    local ok, err = sock:setpeername("unix:/tmp/some-datagram-service.sock")
+    if not ok then
+        ngx.say("failed to connect to the datagram unix domain socket: ", err)
+        return
+    end
+
+
+assuming the datagram service is listening on the unix domain socket file `/tmp/some-datagram-service.sock` and the client socket will use the "autobind" feature on Linux.
+
+Calling this method on an already connected socket object will cause the original connection to be closed first.
+
+This method was first introduced in the `v0.5.7` release.
+
+udpsock:send
+------------
+**syntax:** *ok, err = udpsock:send(data)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Sends data on the current UDP or datagram unix domain socket object.
+
+In case of success, it returns `1`. Otherwise, it returns `nil` and a string describing the error.
+
+The input argument `data` can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.
+
+This feature was first introduced in the `v0.5.7` release.
+
+udpsock:receive
+---------------
+**syntax:** *data, err = udpsock:receive(size?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, `size`.
+
+This method is a synchronous operation and is 100% nonblocking.
+
+In case of success, it returns the data received; in case of error, it returns `nil` with a string describing the error.
+
+If the `size` argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than `8192`, then `8192` will be used instead.
+
+If no argument is specified, then the maximal buffer size, `8192` is assumed.
+
+Timeout for the reading operation is controlled by the [lua_socket_read_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_read_timeout) config directive and the [settimeout](http://wiki.nginx.org/HttpLuaModule#udpsock:settimeout) method. And the latter takes priority. For example:
+
+
+    sock:settimeout(1000)  -- one second timeout
+    local data, err = sock:receive()
+    if not data then
+        ngx.say("failed to read a packet: ", data)
+        return
+    end
+    ngx.say("successfully read a packet: ", data)
+
+
+It is important here to call the [settimeout](http://wiki.nginx.org/HttpLuaModule#udpsock:settimeout) method *before* calling this method.
+
+This feature was first introduced in the `v0.5.7` release.
+
+udpsock:close
+-------------
+**syntax:** *ok, err = udpsock:close()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Closes the current UDP or datagram unix domain socket. It returns the `1` in case of success and returns `nil` with a string describing the error otherwise.
+
+Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.
+
+This feature was first introduced in the `v0.5.7` release.
+
+udpsock:settimeout
+------------------
+**syntax:** *udpsock:settimeout(time)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Set the timeout value in milliseconds for subsequent socket operations (like [receive](http://wiki.nginx.org/HttpLuaModule#udpsock:receive)).
+
+Settings done by this method takes priority over those config directives, like [lua_socket_read_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_read_timeout).
+
+This feature was first introduced in the `v0.5.7` release.
+
+ngx.socket.tcp
+--------------
+**syntax:** *tcpsock = ngx.socket.tcp()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:
+
+* [connect](http://wiki.nginx.org/HttpLuaModule#tcpsock:connect)
+* [send](http://wiki.nginx.org/HttpLuaModule#tcpsock:send)
+* [receive](http://wiki.nginx.org/HttpLuaModule#tcpsock:receive)
+* [close](http://wiki.nginx.org/HttpLuaModule#tcpsock:close)
+* [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout)
+* [setoption](http://wiki.nginx.org/HttpLuaModule#tcpsock:setoption)
+* [receiveuntil](http://wiki.nginx.org/HttpLuaModule#tcpsock:receiveuntil)
+* [setkeepalive](http://wiki.nginx.org/HttpLuaModule#tcpsock:setkeepalive)
+* [getreusedtimes](http://wiki.nginx.org/HttpLuaModule#tcpsock:getreusedtimes)
+
+It is intended to be compatible with the TCP API of the [LuaSocket](http://w3.impa.br/~diego/software/luasocket/tcp.html) library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+See also [ngx.socket.udp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.udp).
+
+tcpsock:connect
+---------------
+**syntax:** *ok, err = tcpsock:connect(host, port, options_table?)*
+
+**syntax:** *ok, err = tcpsock:connect("unix:/path/to/unix-domain.socket", options_table?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.
+
+Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [ngx.socket.connect](http://wiki.nginx.org/HttpLuaModule#ngx.socket.connect) function).
+
+Both IP addresses and domain names can be specified as the `host` argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [resolver](http://wiki.nginx.org/HttpCoreModule#resolver) directive in the `nginx.conf` file like this:
+
+
+    resolver 8.8.8.8;  # use Google's public DNS nameserver
+
+
+If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.
+
+In case of error, the method returns `nil` followed by a string describing the error. In case of success, the method returns `1`.
+
+Here is an example for connecting to a TCP server:
+
+
+    location /test {
+        resolver 8.8.8.8;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("www.google.com", 80)
+            if not ok then
+                ngx.say("failed to connect to google: ", err)
+                return
+            end
+            ngx.say("successfully connected to google!")
+            sock:close()
+        ';
+    }
+
+
+Connecting to a Unix Domain Socket file is also possible:
+
+
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("unix:/tmp/memcached.sock")
+    if not ok then
+        ngx.say("failed to connect to the memcached unix domain socket: ", err)
+        return
+    end
+
+
+assuming memcached (or something else) is listening on the unix domain socket file `/tmp/memcached.sock`.
+
+Timeout for the connecting operation is controlled by the [lua_socket_connect_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_connect_timeout) config directive and the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method. And the latter takes priority. For example:
+
+
+    local sock = ngx.socket.tcp()
+    sock:settimeout(1000)  -- one second timeout
+    local ok, err = sock:connect(host, port)
+
+
+It is important here to call the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method *before* calling this method.
+
+Calling this method on an already connected socket object will cause the original connection to be closed first.
+
+An optional Lua table can be specified as the last argument to this method to specify various connect options:
+
+* `pool`
+	specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template `"<host>:<port>"` or `"<unix-socket-path>"`.
+
+The support for the options table argument was first introduced in the `v0.5.7` release.
+
+This method was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:send
+------------
+**syntax:** *bytes, err = tcpsock:send(data)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Sends data without blocking on the current TCP or Unix Domain Socket connection.
+
+This method is a synchronous operation that will not return until *all* the data has been flushed into the system socket send buffer or an error occurs.
+
+In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns `nil` and a string describing the error.
+
+The input argument `data` can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.
+
+Timeout for the sending operation is controlled by the [lua_socket_send_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_send_timeout) config directive and the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method. And the latter takes priority. For example:
+
+
+    sock:settimeout(1000)  -- one second timeout
+    local bytes, err = sock:send(request)
+
+
+It is important here to call the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method *before* calling this method.
+
+In case of any connection errors, this method always automatically closes the current connection.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:receive
+---------------
+**syntax:** *data, err, partial = tcpsock:receive(size)*
+
+**syntax:** *data, err, partial = tcpsock:receive(pattern?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Receives data from the connected socket according to the reading pattern or size.
+
+This method is a synchronous operation just like the [send](http://wiki.nginx.org/HttpLuaModule#tcpsock:send) method and is 100% nonblocking.
+
+In case of success, it returns the data received; in case of error, it returns `nil` with a string describing the error and the partial data received so far.
+
+If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.
+
+If a non-number-like string argument is specified, then it is interpreted as a "pattern". The following patterns are supported:
+
+* `'*a'`: reads from the socket until the connection is closed. No end-of-line translation is performed;
+* `'*l'`: reads a line of text from the socket. The line is terminated by a `Line Feed` (LF) character (ASCII 10), optionally preceded by a `Carriage Return` (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.
+
+If no argument is specified, then it is assumed to be the pattern `'*l'`, that is, the line reading pattern.
+
+Timeout for the reading operation is controlled by the [lua_socket_read_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_read_timeout) config directive and the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method. And the latter takes priority. For example:
+
+
+    sock:settimeout(1000)  -- one second timeout
+    local line, err, partial = sock:receive()
+    if not line then
+        ngx.say("failed to read a line: ", err)
+        return
+    end
+    ngx.say("successfully read a line: ", line)
+
+
+It is important here to call the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method *before* calling this method.
+
+Since the `v0.8.8` release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:receiveuntil
+--------------------
+**syntax:** *iterator = tcpsock:receiveuntil(pattern, options?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.
+
+Here is an example for using this method to read a data stream with the boundary sequence `--abcedhb`:
+
+
+    local reader = sock:receiveuntil("\r\n--abcedhb")
+    local data, err, partial = reader()
+    if not data then
+        ngx.say("failed to read the data stream: ", err)
+    end
+    ngx.say("read the data stream: ", data)
+
+
+When called without any argument, the iterator function returns the received data right *before* the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is `'hello, world! -agentzh\r\n--abcedhb blah blah'`, then the string `'hello, world! -agentzh'` will be returned.
+
+In case of error, the iterator function will return `nil` along with a string describing the error and the partial data bytes that have been read so far.
+
+The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.
+
+The iterator function behaves differently (i.e., like a real iterator) when it is called with a `size` argument. That is, it will read that `size` of data on each invocation and will return `nil` at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the `err` return value will be `nil` too. The iterator function will be reset after the last successful invocation that returns `nil` data and `nil` error. Consider the following example:
+
+
+    local reader = sock:receiveuntil("\r\n--abcedhb")
+
+    while true do
+        local data, err, partial = reader(4)
+        if not data then
+            if err then
+                ngx.say("failed to read the data stream: ", err)
+                break
+            end
+
+            ngx.say("read done")
+            break
+        end
+        ngx.say("read chunk: [", data, "]")
+    end
+
+
+Then for the incoming data stream `'hello, world! -agentzh\r\n--abcedhb blah blah'`, we shall get the following output from the sample code above:
+
+
+    read chunk: [hell]
+    read chunk: [o, w]
+    read chunk: [orld]
+    read chunk: [! -a]
+    read chunk: [gent]
+    read chunk: [zh]
+    read done
+
+
+Note that, the actual data returned *might* be a little longer than the size limit specified by the `size` argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.
+
+Timeout for the iterator function's reading operation is controlled by the [lua_socket_read_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_read_timeout) config directive and the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method. And the latter takes priority. For example:
+
+
+    local readline = sock:receiveuntil("\r\n")
+
+    sock:settimeout(1000)  -- one second timeout
+    line, err, partial = readline()
+    if not line then
+        ngx.say("failed to read a line: ", err)
+        return
+    end
+    ngx.say("successfully read a line: ", line)
+
+
+It is important here to call the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method *before* calling the iterator function (note that the `receiveuntil` call is irrelevant here).
+
+As from the `v0.5.1` release, this method also takes an optional `options` table argument to control the behavior. The following options are supported:
+
+* `inclusive`
+
+The `inclusive` takes a boolean value to control whether to include the pattern string in the returned data string. Default to `false`. For example,
+
+
+    local reader = tcpsock:receiveuntil("_END_", { inclusive = true })
+    local data = reader()
+    ngx.say(data)
+
+
+Then for the input data stream `"hello world _END_ blah blah blah"`, then the example above will output `hello world _END_`, including the pattern string `_END_` itself.
+
+Since the `v0.8.8` release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.
+
+This method was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:close
+-------------
+**syntax:** *ok, err = tcpsock:close()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Closes the current TCP or stream unix domain socket. It returns the `1` in case of success and returns `nil` with a string describing the error otherwise.
+
+Note that there is no need to call this method on socket objects that have invoked the [setkeepalive](http://wiki.nginx.org/HttpLuaModule#tcpsock:setkeepalive) method because the socket object is already closed (and the current connection is saved into the built-in connection pool).
+
+Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:settimeout
+------------------
+**syntax:** *tcpsock:settimeout(time)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Set the timeout value in milliseconds for subsequent socket operations ([connect](http://wiki.nginx.org/HttpLuaModule#tcpsock:connect), [receive](http://wiki.nginx.org/HttpLuaModule#tcpsock:receive), and iterators returned from [receiveuntil](http://wiki.nginx.org/HttpLuaModule#tcpsock:receiveuntil)).
+
+Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_connect_timeout), [lua_socket_send_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_send_timeout), and [lua_socket_read_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_read_timeout).
+
+Note that this method does *not* affect the [lua_socket_keepalive_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_keepalive_timeout) setting; the `timeout` argument to the [setkeepalive](http://wiki.nginx.org/HttpLuaModule#tcpsock:setkeepalive) method should be used for this purpose instead.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:setoption
+-----------------
+**syntax:** *tcpsock:setoption(option, value?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+This function is added for [LuaSocket](http://w3.impa.br/~diego/software/luasocket/tcp.html) API compatibility and does nothing for now. Its functionality will be implemented in future.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:setkeepalive
+--------------------
+**syntax:** *ok, err = tcpsock:setkeepalive(timeout?, size?)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other [connect](http://wiki.nginx.org/HttpLuaModule#tcpsock:connect) method calls request it or the associated maximal idle timeout is expired.
+
+The first optional argument, `timeout`, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [lua_socket_keepalive_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_keepalive_timeout) config directive will be used. If the `0` value is given, then the timeout interval is unlimited.
+
+The second optional argument, `size`, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path). Note that the size of the connection pool cannot be changed once the pool is created. When this argument is omitted, the default setting in the [lua_socket_pool_size](http://wiki.nginx.org/HttpLuaModule#lua_socket_pool_size) config directive will be used.
+
+When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.
+
+Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.
+
+Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.
+
+In case of success, this method returns `1`; otherwise, it returns `nil` and a string describing the error.
+
+This method also makes the current cosocket object enter the "closed" state, so there is no need to manually call the [close](http://wiki.nginx.org/HttpLuaModule#tcpsock:close) method on it afterwards.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+tcpsock:getreusedtimes
+----------------------
+**syntax:** *count, err = tcpsock:getreusedtimes()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+This method returns the (successfully) reused times for the current connection. In case of error, it returns `nil` and a string describing the error.
+
+If the current connection does not come from the built-in connection pool, then this method always returns `0`, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+ngx.socket.connect
+------------------
+**syntax:** *tcpsock, err = ngx.socket.connect(host, port)*
+
+**syntax:** *tcpsock, err = ngx.socket.connect("unix:/path/to/unix-domain.socket")*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+This function is a shortcut for combining [ngx.socket.tcp()](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp) and the [connect()](http://wiki.nginx.org/HttpLuaModule#tcpsock:connect) method call in a single operation. It is actually implemented like this:
+
+
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect(...)
+    if not ok then
+        return nil, err
+    end
+    return sock
+
+
+There is no way to use the [settimeout](http://wiki.nginx.org/HttpLuaModule#tcpsock:settimeout) method to specify connecting timeout for this method and the [lua_socket_connect_timeout](http://wiki.nginx.org/HttpLuaModule#lua_socket_connect_timeout) directive must be set at configure time instead.
+
+This feature was first introduced in the `v0.5.0rc1` release.
+
+ngx.get_phase
+-------------
+**syntax:** *str = ngx.get_phase()*
+
+**context:** *init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Retrieves the current running phase name. Possible return values are
+
+* `init`
+	for the context of [init_by_lua](http://wiki.nginx.org/HttpLuaModule#init_by_lua) or [init_by_lua_file](http://wiki.nginx.org/HttpLuaModule#init_by_lua_file).
+* `set`
+	for the context of [set_by_lua](http://wiki.nginx.org/HttpLuaModule#set_by_lua) or [set_by_lua_file](http://wiki.nginx.org/HttpLuaModule#set_by_lua_file).
+* `rewrite`
+	for the context of [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) or [rewrite_by_lua_file](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua_file).
+* `access`
+	for the context of [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua) or [access_by_lua_file](http://wiki.nginx.org/HttpLuaModule#access_by_lua_file).
+* `content`
+	for the context of [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) or [content_by_lua_file](http://wiki.nginx.org/HttpLuaModule#content_by_lua_file).
+* `header_filter`
+	for the context of [header_filter_by_lua](http://wiki.nginx.org/HttpLuaModule#header_filter_by_lua) or [header_filter_by_lua_file](http://wiki.nginx.org/HttpLuaModule#header_filter_by_lua_file).
+* `body_filter`
+	for the context of [body_filter_by_lua](http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua) or [body_filter_by_lua_file](http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua_file).
+* `log`
+	for the context of [log_by_lua](http://wiki.nginx.org/HttpLuaModule#log_by_lua) or [log_by_lua_file](http://wiki.nginx.org/HttpLuaModule#log_by_lua_file).
+* `timer`
+	for the context of user callback functions for [ngx.timer.*](http://wiki.nginx.org/HttpLuaModule#ngx.timer.at).
+
+This API was first introduced in the `v0.5.10` release.
+
+ngx.thread.spawn
+----------------
+**syntax:** *co = ngx.thread.spawn(func, arg1, arg2, ...)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Spawns a new user "light thread" with the Lua function `func` as well as those optional arguments `arg1`, `arg2`, and etc. Returns a Lua thread (or Lua coroutine) object represents this "light thread".
+
+"Light threads" are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.
+
+Before `ngx.thread.spawn` returns, the `func` will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [Nginx API for Lua](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) (like [tcpsock:receive](http://wiki.nginx.org/HttpLuaModule#tcpsock:receive)).
+
+After `ngx.thread.spawn` returns, the newly-created "light thread" will keep running asynchronously usually at various I/O events.
+
+All the Lua code chunks running by [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua), [access_by_lua](http://wiki.nginx.org/HttpLuaModule#access_by_lua), and [content_by_lua](http://wiki.nginx.org/HttpLuaModule#content_by_lua) are in a boilerplate "light thread" created automatically by ngx_lua. Such boilerplate "light thread" are also called "entry threads".
+
+By default, the corresponding Nginx handler (e.g., [rewrite_by_lua](http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua) handler) will not terminate until
+1. both the "entry thread" and all the user "light threads" terminates,
+1. a "light thread" (either the "entry thread" or a user "light thread" aborts by calling [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit), [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec), [ngx.redirect](http://wiki.nginx.org/HttpLuaModule#ngx.redirect), or [ngx.req.set_uri(uri, true)](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_uri), or
+1. the "entry thread" terminates with a Lua error.
+
+When the user "light thread" terminates with a Lua error, however, it will not abort other running "light threads" like the "entry thread" does.
+
+Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running "light thread" that is pending on one ore more Nginx subrequests. You must call [ngx.thread.wait](http://wiki.nginx.org/HttpLuaModule#ngx.thread.wait) to wait for those "light thread" to terminate before quitting the "world". A notable exception here is that you can abort pending subrequests by calling [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) with and only with the status code `ngx.ERROR` (-1), `408`, `444`, or `499`.
+
+The "light threads" are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A "light thread" will keep running exclusively on the CPU until
+1. a (nonblocking) I/O operation cannot be completed in a single run,
+1. it calls [coroutine.yield](http://wiki.nginx.org/HttpLuaModule#coroutine.yield) to actively give up execution, or
+1. it is aborted by a Lua error or an invocation of [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit), [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec), [ngx.redirect](http://wiki.nginx.org/HttpLuaModule#ngx.redirect), or [ngx.req.set_uri(uri, true)](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_uri).
+
+For the first two cases, the "light thread" will usually be resumed later by the ngx_lua scheduler unless a "stop-the-world" event happens.
+
+User "light threads" can create "light threads" themselves and normal user coroutiens created by [coroutine.create](http://wiki.nginx.org/HttpLuaModule#coroutine.create) can also create "light threads". The coroutine (be it a normal Lua coroutine or a "light thread") that directly spawns the "light thread" is called the "parent coroutine" for the "light thread" newly spawned.
+
+The "parent coroutine" can call [ngx.thread.wait](http://wiki.nginx.org/HttpLuaModule#ngx.thread.wait) to wait on the termination of its child "light thread".
+
+You can call coroutine.status() and coroutine.yield() on the "light thread" coroutines.
+
+The status of the "light thread" coroutine can be "zombie" if
+1. the current "light thread" already terminates (either successfully or with an error),
+1. its parent coroutine is still alive, and
+1. its parent coroutine is not waiting on it with [ngx.thread.wait](http://wiki.nginx.org/HttpLuaModule#ngx.thread.wait).
+
+The following example demonstrates the use of coroutine.yield() in the "light thread" coroutines
+to do manual time-slicing:
+
+
+    local yield = coroutine.yield
+
+    function f()
+        local self = coroutine.running()
+        ngx.say("f 1")
+        yield(self)
+        ngx.say("f 2")
+        yield(self)
+        ngx.say("f 3")
+    end
+
+    local self = coroutine.running()
+    ngx.say("0")
+    yield(self)
+
+    ngx.say("1")
+    ngx.thread.spawn(f)
+
+    ngx.say("2")
+    yield(self)
+
+    ngx.say("3")
+    yield(self)
+
+    ngx.say("4")
+
+
+Then it will generate the output
+
+
+    0
+    1
+    f 1
+    2
+    f 2
+    3
+    f 3
+    4
+
+
+"Light threads" are mostly useful for doing concurrent upstream requests in a single Nginx request handler, kinda like a generalized version of [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi) that can work with all the [Nginx API for Lua](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua). The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (very much like the Facebook BigPipe model):
+
+
+    -- query mysql, memcached, and a remote http service at the same time,
+    -- output the results in the order that they
+    -- actually return the results.
+
+    local mysql = require "resty.mysql"
+    local memcached = require "resty.memcached"
+
+    local function query_mysql()
+        local db = mysql:new()
+        db:connect{
+                    host = "127.0.0.1",
+                    port = 3306,
+                    database = "test",
+                    user = "monty",
+                    password = "mypass"
+                  }
+        local res, err, errno, sqlstate =
+                db:query("select * from cats order by id asc")
+        db:set_keepalive(0, 100)
+        ngx.say("mysql done: ", cjson.encode(res))
+    end
+
+    local function query_memcached()
+        local memc = memcached:new()
+        memc:connect("127.0.0.1", 11211)
+        local res, err = memc:get("some_key")
+        ngx.say("memcached done: ", res)
+    end
+
+    local function query_http()
+        local res = ngx.location.capture("/my-http-proxy")
+        ngx.say("http done: ", res.body)
+    end
+
+    ngx.thread.spawn(query_mysql)      -- create thread 1
+    ngx.thread.spawn(query_memcached)  -- create thread 2
+    ngx.thread.spawn(query_http)       -- create thread 3 
+
+
+This API was first enabled in the `v0.7.0` release.
+
+ngx.thread.wait
+---------------
+**syntax:** *ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Waits on one or more child "light threads" and returns the results of the first "light thread" that terminates (either successfully or with an error).
+
+The arguments `thread1`, `thread2`, and etc are the Lua thread objects returned by earlier calls of [ngx.thread.spawn](http://wiki.nginx.org/HttpLuaModule#ngx.thread.spawn).
+
+The return values have exactly the same meaning as [coroutine.resume](http://wiki.nginx.org/HttpLuaModule#coroutine.resume), that is, the first value returned is a boolean value indicating whether the "light thread" terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the "light thread" (in case of success) or the error object (in case of failure).
+
+Only the direct "parent coroutine" can wait on its child "light thread", otherwise a Lua exception will be raised.
+
+The following example demonstrates the use of `ngx.thread.wait` and [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) to emulate [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi):
+
+
+    local capture = ngx.location.capture
+    local spawn = ngx.thread.spawn
+    local wait = ngx.thread.wait
+    local say = ngx.say
+
+    local function fetch(uri)
+        return capture(uri)
+    end
+
+    local threads = {
+        spawn(fetch, "/foo"),
+        spawn(fetch, "/bar"),
+        spawn(fetch, "/baz")
+    }
+
+    for i = 1, #threads do
+        local ok, res = wait(threads[i])
+        if not ok then
+            say(i, ": failed to run: ", res)
+        else
+            say(i, ": status: ", res.status)
+            say(i, ": body: ", res.body)
+        end
+    end
+
+
+Here it essentially implements the "wait all" model.
+
+And below is an example demonstrating the "wait any" model:
+
+
+    function f()
+        ngx.sleep(0.2)
+        ngx.say("f: hello")
+        return "f done"
+    end
+
+    function g()
+        ngx.sleep(0.1)
+        ngx.say("g: hello")
+        return "g done"
+    end
+
+    local tf, err = ngx.thread.spawn(f)
+    if not tf then
+        ngx.say("failed to spawn thread f: ", err)
+        return
+    end
+
+    ngx.say("f thread created: ", coroutine.status(tf))
+
+    local tg, err = ngx.thread.spawn(g)
+    if not tg then
+        ngx.say("failed to spawn thread g: ", err)
+        return
+    end
+
+    ngx.say("g thread created: ", coroutine.status(tg))
+
+    ok, res = ngx.thread.wait(tf, tg)
+    if not ok then
+        ngx.say("failed to wait: ", res)
+        return
+    end
+
+    ngx.say("res: ", res)
+
+    -- stop the "world", aborting other running threads
+    ngx.exit(ngx.OK)
+
+
+And it will generate the following output:
+
+
+    f thread created: running
+    g thread created: running
+    g: hello
+    res: g done
+
+
+This API was first enabled in the `v0.7.0` release.
+
+ngx.on_abort
+------------
+**syntax:** *ok, err = ngx.on_abort(callback)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua**
+
+Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.
+
+Returns `1` if the callback is registered successfully or returns `nil` and a string describing the error otherwise.
+
+All the [Nginx API for Lua](http://wiki.nginx.org/HttpLuaModule#Nginx_API_for_Lua) can be used in the callback function because the function is run in a special "light thread", just as those "light threads" created by [ngx.thread.spawn](http://wiki.nginx.org/HttpLuaModule#ngx.thread.spawn).
+
+The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit), for example,
+
+
+    local function my_cleanup()
+        -- custom cleanup work goes here, like cancelling a pending DB transaction
+
+        -- now abort all the "light threads" running in the current request handler
+        ngx.exit(499)
+    end
+
+    local ok, err = ngx.on_abort(my_cleanup)
+    if not ok then
+        ngx.log(ngx.ERR, "failed to register the on_abort callback: ", err)
+        ngx.exit(500)
+    end
+
+
+When [lua_check_client_abort](http://wiki.nginx.org/HttpLuaModule#lua_check_client_abort) is set to `off` (which is the default), then this function call will always return the error message "lua_check_client_abort is off".
+
+According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message "duplicate call".
+
+This API was first introduced in the `v0.7.4` release.
+
+See also [lua_check_client_abort](http://wiki.nginx.org/HttpLuaModule#lua_check_client_abort).
+
+ngx.timer.at
+------------
+**syntax:** *ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+Creates an Nginx timer with a user callback function as well as optional user arguments.
+
+The first argument, `delay`, specifies the delay for the timer,
+in seconds. One can specify fractional seconds like `0.001` to mean 1
+millisecond here. `0` delay can also be specified, in which case the
+timer will immediately expire when the current handler yields
+execution.
+
+The second argument, `callback`, can
+be any Lua function, which will be invoked later in a background
+"light thread" after the delay specified. The user callback will be
+called automatically by the Nginx core with the arguments `premature`,
+`user_arg1`, `user_arg2`, and etc, where the `premature`
+argument takes a boolean value indicating whether it is a premature timer
+expiration or not, and `user_arg1`, `user_arg2`, and etc, are
+those (extra) user arguments specified when calling `ngx.timer.at`
+as the remaining arguments.
+
+Premature timer expiration happens when the Nginx worker process is
+trying to shut down, as in an Nginx configuration reload triggered by
+the `HUP` signal or in an Nginx server shutdown. When the Nginx worker
+is trying to shut down, one can no longer call `ngx.timer.at` to
+create new timers and in that case `ngx.timer.at` will return `nil` and
+a string describing the error, that is, "process exiting".
+
+When a timer expires, the user Lua code in the timer callback is
+running in a "light thread" detached completely from the original
+request creating the timer. So objects with the same lifetime as the
+request creating them, like [cosockets](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp), cannot be shared between the
+original request and the timer user callback function.
+
+Here is a simple example:
+
+
+    location / {
+        ...
+        log_by_lua '
+            local function push_data(premature, uri, args, status)
+                -- push the data uri, args, and status to the remote
+                -- via ngx.socket.tcp or ngx.socket.udp
+                -- (one may want to buffer the data in Lua a bit to
+                -- save I/O operations)
+            end
+            local ok, err = ngx.timer.at(0, push_data,
+                                         ngx.var.uri, ngx.var.args, ngx.header.status)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to create timer: ", err)
+                return
+            end
+        ';
+    }
+
+
+One can also create infinite re-occuring timers, for instance, a timer getting triggered every `5` seconds, by calling `ngx.timer.at` recursively in the timer callback function. Here is such an example,
+
+
+    local delay = 5
+    local handler
+    handler = function (premature)
+        -- do some routine job in Lua just like a cron job
+        if premature then
+            return
+        end
+        local ok, err = ngx.timer.at(delay, handler)
+        if not ok then
+            ngx.log(ngx.ERR, "failed to create the timer: ", err)
+            return
+        end
+    end
+    
+    local ok, err = ngx.timer.at(delay, handler)
+    if not ok then
+        ngx.log(ngx.ERR, "failed to create the timer: ", err)
+        return
+    end
+
+
+Because timer callbacks run in the background and their running time
+will not add to any client request's response time, they can easily
+accumulate in the server and exhaust system resources due to either
+Lua programming mistakes or just too much client traffic. To prevent
+extreme consequences like crashing the Nginx server, there are
+built-in limitations on both the number of "pending timers" and the
+number of "running timers" in an Nginx worker process. The "pending
+timers" here mean timers that have not yet been expired and "running
+timers" are those whose user callbacks are currently running.
+
+The maximal number of pending timers allowed in an Nginx
+worker is constrolled by the [lua_max_pending_timers](http://wiki.nginx.org/HttpLuaModule#lua_max_pending_timers)
+directive. The maximal number of running timers is controlled by the
+[lua_max_running_timers](http://wiki.nginx.org/HttpLuaModule#lua_max_running_timers) directive.
+
+According to the current implementation, each "running timer" will
+take one (fake) connection record from the global connection record
+list configured by the standard [worker_connections](http://wiki.nginx.org/EventsModule#worker_connections) directive in
+`nginx.conf`. So ensure that the
+[worker_connections](http://wiki.nginx.org/EventsModule#worker_connections) directive is set to
+a large enough value that takes into account both the real connections
+and fake connections required by timer callbacks (as limited by the
+[lua_max_running_timers](http://wiki.nginx.org/HttpLuaModule#lua_max_running_timers) directive).
+
+A lot of the Lua APIs for Nginx are enabled in the context of the timer
+callbacks, like stream/datagram cosockets ([ngx.socket.tcp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.tcp) and [ngx.socket.udp](http://wiki.nginx.org/HttpLuaModule#ngx.socket.udp)), shared
+memory dictionaries ([ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT)), user coroutines ([coroutine.*](http://wiki.nginx.org/HttpLuaModule#coroutine.create)),
+user "light threads" ([ngx.thread.*](http://wiki.nginx.org/HttpLuaModule#ngx.thread.spawn)), [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit), [ngx.now](http://wiki.nginx.org/HttpLuaModule#ngx.now)/[ngx.time](http://wiki.nginx.org/HttpLuaModule#ngx.time),
+[ngx.md5](http://wiki.nginx.org/HttpLuaModule#ngx.md5)/[ngx.sha1_bin](http://wiki.nginx.org/HttpLuaModule#ngx.sha1_bin), are all allowed. But the subrequest API (like
+[ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture)), the [ngx.req.*](http://wiki.nginx.org/HttpLuaModule#ngx.req.start_time) API, the downstream output API
+(like [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say), [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print), and [ngx.flush](http://wiki.nginx.org/HttpLuaModule#ngx.flush)) are explicitly disabled in
+this context.
+
+This API was first introduced in the `v0.8.0` release.
+
+ngx.config.debug
+----------------
+**syntax:** *debug = ngx.config.debug*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua**
+
+This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the `./configure` option `--with-debug`.
+
+This field was first introduced in the `0.8.7`.
+
+ndk.set_var.DIRECTIVE
+---------------------
+**syntax:** *res = ndk.set_var.DIRECTIVE_NAME*
+
+**context:** *set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.**
+
+This mechanism allows calling other nginx C modules' directives that are implemented by [Nginx Devel Kit](https://github.com/simpl/ngx_devel_kit) (NDK)'s set_var submodule's `ndk_set_var_value`.
+
+For example, the following [HttpSetMiscModule](http://wiki.nginx.org/HttpSetMiscModule) directives can be invoked this way:
+
+* [set_quote_sql_str](http://wiki.nginx.org/HttpSetMiscModule#set_quote_sql_str)
+* [set_quote_pgsql_str](http://wiki.nginx.org/HttpSetMiscModule#set_quote_pgsql_str)
+* [set_quote_json_str](http://wiki.nginx.org/HttpSetMiscModule#set_quote_json_str)
+* [set_unescape_uri](http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri)
+* [set_escape_uri](http://wiki.nginx.org/HttpSetMiscModule#set_escape_uri)
+* [set_encode_base32](http://wiki.nginx.org/HttpSetMiscModule#set_encode_base32)
+* [set_decode_base32](http://wiki.nginx.org/HttpSetMiscModule#set_decode_base32)
+* [set_encode_base64](http://wiki.nginx.org/HttpSetMiscModule#set_encode_base64)
+* [set_decode_base64](http://wiki.nginx.org/HttpSetMiscModule#set_decode_base64)
+* [set_encode_hex](http://wiki.nginx.org/HttpSetMiscModule#set_encode_base64)
+* [set_decode_hex](http://wiki.nginx.org/HttpSetMiscModule#set_decode_base64)
+* [set_sha1](http://wiki.nginx.org/HttpSetMiscModule#set_encode_base64)
+* [set_md5](http://wiki.nginx.org/HttpSetMiscModule#set_decode_base64)
+
+For instance,
+
+
+    local res = ndk.set_var.set_escape_uri('a/b');
+    -- now res == 'a%2fb'
+
+
+Similarly, the following directives provided by [HttpEncryptedSessionModule](http://wiki.nginx.org/HttpEncryptedSessionModule) can be invoked from within Lua too:
+
+* [set_encrypt_session](http://wiki.nginx.org/HttpEncryptedSessionModule#set_encrypt_session)
+* [set_decrypt_session](http://wiki.nginx.org/HttpEncryptedSessionModule#set_decrypt_session)
+
+This feature requires the [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) module.
+
+coroutine.create
+----------------
+**syntax:** *co = coroutine.create(f)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Creates a user Lua coroutines with a Lua function, and returns a coroutine object.
+
+Similar to the standard Lua [coroutine.create](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create) API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the `v0.6.0` release.
+
+coroutine.resume
+----------------
+**syntax:** *ok, ... = coroutine.resume(co, ...)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Resumes the executation of a user Lua coroutine object previously yielded or just created.
+
+Similar to the standard Lua [coroutine.resume](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume) API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the `v0.6.0` release.
+
+coroutine.yield
+---------------
+**syntax:** *... = coroutine.yield(co, ...)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Yields the executation of the current user Lua coroutine.
+
+Similar to the standard Lua [coroutine.yield](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield) API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the `v0.6.0` release.
+
+coroutine.wrap
+--------------
+**syntax:** *co = coroutine.wrap(f)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Similar to the standard Lua [coroutine.wrap](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap) API, but works in the context of the Lua coroutines created by ngx_lua.
+
+This API was first introduced in the `v0.6.0` release.
+
+coroutine.running
+-----------------
+**syntax:** *co = coroutine.running()*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Identical to the standard Lua [coroutine.running](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running) API.
+
+This API was first enabled in the `v0.6.0` release.
+
+coroutine.status
+----------------
+**syntax:** *status = coroutine.status(co)*
+
+**context:** *rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**
+
+Identical to the standard Lua [coroutine.status](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status) API.
+
+This API was first enabled in the `v0.6.0` release.
+
+Lua/LuaJIT bytecode support
+===========================
+
+As from the `v0.5.0rc32` release, all `*_by_lua_file` configure directives (such as [content_by_lua_file](http://wiki.nginx.org/HttpLuaModule#content_by_lua_file)) support loading Lua 5.1 and LuaJIT 2.0 raw bytecode files directly.
+
+Please note that the bytecode format used by LuaJIT 2.0 is not compatible with that used by the standard Lua 5.1 interpreter. So if using LuaJIT 2.0 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:
+
+
+    /path/to/luajit/bin/luajit -b /path/to/input_file.lua /path/to/output_file.luac
+
+
+The `-bg` option can be used to include debug information in the LuaJIT bytecode file:
+
+
+    /path/to/luajit/bin/luajit -bg /path/to/input_file.lua /path/to/output_file.luac
+
+
+Please refer to the official LuaJIT documentation on the `-b` option for more details:
+
+<http://luajit.org/running.html#opt_b>
+
+Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua compatible bytecode files must be generated using the `luac` commandline utility as shown:
+
+
+    luac -o /path/to/output_file.luac /path/to/input_file.lua
+
+
+Unlike as with LuaJIT, debug information is included in standard Lua 5.1 bytecode files by default. This can be striped out by specifying the `-s` option as shown:
+
+
+    luac -s -o /path/to/output_file.luac /path/to/input_file.lua
+
+
+Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0 or vice versa, will result in an error message, such as that below, being logged into the Nginx `error.log` file:
+
+
+    [error] 13909#0: *1 failed to load Lua inlined code: bad byte-code header in /path/to/test_file.luac
+
+
+Loading bytecode files via the Lua primitives like `require` and `dofile` should always work as expected.
+
+HTTP 1.0 support
+================
+
+The HTTP 1.0 protocol does not support chunked output and requires an explicit `Content-Length` header when the response body is not empty in order to support the HTTP 1.0 keep-alive.
+So when a HTTP 1.0 request is made and the [lua_http10_buffering](http://wiki.nginx.org/HttpLuaModule#lua_http10_buffering) directive is turned `on`, ngx_lua will buffer the
+output of [ngx.say](http://wiki.nginx.org/HttpLuaModule#ngx.say) and [ngx.print](http://wiki.nginx.org/HttpLuaModule#ngx.print) calls and also postpone sending response headers until all the response body output is received.
+At that time ngx_lua can calculate the total length of the body and construct a proper `Content-Length` header to return to the HTTP 1.0 client.
+If the `Content-Length` response header is set in the running Lua code, however, this buffering will be disabled even if the [lua_http10_buffering](http://wiki.nginx.org/HttpLuaModule#lua_http10_buffering) directive is turned `on`.
+
+For large streaming output responses, it is important to disable the [lua_http10_buffering](http://wiki.nginx.org/HttpLuaModule#lua_http10_buffering) directive to minimise memory usage.
+
+Note that common HTTP benchmark tools such as `ab` and `http_load` issue HTTP 1.0 requests by default.
+To force `curl` to send HTTP 1.0 requests, use the `-0` option.
+
+Data Sharing within an Nginx Worker
+===================================
+
+To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua `require` builtin to import the module, and then manipulate the shared data in Lua. This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module (both its code and data). Note however that Lua global variables (note, not module-level variables) WILL NOT persist between requests because of the one-coroutine-per-request isolation design.
+
+Here is a complete small example:
+
+
+    -- mydata.lua
+    local _M = {}
+
+    local data = {
+        dog = 3,
+        cat = 4,
+        pig = 5,
+    }
+ 
+    function _M.get_age(name)
+        return data[name]
+    end
+
+    return _M
+
+
+and then accessing it from `nginx.conf`:
+
+
+    location /lua {
+        content_by_lua '
+            local mydata = require "mydata"
+            ngx.say(mydata.get_age("dog"))
+        ';
+    }
+
+
+The `mydata` module in this example will only be loaded and run on the first request to the location `/lua`,
+and all subsequent requests to the same nginx worker process will use the reloaded instance of the
+module as well as the same copy of the data in it, until a `HUP` signal is sent to the Nginx master process to force a reload.
+This data sharing technique is essential for high performance Lua applications based on this module.
+
+Note that this data sharing is on a *per-worker* basis and not on a *per-server* basis. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.
+
+If server-wide data sharing is required, then use one or more of the following approaches:
+1. Use the [ngx.shared.DICT](http://wiki.nginx.org/HttpLuaModule#ngx.shared.DICT) API provided by this module.
+1. Use only a single nginx worker and a single server (this is however not recommended when there is a multi core CPU or multiple CPUs in a single machine).
+1. Use data storage mechanisms such as `memcached`, `redis`, `MySQL` or `PostgreSQL`. [The ngx_openresty bundle](http://openresty.org) associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.
+
+Known Issues
+============
+
+TCP socket connect operation issues
+-----------------------------------
+The [tcpsock:connect](http://wiki.nginx.org/HttpLuaModule#tcpsock:connect) method may indicate `success` despite connection failures such as with `Connection Refused` errors. 
+
+However, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation. 
+
+This issue is due to limitations in the Nginx event model and only appears to affect Mac OS X.
+
+Lua Coroutine Yielding/Resuming
+-------------------------------
+* Lua's `dofile` builtin is implemented as a C function in both Lua 5.1 and LuaJIT 2.0 and when [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) is called, [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec), [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) or [ngx.req.read_body](http://wiki.nginx.org/HttpLuaModule#ngx.req.read_body) or similar in the file to be loaded by `dofile`, a coroutine yield across the C function boundary will be initiated. This however is not normally allowed within ngx_lua and will usually result in error messages like `lua handler aborted: runtime error: attempt to yield across C-call boundary`. To avoid this, define a real Lua module and use the Lua `require` builtin instead.
+* As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture), [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi), [ngx.redirect](http://wiki.nginx.org/HttpLuaModule#ngx.redirect), [ngx.exec](http://wiki.nginx.org/HttpLuaModule#ngx.exec), and [ngx.exit](http://wiki.nginx.org/HttpLuaModule#ngx.exit) cannot be used within the context of a Lua [pcall()](http://www.lua.org/manual/5.1/manual.html#pdf-pcall) or [xpcall()](http://www.lua.org/manual/5.1/manual.html#pdf-xpcall) or even the first line of the `for ... in ...` statement when the standard Lua 5.1 interpreter is used and the `attempt to yield across metamethod/C-call boundary` error will be produced. Please use LuaJIT 2.0, which supports a fully resumable VM, to avoid this.
+
+Lua Variable Scope
+------------------
+Care must be taken when importing modules and this form should be used:
+
+
+    local xxx = require('xxx')
+
+
+	instead of the old deprecated form:
+
+
+    require('xxx')
+
+
+Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it. Each request handler has its own set of Lua global variables and that is the idea of request isolation. The Lua module is actually loaded by the first Nginx request handler and is cached by the `require()` built-in in the package.loaded table for later reference, and `require()` has the side effect of setting a global variable to the loaded module table. But this global variable will be cleared at the end of the request handler,  and every subsequent request handler all has its own (clean) global environment. So one will get Lua exception for accessing the `nil` value.
+
+Generally, use of Lua global variables is a really really bad idea in the context of ngx_lua because
+1. misuse of Lua globals has very bad side effects for concurrent requests when these variables are actually supposed to be local only,
+1. Lua global variables require Lua table look-up in the global environment (which is just a Lua table), which is kinda expensive, and
+1. some Lua global variable references are just typos, which are hard to debug.
+
+It's *highly* recommended to always declare them via "local" in the scope that is reasonable.
+
+To find out all the uses of Lua global variables in your Lua code, you can run the [lua-releng tool](https://github.com/agentzh/nginx-devel-utils/blob/master/lua-releng) across all your .lua source files:
+
+    $ lua-releng
+    Checking use of Lua global variables in file lib/foo/bar.lua ...
+            1       [1489]  SETGLOBAL       7 -1    ; contains
+            55      [1506]  GETGLOBAL       7 -3    ; setvar
+            3       [1545]  GETGLOBAL       3 -4    ; varexpand
+
+The output says that the line 1489 of file `lib/foo/bar.lua` writes to a global variable named `contains`, the line 1506 reads from the global variable `setvar`, and line 1545 reads the global `varexpand`.
+
+This tool will guarantee that local variables in the Lua module functions are all declared with the `local` keyword, otherwise a runtime exception will be thrown. It prevents undesirable race conditions while accessing such variables. See [Data Sharing within an Nginx Worker](http://wiki.nginx.org/HttpLuaModule#Data_Sharing_within_an_Nginx_Worker) for the reasons behind this.
+
+Locations Configured by Subrequest Directives of Other Modules
+--------------------------------------------------------------
+The [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi) directives cannot capture locations that include the [echo_location](http://wiki.nginx.org/HttpEchoModule#echo_location), [echo_location_async](http://wiki.nginx.org/HttpEchoModule#echo_location_async), [echo_subrequest](http://wiki.nginx.org/HttpEchoModule#echo_subrequest), or [echo_subrequest_async](http://wiki.nginx.org/HttpEchoModule#echo_subrequest_async) directives.
+
+
+    location /foo {
+        content_by_lua '
+            res = ngx.location.capture("/bar")
+        ';
+    }
+    location /bar {
+        echo_location /blah;
+    }
+    location /blah {
+        echo "Success!";
+    }
+
+
+
+    $ curl -i http://example.com/foo
+
+
+will not work as expected.
+
+Special PCRE Sequences
+----------------------
+PCRE sequences such as `\d`, `\s`, or `\w`, require special attention because in string literals, the backslash character, `\`, is stripped out by both the Lua language parser and by the Nginx config file parser before processing. So the following snippet will not work as expected:
+
+
+    # nginx.conf
+    ? location /test {
+    ?     content_by_lua '
+    ?         local regex = "\d+"  -- THIS IS WRONG!!
+    ?         local m = ngx.re.match("hello, 1234", regex)
+    ?         if m then ngx.say(m[0]) else ngx.say("not matched!") end
+    ?     ';
+    ? }
+    # evaluates to "not matched!"
+
+
+To avoid this, *double* escape the backslash:
+
+
+    # nginx.conf
+    location /test {
+        content_by_lua '
+            local regex = "\\\\d+"
+            local m = ngx.re.match("hello, 1234", regex)
+            if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ';
+    }
+    # evaluates to "1234"
+
+
+Here, `\\\\d+` is stripped down to `\\d+` by the Nginx config file parser and this is further stripped down to `\d+` by the Lua language parser before running.
+
+Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in "long brackets", `[[...]]`, in which case backslashes have to only be escaped once for the Nginx config file parser. 
+
+
+    # nginx.conf
+    location /test {
+        content_by_lua '
+            local regex = [[\\d+]]
+            local m = ngx.re.match("hello, 1234", regex)
+            if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ';
+    }
+    # evaluates to "1234"
+
+
+Here, `[[\\d+]]` is stripped down to `[[\d+]]` by the Nginx config file parser and this is processed correctly.
+
+Note that a longer from of the long bracket, `[=[...]=]`, may be required if the regex pattern contains `[...]` sequences. 
+The `[=[...]=]` form may be used as the default form if desired.
+
+
+    # nginx.conf
+    location /test {
+        content_by_lua '
+            local regex = [=[[0-9]+]=]
+            local m = ngx.re.match("hello, 1234", regex)
+            if m then ngx.say(m[0]) else ngx.say("not matched!") end
+        ';
+    }
+    # evaluates to "1234"
+
+
+An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various `*_by_lua_file` directives. 
+With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.
+
+
+    -- test.lua
+    local regex = "\\d+"
+    local m = ngx.re.match("hello, 1234", regex)
+    if m then ngx.say(m[0]) else ngx.say("not matched!") end
+    -- evaluates to "1234"
+
+
+Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification. 
+ 
+
+    -- test.lua
+    local regex = [[\d+]]
+    local m = ngx.re.match("hello, 1234", regex)
+    if m then ngx.say(m[0]) else ngx.say("not matched!") end
+    -- evaluates to "1234"
+
+
+Mixing with SSI Not Supported
+-----------------------------
+
+Mixing SSI with ngx_lua in the same Nginx request is not supported at all. Just use ngx_lua exclusively. Everything you can do with SSI can be done atop ngx_lua anyway and it can be more efficient when using ngx_lua.
+
+SPDY Mode Not Fully Supported
+-----------------------------
+
+Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode yet: [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture), [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi), and [ngx.req.socket](http://wiki.nginx.org/HttpLuaModule#ngx.req.socket).
+
+Typical Uses
+============
+
+Just to name a few:
+
+* Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,
+* doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends,
+* manipulating response headers in an arbitrary way (by Lua)
+* fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly,
+* coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage,
+* doing very complex URL dispatch in Lua at rewrite phase,
+* using Lua to implement advanced caching mechanism for Nginx's subrequests and arbitrary locations.
+
+The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user. The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint. This is particularly the case when LuaJIT 2.0 is enabled. 
+
+Other scripting language implementations typically struggle to match this performance level.
+
+The Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to minimize memory use.
+
+On a ThinkPad T400 2.80 GHz laptop, the Hello World example readily achieves 28k req/sec using `http_load -p 10`. By contrast, Nginx + php-fpm 5.2.8 + Unix Domain Socket yields 6k req/sec and [Node.js](http://nodejs.org/) v0.6.1 yields 10.2k req/sec for their Hello World equivalents.
+
+Nginx Compatibility
+===================
+The latest module is compatible with the following versions of Nginx:
+
+* 1.5.x (last tested: 1.5.4)
+* 1.4.x (last tested: 1.4.2)
+* 1.3.x (last tested: 1.3.11)
+* 1.2.x (last tested: 1.2.9)
+* 1.1.x (last tested: 1.1.5)
+* 1.0.x (last tested: 1.0.15)
+* 0.9.x (last tested: 0.9.4)
+* 0.8.x >= 0.8.54 (last tested: 0.8.54)
+
+Code Repository
+===============
+
+The code repository of this project is hosted on github at [chaoslawful/lua-nginx-module](http://github.com/chaoslawful/lua-nginx-module).
+
+Installation
+============
+
+The [ngx_openresty bundle](http://openresty.org) can be used to install Nginx, ngx_lua, either one of the standard Lua 5.1 interpreter or LuaJIT 2.0, as well as a package of powerful companion Nginx modules. The basic installation step is a simple `./configure --with-luajit && make && make install`.
+
+Alternatively, ngx_lua can be manually compiled into Nginx:
+
+1. Install LuaJIT 2.0 (recommended) or Lua 5.1 (Lua 5.2 is *not* supported yet). LuajIT can be downloaded from the [the LuaJIT project website](http://luajit.org/download.html) and Lua 5.1, from the [Lua project website](http://www.lua.org/).  Some distribution package managers also distribute LuajIT and/or Lua.
+1. Download the latest version of the ngx_devel_kit (NDK) module [HERE](http://github.com/simpl/ngx_devel_kit/tags).
+1. Download the latest version of ngx_lua [HERE](http://github.com/chaoslawful/lua-nginx-module/tags).
+1. Download the latest version of Nginx [HERE](http://nginx.org/) (See [Nginx Compatibility](http://wiki.nginx.org/HttpLuaModule#Nginx_Compatibility))
+
+Build the source with this module:
+
+
+    wget 'http://nginx.org/download/nginx-1.4.2.tar.gz'
+    tar -xzvf nginx-1.4.2.tar.gz
+    cd nginx-1.4.2/
+
+    # tell nginx's build system where to find LuaJIT:
+    export LUAJIT_LIB=/path/to/luajit/lib
+    export LUAJIT_INC=/path/to/luajit/include/luajit-2.0
+ 
+    # or tell where to find Lua if using Lua instead:
+    #export LUA_LIB=/path/to/lua/lib
+    #export LUA_INC=/path/to/lua/include
+ 
+    # Here we assume Nginx is to be installed under /opt/nginx/.
+    ./configure --prefix=/opt/nginx \
+            --add-module=/path/to/ngx_devel_kit \
+            --add-module=/path/to/lua-nginx-module
+ 
+    make -j2
+    make install
+
+
+Installation on Ubuntu 11.10
+----------------------------
+
+Note that it is recommended to use LuaJIT 2.0 instead of the standard Lua 5.1 interpreter where possible. 
+
+If the standard Lua 5.1 interpreter is required however, run the following command to install it from the Ubuntu repository:
+
+
+    apt-get install -y lua5.1 liblua5.1-0 liblua5.1-0-dev
+
+
+Everything should be installed correctly, except for one small tweak. 
+
+Library name `liblua.so` has been changed in liblua5.1 package, it only comes with `liblua5.1.so`, which needs to be symlinked to `/usr/lib` so it could be found during the configuration process.
+
+
+    ln -s /usr/lib/x86_64-linux-gnu/liblua5.1.so /usr/lib/liblua.so
+
+
+Community
+=========
+
+English Mailing List
+--------------------
+
+The [openresty-en](https://groups.google.com/group/openresty-en) mailing list is for English speakers.
+
+Chinese Mailing List
+--------------------
+
+The [openresty](https://groups.google.com/group/openresty) mailing list is for Chinese speakers.
+
+Bugs and Patches
+================
+
+Please submit bug reports, wishlists, or patches by
+
+1. creating a ticket on the [GitHub Issue Tracker](http://github.com/chaoslawful/lua-nginx-module/issues),
+1. or posting to the [OpenResty community](http://wiki.nginx.org/HttpLuaModule#Community).
+
+TODO
+====
+
+Short Term
+----------
+* review and apply Brian Akin's patch for the new directive `lua_socket_log_errors`.
+* review and apply Brian Akin's patch for the new `shdict:flush_expired()` API.
+* implement the SSL cosocket API.
+* review and apply Jader H. Silva's patch for `ngx.re.split()`.
+* review and apply vadim-pavlov's patch for [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture)'s `extra_headers` option
+* use `ngx_hash_t` to optimize the built-in header look-up process for [ngx.req.set_header](http://wiki.nginx.org/HttpLuaModule#ngx.req.set_header), [ngx.header.HEADER](http://wiki.nginx.org/HttpLuaModule#ngx.header.HEADER), and etc.
+* add configure options for different strategies of handling the cosocket connection exceeding in the pools.
+* add directives to run Lua codes when nginx stops.
+* add APIs to access cookies as key/value pairs.
+* add `ignore_resp_headers`, `ignore_resp_body`, and `ignore_resp` options to [ngx.location.capture](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture) and [ngx.location.capture_multi](http://wiki.nginx.org/HttpLuaModule#ngx.location.capture_multi) methods, to allow micro performance tuning on the user side.
+* implement new directive `lua_ignore_client_abort`.
+
+Longer Term
+-----------
+* add lightweight thread API (i.e., the `ngx.thread` API) as demonstrated in [this sample code](http://agentzh.org/misc/nginx/lua-thread2.lua).
+* add automatic Lua code time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks.
+* add `stat` mode similar to [mod_lua](http://httpd.apache.org/docs/2.3/mod/mod_lua.html).
+
+Changes
+=======
+
+The changes of every release of this module can be obtained from the ngx_openresty bundle's change logs:
+
+<http://openresty.org/#Changes>
+
+Test Suite
+==========
+
+The following dependencies are required to run the test suite:
+
+* Nginx version >= 1.4.2
+
+* Perl modules:
+	* Test::Nginx: <http://github.com/agentzh/test-nginx> 
+
+* Nginx modules:
+	* [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit)
+	* [ngx_set_misc](http://github.com/agentzh/set-misc-nginx-module)
+	* [ngx_auth_request](http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz) (this is not needed if you're using Nginx 1.5.4+.
+	* [ngx_echo](http://github.com/agentzh/echo-nginx-module)
+	* [ngx_memc](http://github.com/agentzh/memc-nginx-module)
+	* [ngx_srcache](http://github.com/agentzh/srcache-nginx-module)
+	* ngx_lua (i.e., this module)
+	* [ngx_headers_more](http://github.com/agentzh/headers-more-nginx-module)
+	* [ngx_drizzle](http://github.com/chaoslawful/drizzle-nginx-module)
+	* [ngx_rds_json](http://github.com/agentzh/rds-json-nginx-module)
+	* [ngx_coolkit](https://github.com/FRiCKLE/ngx_coolkit)
+	* [ngx_redis2](http://github.com/agentzh/redis2-nginx-module)
+
+The order in which these modules are added during configuration is important because the position of any filter module in the
+filtering chain determines the final output, for example. The correct adding order is shown above.
+
+* 3rd-party Lua libraries:
+	* [lua-cjson](http://www.kyne.com.au/~mark/software/lua-cjson.php)
+
+* Applications:
+	* mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
+	* memcached: listening on the default port, 11211.
+	* redis: listening on the default port, 6379.
+
+See also the [developer build script](https://github.com/chaoslawful/lua-nginx-module/blob/master/util/build2.sh) for more details on setting up the testing environment.
+
+To run the whole test suite in the default testing mode:
+
+    cd /path/to/lua-nginx-module
+    export PATH=/path/to/your/nginx/sbin:$PATH
+    prove -I/path/to/test-nginx/lib -r t
+
+
+To run specific test files:
+
+    cd /path/to/lua-nginx-module
+    export PATH=/path/to/your/nginx/sbin:$PATH
+    prove -I/path/to/test-nginx/lib t/002-content.t t/003-errors.t
+
+
+To run a specific test block in a particular test file, add the line `--- ONLY` to the test block you want to run, and then use the `prove` utility to run that `.t` file.
+
+There are also various testing modes based on mockeagain, valgrind, and etc. Refer to the [Test::Nginx documentation](http://search.cpan.org/perldoc?Test::Nginx) for more details for various advanced testing modes. See also the test reports for the Nginx test cluster running on Amazon EC2: <http://qa.openresty.org.>
+
+Copyright and License
+=====================
+
+This module is licensed under the BSD license.
+
+Copyright (C) 2009-2013, by Xiaozhe Wang (chaoslawful) <chaoslawful@gmail.com>.
+
+Copyright (C) 2009-2013, by Yichun "agentzh" Zhang (章亦春) <agentzh@gmail.com>, CloudFlare Inc.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+See Also
+========
+
+* [lua-resty-memcached](http://github.com/agentzh/lua-resty-memcached) library based on ngx_lua cosocket.
+* [lua-resty-redis](http://github.com/agentzh/lua-resty-redis) library based on ngx_lua cosocket.
+* [lua-resty-mysql](http://github.com/agentzh/lua-resty-mysql) library based on ngx_lua cosocket.
+* [lua-resty-upload](http://github.com/agentzh/lua-resty-upload) library based on ngx_lua cosocket.
+* [lua-resty-dns](http://github.com/agentzh/lua-resty-dns) library based on ngx_lua cosocket.
+* [lua-resty-websocket](http://github.com/agentzh/lua-resty-websocket) library for both WebSocket server and client, based on ngx_lua cosocket.
+* [lua-resty-string](http://github.com/agentzh/lua-resty-string) library based on [LuaJIT FFI](http://luajit.org/ext_ffi.html).
+* [lua-resty-lock](http://github.com/agentzh/lua-resty-lock) library for a nonblocking simple lock API.
+* [Routing requests to different MySQL queries based on URI arguments](http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs)
+* [Dynamic Routing Based on Redis and Lua](http://openresty.org/#DynamicRoutingBasedOnRedis)
+* [Using LuaRocks with ngx_lua](http://openresty.org/#UsingLuaRocks)
+* [Introduction to ngx_lua](https://github.com/chaoslawful/lua-nginx-module/wiki/Introduction)
+* [ngx_devel_kit](http://github.com/simpl/ngx_devel_kit)
+* [HttpEchoModule](http://wiki.nginx.org/HttpEchoModule)
+* [HttpDrizzleModule](http://wiki.nginx.org/HttpDrizzleModule)
+* [postgres-nginx-module](http://github.com/FRiCKLE/ngx_postgres)
+* [HttpMemcModule](http://wiki.nginx.org/HttpMemcModule)
+* [The ngx_openresty bundle](http://openresty.org)
+* [Nginx Systemtap Toolkit](https://github.com/agentzh/nginx-systemtap-toolkit)
+
diff -rNu a/src/lua/lua-nginx-module/src/api/ngx_http_lua_api.h b/src/lua/lua-nginx-module/src/api/ngx_http_lua_api.h
--- a/src/lua/lua-nginx-module/src/api/ngx_http_lua_api.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/api/ngx_http_lua_api.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,47 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_API_H_INCLUDED_
+#define _NGX_HTTP_LUA_API_H_INCLUDED_
+
+
+#include <nginx.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+#include <lua.h>
+
+
+/* Public API for other Nginx modules */
+
+typedef struct {
+    uint8_t         type;
+
+    union {
+        int         b; /* boolean */
+        lua_Number  n; /* number */
+        ngx_str_t   s; /* string */
+    } value;
+
+} ngx_http_lua_value_t;
+
+
+lua_State * ngx_http_lua_get_global_state(ngx_conf_t *cf);
+
+ngx_http_request_t * ngx_http_lua_get_request(lua_State *L);
+
+ngx_int_t ngx_http_lua_add_package_preload(ngx_conf_t *cf, const char *package,
+    lua_CFunction func);
+
+ngx_int_t ngx_http_lua_shared_dict_get(ngx_shm_zone_t *shm_zone,
+    u_char *key_data, size_t key_len, ngx_http_lua_value_t *value);
+
+ngx_shm_zone_t *ngx_http_lua_find_zone(u_char *name_data, size_t name_len);
+
+
+#endif /* _NGX_HTTP_LUA_API_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ddebug.h b/src/lua/lua-nginx-module/src/ddebug.h
--- a/src/lua/lua-nginx-module/src/ddebug.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ddebug.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,82 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _DDEBUG_H_INCLUDED_
+#define _DDEBUG_H_INCLUDED_
+
+
+#include <nginx.h>
+#include <ngx_core.h>
+
+
+#if defined(DDEBUG) && (DDEBUG)
+
+#   if (NGX_HAVE_VARIADIC_MACROS)
+
+#       define dd(...) fprintf(stderr, "lua *** %s: ", __func__); \
+            fprintf(stderr, __VA_ARGS__); \
+            fprintf(stderr, " at %s line %d.\n", __FILE__, __LINE__)
+
+#   else
+
+#include <stdarg.h>
+#include <stdio.h>
+
+#include <stdarg.h>
+
+static void dd(const char *fmt, ...) {
+}
+
+#    endif
+
+#else
+
+#   if (NGX_HAVE_VARIADIC_MACROS)
+
+#       define dd(...)
+
+#   else
+
+#include <stdarg.h>
+
+static void dd(const char *fmt, ...) {
+}
+
+#   endif
+
+#endif
+
+#if defined(DDEBUG) && (DDEBUG)
+
+#define dd_check_read_event_handler(r)   \
+    dd("r->read_event_handler = %s", \
+        r->read_event_handler == ngx_http_block_reading ? \
+            "ngx_http_block_reading" : \
+        r->read_event_handler == ngx_http_test_reading ? \
+            "ngx_http_test_reading" : \
+        r->read_event_handler == ngx_http_request_empty_handler ? \
+            "ngx_http_request_empty_handler" : "UNKNOWN")
+
+#define dd_check_write_event_handler(r)   \
+    dd("r->write_event_handler = %s", \
+        r->write_event_handler == ngx_http_handler ? \
+            "ngx_http_handler" : \
+        r->write_event_handler == ngx_http_core_run_phases ? \
+            "ngx_http_core_run_phases" : \
+        r->write_event_handler == ngx_http_request_empty_handler ? \
+            "ngx_http_request_empty_handler" : "UNKNOWN")
+
+#else
+
+#define dd_check_read_event_handler(r)
+#define dd_check_write_event_handler(r)
+
+#endif
+
+
+#endif /* _DDEBUG_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,324 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include <nginx.h>
+#include "ngx_http_lua_accessby.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_cache.h"
+
+
+static ngx_int_t ngx_http_lua_access_by_chunk(lua_State *L,
+    ngx_http_request_t *r);
+
+
+ngx_int_t
+ngx_http_lua_access_handler(ngx_http_request_t *r)
+{
+    ngx_int_t                   rc;
+    ngx_http_lua_ctx_t         *ctx;
+    ngx_http_lua_loc_conf_t    *llcf;
+    ngx_http_lua_main_conf_t   *lmcf;
+    ngx_http_phase_handler_t    tmp, *ph, *cur_ph, *last_ph;
+    ngx_http_core_main_conf_t  *cmcf;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua access handler, uri:\"%V\" c:%ud", &r->uri,
+                   r->main->count);
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    if (!lmcf->postponed_to_access_phase_end) {
+
+        lmcf->postponed_to_access_phase_end = 1;
+
+        cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+        ph = cmcf->phase_engine.handlers;
+        cur_ph = &ph[r->phase_handler];
+
+        /* we should skip the post_access phase handler here too */
+        last_ph = &ph[cur_ph->next - 2];
+
+        dd("ph cur: %d, ph next: %d", (int) r->phase_handler,
+           (int) (cur_ph->next - 2));
+
+#if 0
+        if (cur_ph == last_ph) {
+            dd("XXX our handler is already the last access phase handler");
+        }
+#endif
+
+        if (cur_ph < last_ph) {
+            dd("swaping the contents of cur_ph and last_ph...");
+
+            tmp = *cur_ph;
+
+            memmove(cur_ph, cur_ph + 1,
+                    (last_ph - cur_ph) * sizeof (ngx_http_phase_handler_t));
+
+            *last_ph = tmp;
+
+            r->phase_handler--; /* redo the current ph */
+
+            return NGX_DECLINED;
+        }
+    }
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->access_handler == NULL) {
+        dd("no access handler found");
+        return NGX_DECLINED;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+    }
+
+    dd("entered? %d", (int) ctx->entered_access_phase);
+
+    if (ctx->entered_access_phase) {
+        dd("calling wev handler");
+        rc = ctx->resume_handler(r);
+        dd("wev handler returns %d", (int) rc);
+
+        if (rc == NGX_ERROR || rc == NGX_DONE || rc >= NGX_OK) {
+            return rc;
+        }
+
+        return NGX_DECLINED;
+    }
+
+    if (ctx->waiting_more_body) {
+        dd("WAITING MORE BODY");
+        return NGX_DONE;
+    }
+
+    if (llcf->force_read_body && !ctx->read_body_done) {
+        r->request_body_in_single_buf = 1;
+        r->request_body_in_persistent_file = 1;
+        r->request_body_in_clean_file = 1;
+
+        rc = ngx_http_read_client_request_body(r,
+                                       ngx_http_lua_generic_phase_post_read);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+#if (nginx_version < 1002006) ||                                             \
+        (nginx_version >= 1003000 && nginx_version < 1003009)
+            r->main->count--;
+#endif
+
+            return rc;
+        }
+
+        if (rc == NGX_AGAIN) {
+            ctx->waiting_more_body = 1;
+            return NGX_DONE;
+        }
+    }
+
+    dd("calling access handler");
+    return llcf->access_handler(r);
+}
+
+
+ngx_int_t
+ngx_http_lua_access_handler_inline(ngx_http_request_t *r)
+{
+    ngx_int_t                  rc;
+    lua_State                 *L;
+    ngx_http_lua_loc_conf_t   *llcf;
+    ngx_http_lua_main_conf_t  *lmcf;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    /*  load Lua inline script (w/ cache) sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, llcf->access_src.value.data,
+                                       llcf->access_src.value.len,
+                                       llcf->access_src_key,
+                                       "access_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    return ngx_http_lua_access_by_chunk(L, r);
+}
+
+
+ngx_int_t
+ngx_http_lua_access_handler_file(ngx_http_request_t *r)
+{
+    u_char                    *script_path;
+    ngx_int_t                  rc;
+    ngx_str_t                  eval_src;
+    lua_State                 *L;
+    ngx_http_lua_loc_conf_t   *llcf;
+    ngx_http_lua_main_conf_t  *lmcf;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    /* Eval nginx variables in code path string first */
+    if (ngx_http_complex_value(r, &llcf->access_src, &eval_src) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    script_path = ngx_http_lua_rebase_path(r->pool, eval_src.data,
+                                           eval_src.len);
+
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    L = lmcf->lua;
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path, llcf->access_src_key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    /*  make sure we have a valid code chunk */
+    assert(lua_isfunction(L, -1));
+
+    return ngx_http_lua_access_by_chunk(L, r);
+}
+
+
+static ngx_int_t
+ngx_http_lua_access_by_chunk(lua_State *L, ngx_http_request_t *r)
+{
+    int                  co_ref;
+    ngx_int_t            rc;
+    lua_State           *co;
+    ngx_connection_t    *c;
+    ngx_http_lua_ctx_t  *ctx;
+    ngx_http_cleanup_t  *cln;
+
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    /*  {{{ new coroutine to handle request */
+    co = ngx_http_lua_new_thread(r, L, &co_ref);
+
+    if (co == NULL) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "lua: failed to create new coroutine "
+                      "to handle request");
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    /*  move code closure to new coroutine */
+    lua_xmove(L, co, 1);
+
+    /*  set closure's env table to new coroutine's globals table */
+    lua_pushvalue(co, LUA_GLOBALSINDEX);
+    lua_setfenv(co, -2);
+
+    /*  save nginx request in coroutine globals table */
+    ngx_http_lua_set_req(co, r);
+
+    /*  {{{ initialize request context */
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_http_lua_reset_ctx(r, L, ctx);
+
+    ctx->entered_access_phase = 1;
+
+    ctx->cur_co_ctx = &ctx->entry_co_ctx;
+    ctx->cur_co_ctx->co = co;
+    ctx->cur_co_ctx->co_ref = co_ref;
+
+    /*  }}} */
+
+    /*  {{{ register request cleanup hooks */
+    if (ctx->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        cln->handler = ngx_http_lua_request_cleanup_handler;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+    }
+    /*  }}} */
+
+    ctx->context = NGX_HTTP_LUA_CONTEXT_ACCESS;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->check_client_abort) {
+        r->read_event_handler = ngx_http_lua_rd_check_broken_connection;
+
+    } else {
+        r->read_event_handler = ngx_http_block_reading;
+    }
+
+    rc = ngx_http_lua_run_thread(L, r, ctx, 0);
+
+    dd("returned %d", (int) rc);
+
+    if (rc == NGX_ERROR || rc >= NGX_OK) {
+        return rc;
+    }
+
+    c = r->connection;
+
+    if (rc == NGX_AGAIN) {
+        rc = ngx_http_lua_run_posted_threads(c, L, r, ctx);
+
+        if (rc == NGX_ERROR || rc == NGX_DONE || rc >= NGX_OK) {
+            return rc;
+        }
+
+        return NGX_DECLINED;
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+
+        rc = ngx_http_lua_run_posted_threads(c, L, r, ctx);
+
+        if (rc == NGX_ERROR || rc == NGX_DONE || rc >= NGX_OK) {
+            return rc;
+        }
+
+        return NGX_DECLINED;
+    }
+
+    return NGX_DECLINED;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_accessby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,22 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_ACCESSBY_H_INCLUDED_
+#define _NGX_HTTP_LUA_ACCESSBY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_access_handler(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_access_handler_inline(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_access_handler_file(ngx_http_request_t *r);
+
+
+#endif /* _NGX_HTTP_LUA_ACCESSBY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_api.c b/src/lua/lua-nginx-module/src/ngx_http_lua_api.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_api.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_api.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,77 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#include "ddebug.h"
+
+#include "ngx_http_lua_common.h"
+#include "api/ngx_http_lua_api.h"
+#include "ngx_http_lua_util.h"
+
+
+lua_State *
+ngx_http_lua_get_global_state(ngx_conf_t *cf)
+{
+    ngx_http_lua_main_conf_t *lmcf;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    return lmcf->lua;
+}
+
+
+ngx_http_request_t *
+ngx_http_lua_get_request(lua_State *L)
+{
+    return ngx_http_lua_get_req(L);
+}
+
+
+ngx_int_t
+ngx_http_lua_add_package_preload(ngx_conf_t *cf, const char *package,
+    lua_CFunction func)
+{
+    lua_State                     *L;
+    ngx_http_lua_main_conf_t      *lmcf;
+    ngx_http_lua_preload_hook_t   *hook;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    if (L) {
+        lua_getglobal(L, "package");
+        lua_getfield(L, -1, "preload");
+        lua_pushcfunction(L, func);
+        lua_setfield(L, -2, package);
+        lua_pop(L, 2);
+
+        return NGX_OK;
+    }
+
+    /* L == NULL */
+
+    if (lmcf->preload_hooks == NULL) {
+        lmcf->preload_hooks =
+            ngx_array_create(cf->pool, 4,
+                             sizeof(ngx_http_lua_preload_hook_t));
+
+        if (lmcf->preload_hooks == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    hook = ngx_array_push(lmcf->preload_hooks);
+    if (hook == NULL) {
+        return NGX_ERROR;
+    }
+
+    hook->package = (u_char *) package;
+    hook->loader = func;
+
+    return NGX_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_args.c b/src/lua/lua-nginx-module/src/ngx_http_lua_args.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_args.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_args.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,367 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_args.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_ngx_req_set_uri_args(lua_State *L);
+static int ngx_http_lua_ngx_req_get_uri_args(lua_State *L);
+static int ngx_http_lua_ngx_req_get_post_args(lua_State *L);
+
+
+static int
+ngx_http_lua_ngx_req_set_uri_args(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_str_t                    args;
+    const char                  *msg;
+    size_t                       len;
+    u_char                      *p;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting 1 argument but seen %d",
+                          lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    switch (lua_type(L, 1)) {
+    case LUA_TNUMBER:
+    case LUA_TSTRING:
+        p = (u_char *) lua_tolstring(L, 1, &len);
+
+        args.data = ngx_palloc(r->pool, len);
+        if (args.data == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        ngx_memcpy(args.data, p, len);
+
+        args.len = len;
+        break;
+
+    case LUA_TTABLE:
+        ngx_http_lua_process_args_option(r, L, 1, &args);
+
+        dd("args: %.*s", (int) args.len, args.data);
+
+        break;
+
+    default:
+        msg = lua_pushfstring(L, "string, number, or table expected, "
+                              "but got %s", luaL_typename(L, 2));
+        return luaL_argerror(L, 1, msg);
+    }
+
+    dd("args: %.*s", (int) args.len, args.data);
+
+    r->args.data = args.data;
+    r->args.len = args.len;
+
+    r->valid_unparsed_uri = 0;
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_req_get_uri_args(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *buf;
+    u_char                      *last;
+    int                          retval;
+    int                          n;
+    int                          max;
+
+    n = lua_gettop(L);
+
+    if (n != 0 && n != 1) {
+        return luaL_error(L, "expecting 0 or 1 arguments but seen %d", n);
+    }
+
+    if (n == 1) {
+        max = luaL_checkinteger(L, 1);
+        lua_pop(L, 1);
+
+    } else {
+        max = NGX_HTTP_LUA_MAX_ARGS;
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    lua_createtable(L, 0, 4);
+
+    /* we copy r->args over to buf to simplify
+     * unescaping query arg keys and values */
+
+    buf = ngx_palloc(r->pool, r->args.len);
+    if (buf == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(buf, r->args.data, r->args.len);
+
+    last = buf + r->args.len;
+
+    retval = ngx_http_lua_parse_args(L, buf, last, max);
+
+    ngx_pfree(r->pool, buf);
+
+    return retval;
+}
+
+
+static int
+ngx_http_lua_ngx_req_get_post_args(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *buf;
+    int                          retval;
+    size_t                       len;
+    ngx_chain_t                 *cl;
+    u_char                      *p;
+    u_char                      *last;
+    int                          n;
+    int                          max;
+
+    n = lua_gettop(L);
+
+    if (n != 0 && n != 1) {
+        return luaL_error(L, "expecting 0 or 1 arguments but seen %d", n);
+    }
+
+    if (n == 1) {
+        max = luaL_checkinteger(L, 1);
+        lua_pop(L, 1);
+
+    } else {
+        max = NGX_HTTP_LUA_MAX_ARGS;
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->discard_body) {
+        lua_createtable(L, 0, 0);
+        return 1;
+    }
+
+    if (r->request_body == NULL) {
+        return luaL_error(L, "no request body found; "
+                          "maybe you should turn on lua_need_request_body?");
+    }
+
+    if (r->request_body->temp_file) {
+        return luaL_error(L, "requesty body in temp file not supported");
+    }
+
+    lua_createtable(L, 0, 4);
+
+    if (r->request_body->bufs == NULL) {
+        return 1;
+    }
+
+    /* we copy r->request_body->bufs over to buf to simplify
+     * unescaping query arg keys and values */
+
+    len = 0;
+    for (cl = r->request_body->bufs; cl; cl = cl->next) {
+        len += cl->buf->last - cl->buf->pos;
+    }
+
+    dd("post body length: %d", (int) len);
+
+    buf = ngx_palloc(r->pool, len);
+    if (buf == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    p = buf;
+    for (cl = r->request_body->bufs; cl; cl = cl->next) {
+        p = ngx_copy(p, cl->buf->pos, cl->buf->last - cl->buf->pos);
+    }
+
+    dd("post body: %.*s", (int) len, buf);
+
+    last = buf + len;
+
+    retval = ngx_http_lua_parse_args(L, buf, last, max);
+
+    ngx_pfree(r->pool, buf);
+
+    return retval;
+}
+
+
+int
+ngx_http_lua_parse_args(lua_State *L, u_char *buf, u_char *last, int max)
+{
+    u_char                      *p, *q;
+    u_char                      *src, *dst;
+    unsigned                     parsing_value;
+    size_t                       len;
+    int                          count = 0;
+    int                          top;
+
+    top = lua_gettop(L);
+
+    p = buf;
+
+    parsing_value = 0;
+    q = p;
+
+    while (p != last) {
+        if (*p == '=' && ! parsing_value) {
+            /* key data is between p and q */
+
+            src = q; dst = q;
+
+            ngx_http_lua_unescape_uri(&dst, &src, p - q,
+                                      NGX_UNESCAPE_URI_COMPONENT);
+
+            dd("pushing key %.*s", (int) (dst - q), q);
+
+            /* push the key */
+            lua_pushlstring(L, (char *) q, dst - q);
+
+            /* skip the current '=' char */
+            p++;
+
+            q = p;
+            parsing_value = 1;
+
+        } else if (*p == '&') {
+            /* reached the end of a key or a value, just save it */
+            src = q; dst = q;
+
+            ngx_http_lua_unescape_uri(&dst, &src, p - q,
+                                      NGX_UNESCAPE_URI_COMPONENT);
+
+            dd("pushing key or value %.*s", (int) (dst - q), q);
+
+            /* push the value or key */
+            lua_pushlstring(L, (char *) q, dst - q);
+
+            /* skip the current '&' char */
+            p++;
+
+            q = p;
+
+            if (parsing_value) {
+                /* end of the current pair's value */
+                parsing_value = 0;
+
+            } else {
+                /* the current parsing pair takes no value,
+                 * just push the value "true" */
+                dd("pushing boolean true");
+
+                lua_pushboolean(L, 1);
+            }
+
+            (void) lua_tolstring(L, -2, &len);
+
+            if (len == 0) {
+                /* ignore empty string key pairs */
+                dd("popping key and value...");
+                lua_pop(L, 2);
+
+            } else {
+                dd("setting table...");
+                ngx_http_lua_set_multi_value_table(L, top);
+            }
+
+            if (max > 0 && ++count == max) {
+                ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
+                               "lua hit query args limit %d", max);
+
+                return 1;
+            }
+
+        } else {
+            p++;
+        }
+    }
+
+    if (p != q || parsing_value) {
+        src = q; dst = q;
+
+        ngx_http_lua_unescape_uri(&dst, &src, p - q,
+                                  NGX_UNESCAPE_URI_COMPONENT);
+
+        dd("pushing key or value %.*s", (int) (dst - q), q);
+
+        lua_pushlstring(L, (char *) q, dst - q);
+
+        if (!parsing_value) {
+            dd("pushing boolean true...");
+            lua_pushboolean(L, 1);
+        }
+
+        (void) lua_tolstring(L, -2, &len);
+
+        if (len == 0) {
+            /* ignore empty string key pairs */
+            dd("popping key and value...");
+            lua_pop(L, 2);
+
+        } else {
+            dd("setting table...");
+            ngx_http_lua_set_multi_value_table(L, top);
+        }
+    }
+
+    dd("gettop: %d", lua_gettop(L));
+    dd("type: %s", lua_typename(L, lua_type(L, 1)));
+
+    if (lua_gettop(L) != top) {
+        return luaL_error(L, "internal error: stack in bad state");
+    }
+
+    return 1;
+}
+
+
+void
+ngx_http_lua_inject_req_args_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_set_uri_args);
+    lua_setfield(L, -2, "set_uri_args");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_uri_args);
+    lua_setfield(L, -2, "get_uri_args");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_uri_args);
+    lua_setfield(L, -2, "get_query_args"); /* deprecated */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_post_args);
+    lua_setfield(L, -2, "get_post_args");
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_args.h b/src/lua/lua-nginx-module/src/ngx_http_lua_args.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_args.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_args.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,13 @@
+#ifndef NGX_HTTP_LUA_ARGS
+#define NGX_HTTP_LUA_ARGS
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_req_args_api(lua_State *L);
+
+int ngx_http_lua_parse_args(lua_State *L, u_char *buf, u_char *last, int max);
+
+#endif /* NGX_HTTP_LUA_ARGS */
+
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,665 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_bodyfilterby.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_time.h"
+#include "ngx_http_lua_log.h"
+#include "ngx_http_lua_regex.h"
+#include "ngx_http_lua_cache.h"
+#include "ngx_http_lua_headers.h"
+#include "ngx_http_lua_variable.h"
+#include "ngx_http_lua_string.h"
+#include "ngx_http_lua_misc.h"
+#include "ngx_http_lua_consts.h"
+#include "ngx_http_lua_output.h"
+
+
+static void ngx_http_lua_body_filter_by_lua_env(lua_State *L,
+    ngx_http_request_t *r, ngx_chain_t *in);
+static ngx_http_output_body_filter_pt ngx_http_next_body_filter;
+
+
+/* light user data key for the ngx_chain_t *in pointer in the
+ * Lua VM registory */
+static char ngx_http_lua_body_filter_chain_key;
+
+
+/**
+ * Set environment table for the given code closure.
+ *
+ * Before:
+ *         | code closure | <- top
+ *         |      ...     |
+ *
+ * After:
+ *         | code closure | <- top
+ *         |      ...     |
+ * */
+static void
+ngx_http_lua_body_filter_by_lua_env(lua_State *L, ngx_http_request_t *r,
+    ngx_chain_t *in)
+{
+    /*  set nginx request pointer to current lua thread's globals table */
+    ngx_http_lua_set_req(L, r);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+    lua_pushlightuserdata(L, in);
+    lua_rawset(L, LUA_GLOBALSINDEX);
+
+    /**
+     * we want to create empty environment for current script
+     *
+     * setmetatable({}, {__index = _G})
+     *
+     * if a function or symbol is not defined in our env, __index will lookup
+     * in the global env.
+     *
+     * all variables created in the script-env will be thrown away at the end
+     * of the script run.
+     * */
+    ngx_http_lua_create_new_global_table(L, 0 /* narr */, 1 /* nrec */);
+
+    /*  {{{ make new env inheriting main thread's globals table */
+    lua_newtable(L);    /*  the metatable for the new env */
+    lua_pushvalue(L, LUA_GLOBALSINDEX);
+    lua_setfield(L, -2, "__index");
+    lua_setmetatable(L, -2);    /*  setmetatable({}, {__index = _G}) */
+    /*  }}} */
+
+    lua_setfenv(L, -2);    /*  set new running env for the code closure */
+}
+
+
+ngx_int_t
+ngx_http_lua_body_filter_by_chunk(lua_State *L, ngx_http_request_t *r,
+    ngx_chain_t *in)
+{
+    ngx_int_t        rc;
+    u_char          *err_msg;
+    size_t           len;
+#if (NGX_PCRE)
+    ngx_pool_t      *old_pool;
+#endif
+
+    dd("initialize nginx context in Lua VM, code chunk at stack top  sp = 1");
+    ngx_http_lua_body_filter_by_lua_env(L, r, in);
+
+#if (NGX_PCRE)
+    /* XXX: work-around to nginx regex subsystem */
+    old_pool = ngx_http_lua_pcre_malloc_init(r->pool);
+#endif
+
+    lua_pushcfunction(L, ngx_http_lua_traceback);
+    lua_insert(L, 1);  /* put it under chunk and args */
+
+    dd("protected call user code");
+    rc = lua_pcall(L, 0, 1, 1);
+
+    lua_remove(L, 1);  /* remove traceback function */
+
+#if (NGX_PCRE)
+    /* XXX: work-around to nginx regex subsystem */
+    ngx_http_lua_pcre_malloc_done(old_pool);
+#endif
+
+    if (rc != 0) {
+
+        /*  error occured */
+        err_msg = (u_char *) lua_tolstring(L, -1, &len);
+
+        if (err_msg == NULL) {
+            err_msg = (u_char *) "unknown reason";
+            len = sizeof("unknown reason") - 1;
+        }
+
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "failed to run body_filter_by_lua*: %*s", len, err_msg);
+
+        lua_settop(L, 0);    /*  clear remaining elems on stack */
+
+        return NGX_ERROR;
+    }
+
+    /* rc == 0 */
+
+    rc = (ngx_int_t) lua_tointeger(L, -1);
+
+    dd("got return value: %d", (int) rc);
+
+    lua_settop(L, 0);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_body_filter_inline(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    /*  load Lua inline script (w/ cache) sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, llcf->body_filter_src.value.data,
+                                       llcf->body_filter_src.value.len,
+                                       llcf->body_filter_src_key,
+                                       "body_filter_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_lua_body_filter_by_chunk(L, r, in);
+
+    dd("body filter by chunk returns %d", (int) rc);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_body_filter_file(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    lua_State                       *L;
+    ngx_int_t                        rc;
+    u_char                          *script_path;
+    ngx_http_lua_main_conf_t        *lmcf;
+    ngx_http_lua_loc_conf_t         *llcf;
+    ngx_str_t                        eval_src;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    /* Eval nginx variables in code path string first */
+    if (ngx_http_complex_value(r, &llcf->body_filter_src, &eval_src)
+        != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+    script_path = ngx_http_lua_rebase_path(r->pool, eval_src.data,
+                                           eval_src.len);
+
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    L = lmcf->lua;
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path,
+                                     llcf->body_filter_src_key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    /*  make sure we have a valid code chunk */
+    assert(lua_isfunction(L, -1));
+
+    rc = ngx_http_lua_body_filter_by_chunk(L, r, in);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+    uint16_t                     old_context;
+    ngx_http_cleanup_t          *cln;
+    ngx_http_lua_main_conf_t    *lmcf;
+    lua_State                   *L;
+    ngx_chain_t                 *out;
+    ngx_buf_tag_t                tag;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua body filter for user lua code, uri \"%V\"", &r->uri);
+
+    if (in == NULL) {
+        return ngx_http_next_body_filter(r, in);
+    }
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->body_filter_handler == NULL) {
+        dd("no body filter handler found");
+        return ngx_http_next_body_filter(r, in);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    if (ctx->seen_last_in_filter) {
+        for (/* void */; in; in = in->next) {
+            dd("mark the buf as consumed: %d", (int) ngx_buf_size(in->buf));
+            in->buf->pos = in->buf->last;
+            in->buf->file_pos = in->buf->file_last;
+        }
+
+        return NGX_OK;
+    }
+
+    if (ctx->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            return NGX_ERROR;
+        }
+
+        cln->handler = ngx_http_lua_request_cleanup_handler;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+    }
+
+    old_context = ctx->context;
+    ctx->context = NGX_HTTP_LUA_CONTEXT_BODY_FILTER;
+
+    dd("calling body filter handler");
+    rc = llcf->body_filter_handler(r, in);
+
+    dd("calling body filter handler returned %d", (int) rc);
+
+    ctx->context = old_context;
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+    lua_rawget(L, LUA_GLOBALSINDEX);
+    out = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (in == out) {
+        return ngx_http_next_body_filter(r, in);
+    }
+
+    /* in != out */
+    rc = ngx_http_next_body_filter(r, out);
+
+    if (rc == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+#if nginx_version >= 1001004
+    ngx_chain_update_chains(r->pool,
+#else
+    ngx_chain_update_chains(
+#endif
+                            &ctx->free_bufs, &ctx->busy_bufs, &out, tag);
+
+    return rc;
+}
+
+
+ngx_int_t
+ngx_http_lua_body_filter_init(void)
+{
+    dd("calling body filter init");
+    ngx_http_next_body_filter = ngx_http_top_body_filter;
+    ngx_http_top_body_filter = ngx_http_lua_body_filter;
+
+    return NGX_OK;
+}
+
+
+int
+ngx_http_lua_body_filter_param_get(lua_State *L)
+{
+    u_char              *data, *p;
+    size_t               size;
+    ngx_chain_t         *cl;
+    ngx_buf_t           *b;
+    int                  idx;
+    ngx_chain_t         *in;
+
+    idx = luaL_checkint(L, 2);
+
+    dd("index: %d", idx);
+
+    if (idx != 1 && idx != 2) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+    lua_rawget(L, LUA_GLOBALSINDEX);
+    in = lua_touserdata(L, -1);
+
+    if (in == NULL) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    if (idx == 2) {
+        /* asking for the eof argument */
+
+        for (cl = in; cl; cl = cl->next) {
+            if (cl->buf->last_buf || cl->buf->last_in_chain) {
+                lua_pushboolean(L, 1);
+                return 1;
+            }
+        }
+
+        lua_pushboolean(L, 0);
+        return 1;
+    }
+
+    /* idx == 1 */
+
+    if (in == NULL) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    size = 0;
+
+    if (in->next == NULL) {
+
+        dd("seen only single buffer");
+
+        b = in->buf;
+        lua_pushlstring(L, (char *) b->pos, b->last - b->pos);
+        return 1;
+    }
+
+    dd("seen multiple buffers");
+
+    for (cl = in; cl; cl = cl->next) {
+        b = cl->buf;
+
+        size += b->last - b->pos;
+
+        if (b->last_buf || b->last_in_chain) {
+            break;
+        }
+    }
+
+    data = (u_char *) lua_newuserdata(L, size);
+
+    for (p = data, cl = in; cl; cl = cl->next) {
+        b = cl->buf;
+        p = ngx_copy(p, b->pos, b->last - b->pos);
+
+        if (b->last_buf || b->last_in_chain) {
+            break;
+        }
+    }
+
+    lua_pushlstring(L, (char *) data, size);
+    return 1;
+}
+
+
+int
+ngx_http_lua_body_filter_param_set(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    int                      type;
+    int                      idx;
+    u_char                  *data;
+    size_t                   size;
+    unsigned                 last;
+    ngx_chain_t             *cl;
+    ngx_chain_t             *in;
+    ngx_buf_tag_t            tag;
+
+    idx = luaL_checkint(L, 2);
+
+    dd("index: %d", idx);
+
+    if (idx != 1 && idx != 2) {
+        return luaL_error(L, "bad index: %d", idx);
+    }
+
+    if (idx == 2) {
+        /* overwriting the eof flag */
+        last = lua_toboolean(L, 3);
+
+        lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+        lua_rawget(L, LUA_GLOBALSINDEX);
+        in = lua_touserdata(L, -1);
+
+        if (last) {
+            ctx->seen_last_in_filter = 1;
+
+            if (in) {
+                for (cl = in; cl; cl = cl->next) {
+                    if (cl->next == NULL) {
+                        if (r == r->main) {
+                            cl->buf->last_buf = 1;
+
+                        } else {
+                            cl->buf->last_in_chain = 1;
+                        }
+
+                        break;
+                    }
+                }
+
+            } else {
+                tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+                cl = ngx_http_lua_chains_get_free_buf(r->connection->log,
+                                                      r->pool, &ctx->free_bufs,
+                                                      0, tag);
+
+                if (cl == NULL) {
+                    return luaL_error(L, "out of memory");
+                }
+
+                if (r == r->main) {
+                    cl->buf->last_buf = 1;
+
+                } else {
+                    cl->buf->last_in_chain = 1;
+                }
+
+                lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+                lua_pushlightuserdata(L, cl);
+                lua_rawset(L, LUA_GLOBALSINDEX);
+            }
+
+        } else {
+            /* last == 0 */
+
+            if (in) {
+                for (size = 0, cl = in; cl; cl = cl->next) {
+                    if (cl->buf->last_buf) {
+                        cl->buf->last_buf = 0;
+                    }
+
+                    if (cl->buf->last_in_chain) {
+                        cl->buf->last_in_chain = 0;
+                    }
+
+                    size += cl->buf->last - cl->buf->pos;
+                }
+
+                if (size == 0) {
+                    lua_pushlightuserdata(L,
+                                          &ngx_http_lua_body_filter_chain_key);
+                    lua_pushlightuserdata(L, NULL);
+                    lua_rawset(L, LUA_GLOBALSINDEX);
+                }
+            }
+        }
+
+        return 0;
+    }
+
+    /* idx == 1, overwriting the chunk data */
+
+    type = lua_type(L, 3);
+
+    switch (type) {
+    case LUA_TSTRING:
+    case LUA_TNUMBER:
+        data = (u_char *) lua_tolstring(L, 3, &size);
+        break;
+
+    case LUA_TNIL:
+        /* discard the buffers */
+        lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key); /* key */
+        lua_pushvalue(L, -1); /* key key */
+        lua_rawget(L, LUA_GLOBALSINDEX); /* key val */
+        in = lua_touserdata(L, -1);
+        lua_pop(L, 1); /* key */
+
+        for (cl = in; cl; cl = cl->next) {
+            dd("mark the buf as consumed: %d", (int) ngx_buf_size(cl->buf));
+            cl->buf->pos = cl->buf->last;
+            cl->buf->file_pos = cl->buf->file_last;
+        }
+
+        lua_pushlightuserdata(L, NULL); /* key val */
+        lua_rawset(L, LUA_GLOBALSINDEX);
+        return 0;
+
+    case LUA_TTABLE:
+        size = ngx_http_lua_calc_strlen_in_table(L, 3 /* index */, 3 /* arg */,
+                                                 1 /* strict */);
+        data = NULL;
+        break;
+
+    default:
+        return luaL_error(L, "bad chunk data type: %s",
+                          lua_typename(L, type));
+    }
+
+    lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+    lua_rawget(L, LUA_GLOBALSINDEX);
+    in = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    last = 0;
+    for (cl = in; cl; cl = cl->next) {
+        if (cl->buf->last_buf || cl->buf->last_in_chain) {
+            last = 1;
+        }
+
+        dd("mark the buf as consumed: %d", (int) ngx_buf_size(cl->buf));
+        cl->buf->pos = cl->buf->last;
+    }
+
+    if (size == 0) {
+        if (last) {
+            if (in) {
+                if (r == r->main) {
+                    in->buf->last_buf = 1;
+
+                } else {
+                    in->buf->last_in_chain = 1;
+                }
+
+            } else {
+
+                tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+                cl = ngx_http_lua_chains_get_free_buf(r->connection->log,
+                                                      r->pool, &ctx->free_bufs,
+                                                      0, tag);
+
+                if (cl == NULL) {
+                    return luaL_error(L, "out of memory");
+                }
+
+                if (r == r->main) {
+                    cl->buf->last_buf = 1;
+
+                } else {
+                    in->buf->last_in_chain = 1;
+                }
+
+                lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+                lua_pushlightuserdata(L, cl);
+                lua_rawset(L, LUA_GLOBALSINDEX);
+            }
+        }
+
+        return 0;
+    }
+
+    tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+    cl = ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                          &ctx->free_bufs, size, tag);
+    if (cl == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    if (type == LUA_TTABLE) {
+        cl->buf->last = ngx_http_lua_copy_str_in_table(L, 3, cl->buf->last);
+
+    } else {
+        cl->buf->last = ngx_copy(cl->buf->pos, data, size);
+    }
+
+    if (last) {
+        ctx->seen_last_in_filter = 1;
+
+        if (r == r->main) {
+            cl->buf->last_buf = 1;
+
+        } else {
+            cl->buf->last_in_chain = 1;
+        }
+    }
+
+    lua_pushlightuserdata(L, &ngx_http_lua_body_filter_chain_key);
+    lua_pushlightuserdata(L, cl);
+    lua_rawset(L, LUA_GLOBALSINDEX);
+    return 0;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_bodyfilterby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,31 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_BODYFILTERBY_H_INCLUDED_
+#define _NGX_HTTP_LUA_BODYFILTERBY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+extern ngx_http_output_body_filter_pt ngx_http_lua_next_filter_body_filter;
+
+
+ngx_int_t ngx_http_lua_body_filter_init(void);
+ngx_int_t ngx_http_lua_body_filter_by_chunk(lua_State *L,
+    ngx_http_request_t *r, ngx_chain_t *in);
+ngx_int_t ngx_http_lua_body_filter_inline(ngx_http_request_t *r,
+    ngx_chain_t *in);
+ngx_int_t ngx_http_lua_body_filter_file(ngx_http_request_t *r,
+    ngx_chain_t *in);
+int ngx_http_lua_body_filter_param_get(lua_State *L);
+int ngx_http_lua_body_filter_param_set(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+
+
+#endif /* _NGX_HTTP_LUA_BODYFILTERBY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_cache.c b/src/lua/lua-nginx-module/src/ngx_http_lua_cache.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_cache.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_cache.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,418 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include <nginx.h>
+#include <ngx_md5.h>
+#include "ngx_http_lua_common.h"
+#include "ngx_http_lua_cache.h"
+#include "ngx_http_lua_clfactory.h"
+#include "ngx_http_lua_util.h"
+
+
+static void ngx_http_lua_clear_package_loaded(lua_State *L);
+
+
+/**
+ * Find code chunk associated with the given key in code cache,
+ * and push it to the top of Lua stack if found.
+ *
+ * Stack layout before call:
+ *         |     ...    | <- top
+ *
+ * Stack layout after call:
+ *         | code chunk | <- top
+ *         |     ...    |
+ *
+ * */
+static ngx_int_t
+ngx_http_lua_cache_load_code(lua_State *L, const char *key)
+{
+    /*  get code cache table */
+    lua_pushlightuserdata(L, &ngx_http_lua_code_cache_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);    /*  sp++ */
+
+    dd("Code cache table to load: %p", lua_topointer(L, -1));
+
+    if (!lua_istable(L, -1)) {
+        dd("Error: code cache table to load did not exist!!");
+        return NGX_ERROR;
+    }
+
+    lua_getfield(L, -1, key);    /*  sp++ */
+
+    if (lua_isfunction(L, -1)) {
+        /*  call closure factory to gen new closure */
+        int rc = lua_pcall(L, 0, 1, 0);
+
+        if (rc == 0) {
+            /*  remove cache table from stack, leave code chunk at
+             *  top of stack */
+            lua_remove(L, -2);   /*  sp-- */
+            return NGX_OK;
+        }
+    }
+
+    dd("Value associated with given key in code cache table is not code "
+       "chunk: stack top=%d, top value type=%s\n",
+       lua_gettop(L), lua_typename(L, -1));
+
+    /*  remove cache table and value from stack */
+    lua_pop(L, 2);                                /*  sp-=2 */
+
+    return NGX_DECLINED;
+}
+
+
+/**
+ * Store the closure factory at the top of Lua stack to code cache, and
+ * associate it with the given key. Then generate new closure.
+ *
+ * Stack layout before call:
+ *         | code factory | <- top
+ *         |     ...      |
+ *
+ * Stack layout after call:
+ *         | code chunk | <- top
+ *         |     ...    |
+ *
+ * */
+static ngx_int_t
+ngx_http_lua_cache_store_code(lua_State *L, const char *key)
+{
+    int rc;
+
+    /*  get code cache table */
+    lua_pushlightuserdata(L, &ngx_http_lua_code_cache_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+
+    dd("Code cache table to store: %p", lua_topointer(L, -1));
+
+    if (!lua_istable(L, -1)) {
+        dd("Error: code cache table to load did not exist!!");
+        return NGX_ERROR;
+    }
+
+    lua_pushvalue(L, -2); /* closure cache closure */
+    lua_setfield(L, -2, key); /* closure cache */
+
+    /*  remove cache table, leave closure factory at top of stack */
+    lua_pop(L, 1); /* closure */
+
+    /*  call closure factory to generate new closure */
+    rc = lua_pcall(L, 0, 1, 0);
+    if (rc != 0) {
+        dd("Error: failed to call closure factory!!");
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_cache_loadbuffer(lua_State *L, const u_char *src, size_t src_len,
+    const u_char *cache_key, const char *name, unsigned enabled)
+{
+    int          rc, n;
+    const char  *err = NULL;
+
+    n = lua_gettop(L);
+
+    dd("XXX cache key: [%s]", cache_key);
+
+    if (!enabled) {
+        ngx_http_lua_clear_package_loaded(L);
+    }
+
+    if (ngx_http_lua_cache_load_code(L, (char *) cache_key) == NGX_OK) {
+        /*  code chunk loaded from cache, sp++ */
+        dd("Code cache hit! cache key='%s', stack top=%d, script='%.*s'",
+           cache_key, lua_gettop(L), (int) src_len, src);
+        return NGX_OK;
+    }
+
+    dd("Code cache missed! cache key='%s', stack top=%d, script='%.*s'",
+       cache_key, lua_gettop(L), (int) src_len, src);
+
+    /* load closure factory of inline script to the top of lua stack, sp++ */
+    rc = ngx_http_lua_clfactory_loadbuffer(L, (char *) src, src_len, name);
+
+    if (rc != 0) {
+        /*  Oops! error occured when loading Lua script */
+        if (rc == LUA_ERRMEM) {
+            err = "memory allocation error";
+
+        } else {
+            if (lua_isstring(L, -1)) {
+                err = lua_tostring(L, -1);
+
+            } else {
+                err = "unknown error";
+            }
+        }
+
+        goto error;
+    }
+
+    /*  store closure factory and gen new closure at the top of lua stack to
+     *  code cache */
+    rc = ngx_http_lua_cache_store_code(L, (char *) cache_key);
+
+    if (rc != NGX_OK) {
+        err = "fail to generate new closure from the closure factory";
+        goto error;
+    }
+
+    return NGX_OK;
+
+error:
+    ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,
+                  "failed to load inlined Lua code: %s", err);
+    lua_settop(L, n);
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_http_lua_cache_loadfile(lua_State *L, const u_char *script,
+    const u_char *cache_key, unsigned enabled)
+{
+    int              rc;
+    u_char          *p;
+    u_char           buf[NGX_HTTP_LUA_FILE_KEY_LEN + 1];
+    int              n;
+    const char      *err = NULL;
+
+    n = lua_gettop(L);
+
+    /*  calculate digest of script file path */
+    dd("code cache enabled: %d", (int) enabled);
+
+    if (enabled) {
+        if (cache_key == NULL) {
+            dd("CACHE file key not pre-calculated...calculating");
+            p = ngx_copy(buf, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+
+            p = ngx_http_lua_digest_hex(p, script, ngx_strlen(script));
+
+            *p = '\0';
+            cache_key = buf;
+
+        } else {
+            dd("CACHE file key already pre-calculated");
+        }
+
+        dd("XXX cache key for file: [%s]", cache_key);
+
+        if (ngx_http_lua_cache_load_code(L, (char *) cache_key) == NGX_OK) {
+            /*  code chunk loaded from cache, sp++ */
+            dd("Code cache hit! cache key='%s', stack top=%d, file path='%s'",
+               cache_key, lua_gettop(L), script);
+            return NGX_OK;
+        }
+
+        dd("Code cache missed! cache key='%s', stack top=%d, file path='%s'",
+           cache_key, lua_gettop(L), script);
+    }
+
+    /*  load closure factory of script file to the top of lua stack, sp++ */
+    rc = ngx_http_lua_clfactory_loadfile(L, (char *) script);
+
+    if (rc != 0) {
+        /*  Oops! error occured when loading Lua script */
+        if (rc == LUA_ERRMEM) {
+            err = "memory allocation error";
+
+        } else {
+            if (lua_isstring(L, -1)) {
+                err = lua_tostring(L, -1);
+
+            } else {
+                err = "unknown error";
+            }
+        }
+
+        goto error;
+    }
+
+    if (enabled) {
+        /*  store closure factory and gen new closure at the top of lua stack
+         *  to code cache */
+        rc = ngx_http_lua_cache_store_code(L, (char *) cache_key);
+
+        if (rc != NGX_OK) {
+            err = "fail to generate new closure from the closure factory";
+            goto error;
+        }
+
+    } else {
+        /*  call closure factory to generate new closure */
+        rc = lua_pcall(L, 0, 1, 0);
+        if (rc != 0) {
+            err = "failed to call closure factory";
+            goto error;
+        }
+
+        ngx_http_lua_clear_package_loaded(L);
+    }
+
+    return NGX_OK;
+
+error:
+    ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,
+                  "failed to load external Lua file: %s", err);
+
+    lua_settop(L, n);
+    return NGX_ERROR;
+}
+
+
+static void
+ngx_http_lua_clear_package_loaded(lua_State *L)
+{
+    size_t       len;
+    u_char      *p;
+
+    dd("clear out package.loaded.* on the Lua land");
+    lua_getglobal(L, "package"); /* package */
+    lua_getfield(L, -1, "loaded"); /* package loaded */
+    lua_pushnil(L); /* package loaded nil */
+
+    while (lua_next(L, -2)) { /* package loaded key value */
+        lua_pop(L, 1);  /* package loaded key */
+
+        p = (u_char *) lua_tolstring(L, -1, &len);
+
+#if 1
+        /* XXX work-around the "stack overflow" issue of LuaRocks
+         * while unloading and reloading Lua modules */
+        if (len >= sizeof("luarocks") - 1
+            && ngx_strncmp(p, "luarocks", sizeof("luarocks") - 1) == 0)
+        {
+            goto done;
+        }
+#endif
+
+        switch (len) {
+        case 2:
+            if (p[0] == 'o' && p[1] == 's') {
+                goto done;
+            }
+
+            if (p[0] == 'i' && p[1] == 'o') {
+                goto done;
+            }
+
+#if 0
+            if (ngx_strncmp(p, "_G", sizeof("_G") - 1) == 0) {
+                goto done;
+            }
+#endif
+
+            break;
+
+        case 3:
+            if (ngx_strncmp(p, "bit", sizeof("bit") - 1) == 0) {
+                goto done;
+            }
+
+            if (ngx_strncmp(p, "jit", sizeof("jit") - 1) == 0) {
+                goto done;
+            }
+
+            if (ngx_strncmp(p, "ngx", sizeof("ngx") - 1) == 0) {
+                goto done;
+            }
+
+            if (ngx_strncmp(p, "ndk", sizeof("ndk") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+        case 4:
+            if (ngx_strncmp(p, "math", sizeof("math") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+        case 5:
+            if (ngx_strncmp(p, "table", sizeof("table") - 1) == 0) {
+                goto done;
+            }
+
+            if (ngx_strncmp(p, "debug", sizeof("table") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+        case 6:
+            if (ngx_strncmp(p, "string", sizeof("string") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+        case 7:
+            if (ngx_strncmp(p, "package", sizeof("package") - 1) == 0) {
+                goto done;
+            }
+
+            if (ngx_strncmp(p, "jit.opt", sizeof("jit.opt") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+       case 8:
+            if (ngx_strncmp(p, "jit.util", sizeof("jit.util") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+       case 9:
+            if (ngx_strncmp(p, "coroutine", sizeof("coroutine") - 1) == 0) {
+                goto done;
+            }
+
+            break;
+
+        default:
+            break;
+        }
+
+        dd("clearing package %s", p);
+
+        lua_pushvalue(L, -1);  /* package loaded key key */
+        lua_pushnil(L); /* package loaded key key nil */
+        lua_settable(L, -4);  /* package loaded key */
+done:
+        continue;
+    }
+
+    /* package loaded */
+    lua_pop(L, 2);
+
+    /* force a full GC cycle */
+    lua_gc(L, LUA_GCCOLLECT, 0);
+
+#if 0
+    lua_newtable(L);
+    lua_setglobal(L, "_G");
+#endif
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_cache.h b/src/lua/lua-nginx-module/src/ngx_http_lua_cache.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_cache.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_cache.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,24 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CACHE_H_INCLUDED_
+#define _NGX_HTTP_LUA_CACHE_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_cache_loadbuffer(lua_State *L, const u_char *src,
+    size_t src_len, const u_char *cache_key, const char *name,
+    unsigned enabled);
+ngx_int_t ngx_http_lua_cache_loadfile(lua_State *L, const u_char *script,
+    const u_char *cache_key, unsigned enabled);
+
+
+#endif /* _NGX_HTTP_LUA_CACHE_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.c b/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,170 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include <nginx.h>
+#include "ngx_http_lua_capturefilter.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_subrequest.h"
+
+
+ngx_http_output_header_filter_pt ngx_http_lua_next_header_filter;
+ngx_http_output_body_filter_pt ngx_http_lua_next_body_filter;
+
+
+static ngx_int_t ngx_http_lua_capture_header_filter(ngx_http_request_t *r);
+static ngx_int_t ngx_http_lua_capture_body_filter(ngx_http_request_t *r,
+    ngx_chain_t *in);
+
+
+ngx_int_t
+ngx_http_lua_capture_filter_init(ngx_conf_t *cf)
+{
+    /* setting up output filters to intercept subrequest responses */
+    ngx_http_lua_next_header_filter = ngx_http_top_header_filter;
+    ngx_http_top_header_filter = ngx_http_lua_capture_header_filter;
+
+    ngx_http_lua_next_body_filter = ngx_http_top_body_filter;
+    ngx_http_top_body_filter = ngx_http_lua_capture_body_filter;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_capture_header_filter(ngx_http_request_t *r)
+{
+    ngx_http_post_subrequest_t      *psr;
+    ngx_http_lua_ctx_t              *old_ctx;
+    ngx_http_lua_ctx_t              *ctx;
+
+    ngx_http_lua_post_subrequest_data_t      *psr_data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua capture header filter, uri \"%V\"", &r->uri);
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("old ctx: %p", ctx);
+
+    if (ctx == NULL || ! ctx->capture) {
+
+        psr = r->post_subrequest;
+
+        if (psr != NULL
+            && psr->handler == ngx_http_lua_post_subrequest
+            && psr->data != NULL)
+        {
+            /* the lua ctx has been cleared by ngx_http_internal_redirect,
+             * resume it from the post_subrequest data
+             */
+            psr_data = psr->data;
+
+            old_ctx = psr_data->ctx;
+
+            if (ctx == NULL) {
+                ctx = old_ctx;
+                ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+
+            } else {
+                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "lua restoring ctx with capture %d, index %d",
+                               old_ctx->capture, old_ctx->index);
+
+                ctx->capture = old_ctx->capture;
+                ctx->index = old_ctx->index;
+                ctx->body = NULL;
+                ctx->last_body = &ctx->body;
+                psr_data->ctx = ctx;
+            }
+        }
+    }
+
+    if (ctx && ctx->capture) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua capturing response body");
+
+        /* force subrequest response body buffer in memory */
+        r->filter_need_in_memory = 1;
+
+        return NGX_OK;
+    }
+
+    return ngx_http_lua_next_header_filter(r);
+}
+
+
+static ngx_int_t
+ngx_http_lua_capture_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    int                              rc;
+    ngx_int_t                        eof;
+    ngx_http_lua_ctx_t              *ctx;
+    ngx_http_lua_ctx_t              *pr_ctx;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua capture body filter, uri \"%V\"", &r->uri);
+
+    if (in == NULL) {
+        return ngx_http_lua_next_body_filter(r, NULL);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (!ctx || !ctx->capture) {
+        dd("no ctx or no capture %.*s", (int) r->uri.len, r->uri.data);
+
+        return ngx_http_lua_next_body_filter(r, in);
+    }
+
+    if (ctx->run_post_subrequest) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua body filter skipped because post subrequest "
+                       "already run");
+        return NGX_OK;
+    }
+
+    if (r->parent == NULL) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua body filter skipped because no parent request "
+                       "found");
+
+        return NGX_ERROR;
+    }
+
+    pr_ctx = ngx_http_get_module_ctx(r->parent, ngx_http_lua_module);
+    if (pr_ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua capture body filter capturing response body, uri "
+                   "\"%V\"", &r->uri);
+
+    rc = ngx_http_lua_add_copy_chain(r, pr_ctx, &ctx->last_body, in, &eof);
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    dd("add copy chain eof: %d, sr: %d", (int) eof, r != r->main);
+
+    if (eof) {
+        ctx->seen_last_for_subreq = 1;
+    }
+
+    ngx_http_lua_discard_bufs(r->pool, in);
+
+    return NGX_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.h b/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_capturefilter.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CAPTUREFILTER_H_INCLUDED_
+#define _NGX_HTTP_LUA_CAPTUREFILTER_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_capture_filter_init(ngx_conf_t *cf);
+
+
+#endif /* NGX_HTTP_LUA_CAPTUREFILTER_H */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.c b/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,824 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include <nginx.h>
+#include "ngx_http_lua_clfactory.h"
+
+
+#define CLFACTORY_BEGIN_CODE "return function() "
+#define CLFACTORY_BEGIN_SIZE (sizeof(CLFACTORY_BEGIN_CODE) - 1)
+
+#define CLFACTORY_END_CODE "\nend"
+#define CLFACTORY_END_SIZE (sizeof(CLFACTORY_END_CODE) - 1)
+
+
+/*
+ * taken from chaoslawful:
+ * Lua bytecode header        Luajit bytecode header
+ * --------------              --------------
+ * |  \033Lua   | 0-3          |  \033LJ    | 0-2
+ * --------------              --------------
+ * |    LuaC    | 4            |  bytecode  | 3
+ * |   Version  |              |   version  |
+ * --------------              --------------
+ * |    LuaC    | 5            |  misc flag | 4 [F|S|B]
+ * |   Format   |              --------------
+ * --------------              |  chunkname | ULEB128 var-len
+ * |   Endian   | 6            |     len    | encoded uint32
+ * --------------              --------------
+ * |   size of  | 7            |  chunkname |
+ * |     int    |              |  str no \0 |
+ * --------------              --------------
+ * |   size of  | 8
+ * |    size_t  |
+ * --------------
+ * |   size of  | 9
+ * | instruction|
+ * --------------
+ * |   size of  | 10
+ * |   number   |
+ * --------------
+ * |   number   | 11
+ * |   is int?  |
+ * --------------
+*/
+
+
+/*
+ * CLOSURE 0 0 RETURN 0 2 RETURN 0 1
+ * length(Instruction) = 4 or 8
+ * little endian or big endian
+*/
+#define    LUA_LITTLE_ENDIAN_4BYTES_CODE                                \
+    "\x24\x00\x00\x00\x1e\x00\x00\x01\x1e\x00\x80\x00"
+#define    LUA_LITTLE_ENDIAN_8BYTES_CODE                                \
+    "\x24\x00\x00\x00\x00\x00\x00\x00\x1e\x00\x00\x01"                  \
+    "\x00\x00\x00\x00\x1e\x00\x80\x00\x00\x00\x00\x00"
+#define    LUA_BIG_ENDIAN_4BYTES_CODE                                   \
+    "\x00\x00\x00\x24\x01\x00\x00\x1e\x00\x08\x00\x1e"
+#define    LUA_BIG_ENDIAN_8BYTES_CODE                                   \
+    "\x00\x00\x00\x00\x00\x00\x00\x24\x00\x00\x00\x00"                  \
+    "\x01\x00\x00\x1e\x00\x00\x00\x00\x00\x08\x00\x1e"
+#define    LUA_LITTLE_ENDIAN_4BYTES_CODE_LEN        (4 + 4 + 4)
+#define    LUA_LITTLE_ENDIAN_8BYTES_CODE_LEN        (8 + 8 + 8)
+#define    LUA_BIG_ENDIAN_4BYTES_CODE_LEN           (4 + 4 + 4)
+#define    LUA_BIG_ENDIAN_8BYTES_CODE_LEN           (8 + 8 + 8)
+#define    LUAC_HEADERSIZE         12
+#define    LUAC_VERSION            0x51
+
+
+/*
+ * taken from chaoslawful:
+ *  Lua Proto
+ * ---------------------
+ * | String            | Can be empty string
+ * | [source]          | (stripped or internal function)
+ * ---------------------
+ * | Int               | At which line this function is defined
+ * | [linedefined]     |
+ * ---------------------
+ * | Int               | At while line this function definition ended
+ * | [lastlinedefined] |
+ * ---------------------
+ * | Char              | Number of upvalues referenced by this function
+ * | [nups]            |
+ * ---------------------
+ * | Char              | Number of paramters of this function
+ * | [numparams]       |
+ * ---------------------
+ * | Char              | Does this function has variable number of arguments?
+ * | [is_var_arg]      | main function always set to VARARG_ISVARARG (2)
+ * ---------------------
+ * | Char              | Maximum stack size this function used
+ * | [maxstacksize]    | Intially set to 2
+ * ---------------------
+ * | Vector(instr)     | Code instructions of this function
+ * | [code]            |
+ * ---------------------
+ * | Int               | Number of constants referenced by this function
+ * | [sizek]           |
+ * ---------------------
+ * | Char              | ------------------------------------
+ * | type of [k[i]]    |  The type and content of constants |
+ * ---------------------                                    |-> repeat for i in
+ * | Char if boolean   |  No content part if type is NIL    |   [1..sizek]
+ * | Number if number  | ------------------------------------
+ * | String if string  |
+ * ---------------------
+ * | Int               | Number of internal functions
+ * | [sizep]           |
+ * ---------------------
+ * | Function          | -> repeat for i in [1..sizep]
+ * | at [p[i]]         |
+ * ---------------------
+ * | Vector            | Debug lineinfo vector
+ * | [lineinfo]        | Empty vector here if dubug info is stripped
+ * ---------------------
+ * | Int               | Number of local variable in this function
+ * | [sizelocvars]     | 0 if debug info is stripped
+ * ---------------------
+ * | String            | ------------------------------------
+ * | [locvars[i]]      |  Name of local var i               |
+ * |  .varname]        |                                    |
+ * ---------------------                                    |
+ * | Int               |  instruction counter               |
+ * | [locvars[i]]      |  where lcoal var i start to be     |-> repeat for i in
+ * |  .startpc]        |  referenced                        |  [0..sizelocvars]
+ * ---------------------                                    |
+ * | Int               |  instruction counter, where local  |
+ * | [locvars[i]]      |  var i ceased to be referenced     |
+ * |  .endpc]          | ------------------------------------
+ * ---------------------
+ * | Int               | Number of upvalues referenced by this function,
+ * | [sizeupvalues]    | 0 if stripped
+ * ---------------------
+ * | String            | -> repeat for i in[0..sizeupvalues]
+ * | [upvalues[i]]     |
+ * ---------------------
+*/
+
+#define    POS_SOURCE_STR_LEN      LUAC_HEADERSIZE
+#define    POS_START_LINE          (POS_SOURCE_STR_LEN + sizeof(size_t))
+#define    POS_LAST_LINE           (POS_START_LINE + sizeof(int))
+#define    POS_NUM_OF_UPVS         (POS_LAST_LINE + sizeof(int))
+#define    POS_NUM_OF_PARA         (POS_NUM_OF_UPVS + sizeof(char))
+#define    POS_IS_VAR_ARG          (POS_NUM_OF_PARA + sizeof(char))
+#define    POS_MAX_STACK_SIZE      (POS_IS_VAR_ARG + sizeof(char))
+#define    POS_NUM_OF_INST         (POS_MAX_STACK_SIZE +sizeof(char))
+#define    POS_BYTECODE            (POS_NUM_OF_INST + sizeof(int))
+#define    MAX_BEGIN_CODE_SIZE                                              \
+    (POS_BYTECODE + LUA_LITTLE_ENDIAN_8BYTES_CODE_LEN                       \
+    + sizeof(int) + sizeof(int))
+#define    MAX_END_CODE_SIZE       (sizeof(int) + sizeof(int) + sizeof(int))
+
+/*
+ * taken from chaoslawful:
+ * Luajit bytecode format
+ * ---------------------
+ * | HEAD              | Luajit bytecode head
+ * ---------------------
+ * | Internal          | All internal functions
+ * | functions         |
+ * ---------------------
+ * | ULEB128           | Rest data total length of this function
+ * | [Date len of      | (not include itself)
+ * |  this function]   |
+ * ---------------------
+ * | Char              | F(ffi) | V(vararg)| C(has internal funcs)
+ * | [func flag]       |
+ * ---------------------
+ * | Char              | Number of paramters of this function
+ * | [numparams]       |
+ * ---------------------
+ * | Char              |
+ * | [framesize]       |
+ * ---------------------
+ * | Char              | Number of upvalues referenced by this function
+ * | [sizeupvalues]    |
+ * ---------------------
+ * | ULEB128           | Number of collectable constants referenced
+ * | [sizekgc]         | by this function
+ * ---------------------
+ * | ULEB128           | Number of lua number constants referenced
+ * | [sizekn]          | by this function
+ * ---------------------
+ * | ULEB128           | Number of bytecode instructions of this function
+ * | [sizebc]m1        | minus 1 to omit the BC_FUNCV/BC_FUNCF header bytecode
+ * ---------------------
+ * | ULEB128           |
+ * | [size of dbg      | Size of debug lineinfo map, available when not stripped
+ * |  lineinfo]        |
+ * ---------------------
+ * | ULEB128           | Available when not stripped
+ * | [firstline]       | The first line of this function's definition
+ * ---------------------
+ * | ULEB128           | Available when not stripped
+ * | [numline]         | The number of lines of this function's definition
+ * ---------------------
+ * | [bytecode]        | Bytecode instructions of this function
+ * ---------------------
+ * |[upvalue ref slots]| [sizeupvalues] * 2
+ * ---------------------
+ * | [collectable      | [sizekgc] elems, variable length
+ * |  constants]       |
+ * ---------------------
+ * | [lua number       | [sizekn] elems, variable length
+ * |  constants]       |
+ * ---------------------
+ * | [debug lineinfo   | Length is the calculated size of debug lineinfo above
+ * |                   | Only available if not stripped
+ * ---------------------
+ * | Char              |
+ * | [\x00]            | Footer
+ * ---------------------
+*/
+
+/* bytecode for luajit */
+#define    LJ_LITTLE_ENDIAN_CODE_STRIPPED                               \
+    "\x14\x03\x00\x01\x00\x01\x00\x03"                                  \
+    "\x31\x00\x00\x00\x30\x00\x00\x80\x48\x00\x02\x00"                  \
+    "\x00\x00"
+#define    LJ_BIG_ENDIAN_CODE_STRIPPED                                  \
+    "\x14\x03\x00\x01\x00\x01\x00\x03"                                  \
+    "\x00\x00\x00\x31\x80\x00\x00\x30\x00\x02\x00\x48"                  \
+    "\x00\x00"
+#define    LJ_LITTLE_ENDIAN_CODE                                        \
+    "\x15\x03\x00\x01\x00\x01\x00\x03\x00"                              \
+    "\x31\x00\x00\x00\x30\x00\x00\x80\x48\x00\x02\x00"                  \
+    "\x00\x00"
+#define    LJ_BIG_ENDIAN_CODE                                           \
+    "\x15\x03\x00\x01\x00\x01\x00\x03\x00"                              \
+    "\x00\x00\x00\x31\x80\x00\x00\x30\x00\x02\x00\x48"                  \
+    "\x00\x00"
+
+#define    LJ_CODE_LEN              23
+#define    LJ_CODE_LEN_STRIPPED     22
+#define    LJ_HEADERSIZE            5
+#define    LJ_BCDUMP_F_BE           0x01
+#define    LJ_BCDUMP_F_STRIP        0x02
+#define    LJ_BCDUMP_VERSION        1
+#define    LJ_SIGNATURE             "\x1b\x4c\x4a"
+
+
+typedef enum {
+    NGX_LUA_TEXT_FILE,
+    NGX_LUA_BT_LUA,
+    NGX_LUA_BT_LJ
+} ngx_http_lua_clfactory_file_type_e;
+
+
+typedef struct {
+    ngx_http_lua_clfactory_file_type_e file_type;
+
+    int         sent_begin;
+    int         sent_end;
+    int         extraline;
+    FILE       *f;
+    size_t      begin_code_len;
+    size_t      end_code_len;
+    size_t      rest_len;
+    union {
+        char   *ptr;
+        char    str[MAX_BEGIN_CODE_SIZE];
+    }           begin_code;
+    union {
+        char   *ptr;
+        char    str[MAX_END_CODE_SIZE];
+    }           end_code;
+    char        buff[LUAL_BUFFERSIZE];
+} ngx_http_lua_clfactory_file_ctx_t;
+
+
+typedef struct {
+    int         sent_begin;
+    int         sent_end;
+    const char *s;
+    size_t      size;
+} ngx_http_lua_clfactory_buffer_ctx_t;
+
+
+static const char *ngx_http_lua_clfactory_getF(lua_State *L, void *ud,
+    size_t *size);
+static int ngx_http_lua_clfactory_errfile(lua_State *L, const char *what,
+    int fname_index);
+static const char *ngx_http_lua_clfactory_getS(lua_State *L, void *ud,
+    size_t *size);
+static long ngx_http_lua_clfactory_file_size(FILE *f);
+
+
+int
+ngx_http_lua_clfactory_bytecode_prepare(lua_State *L,
+    ngx_http_lua_clfactory_file_ctx_t *lf, int fname_index)
+{
+    int                 x = 1, size_of_int, size_of_size_t, little_endian,
+                        size_of_inst, version, stripped;
+    static int          num_of_inst = 3, num_of_inter_func = 1;
+    const char         *filename, *emsg, *serr, *bytecode;
+    size_t              size, bytecode_len;
+    long                fsize;
+
+    serr = NULL;
+
+    *lf->begin_code.str = LUA_SIGNATURE[0];
+
+    if (lf->file_type == NGX_LUA_BT_LJ) {
+        size = fread(lf->begin_code.str + 1, 1, LJ_HEADERSIZE - 1, lf->f);
+
+        if (size != LJ_HEADERSIZE - 1) {
+            serr = strerror(errno);
+            emsg = "cannot read header";
+            goto error;
+        }
+
+        version = *(lf->begin_code.str + 3);
+
+        if (ngx_memcmp(lf->begin_code.str, LJ_SIGNATURE,
+                       sizeof(LJ_SIGNATURE) - 1)
+            || version != LJ_BCDUMP_VERSION)
+        {
+            emsg = "bad byte-code header";
+            goto error;
+        }
+
+#if defined(DDEBUG) && (DDEBUG)
+        {
+        dd("==LJ_BT_HEADER==");
+        size_t i;
+        for (i = 0; i < LJ_HEADERSIZE; i++) {
+            dd("%ld: 0x%02X", i, (unsigned)(u_char)lf->begin_code.str[i]);
+        }
+        dd("==LJ_BT_HEADER_END==");
+        }
+#endif
+
+        lf->begin_code_len = LJ_HEADERSIZE;
+        little_endian = !((*(lf->begin_code.str + 4)) & LJ_BCDUMP_F_BE);
+        stripped = (*(lf->begin_code.str + 4)) & LJ_BCDUMP_F_STRIP;
+
+        if (stripped) {
+            if (little_endian) {
+                lf->end_code.ptr = LJ_LITTLE_ENDIAN_CODE_STRIPPED;
+
+            } else {
+                lf->end_code.ptr = LJ_BIG_ENDIAN_CODE_STRIPPED;
+            }
+
+            lf->end_code_len = LJ_CODE_LEN_STRIPPED;
+
+        } else {
+            if (little_endian) {
+                lf->end_code.ptr = LJ_LITTLE_ENDIAN_CODE;
+
+            } else {
+                lf->end_code.ptr = LJ_BIG_ENDIAN_CODE;
+            }
+
+            lf->end_code_len = LJ_CODE_LEN;
+        }
+
+        fsize = ngx_http_lua_clfactory_file_size(lf->f);
+        if (fsize < 0) {
+            serr = strerror(errno);
+            emsg = "cannot fseek/ftell";
+            goto error;
+        }
+
+        lf->rest_len = fsize - LJ_HEADERSIZE;
+
+#if defined(DDEBUG) && (DDEBUG)
+        {
+        size_t i = 0;
+        dd("==LJ_END_CODE: %ld rest_len: %ld==", lf->end_code_len,
+           lf->rest_len);
+
+        for (i = 0; i < lf->end_code_len; i++) {
+            dd("%ld: 0x%02X", i, (unsigned) ((u_char) lf->end_code.ptr[i]));
+        }
+        dd("==LJ_END_CODE_END==");
+        }
+#endif
+
+    } else {
+        size = fread(lf->begin_code.str + 1, 1, LUAC_HEADERSIZE - 1, lf->f);
+
+        if (size != LUAC_HEADERSIZE - 1) {
+            serr = strerror(errno);
+            emsg = "cannot read header";
+            goto error;
+        }
+
+        version = *(lf->begin_code.str + 4);
+        little_endian = *(lf->begin_code.str + 6);
+        size_of_int = *(lf->begin_code.str + 7);
+        size_of_size_t = *(lf->begin_code.str + 8);
+        size_of_inst = *(lf->begin_code.str + 9);
+
+#if defined(DDEBUG) && (DDEBUG)
+        {
+        dd("==LUA_BT_HEADER==");
+        size_t i;
+        for (i = 0; i < LUAC_HEADERSIZE; i++) {
+            dd("%ld, 0x%02X", i, (unsigned)(u_char)lf->begin_code.str[i]);
+        }
+        dd("==LUA_BT_HEADER_END==");
+        }
+#endif
+
+        if (ngx_memcmp(lf->begin_code.str, LUA_SIGNATURE,
+                       sizeof(LUA_SIGNATURE) -1)
+            || version != LUAC_VERSION
+            || little_endian != (int) (*(char *) &x)
+            || size_of_int != sizeof(int)
+            || size_of_size_t != sizeof(size_t)
+            || (size_of_inst != 4 && size_of_inst != 8))
+        {
+            emsg = "bad byte-code header";
+            goto error;
+        }
+
+        /* clear the following fields to zero:
+         * - source string length
+         * - start line
+         * - last line
+         */
+        ngx_memzero(lf->begin_code.str + POS_SOURCE_STR_LEN,
+                    sizeof(size_t) + sizeof(int) * 2);
+        /* number of upvalues */
+        *(lf->begin_code.str + POS_NUM_OF_UPVS) = 0;
+        /* number of paramters */
+        *(lf->begin_code.str + POS_NUM_OF_PARA) = 0;
+        /* is var-argument function? */
+        *(lf->begin_code.str + POS_IS_VAR_ARG) = 2;
+        /* max stack size */
+        *(lf->begin_code.str + POS_MAX_STACK_SIZE) = 2;
+        /* number of bytecode instructions */
+        ngx_memcpy(lf->begin_code.str + POS_NUM_OF_INST, &num_of_inst,
+                   sizeof(int));
+
+        lf->begin_code_len = POS_BYTECODE;
+
+        if (little_endian) {
+            if (size_of_inst == 4) {
+                bytecode = LUA_LITTLE_ENDIAN_4BYTES_CODE;
+                bytecode_len = LUA_LITTLE_ENDIAN_4BYTES_CODE_LEN;
+
+            } else {
+                bytecode = LUA_LITTLE_ENDIAN_8BYTES_CODE;
+                bytecode_len = LUA_LITTLE_ENDIAN_8BYTES_CODE_LEN;
+            }
+
+        } else {
+            if (size_of_inst == 4) {
+                bytecode = LUA_BIG_ENDIAN_4BYTES_CODE;
+                bytecode_len = LUA_BIG_ENDIAN_4BYTES_CODE_LEN;
+
+            } else {
+                bytecode = LUA_BIG_ENDIAN_8BYTES_CODE;
+                bytecode_len = LUA_BIG_ENDIAN_8BYTES_CODE_LEN;
+            }
+        }
+
+        /* bytecode */
+        ngx_memcpy(lf->begin_code.str + POS_BYTECODE, bytecode, bytecode_len);
+
+        /* number of consts */
+        ngx_memzero(lf->begin_code.str + POS_BYTECODE + bytecode_len,
+                    sizeof(int));
+        /* number of internal functions */
+        ngx_memcpy(lf->begin_code.str + POS_BYTECODE + bytecode_len
+                   + sizeof(int), &num_of_inter_func, sizeof(int));
+
+        lf->begin_code_len += bytecode_len + sizeof(int) + sizeof(int);
+
+#if defined(DDEBUG) && (DDEBUG)
+        {
+        size_t i = 0;
+        dd("==LUA_BEGIN_CODE: %ld==", lf->begin_code_len);
+        for (i = 0; i < lf->begin_code_len; i++) {
+            dd("%ld: 0x%02X", i, (unsigned) ((u_char) lf->begin_code.str[i]));
+        }
+        dd("==LUA_BEGIN_CODE_END==");
+        }
+#endif
+
+        /* clear the following fields to zero:
+         * - lineinfo vector size
+         * - number of local vars
+         * - number of upvalues
+         */
+        ngx_memzero(lf->end_code.str, sizeof(int) * 3);
+
+        lf->end_code_len = sizeof(int) + sizeof(int) + sizeof(int);
+
+#if defined(DDEBUG) && (DDEBUG)
+        {
+        size_t i = 0;
+        dd("==LUA_END_CODE: %ld==", lf->end_code_len);
+        for (i = 0; i < lf->end_code_len; i++) {
+            dd("%ld: 0x%02X", i, (unsigned) ((u_char) lf->end_code.str[i]));
+        }
+        dd("==LUA_END_CODE_END==");
+        }
+#endif
+
+    }
+
+    return 0;
+
+error:
+
+    fclose(lf->f);  /* close file (even in case of errors) */
+
+    filename = lua_tostring(L, fname_index) + 1;
+
+    if (serr) {
+        lua_pushfstring(L, "%s in %s: %s", emsg, filename, serr);
+
+    } else {
+        lua_pushfstring(L, "%s in %s", emsg, filename);
+    }
+
+    lua_remove(L, fname_index);
+
+    return LUA_ERRFILE;
+}
+
+
+int
+ngx_http_lua_clfactory_loadfile(lua_State *L, const char *filename)
+{
+    int                         c, status, readstatus;
+    ngx_flag_t                  sharp;
+
+    ngx_http_lua_clfactory_file_ctx_t        lf;
+
+    /* index of filename on the stack */
+    int                         fname_index;
+
+    sharp = 0;
+    fname_index = lua_gettop(L) + 1;
+
+    lf.extraline = 0;
+    lf.file_type = NGX_LUA_TEXT_FILE;
+
+    lf.begin_code.ptr = CLFACTORY_BEGIN_CODE;
+    lf.begin_code_len = CLFACTORY_BEGIN_SIZE;
+    lf.end_code.ptr = CLFACTORY_END_CODE;
+    lf.end_code_len = CLFACTORY_END_SIZE;
+
+    lua_pushfstring(L, "@%s", filename);
+
+    lf.f = fopen(filename, "r");
+    if (lf.f == NULL) {
+        return ngx_http_lua_clfactory_errfile(L, "open", fname_index);
+    }
+
+    c = getc(lf.f);
+
+    if (c == '#') {  /* Unix exec. file? */
+        lf.extraline = 1;
+
+        while ((c = getc(lf.f)) != EOF && c != '\n') {
+            /* skip first line */
+        }
+
+        if (c == '\n') {
+            c = getc(lf.f);
+        }
+
+        sharp = 1;
+    }
+
+    if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
+        lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
+
+        if (lf.f == NULL) {
+            return ngx_http_lua_clfactory_errfile(L, "reopen", fname_index);
+        }
+
+        /* check whether lib jit exists */
+        luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);
+        lua_getfield(L, -1, "jit");  /* get _LOADED["jit"] */
+
+        if (lua_istable(L, -1)) {
+            lf.file_type = NGX_LUA_BT_LJ;
+
+        } else {
+            lf.file_type = NGX_LUA_BT_LUA;
+        }
+
+        lua_pop(L, 2);
+
+        /*
+         * Loading bytecode with an extra header is disabled for security
+         * reasons. This may circumvent the usual check for bytecode vs.
+         * Lua code by looking at the first char. Since this is a potential
+         * security violation no attempt is made to echo the chunkname either.
+         */
+        if (lf.file_type == NGX_LUA_BT_LJ && sharp) {
+
+            if (filename) {
+                fclose(lf.f);  /* close file (even in case of errors) */
+            }
+
+            filename = lua_tostring(L, fname_index) + 1;
+            lua_pushfstring(L, "bad byte-code header in %s", filename);
+            lua_remove(L, fname_index);
+
+            return LUA_ERRFILE;
+        }
+
+        while ((c = getc(lf.f)) != EOF && c != LUA_SIGNATURE[0]) {
+            /* skip eventual `#!...' */
+        }
+
+        status = ngx_http_lua_clfactory_bytecode_prepare(L, &lf, fname_index);
+
+        if (status != 0) {
+            return status;
+        }
+
+        lf.extraline = 0;
+    }
+
+    if (lf.file_type == NGX_LUA_TEXT_FILE) {
+        ungetc(c, lf.f);
+    }
+
+    lf.sent_begin = lf.sent_end = 0;
+    status = lua_load(L, ngx_http_lua_clfactory_getF, &lf,
+                      lua_tostring(L, -1));
+
+    readstatus = ferror(lf.f);
+
+    if (filename) {
+        fclose(lf.f);  /* close file (even in case of errors) */
+    }
+
+    if (readstatus) {
+        lua_settop(L, fname_index);  /* ignore results from `lua_load' */
+        return ngx_http_lua_clfactory_errfile(L, "read", fname_index);
+    }
+
+    lua_remove(L, fname_index);
+
+    return status;
+}
+
+
+int
+ngx_http_lua_clfactory_loadbuffer(lua_State *L, const char *buff,
+    size_t size, const char *name)
+{
+    ngx_http_lua_clfactory_buffer_ctx_t     ls;
+
+    ls.s = buff;
+    ls.size = size;
+    ls.sent_begin = 0;
+    ls.sent_end = 0;
+
+    return lua_load(L, ngx_http_lua_clfactory_getS, &ls, name);
+}
+
+
+static const char *
+ngx_http_lua_clfactory_getF(lua_State *L, void *ud, size_t *size)
+{
+    char                        *buf;
+    size_t                       num;
+
+    ngx_http_lua_clfactory_file_ctx_t        *lf;
+
+    lf = (ngx_http_lua_clfactory_file_ctx_t *) ud;
+
+    if (lf->extraline) {
+        lf->extraline = 0;
+        *size = 1;
+        return "\n";
+    }
+
+    if (lf->sent_begin == 0) {
+        lf->sent_begin = 1;
+        *size = lf->begin_code_len;
+
+        if (lf->file_type == NGX_LUA_TEXT_FILE) {
+            buf = lf->begin_code.ptr;
+
+        } else {
+            buf = lf->begin_code.str;
+        }
+
+        return buf;
+    }
+
+    if (feof(lf->f)) {
+
+        if (lf->sent_end == 0) {
+            lf->sent_end = 1;
+            *size = lf->end_code_len;
+
+            if (lf->file_type == NGX_LUA_BT_LUA) {
+                buf = lf->end_code.str;
+
+            } else {
+                buf = lf->end_code.ptr;
+            }
+
+            return buf;
+        }
+
+        return NULL;
+    }
+
+    num = fread(lf->buff, 1, sizeof(lf->buff), lf->f);
+
+    /* skip the footer(\x00) in luajit */
+    if (num > 0 && lf->file_type == NGX_LUA_BT_LJ) {
+        lf->rest_len -= num;
+
+        if (lf->rest_len == 0) {
+            if (--num == 0 && lf->sent_end == 0) {
+                lf->sent_end = 1;
+                buf = lf->end_code.ptr;
+                *size = lf->end_code_len;
+
+                return buf;
+            }
+        }
+    }
+
+    *size = num;
+
+    return (*size > 0) ? lf->buff : NULL;
+}
+
+
+static int
+ngx_http_lua_clfactory_errfile(lua_State *L, const char *what, int fname_index)
+{
+    const char      *serr;
+    const char      *filename;
+
+    filename = lua_tostring(L, fname_index) + 1;
+
+    if (errno) {
+        serr = strerror(errno);
+        lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
+
+    } else {
+        lua_pushfstring(L, "cannot %s %s", what, filename);
+    }
+
+    lua_remove(L, fname_index);
+
+    return LUA_ERRFILE;
+}
+
+
+static const char *
+ngx_http_lua_clfactory_getS(lua_State *L, void *ud, size_t *size)
+{
+    ngx_http_lua_clfactory_buffer_ctx_t      *ls = ud;
+
+    if (ls->sent_begin == 0) {
+        ls->sent_begin = 1;
+        *size = CLFACTORY_BEGIN_SIZE;
+
+        return CLFACTORY_BEGIN_CODE;
+    }
+
+    if (ls->size == 0) {
+        if (ls->sent_end == 0) {
+            ls->sent_end = 1;
+            *size = CLFACTORY_END_SIZE;
+            return CLFACTORY_END_CODE;
+        }
+
+        return NULL;
+    }
+
+    *size = ls->size;
+    ls->size = 0;
+
+    return ls->s;
+}
+
+
+static long
+ngx_http_lua_clfactory_file_size(FILE *f)
+{
+    long              cur_pos, len;
+
+    cur_pos = ftell(f);
+    if (cur_pos == -1) {
+        return -1;
+    }
+
+    if (fseek(f, 0, SEEK_END) != 0) {
+        return -1;
+    }
+
+    len = ftell(f);
+    if (len == -1) {
+        return -1;
+    }
+
+    if (fseek(f, cur_pos, SEEK_SET) != 0) {
+        return -1;
+    }
+
+    return len;
+}
+
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.h b/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_clfactory.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,22 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CLFACTORY_H_INCLUDED_
+#define _NGX_HTTP_LUA_CLFACTORY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+int ngx_http_lua_clfactory_loadfile(lua_State *L, const char *filename);
+int ngx_http_lua_clfactory_loadbuffer(lua_State *L, const char *buff,
+    size_t size, const char *name);
+
+
+#endif /* _NGX_HTTP_LUA_CLFACTORY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_common.h b/src/lua/lua-nginx-module/src/ngx_http_lua_common.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_common.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_common.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,424 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_COMMON_H_INCLUDED_
+#define _NGX_HTTP_LUA_COMMON_H_INCLUDED_
+
+
+#include <nginx.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <ngx_md5.h>
+
+#include <assert.h>
+#include <setjmp.h>
+#include <stdint.h>
+
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
+
+#if defined(NDK) && NDK
+#include <ndk.h>
+#endif
+
+#ifndef MD5_DIGEST_LENGTH
+#define MD5_DIGEST_LENGTH 16
+#endif
+
+/* Nginx HTTP Lua Inline tag prefix */
+
+#define NGX_HTTP_LUA_INLINE_TAG "nhli_"
+
+#define NGX_HTTP_LUA_INLINE_TAG_LEN \
+    (sizeof(NGX_HTTP_LUA_INLINE_TAG) - 1)
+
+#define NGX_HTTP_LUA_INLINE_KEY_LEN \
+    (NGX_HTTP_LUA_INLINE_TAG_LEN + 2 * MD5_DIGEST_LENGTH)
+
+/* Nginx HTTP Lua File tag prefix */
+
+#define NGX_HTTP_LUA_FILE_TAG "nhlf_"
+
+#define NGX_HTTP_LUA_FILE_TAG_LEN \
+    (sizeof(NGX_HTTP_LUA_FILE_TAG) - 1)
+
+#define NGX_HTTP_LUA_FILE_KEY_LEN \
+    (NGX_HTTP_LUA_FILE_TAG_LEN + 2 * MD5_DIGEST_LENGTH)
+
+
+#if defined(NDK) && NDK
+typedef struct {
+    size_t       size;
+    u_char      *key;
+    ngx_str_t    script;
+} ngx_http_lua_set_var_data_t;
+#endif
+
+
+#ifndef NGX_HTTP_LUA_MAX_ARGS
+#define NGX_HTTP_LUA_MAX_ARGS 100
+#endif
+
+
+#ifndef NGX_HTTP_LUA_MAX_HEADERS
+#define NGX_HTTP_LUA_MAX_HEADERS 100
+#endif
+
+
+#define NGX_HTTP_LUA_CONTEXT_SET            0x01
+#define NGX_HTTP_LUA_CONTEXT_REWRITE        0x02
+#define NGX_HTTP_LUA_CONTEXT_ACCESS         0x04
+#define NGX_HTTP_LUA_CONTEXT_CONTENT        0x08
+#define NGX_HTTP_LUA_CONTEXT_LOG            0x10
+#define NGX_HTTP_LUA_CONTEXT_HEADER_FILTER  0x20
+#define NGX_HTTP_LUA_CONTEXT_BODY_FILTER    0x40
+#define NGX_HTTP_LUA_CONTEXT_TIMER          0x80
+
+
+typedef struct ngx_http_lua_main_conf_s ngx_http_lua_main_conf_t;
+
+
+typedef ngx_int_t (*ngx_http_lua_conf_handler_pt)(ngx_log_t *log,
+        ngx_http_lua_main_conf_t *lmcf, lua_State *L);
+
+
+typedef struct {
+    u_char              *package;
+    lua_CFunction        loader;
+} ngx_http_lua_preload_hook_t;
+
+
+struct ngx_http_lua_main_conf_s {
+    lua_State           *lua;
+
+    ngx_str_t            lua_path;
+    ngx_str_t            lua_cpath;
+
+    ngx_pool_t          *pool;
+
+    ngx_int_t            max_pending_timers;
+    ngx_int_t            pending_timers;
+
+    ngx_int_t            max_running_timers;
+    ngx_int_t            running_timers;
+
+    ngx_connection_t    *watcher;  /* for watching the process exit event */
+
+#if (NGX_PCRE)
+    ngx_int_t            regex_cache_entries;
+    ngx_int_t            regex_cache_max_entries;
+    ngx_int_t            regex_match_limit;
+#endif
+
+    ngx_array_t         *shm_zones;  /* of ngx_shm_zone_t* */
+
+    ngx_array_t         *preload_hooks; /* of ngx_http_lua_preload_hook_t */
+
+    ngx_flag_t           postponed_to_rewrite_phase_end;
+    ngx_flag_t           postponed_to_access_phase_end;
+
+    ngx_http_lua_conf_handler_pt    init_handler;
+    ngx_str_t                       init_src;
+    ngx_uint_t                      shm_zones_inited;
+
+    unsigned             requires_header_filter:1;
+    unsigned             requires_body_filter:1;
+    unsigned             requires_capture_filter:1;
+    unsigned             requires_rewrite:1;
+    unsigned             requires_access:1;
+    unsigned             requires_log:1;
+    unsigned             requires_shm:1;
+};
+
+
+typedef struct {
+    ngx_flag_t              force_read_body; /* whether force request body to
+                                                be read */
+
+    ngx_flag_t              enable_code_cache; /* whether to enable
+                                                  code cache */
+
+    ngx_flag_t              http10_buffering;
+
+    ngx_http_handler_pt     rewrite_handler;
+    ngx_http_handler_pt     access_handler;
+    ngx_http_handler_pt     content_handler;
+    ngx_http_handler_pt     log_handler;
+    ngx_http_handler_pt     header_filter_handler;
+
+    ngx_http_output_body_filter_pt         body_filter_handler;
+
+    ngx_http_complex_value_t rewrite_src;    /*  rewrite_by_lua
+                                                inline script/script
+                                                file path */
+
+    u_char                 *rewrite_src_key; /* cached key for rewrite_src */
+
+    ngx_http_complex_value_t access_src;     /*  access_by_lua
+                                                inline script/script
+                                                file path */
+
+    u_char                  *access_src_key; /* cached key for access_src */
+
+    ngx_http_complex_value_t content_src;    /*  content_by_lua
+                                                inline script/script
+                                                file path */
+
+    u_char                 *content_src_key; /* cached key for content_src */
+
+
+    ngx_http_complex_value_t     log_src;     /* log_by_lua inline script/script
+                                                 file path */
+
+    u_char                      *log_src_key; /* cached key for log_src */
+
+    ngx_http_complex_value_t header_filter_src;  /*  header_filter_by_lua
+                                                     inline script/script
+                                                     file path */
+
+    u_char                 *header_filter_src_key;
+                                    /* cached key for header_filter_src */
+
+
+    ngx_http_complex_value_t         body_filter_src;
+    u_char                          *body_filter_src_key;
+
+    ngx_msec_t                       keepalive_timeout;
+    ngx_msec_t                       connect_timeout;
+    ngx_msec_t                       send_timeout;
+    ngx_msec_t                       read_timeout;
+
+    size_t                           send_lowat;
+    size_t                           buffer_size;
+
+    ngx_uint_t                       pool_size;
+
+    ngx_flag_t                       transform_underscores_in_resp_headers;
+    ngx_flag_t                       log_socket_errors;
+    ngx_flag_t                       check_client_abort;
+} ngx_http_lua_loc_conf_t;
+
+
+typedef enum {
+    NGX_HTTP_LUA_USER_CORO_NOP      = 0,
+    NGX_HTTP_LUA_USER_CORO_RESUME   = 1,
+    NGX_HTTP_LUA_USER_CORO_YIELD    = 2,
+    NGX_HTTP_LUA_USER_THREAD_RESUME = 3
+} ngx_http_lua_user_coro_op_t;
+
+
+typedef enum {
+    NGX_HTTP_LUA_CO_RUNNING   = 0, /* coroutine running */
+    NGX_HTTP_LUA_CO_SUSPENDED = 1, /* coroutine suspended */
+    NGX_HTTP_LUA_CO_NORMAL    = 2, /* coroutine normal */
+    NGX_HTTP_LUA_CO_DEAD      = 3, /* coroutine dead */
+    NGX_HTTP_LUA_CO_ZOMBIE    = 4, /* coroutine zombie */
+} ngx_http_lua_co_status_t;
+
+
+typedef struct ngx_http_lua_co_ctx_s  ngx_http_lua_co_ctx_t;
+
+typedef struct ngx_http_lua_posted_thread_s  ngx_http_lua_posted_thread_t;
+
+struct ngx_http_lua_posted_thread_s {
+    ngx_http_lua_co_ctx_t               *co_ctx;
+    ngx_http_lua_posted_thread_t        *next;
+};
+
+
+enum {
+    NGX_HTTP_LUA_SUBREQ_TRUNCATED = 1
+};
+
+
+struct ngx_http_lua_co_ctx_s {
+    void                    *data;      /* user state for cosockets */
+
+    lua_State               *co;
+    ngx_http_lua_co_ctx_t   *parent_co_ctx;
+
+    ngx_http_lua_posted_thread_t    *zombie_child_threads;
+
+    ngx_http_cleanup_pt      cleanup;
+
+    unsigned                 nsubreqs;  /* number of subrequests of the
+                                         * current request */
+
+    ngx_int_t               *sr_statuses; /* all capture subrequest statuses */
+
+    ngx_http_headers_out_t **sr_headers;
+
+    ngx_str_t               *sr_bodies;   /* all captured subrequest bodies */
+
+    uint8_t                 *sr_flags;
+
+    unsigned                 pending_subreqs; /* number of subrequests being
+                                                 waited */
+
+    ngx_event_t              sleep;  /* used for ngx.sleep */
+
+    int                      co_ref; /*  reference to anchor the thread
+                                         coroutines (entry coroutine and user
+                                         threads) in the Lua registry,
+                                         preventing the thread coroutine
+                                         from beging collected by the
+                                         Lua GC */
+
+    unsigned                 waited_by_parent:1;  /* whether being waited by
+                                                     a parent coroutine */
+
+    unsigned                 co_status:3;  /* the current coroutine's status */
+
+    unsigned                 flushing:1; /* indicates whether the current
+                                            coroutine is waiting for
+                                            ngx.flush(true) */
+
+    unsigned                 is_uthread:1; /* whether the current coroutine is
+                                              a user thread */
+
+    unsigned                 thread_spawn_yielded:1; /* yielded from
+                                                        the ngx.thread.spawn()
+                                                        call */
+};
+
+
+typedef struct ngx_http_lua_ctx_s {
+    ngx_http_request_t      *request;
+    ngx_http_handler_pt      resume_handler;
+
+    ngx_http_lua_co_ctx_t   *cur_co_ctx; /* co ctx for the current coroutine */
+
+    /* FIXME: we should use rbtree here to prevent O(n) lookup overhead */
+    ngx_list_t              *user_co_ctx; /* coroutine contexts for user
+                                             coroutines */
+
+    ngx_http_lua_co_ctx_t    entry_co_ctx; /* coroutine context for the
+                                              entry coroutine */
+
+    ngx_http_lua_co_ctx_t   *on_abort_co_ctx; /* coroutine context for the
+                                                 on_abort thread */
+
+    int                      ctx_ref;  /*  reference to anchor
+                                           request ctx data in lua
+                                           registry */
+
+    unsigned                 flushing_coros; /* number of coroutines waiting on
+                                                ngx.flush(true) */
+
+    unsigned                 uthreads; /* number of active user threads */
+
+    ngx_chain_t             *out;  /* buffered output chain for HTTP 1.0 */
+    ngx_chain_t             *free_bufs;
+    ngx_chain_t             *busy_bufs;
+    ngx_chain_t             *free_recv_bufs;
+    ngx_chain_t             *flush_buf;
+
+    ngx_http_cleanup_pt     *cleanup;
+
+    ngx_chain_t             *body; /* buffered subrequest response body
+                                      chains */
+
+    ngx_chain_t            **last_body; /* for the "body" field */
+
+    ngx_str_t                exec_uri;
+    ngx_str_t                exec_args;
+
+    ngx_int_t                exit_code;
+
+    ngx_http_lua_co_ctx_t   *downstream_co_ctx; /* co ctx for the coroutine
+                                                   reading the request body */
+
+    ngx_uint_t               index;              /* index of the current
+                                                    subrequest in its parent
+                                                    request */
+
+    ngx_http_lua_posted_thread_t   *posted_threads;
+
+    uint16_t                 context;   /* the current running directive context
+                                           (or running phase) for the current
+                                           Lua chunk */
+
+    unsigned                 run_post_subrequest:1; /* whether it has run
+                                                       post_subrequest
+                                                       (for subrequests only) */
+
+    unsigned                 waiting_more_body:1;   /* 1: waiting for more
+                                                       request body data;
+                                                       0: no need to wait */
+
+    unsigned         co_op:2; /*  coroutine API operation */
+
+    unsigned         exited:1;
+
+    unsigned         eof:1;             /*  1: last_buf has been sent;
+                                            0: last_buf not sent yet */
+
+    unsigned         capture:1;  /*  1: response body of current request
+                                        is to be captured by the lua
+                                        capture filter,
+                                     0: not to be captured */
+
+
+    unsigned         read_body_done:1;      /* 1: request body has been all
+                                               read; 0: body has not been
+                                               all read */
+
+    unsigned         headers_set:1; /* whether the user has set custom
+                                       response headers */
+
+    unsigned         entered_rewrite_phase:1;
+    unsigned         entered_access_phase:1;
+    unsigned         entered_content_phase:1;
+
+    unsigned         buffering:1; /* HTTP 1.0 response body buffering flag */
+
+    unsigned         no_abort:1; /* prohibit "world abortion" via ngx.exit()
+                                    and etc */
+
+    unsigned         seen_last_in_filter:1;  /* used by body_filter_by_lua* */
+    unsigned         seen_last_for_subreq:1; /* used by body capture filter */
+    unsigned         writing_raw_req_socket:1; /* used by raw downstream
+                                                  socket */
+    unsigned         acquired_raw_req_socket:1;  /* whether a raw req socket
+                                                    is acquired */
+} ngx_http_lua_ctx_t;
+
+
+typedef struct ngx_http_lua_header_val_s ngx_http_lua_header_val_t;
+
+
+typedef ngx_int_t (*ngx_http_lua_set_header_pt)(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+
+
+struct ngx_http_lua_header_val_s {
+    ngx_http_complex_value_t                value;
+    ngx_uint_t                              hash;
+    ngx_str_t                               key;
+    ngx_http_lua_set_header_pt              handler;
+    ngx_uint_t                              offset;
+    unsigned                                no_override;
+};
+
+
+typedef struct {
+    ngx_str_t                               name;
+    ngx_uint_t                              offset;
+    ngx_http_lua_set_header_pt              handler;
+
+} ngx_http_lua_set_header_t;
+
+
+extern ngx_module_t ngx_http_lua_module;
+extern ngx_http_output_header_filter_pt ngx_http_lua_next_header_filter;
+extern ngx_http_output_body_filter_pt ngx_http_lua_next_body_filter;
+
+
+#endif /* _NGX_HTTP_LUA_COMMON_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_config.c b/src/lua/lua-nginx-module/src/ngx_http_lua_config.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_config.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_config.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,32 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_config.h"
+
+
+void
+ngx_http_lua_inject_config_api(lua_State *L)
+{
+    /* ngx.config */
+
+    lua_createtable(L, 0, 1 /* nrec */);    /* .config */
+
+#if (NGX_DEBUG)
+    lua_pushboolean(L, 1);
+#else
+    lua_pushboolean(L, 0);
+#endif
+
+    lua_setfield(L, -2, "debug");
+
+    lua_setfield(L, -2, "config");
+}
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_config.h b/src/lua/lua-nginx-module/src/ngx_http_lua_config.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_config.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,19 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CONFIG_H_INCLUDED_
+#define _NGX_HTTP_LUA_CONFIG_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_config_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_CONFIG_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_consts.c b/src/lua/lua-nginx-module/src/ngx_http_lua_consts.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_consts.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_consts.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,148 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_consts.h"
+
+
+void
+ngx_http_lua_inject_core_consts(lua_State *L)
+{
+    /* {{{ core constants */
+    lua_pushinteger(L, NGX_OK);
+    lua_setfield(L, -2, "OK");
+
+    lua_pushinteger(L, NGX_AGAIN);
+    lua_setfield(L, -2, "AGAIN");
+
+    lua_pushinteger(L, NGX_DONE);
+    lua_setfield(L, -2, "DONE");
+
+    lua_pushinteger(L, NGX_DECLINED);
+    lua_setfield(L, -2, "DECLINED");
+
+    lua_pushinteger(L, NGX_ERROR);
+    lua_setfield(L, -2, "ERROR");
+
+    lua_pushlightuserdata(L, NULL);
+    lua_setfield(L, -2, "null");
+    /* }}} */
+}
+
+
+void
+ngx_http_lua_inject_http_consts(lua_State *L)
+{
+    /* {{{ HTTP status constants */
+    lua_pushinteger(L, NGX_HTTP_GET);
+    lua_setfield(L, -2, "HTTP_GET");
+
+    lua_pushinteger(L, NGX_HTTP_POST);
+    lua_setfield(L, -2, "HTTP_POST");
+
+    lua_pushinteger(L, NGX_HTTP_PUT);
+    lua_setfield(L, -2, "HTTP_PUT");
+
+    lua_pushinteger(L, NGX_HTTP_HEAD);
+    lua_setfield(L, -2, "HTTP_HEAD");
+
+    lua_pushinteger(L, NGX_HTTP_DELETE);
+    lua_setfield(L, -2, "HTTP_DELETE");
+
+    lua_pushinteger(L, NGX_HTTP_OPTIONS);
+    lua_setfield(L, -2, "HTTP_OPTIONS");
+
+    lua_pushinteger(L, NGX_HTTP_MKCOL);
+    lua_setfield(L, -2, "HTTP_MKCOL");
+
+    lua_pushinteger(L, NGX_HTTP_COPY);
+    lua_setfield(L, -2, "HTTP_COPY");
+
+    lua_pushinteger(L, NGX_HTTP_MOVE);
+    lua_setfield(L, -2, "HTTP_MOVE");
+
+    lua_pushinteger(L, NGX_HTTP_PROPFIND);
+    lua_setfield(L, -2, "HTTP_PROPFIND");
+
+    lua_pushinteger(L, NGX_HTTP_PROPPATCH);
+    lua_setfield(L, -2, "HTTP_PROPPATCH");
+
+    lua_pushinteger(L, NGX_HTTP_LOCK);
+    lua_setfield(L, -2, "HTTP_LOCK");
+
+    lua_pushinteger(L, NGX_HTTP_UNLOCK);
+    lua_setfield(L, -2, "HTTP_UNLOCK");
+
+    lua_pushinteger(L, NGX_HTTP_PATCH);
+    lua_setfield(L, -2, "HTTP_PATCH");
+
+    lua_pushinteger(L, NGX_HTTP_TRACE);
+    lua_setfield(L, -2, "HTTP_TRACE");
+    /* }}} */
+
+    lua_pushinteger(L, NGX_HTTP_OK);
+    lua_setfield(L, -2, "HTTP_OK");
+
+    lua_pushinteger(L, NGX_HTTP_CREATED);
+    lua_setfield(L, -2, "HTTP_CREATED");
+
+    lua_pushinteger(L, NGX_HTTP_SPECIAL_RESPONSE);
+    lua_setfield(L, -2, "HTTP_SPECIAL_RESPONSE");
+
+    lua_pushinteger(L, NGX_HTTP_MOVED_PERMANENTLY);
+    lua_setfield(L, -2, "HTTP_MOVED_PERMANENTLY");
+
+    lua_pushinteger(L, NGX_HTTP_MOVED_TEMPORARILY);
+    lua_setfield(L, -2, "HTTP_MOVED_TEMPORARILY");
+
+#if defined(nginx_version) && nginx_version >= 8042
+    lua_pushinteger(L, NGX_HTTP_SEE_OTHER);
+    lua_setfield(L, -2, "HTTP_SEE_OTHER");
+#endif
+
+    lua_pushinteger(L, NGX_HTTP_NOT_MODIFIED);
+    lua_setfield(L, -2, "HTTP_NOT_MODIFIED");
+
+    lua_pushinteger(L, NGX_HTTP_BAD_REQUEST);
+    lua_setfield(L, -2, "HTTP_BAD_REQUEST");
+
+    lua_pushinteger(L, NGX_HTTP_UNAUTHORIZED);
+    lua_setfield(L, -2, "HTTP_UNAUTHORIZED");
+
+
+    lua_pushinteger(L, NGX_HTTP_FORBIDDEN);
+    lua_setfield(L, -2, "HTTP_FORBIDDEN");
+
+    lua_pushinteger(L, NGX_HTTP_NOT_FOUND);
+    lua_setfield(L, -2, "HTTP_NOT_FOUND");
+
+    lua_pushinteger(L, NGX_HTTP_NOT_ALLOWED);
+    lua_setfield(L, -2, "HTTP_NOT_ALLOWED");
+
+    lua_pushinteger(L, 410);
+    lua_setfield(L, -2, "HTTP_GONE");
+
+    lua_pushinteger(L, NGX_HTTP_INTERNAL_SERVER_ERROR);
+    lua_setfield(L, -2, "HTTP_INTERNAL_SERVER_ERROR");
+
+    lua_pushinteger(L, 501);
+    lua_setfield(L, -2, "HTTP_METHOD_NOT_IMPLEMENTED");
+
+    lua_pushinteger(L, NGX_HTTP_SERVICE_UNAVAILABLE);
+    lua_setfield(L, -2, "HTTP_SERVICE_UNAVAILABLE");
+
+    lua_pushinteger(L, 504);
+    lua_setfield(L, -2, "HTTP_GATEWAY_TIMEOUT");
+    /* }}} */
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_consts.h b/src/lua/lua-nginx-module/src/ngx_http_lua_consts.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_consts.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_consts.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,13 @@
+#ifndef NGX_HTTP_LUA_CONSTS
+#define NGX_HTTP_LUA_CONSTS
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_http_consts(lua_State *L);
+void ngx_http_lua_inject_core_consts(lua_State *L);
+
+
+#endif /* NGX_HTTP_LUA_CONSTS */
+
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,367 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_cache.h"
+#include "ngx_http_lua_probe.h"
+
+
+static void ngx_http_lua_content_phase_post_read(ngx_http_request_t *r);
+
+
+ngx_int_t
+ngx_http_lua_content_by_chunk(lua_State *L, ngx_http_request_t *r)
+{
+    int                      co_ref;
+    ngx_int_t                rc;
+    lua_State               *co;
+    ngx_http_lua_ctx_t      *ctx;
+    ngx_http_cleanup_t      *cln;
+
+    ngx_http_lua_loc_conf_t      *llcf;
+
+    dd("content by chunk");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+    } else {
+        dd("reset ctx");
+        ngx_http_lua_reset_ctx(r, L, ctx);
+    }
+
+    ctx->entered_content_phase = 1;
+
+    /*  {{{ new coroutine to handle request */
+    co = ngx_http_lua_new_thread(r, L, &co_ref);
+
+    if (co == NULL) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                     "lua: failed to create new coroutine to handle request");
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    /*  move code closure to new coroutine */
+    lua_xmove(L, co, 1);
+
+    /*  set closure's env table to new coroutine's globals table */
+    lua_pushvalue(co, LUA_GLOBALSINDEX);
+    lua_setfenv(co, -2);
+
+    /*  save nginx request in coroutine globals table */
+    ngx_http_lua_set_req(co, r);
+
+    ctx->cur_co_ctx = &ctx->entry_co_ctx;
+    ctx->cur_co_ctx->co = co;
+    ctx->cur_co_ctx->co_ref = co_ref;
+
+    /*  {{{ register request cleanup hooks */
+    if (ctx->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        cln->handler = ngx_http_lua_request_cleanup_handler;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+    }
+    /*  }}} */
+
+    ctx->context = NGX_HTTP_LUA_CONTEXT_CONTENT;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->check_client_abort) {
+        r->read_event_handler = ngx_http_lua_rd_check_broken_connection;
+
+    } else {
+        r->read_event_handler = ngx_http_block_reading;
+    }
+
+    rc = ngx_http_lua_run_thread(L, r, ctx, 0);
+
+    if (rc == NGX_ERROR || rc >= NGX_OK) {
+        return rc;
+    }
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_content_run_posted_threads(L, r, ctx, 0);
+    }
+
+    if (rc == NGX_DONE) {
+        return ngx_http_lua_content_run_posted_threads(L, r, ctx, 1);
+    }
+
+    return NGX_OK;
+}
+
+
+void
+ngx_http_lua_content_wev_handler(ngx_http_request_t *r)
+{
+    ngx_http_lua_ctx_t          *ctx;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return;
+    }
+
+    (void) ctx->resume_handler(r);
+}
+
+
+ngx_int_t
+ngx_http_lua_content_handler(ngx_http_request_t *r)
+{
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua content handler, uri:\"%V\" c:%ud", &r->uri,
+                   r->main->count);
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->content_handler == NULL) {
+        dd("no content handler found");
+        return NGX_DECLINED;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+    }
+
+    dd("entered? %d", (int) ctx->entered_content_phase);
+
+    if (ctx->waiting_more_body) {
+        return NGX_DONE;
+    }
+
+    if (ctx->entered_content_phase) {
+        dd("calling wev handler");
+        rc = ctx->resume_handler(r);
+        dd("wev handler returns %d", (int) rc);
+        return rc;
+    }
+
+    if (llcf->force_read_body && !ctx->read_body_done) {
+        r->request_body_in_single_buf = 1;
+        r->request_body_in_persistent_file = 1;
+        r->request_body_in_clean_file = 1;
+
+        rc = ngx_http_read_client_request_body(r,
+                                       ngx_http_lua_content_phase_post_read);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+#if (nginx_version < 1002006) ||                                             \
+        (nginx_version >= 1003000 && nginx_version < 1003009)
+            r->main->count--;
+#endif
+            return rc;
+        }
+
+        if (rc == NGX_AGAIN) {
+            ctx->waiting_more_body = 1;
+
+            return NGX_DONE;
+        }
+    }
+
+    dd("setting entered");
+
+    ctx->entered_content_phase = 1;
+
+    dd("calling content handler");
+    return llcf->content_handler(r);
+}
+
+
+/* post read callback for the content phase */
+static void
+ngx_http_lua_content_phase_post_read(ngx_http_request_t *r)
+{
+    ngx_http_lua_ctx_t  *ctx;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    ctx->read_body_done = 1;
+
+    if (ctx->waiting_more_body) {
+        ctx->waiting_more_body = 0;
+        ngx_http_lua_finalize_request(r, ngx_http_lua_content_handler(r));
+
+    } else {
+        r->main->count--;
+    }
+}
+
+
+ngx_int_t
+ngx_http_lua_content_handler_file(ngx_http_request_t *r)
+{
+    lua_State                       *L;
+    ngx_int_t                        rc;
+    u_char                          *script_path;
+    ngx_http_lua_main_conf_t        *lmcf;
+    ngx_http_lua_loc_conf_t         *llcf;
+    ngx_str_t                        eval_src;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (ngx_http_complex_value(r, &llcf->content_src, &eval_src) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    script_path = ngx_http_lua_rebase_path(r->pool, eval_src.data,
+            eval_src.len);
+
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    L = lmcf->lua;
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path, llcf->content_src_key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    /*  make sure we have a valid code chunk */
+    assert(lua_isfunction(L, -1));
+
+    return ngx_http_lua_content_by_chunk(L, r);
+}
+
+
+ngx_int_t
+ngx_http_lua_content_handler_inline(ngx_http_request_t *r)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    /*  load Lua inline script (w/ cache) sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, llcf->content_src.value.data,
+                                       llcf->content_src.value.len,
+                                       llcf->content_src_key,
+                                       "content_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    return ngx_http_lua_content_by_chunk(L, r);
+}
+
+
+ngx_int_t
+ngx_http_lua_content_run_posted_threads(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, int n)
+{
+    ngx_int_t                        rc;
+    ngx_http_lua_posted_thread_t    *pt;
+
+    dd("run posted threads: %p", ctx->posted_threads);
+
+    for ( ;; ) {
+        pt = ctx->posted_threads;
+        if (pt == NULL) {
+            goto done;
+        }
+
+        ctx->posted_threads = pt->next;
+
+        ngx_http_lua_probe_run_posted_thread(r, pt->co_ctx->co,
+                                             (int) pt->co_ctx->co_status);
+
+        dd("posted thread status: %d", pt->co_ctx->co_status);
+
+        if (pt->co_ctx->co_status != NGX_HTTP_LUA_CO_RUNNING) {
+            continue;
+        }
+
+        ctx->cur_co_ctx = pt->co_ctx;
+
+        rc = ngx_http_lua_run_thread(L, r, ctx, 0);
+
+        if (rc == NGX_AGAIN) {
+            continue;
+        }
+
+        if (rc == NGX_DONE) {
+            n++;
+            continue;
+        }
+
+        if (rc == NGX_OK) {
+            while (n > 0) {
+                ngx_http_lua_finalize_request(r, NGX_DONE);
+                n--;
+            }
+
+            return NGX_OK;
+        }
+
+        /* rc == NGX_ERROR || rc > NGX_OK */
+
+        return rc;
+    }
+
+done:
+    if (n == 1) {
+        return NGX_DONE;
+    }
+
+    if (n == 0) {
+        r->main->count++;
+        return NGX_DONE;
+    }
+
+    /* n > 1 */
+
+    do {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+    } while (--n > 1);
+
+    return NGX_DONE;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_contentby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,26 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CONTENT_BY_H_INCLUDED_
+#define _NGX_HTTP_LUA_CONTENT_BY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_content_by_chunk(lua_State *l, ngx_http_request_t *r);
+void ngx_http_lua_content_wev_handler(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_content_handler_file(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_content_handler_inline(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_content_handler(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_content_run_posted_threads(lua_State *L,
+    ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx, int n);
+
+
+#endif /* _NGX_HTTP_LUA_CONTENT_BY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_control.c b/src/lua/lua-nginx-module/src/ngx_http_lua_control.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_control.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_control.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,401 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+#include "ngx_http_lua_control.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_coroutine.h"
+
+
+static int ngx_http_lua_ngx_exec(lua_State *L);
+static int ngx_http_lua_ngx_redirect(lua_State *L);
+static int ngx_http_lua_ngx_exit(lua_State *L);
+static int ngx_http_lua_on_abort(lua_State *L);
+
+
+void
+ngx_http_lua_inject_control_api(ngx_log_t *log, lua_State *L)
+{
+    /* ngx.redirect */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_redirect);
+    lua_setfield(L, -2, "redirect");
+
+    /* ngx.exec */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_exec);
+    lua_setfield(L, -2, "exec");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_exit);
+    lua_setfield(L, -2, "throw_error"); /* deprecated */
+
+    /* ngx.exit */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_exit);
+    lua_setfield(L, -2, "exit");
+
+    /* ngx.on_abort */
+
+    lua_pushcfunction(L, ngx_http_lua_on_abort);
+    lua_setfield(L, -2, "on_abort");
+}
+
+
+static int
+ngx_http_lua_ngx_exec(lua_State *L)
+{
+    int                          n;
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_str_t                    uri;
+    ngx_str_t                    args, user_args;
+    ngx_uint_t                   flags;
+    u_char                      *p;
+    u_char                      *q;
+    size_t                       len;
+    const char                  *msg;
+
+    n = lua_gettop(L);
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting one or two arguments, but got %d",
+                          n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    args.data = NULL;
+    args.len = 0;
+
+    /* read the 1st argument (uri) */
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    if (len == 0) {
+        return luaL_error(L, "The uri argument is empty");
+    }
+
+    uri.data = ngx_palloc(r->pool, len);
+    if (uri.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(uri.data, p, len);
+
+    uri.len = len;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    ngx_http_lua_check_if_abortable(L, ctx);
+
+    if (ngx_http_parse_unsafe_uri(r, &uri, &args, &flags)
+        != NGX_OK)
+    {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (n == 2) {
+        /* read the 2nd argument (args) */
+        dd("args type: %s", luaL_typename(L, 2));
+
+        switch (lua_type(L, 2)) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            p = (u_char *) lua_tolstring(L, 2, &len);
+
+            user_args.data = ngx_palloc(r->pool, len);
+            if (user_args.data == NULL) {
+                return luaL_error(L, "out of memory");
+            }
+
+            ngx_memcpy(user_args.data, p, len);
+
+            user_args.len = len;
+            break;
+
+        case LUA_TTABLE:
+            ngx_http_lua_process_args_option(r, L, 2, &user_args);
+
+            dd("user_args: %.*s", (int) user_args.len, user_args.data);
+
+            break;
+
+        case LUA_TNIL:
+            user_args.data = NULL;
+            user_args.len = 0;
+            break;
+
+        default:
+            msg = lua_pushfstring(L, "string, number, or table expected, "
+                                  "but got %s", luaL_typename(L, 2));
+            return luaL_argerror(L, 2, msg);
+        }
+
+    } else {
+        user_args.data = NULL;
+        user_args.len = 0;
+    }
+
+    if (user_args.len) {
+        if (args.len == 0) {
+            args = user_args;
+
+        } else {
+            p = ngx_palloc(r->pool, args.len + user_args.len + 1);
+            if (p == NULL) {
+                return luaL_error(L, "out of memory");
+            }
+
+            q = ngx_copy(p, args.data, args.len);
+            *q++ = '&';
+            ngx_memcpy(q, user_args.data, user_args.len);
+
+            args.data = p;
+            args.len += user_args.len + 1;
+        }
+    }
+
+    if (r->header_sent) {
+        return luaL_error(L, "attempt to call ngx.exec after "
+                          "sending out response headers");
+    }
+
+    ctx->exec_uri = uri;
+    ctx->exec_args = args;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua exec \"%V?%V\"",
+                   &ctx->exec_uri, &ctx->exec_args);
+
+    return lua_yield(L, 0);
+}
+
+
+static int
+ngx_http_lua_ngx_redirect(lua_State *L)
+{
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+    int                          n;
+    u_char                      *p;
+    u_char                      *uri;
+    size_t                       len;
+    ngx_http_request_t          *r;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting one or two arguments");
+    }
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    if (n == 2) {
+        rc = (ngx_int_t) luaL_checknumber(L, 2);
+
+        if (rc != NGX_HTTP_MOVED_TEMPORARILY &&
+                rc != NGX_HTTP_MOVED_PERMANENTLY)
+        {
+            return luaL_error(L, "only ngx.HTTP_MOVED_TEMPORARILY and "
+                              "ngx.HTTP_MOVED_PERMANENTLY are allowed");
+        }
+    } else {
+        rc = NGX_HTTP_MOVED_TEMPORARILY;
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    ngx_http_lua_check_if_abortable(L, ctx);
+
+    if (r->header_sent) {
+        return luaL_error(L, "attempt to call ngx.redirect after sending out "
+                          "the headers");
+    }
+
+    uri = ngx_palloc(r->pool, len);
+    if (uri == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(uri, p, len);
+
+    r->headers_out.location = ngx_list_push(&r->headers_out.headers);
+    if (r->headers_out.location == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    r->headers_out.location->hash = ngx_http_lua_location_hash;
+
+#if 0
+    dd("location hash: %lu == %lu",
+            (unsigned long) r->headers_out.location->hash,
+            (unsigned long) ngx_hash_key_lc((u_char *) "Location",
+            sizeof("Location") - 1));
+#endif
+
+    r->headers_out.location->value.len = len;
+    r->headers_out.location->value.data = uri;
+    ngx_str_set(&r->headers_out.location->key, "Location");
+
+    r->headers_out.status = rc;
+
+    ctx->exit_code = rc;
+    ctx->exited = 1;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua redirect to \"%V\" with code %i",
+                   &r->headers_out.location->value, ctx->exit_code);
+
+    return lua_yield(L, 0);
+}
+
+
+static int
+ngx_http_lua_ngx_exit(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    rc = (ngx_int_t) luaL_checkinteger(L, 1);
+
+    if (ctx->no_abort
+        && rc != NGX_ERROR
+        && rc != NGX_HTTP_CLOSE
+        && rc != NGX_HTTP_REQUEST_TIME_OUT
+        && rc != NGX_HTTP_CLIENT_CLOSED_REQUEST)
+    {
+        return luaL_error(L, "attempt to abort with pending subrequests");
+    }
+
+    if (r->header_sent
+        && rc >= NGX_HTTP_SPECIAL_RESPONSE
+        && rc != NGX_HTTP_REQUEST_TIME_OUT
+        && rc != NGX_HTTP_CLIENT_CLOSED_REQUEST
+        && rc != NGX_HTTP_CLOSE)
+    {
+        if (rc != (ngx_int_t) r->headers_out.status) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "attempt to "
+                          "set status %i via ngx.exit after sending out the "
+                          "response status %ui", rc, r->headers_out.status);
+        }
+
+        rc = NGX_HTTP_OK;
+    }
+
+    ctx->exit_code = rc;
+    ctx->exited = 1;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua exit with code %i", ctx->exit_code);
+
+    dd("calling yield");
+    return lua_yield(L, 0);
+}
+
+
+static int
+ngx_http_lua_on_abort(lua_State *L)
+{
+    ngx_http_request_t           *r;
+    ngx_http_lua_ctx_t           *ctx;
+    ngx_http_lua_co_ctx_t        *coctx = NULL;
+    ngx_http_lua_loc_conf_t      *llcf;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_fake_request2(L, r, ctx);
+
+    if (ctx->on_abort_co_ctx) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "duplicate call");
+        return 2;
+    }
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    if (!llcf->check_client_abort) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "lua_check_client_abort is off");
+        return 2;
+    }
+
+    ngx_http_lua_coroutine_create_helper(L, r, ctx, &coctx);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_pushvalue(L, -2);
+
+    dd("on_wait thread 1: %p", lua_tothread(L, -1));
+
+    coctx->co_ref = luaL_ref(L, -2);
+    lua_pop(L, 1);
+
+    coctx->is_uthread = 1;
+    ctx->on_abort_co_ctx = coctx;
+
+    dd("on_wait thread 2: %p", coctx->co);
+
+    coctx->co_status = NGX_HTTP_LUA_CO_SUSPENDED;
+    coctx->parent_co_ctx = ctx->cur_co_ctx;
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_control.h b/src/lua/lua-nginx-module/src/ngx_http_lua_control.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_control.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_control.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CONTROL_H_INCLUDED_
+#define _NGX_HTTP_LUA_CONTROL_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_control_api(ngx_log_t *log, lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_CONTROL_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.c b/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,339 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_coroutine.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_probe.h"
+
+
+/*
+ * Design:
+ *
+ * In order to support using ngx.* API in Lua coroutines, we have to create
+ * new coroutine in the main coroutine instead of the calling coroutine
+ */
+
+
+static int ngx_http_lua_coroutine_create(lua_State *L);
+static int ngx_http_lua_coroutine_resume(lua_State *L);
+static int ngx_http_lua_coroutine_yield(lua_State *L);
+static int ngx_http_lua_coroutine_status(lua_State *L);
+
+
+static const char *
+    ngx_http_lua_co_status_names[] =
+        {"running", "suspended", "normal", "dead", "zombie"};
+
+
+
+static int
+ngx_http_lua_coroutine_create(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    return ngx_http_lua_coroutine_create_helper(L, r, ctx, NULL);
+}
+
+
+int
+ngx_http_lua_coroutine_create_helper(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t **pcoctx)
+{
+    lua_State                     *mt;  /* the main thread */
+    lua_State                     *co;  /* new coroutine to be created */
+    ngx_http_lua_main_conf_t      *lmcf;
+    ngx_http_lua_co_ctx_t         *coctx; /* co ctx for the new coroutine */
+
+    luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
+                 "Lua function expected");
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    mt = lmcf->lua;
+
+    /* create new coroutine on root Lua state, so it always yields
+     * to main Lua thread
+     */
+    co = lua_newthread(mt);
+
+    ngx_http_lua_probe_user_coroutine_create(r, L, co);
+
+    coctx = ngx_http_lua_create_co_ctx(r, ctx);
+    if (coctx == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    coctx->co = co;
+    coctx->co_status = NGX_HTTP_LUA_CO_SUSPENDED;
+
+    /* make new coroutine share globals of the parent coroutine.
+     * NOTE: globals don't have to be separated! */
+    lua_pushvalue(L, LUA_GLOBALSINDEX);
+    lua_xmove(L, co, 1);
+    lua_replace(co, LUA_GLOBALSINDEX);
+
+    lua_xmove(mt, L, 1);    /* move coroutine from main thread to L */
+
+    lua_pushvalue(L, 1);    /* copy entry function to top of L*/
+    lua_xmove(L, co, 1);    /* move entry function from L to co */
+
+    if (pcoctx) {
+        *pcoctx = coctx;
+    }
+
+    return 1;    /* return new coroutine to Lua */
+}
+
+
+static int
+ngx_http_lua_coroutine_resume(lua_State *L)
+{
+    lua_State                   *co;
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+    ngx_http_lua_co_ctx_t       *p_coctx; /* parent co ctx */
+
+    co = lua_tothread(L, 1);
+
+    luaL_argcheck(L, co, 1, "coroutine expected");
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    p_coctx = ctx->cur_co_ctx;
+    if (p_coctx == NULL) {
+        return luaL_error(L, "no parent co ctx found");
+    }
+
+    coctx = ngx_http_lua_get_co_ctx(co, ctx);
+    if (coctx == NULL) {
+        return luaL_error(L, "no co ctx found");
+    }
+
+    ngx_http_lua_probe_user_coroutine_resume(r, L, co);
+
+    if (coctx->co_status != NGX_HTTP_LUA_CO_SUSPENDED) {
+        dd("coroutine resume: %d", coctx->co_status);
+
+        lua_pushboolean(L, 0);
+        lua_pushfstring(L, "cannot resume %s coroutine",
+                        ngx_http_lua_co_status_names[coctx->co_status]);
+        return 2;
+    }
+
+    p_coctx->co_status = NGX_HTTP_LUA_CO_NORMAL;
+
+    coctx->parent_co_ctx = p_coctx;
+
+    dd("set coroutine to running");
+    coctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+
+    ctx->co_op = NGX_HTTP_LUA_USER_CORO_RESUME;
+    ctx->cur_co_ctx = coctx;
+
+    /* yield and pass args to main thread, and resume target coroutine from
+     * there */
+    return lua_yield(L, lua_gettop(L) - 1);
+}
+
+
+static int
+ngx_http_lua_coroutine_yield(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    coctx = ctx->cur_co_ctx;
+
+    coctx->co_status = NGX_HTTP_LUA_CO_SUSPENDED;
+
+    ctx->co_op = NGX_HTTP_LUA_USER_CORO_YIELD;
+
+    if (!coctx->is_uthread && coctx->parent_co_ctx) {
+        dd("set coroutine to running");
+        coctx->parent_co_ctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+
+        ngx_http_lua_probe_user_coroutine_yield(r, coctx->parent_co_ctx->co, L);
+
+    } else {
+        ngx_http_lua_probe_user_coroutine_yield(r, NULL, L);
+    }
+
+    /* yield and pass retvals to main thread,
+     * and resume parent coroutine there */
+    return lua_yield(L, lua_gettop(L));
+}
+
+
+void
+ngx_http_lua_inject_coroutine_api(ngx_log_t *log, lua_State *L)
+{
+    int         rc;
+
+    /* new coroutine table */
+    lua_newtable(L);
+
+    /* get old coroutine table */
+    lua_getglobal(L, "coroutine");
+
+    /* set running to the old one */
+    lua_getfield(L, -1, "running");
+    lua_setfield(L, -3, "running");
+
+    lua_getfield(L, -1, "create");
+    lua_setfield(L, -3, "_create");
+
+    lua_getfield(L, -1, "resume");
+    lua_setfield(L, -3, "_resume");
+
+    lua_getfield(L, -1, "yield");
+    lua_setfield(L, -3, "_yield");
+
+    lua_getfield(L, -1, "status");
+    lua_setfield(L, -3, "_status");
+
+    /* pop the old coroutine */
+    lua_pop(L, 1);
+
+    lua_pushcfunction(L, ngx_http_lua_coroutine_create);
+    lua_setfield(L, -2, "create");
+
+    lua_pushcfunction(L, ngx_http_lua_coroutine_resume);
+    lua_setfield(L, -2, "resume");
+
+    lua_pushcfunction(L, ngx_http_lua_coroutine_yield);
+    lua_setfield(L, -2, "yield");
+
+    lua_pushcfunction(L, ngx_http_lua_coroutine_status);
+    lua_setfield(L, -2, "status");
+
+    lua_setglobal(L, "coroutine");
+
+    /* inject wrap */
+    {
+        const char buf[] =
+            "local create, resume = coroutine.create, coroutine.resume\n"
+            "coroutine.wrap = function(f)\n"
+               "local co = create(f)\n"
+               "return function(...) return select(2, resume(co, ...)) end\n"
+            "end\n"
+#if 0
+            "debug.sethook(function () collectgarbage() end, 'rl', 1)"
+#endif
+            ;
+
+        rc = luaL_loadbuffer(L, buf, sizeof(buf) - 1, "coroutine.wrap");
+    }
+
+    if (rc != 0) {
+        ngx_log_error(NGX_LOG_ERR, log, 0,
+                      "failed to load Lua code for coroutine.wrap(): %i: %s",
+                      rc, lua_tostring(L, -1));
+
+        lua_pop(L, 1);
+        return;
+    }
+
+    rc = lua_pcall(L, 0, 0, 0);
+    if (rc != 0) {
+        ngx_log_error(NGX_LOG_ERR, log, 0,
+                      "failed to run the Lua code for coroutine.wrap(): %i: %s",
+                      rc, lua_tostring(L, -1));
+        lua_pop(L, 1);
+    }
+}
+
+
+static int
+ngx_http_lua_coroutine_status(lua_State *L)
+{
+    lua_State                     *co;  /* new coroutine to be created */
+    ngx_http_request_t            *r;
+    ngx_http_lua_ctx_t            *ctx;
+    ngx_http_lua_co_ctx_t         *coctx; /* co ctx for the new coroutine */
+
+    co = lua_tothread(L, 1);
+
+    luaL_argcheck(L, co, 1, "coroutine expected");
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    coctx = ngx_http_lua_get_co_ctx(co, ctx);
+    if (coctx == NULL) {
+        return luaL_error(L, "no co ctx found");
+    }
+
+    dd("co status: %d", coctx->co_status);
+
+    lua_pushstring(L, ngx_http_lua_co_status_names[coctx->co_status]);
+    return 1;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.h b/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_coroutine.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,23 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_COROUTINE_H_INCLUDED_
+#define _NGX_HTTP_LUA_COROUTINE_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_coroutine_api(ngx_log_t *log, lua_State *L);
+
+int ngx_http_lua_coroutine_create_helper(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t **pcoctx);
+
+
+#endif /* _NGX_HTTP_LUA_COROUTINE_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.c b/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,111 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_ctx.h"
+
+
+int
+ngx_http_lua_ngx_get_ctx(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    if (ctx->ctx_ref == LUA_NOREF) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua create ngx.ctx table for the current request");
+
+        lua_pushlightuserdata(L, &ngx_http_lua_ctx_tables_key);
+        lua_rawget(L, LUA_REGISTRYINDEX);
+        lua_newtable(L);
+        lua_pushvalue(L, -1);
+        ctx->ctx_ref = luaL_ref(L, -3);
+        return 1;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua fetching existing ngx.ctx table for the current "
+                   "request");
+
+    lua_pushlightuserdata(L, &ngx_http_lua_ctx_tables_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_rawgeti(L, -1, ctx->ctx_ref);
+
+    return 1;
+}
+
+
+int
+ngx_http_lua_ngx_set_ctx(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    return ngx_http_lua_ngx_set_ctx_helper(L, r, ctx, 3);
+}
+
+
+int
+ngx_http_lua_ngx_set_ctx_helper(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, int index)
+{
+    if (index < 0) {
+        index = lua_gettop(L) + index + 1;
+    }
+
+    if (ctx->ctx_ref == LUA_NOREF) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua create ngx.ctx table for the current request");
+
+        lua_pushlightuserdata(L, &ngx_http_lua_ctx_tables_key);
+        lua_rawget(L, LUA_REGISTRYINDEX);
+        lua_pushvalue(L, index);
+        ctx->ctx_ref = luaL_ref(L, -2);
+        lua_pop(L, 1);
+        return 0;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua fetching existing ngx.ctx table for the current "
+                   "request");
+
+    lua_pushlightuserdata(L, &ngx_http_lua_ctx_tables_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    luaL_unref(L, -1, ctx->ctx_ref);
+    lua_pushvalue(L, index);
+    ctx->ctx_ref = luaL_ref(L, -2);
+    lua_pop(L, 1);
+
+    return 0;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.h b/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_ctx.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,23 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_CTX_H_INCLUDED_
+#define _NGX_HTTP_LUA_CTX_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+int ngx_http_lua_ngx_get_ctx(lua_State *L);
+int ngx_http_lua_ngx_set_ctx(lua_State *L);
+int ngx_http_lua_ngx_set_ctx_helper(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, int index);
+
+
+#endif /* _NGX_HTTP_LUA_CTX_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_directive.c b/src/lua/lua-nginx-module/src/ngx_http_lua_directive.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_directive.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_directive.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,918 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_common.h"
+#include "ngx_http_lua_directive.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_cache.h"
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_accessby.h"
+#include "ngx_http_lua_rewriteby.h"
+#include "ngx_http_lua_logby.h"
+#include "ngx_http_lua_headerfilterby.h"
+#include "ngx_http_lua_bodyfilterby.h"
+#include "ngx_http_lua_initby.h"
+#include "ngx_http_lua_shdict.h"
+
+#if defined(NDK) && NDK
+#include "ngx_http_lua_setby.h"
+#endif
+
+
+char *
+ngx_http_lua_shared_dict(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_lua_main_conf_t   *lmcf = conf;
+
+    ngx_str_t                  *value, name;
+    ngx_shm_zone_t             *zone;
+    ngx_shm_zone_t            **zp;
+    ngx_http_lua_shdict_ctx_t  *ctx;
+    ssize_t                     size;
+
+    if (lmcf->shm_zones == NULL) {
+        lmcf->shm_zones = ngx_palloc(cf->pool, sizeof(ngx_array_t));
+        if (lmcf->shm_zones == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        ngx_array_init(lmcf->shm_zones, cf->pool, 2, sizeof(ngx_shm_zone_t *));
+    }
+
+    value = cf->args->elts;
+
+    ctx = NULL;
+
+    if (value[1].len == 0) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid lua shared dict name \"%V\"", &value[1]);
+        return NGX_CONF_ERROR;
+    }
+
+    name = value[1];
+
+    size = ngx_parse_size(&value[2]);
+
+    if (size <= 8191) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid lua shared dict size \"%V\"", &value[2]);
+        return NGX_CONF_ERROR;
+    }
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_lua_shdict_ctx_t));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ctx->name = name;
+    ctx->main_conf = lmcf;
+    ctx->log = &cf->cycle->new_log;
+
+    zone = ngx_shared_memory_add(cf, &name, (size_t) size,
+                                 &ngx_http_lua_module);
+    if (zone == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (zone->data) {
+        ctx = zone->data;
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "lua_shared_dict \"%V\" is already defined as "
+                           "\"%V\"", &name, &ctx->name);
+        return NGX_CONF_ERROR;
+    }
+
+    zone->init = ngx_http_lua_shdict_init_zone;
+    zone->data = ctx;
+
+    zp = ngx_array_push(lmcf->shm_zones);
+    if (zp == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *zp = zone;
+
+    lmcf->requires_shm = 1;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_code_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char             *p = conf;
+    ngx_flag_t       *fp;
+    char             *ret;
+
+    ret = ngx_conf_set_flag_slot(cf, cmd, conf);
+    if (ret != NGX_CONF_OK) {
+        return ret;
+    }
+
+    fp = (ngx_flag_t *) (p + cmd->offset);
+
+    if (!*fp) {
+        ngx_conf_log_error(NGX_LOG_ALERT, cf, 0,
+                           "lua_code_cache is off; this will hurt "
+                           "performance");
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_package_cpath(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_lua_main_conf_t *lmcf = conf;
+    ngx_str_t                *value;
+
+    if (lmcf->lua_cpath.len != 0) {
+        return "is duplicate";
+    }
+
+    dd("enter");
+
+    value = cf->args->elts;
+
+    lmcf->lua_cpath.len = value[1].len;
+    lmcf->lua_cpath.data = value[1].data;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_package_path(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_lua_main_conf_t *lmcf = conf;
+    ngx_str_t                *value;
+
+    if (lmcf->lua_path.len != 0) {
+        return "is duplicate";
+    }
+
+    dd("enter");
+
+    value = cf->args->elts;
+
+    lmcf->lua_path.len = value[1].len;
+    lmcf->lua_path.data = value[1].data;
+
+    return NGX_CONF_OK;
+}
+
+
+#if defined(NDK) && NDK
+char *
+ngx_http_lua_set_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    u_char              *p;
+    ngx_str_t           *value;
+    ngx_str_t            target;
+    ndk_set_var_t        filter;
+
+    ngx_http_lua_set_var_data_t     *filter_data;
+
+    /*
+     * value[0] = "set_by_lua"
+     * value[1] = target variable name
+     * value[2] = lua script source to be executed
+     * value[3..] = real params
+     * */
+    value = cf->args->elts;
+    target = value[1];
+
+    filter.type = NDK_SET_VAR_MULTI_VALUE_DATA;
+    filter.func = cmd->post;
+    filter.size = cf->args->nelts - 3;    /*  get number of real params */
+
+    filter_data = ngx_palloc(cf->pool, sizeof(ngx_http_lua_set_var_data_t));
+    if (filter_data == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    filter_data->size = filter.size;
+
+    p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+    if (p == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    filter_data->key = p;
+
+    p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+    p = ngx_http_lua_digest_hex(p, value[2].data, value[2].len);
+    *p = '\0';
+
+    filter_data->script = value[2];
+
+    filter.data = filter_data;
+
+    return ndk_set_var_multi_value_core(cf, &target, &value[3], &filter);
+}
+
+
+char *
+ngx_http_lua_set_by_lua_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    u_char              *p;
+    ngx_str_t           *value;
+    ngx_str_t            target;
+    ndk_set_var_t        filter;
+
+    ngx_http_lua_set_var_data_t     *filter_data;
+
+    /*
+     * value[0] = "set_by_lua_file"
+     * value[1] = target variable name
+     * value[2] = lua script file path to be executed
+     * value[3..] = real params
+     * */
+    value = cf->args->elts;
+    target = value[1];
+
+    filter.type = NDK_SET_VAR_MULTI_VALUE_DATA;
+    filter.func = cmd->post;
+    filter.size = cf->args->nelts - 2;    /*  get number of real params and
+                                              lua script */
+
+    filter_data = ngx_palloc(cf->pool, sizeof(ngx_http_lua_set_var_data_t));
+    if (filter_data == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    filter_data->size = filter.size;
+
+    p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+    if (p == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    filter_data->key = p;
+
+    p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+    p = ngx_http_lua_digest_hex(p, value[2].data, value[2].len);
+    *p = '\0';
+
+    ngx_str_null(&filter_data->script);
+
+    filter.data = filter_data;
+
+    return ndk_set_var_multi_value_core(cf, &target, &value[2], &filter);
+}
+
+
+ngx_int_t
+ngx_http_lua_filter_set_by_lua_inline(ngx_http_request_t *r, ngx_str_t *val,
+    ngx_http_variable_value_t *v, void *data)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    ngx_http_lua_set_var_data_t     *filter_data = data;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    /*  load Lua inline script (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, filter_data->script.data,
+                                       filter_data->script.len,
+                                       filter_data->key, "set_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_lua_set_by_chunk(L, r, val, v, filter_data->size,
+                                   &filter_data->script);
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_filter_set_by_lua_file(ngx_http_request_t *r, ngx_str_t *val,
+    ngx_http_variable_value_t *v, void *data)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    u_char                      *script_path;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+    size_t                       nargs;
+
+    ngx_http_lua_set_var_data_t     *filter_data = data;
+
+    dd("set by lua file");
+
+    filter_data->script.data = v[0].data;
+    filter_data->script.len = v[0].len;
+
+    /* skip the lua file path argument */
+    v++;
+    nargs = filter_data->size - 1;
+
+    dd("script: %.*s", (int) filter_data->script.len, filter_data->script.data);
+    dd("nargs: %d", (int) nargs);
+
+    script_path = ngx_http_lua_rebase_path(r->pool, filter_data->script.data,
+                                           filter_data->script.len);
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path, filter_data->key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_lua_set_by_chunk(L, r, val, v, nargs, &filter_data->script);
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+#endif /* defined(NDK) && NDK */
+
+
+char *
+ngx_http_lua_rewrite_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    u_char                      *p;
+    ngx_str_t                   *value;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf = conf;
+
+    ngx_http_compile_complex_value_t         ccv;
+
+    dd("enter");
+
+#if defined(nginx_version) && nginx_version >= 8042 && nginx_version <= 8053
+    return "does not work with " NGINX_VER;
+#endif
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (llcf->rewrite_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+
+        return NGX_CONF_ERROR;
+    }
+
+    if (cmd->post == ngx_http_lua_rewrite_handler_inline) {
+        /* Don't eval nginx variables for inline lua code */
+        llcf->rewrite_src.value = value[1];
+
+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+        if (p == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        llcf->rewrite_src_key = p;
+
+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+        *p = '\0';
+
+    } else {
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+        ccv.cf = cf;
+        ccv.value = &value[1];
+        ccv.complex_value = &llcf->rewrite_src;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (llcf->rewrite_src.lengths == NULL) {
+            /* no variable found */
+            p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+            if (p == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            llcf->rewrite_src_key = p;
+
+            p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+            p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+            *p = '\0';
+        }
+    }
+
+    llcf->rewrite_handler = (ngx_http_handler_pt) cmd->post;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lmcf->requires_rewrite = 1;
+    lmcf->requires_capture_filter = 1;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_access_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    u_char                      *p;
+    ngx_str_t                   *value;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf = conf;
+
+    ngx_http_compile_complex_value_t         ccv;
+
+    dd("enter");
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (llcf->access_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+
+        return NGX_CONF_ERROR;
+    }
+
+    if (cmd->post == ngx_http_lua_access_handler_inline) {
+        /* Don't eval nginx variables for inline lua code */
+        llcf->access_src.value = value[1];
+
+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+        if (p == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        llcf->access_src_key = p;
+
+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+        *p = '\0';
+
+    } else {
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+        ccv.cf = cf;
+        ccv.value = &value[1];
+        ccv.complex_value = &llcf->access_src;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (llcf->access_src.lengths == NULL) {
+            /* no variable found */
+            p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+            if (p == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            llcf->access_src_key = p;
+
+            p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+            p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+            *p = '\0';
+        }
+    }
+
+    llcf->access_handler = (ngx_http_handler_pt) cmd->post;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lmcf->requires_access = 1;
+    lmcf->requires_capture_filter = 1;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_content_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    u_char                      *p;
+    ngx_str_t                   *value;
+    ngx_http_core_loc_conf_t    *clcf;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf = conf;
+
+    ngx_http_compile_complex_value_t         ccv;
+
+    dd("enter");
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (llcf->content_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+        return NGX_CONF_ERROR;
+    }
+
+    if (cmd->post == ngx_http_lua_content_handler_inline) {
+        /* Don't eval nginx variables for inline lua code */
+        llcf->content_src.value = value[1];
+
+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+        if (p == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        llcf->content_src_key = p;
+
+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+        *p = '\0';
+
+    } else {
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+        ccv.cf = cf;
+        ccv.value = &value[1];
+        ccv.complex_value = &llcf->content_src;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (llcf->content_src.lengths == NULL) {
+            /* no variable found */
+            p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+            if (p == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            llcf->content_src_key = p;
+
+            p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+            p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+            *p = '\0';
+        }
+    }
+
+    llcf->content_handler = (ngx_http_handler_pt) cmd->post;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lmcf->requires_capture_filter = 1;
+
+    /*  register location content handler */
+    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
+    if (clcf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    clcf->handler = ngx_http_lua_content_handler;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_log_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    u_char                      *p;
+    ngx_str_t                   *value;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf = conf;
+
+    ngx_http_compile_complex_value_t         ccv;
+
+    dd("enter");
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (llcf->log_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+
+        return NGX_CONF_ERROR;
+    }
+
+    if (cmd->post == ngx_http_lua_log_handler_inline) {
+        /* Don't eval nginx variables for inline lua code */
+        llcf->log_src.value = value[1];
+
+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+        if (p == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        llcf->log_src_key = p;
+
+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+        *p = '\0';
+
+    } else {
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+        ccv.cf = cf;
+        ccv.value = &value[1];
+        ccv.complex_value = &llcf->log_src;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (llcf->log_src.lengths == NULL) {
+            /* no variable found */
+            p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+            if (p == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            llcf->log_src_key = p;
+
+            p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+            p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+            *p = '\0';
+        }
+    }
+
+    llcf->log_handler = (ngx_http_handler_pt) cmd->post;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lmcf->requires_log = 1;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_header_filter_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf)
+{
+    u_char                      *p;
+    ngx_str_t                   *value;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf = conf;
+
+    ngx_http_compile_complex_value_t         ccv;
+
+    dd("enter");
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (llcf->header_filter_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+        return NGX_CONF_ERROR;
+    }
+
+    if (cmd->post == ngx_http_lua_header_filter_inline) {
+        /* Don't eval nginx variables for inline lua code */
+        llcf->header_filter_src.value = value[1];
+
+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+        if (p == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        llcf->header_filter_src_key = p;
+
+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+        *p = '\0';
+
+    } else {
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+        ccv.cf = cf;
+        ccv.value = &value[1];
+        ccv.complex_value = &llcf->header_filter_src;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (llcf->header_filter_src.lengths == NULL) {
+            /* no variable found */
+            p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+            if (p == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            llcf->header_filter_src_key = p;
+
+            p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+            p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+            *p = '\0';
+        }
+    }
+
+    llcf->header_filter_handler = (ngx_http_handler_pt) cmd->post;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lmcf->requires_header_filter = 1;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_body_filter_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf)
+{
+    u_char                      *p;
+    ngx_str_t                   *value;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf = conf;
+
+    ngx_http_compile_complex_value_t         ccv;
+
+    dd("enter");
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (llcf->body_filter_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+        return NGX_CONF_ERROR;
+    }
+
+    if (cmd->post == ngx_http_lua_body_filter_inline) {
+        /* Don't eval nginx variables for inline lua code */
+        llcf->body_filter_src.value = value[1];
+
+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);
+        if (p == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        llcf->body_filter_src_key = p;
+
+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);
+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+        *p = '\0';
+
+    } else {
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+        ccv.cf = cf;
+        ccv.value = &value[1];
+        ccv.complex_value = &llcf->body_filter_src;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (llcf->body_filter_src.lengths == NULL) {
+            /* no variable found */
+            p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);
+            if (p == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            llcf->body_filter_src_key = p;
+
+            p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);
+            p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);
+            *p = '\0';
+        }
+    }
+
+    llcf->body_filter_handler = (ngx_http_output_body_filter_pt) cmd->post;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lmcf->requires_body_filter = 1;
+    lmcf->requires_header_filter = 1;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_lua_init_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf)
+{
+    u_char                      *name;
+    ngx_str_t                   *value;
+    ngx_http_lua_main_conf_t    *lmcf = conf;
+
+    dd("enter");
+
+    /*  must specifiy a content handler */
+    if (cmd->post == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (lmcf->init_handler) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].len == 0) {
+        /*  Oops...Invalid location conf */
+        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                           "invalid location config: no runnable Lua code");
+        return NGX_CONF_ERROR;
+    }
+
+    lmcf->init_handler = (ngx_http_lua_conf_handler_pt) cmd->post;
+
+    if (cmd->post == ngx_http_lua_init_by_file) {
+        name = ngx_http_lua_rebase_path(cf->pool, value[1].data,
+                                        value[1].len);
+        if (name == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        lmcf->init_src.data = name;
+        lmcf->init_src.len = ngx_strlen(name);
+
+    } else {
+        lmcf->init_src = value[1];
+    }
+
+    return NGX_CONF_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_directive.h b/src/lua/lua-nginx-module/src/ngx_http_lua_directive.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_directive.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_directive.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,54 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_DIRECTIVE_H_INCLUDED_
+#define _NGX_HTTP_LUA_DIRECTIVE_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+char * ngx_http_lua_shared_dict(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char * ngx_http_lua_package_cpath(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_package_path(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_content_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_rewrite_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_access_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_log_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_header_filter_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_body_filter_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_init_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char * ngx_http_lua_code_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+#if defined(NDK) && NDK
+
+char * ngx_http_lua_set_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char * ngx_http_lua_set_by_lua_file(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+ngx_int_t ngx_http_lua_filter_set_by_lua_inline(ngx_http_request_t *r,
+    ngx_str_t *val, ngx_http_variable_value_t *v, void *data);
+ngx_int_t ngx_http_lua_filter_set_by_lua_file(ngx_http_request_t *r,
+    ngx_str_t *val, ngx_http_variable_value_t *v, void *data);
+
+#endif
+
+char * ngx_http_lua_rewrite_no_postpone(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+
+#endif /* _NGX_HTTP_LUA_DIRECTIVE_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_exception.c b/src/lua/lua-nginx-module/src/ngx_http_lua_exception.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_exception.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_exception.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,54 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_util.h"
+
+
+/*  longjmp mark for restoring nginx execution after Lua VM crashing */
+jmp_buf ngx_http_lua_exception;
+
+/**
+ * Override default Lua panic handler, output VM crash reason to nginx error
+ * log, and restore execution to the nearest jmp-mark.
+ *
+ * @param L Lua state pointer
+ * @retval Long jump to the nearest jmp-mark, never returns.
+ * @note nginx request pointer should be stored in Lua thread's globals table
+ * in order to make logging working.
+ * */
+int
+ngx_http_lua_atpanic(lua_State *L)
+{
+    u_char                  *s = NULL;
+    size_t                   len = 0;
+
+    if (lua_type(L, -1) == LUA_TSTRING) {
+        s = (u_char *) lua_tolstring(L, -1, &len);
+    }
+
+    if (s == NULL) {
+        s = (u_char *) "unknown reason";
+        len = sizeof("unknown reason") - 1;
+    }
+
+    ngx_log_stderr(0, "lua atpanic: Lua VM crashed, reason: %*s", len, s);
+    ngx_quit = 1;
+
+    /*  restore nginx execution */
+    NGX_LUA_EXCEPTION_THROW(1);
+
+    /* impossible to reach here */
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_exception.h b/src/lua/lua-nginx-module/src/ngx_http_lua_exception.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_exception.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_exception.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,33 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_EXCEPTION_H_INCLUDED_
+#define _NGX_HTTP_LUA_EXCEPTION_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+#define NGX_LUA_EXCEPTION_TRY                                               \
+    if (setjmp(ngx_http_lua_exception) == 0)
+
+#define NGX_LUA_EXCEPTION_CATCH                                             \
+    else
+
+#define NGX_LUA_EXCEPTION_THROW(x)                                          \
+    longjmp(ngx_http_lua_exception, (x))
+
+
+extern jmp_buf ngx_http_lua_exception;
+
+
+int ngx_http_lua_atpanic(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_EXCEPTION_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,298 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+#include "ngx_http_lua_headerfilterby.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_time.h"
+#include "ngx_http_lua_log.h"
+#include "ngx_http_lua_regex.h"
+#include "ngx_http_lua_cache.h"
+#include "ngx_http_lua_headers.h"
+#include "ngx_http_lua_variable.h"
+#include "ngx_http_lua_string.h"
+#include "ngx_http_lua_misc.h"
+#include "ngx_http_lua_consts.h"
+#include "ngx_http_lua_shdict.h"
+
+
+static ngx_http_output_header_filter_pt ngx_http_next_header_filter;
+
+
+/* light user data key for the "ngx" table in the Lua VM regsitry */
+static char ngx_http_lua_headerfilterby_ngx_key;
+
+
+/**
+ * Set environment table for the given code closure.
+ *
+ * Before:
+ *         | code closure | <- top
+ *         |      ...     |
+ *
+ * After:
+ *         | code closure | <- top
+ *         |      ...     |
+ * */
+static void
+ngx_http_lua_header_filter_by_lua_env(lua_State *L, ngx_http_request_t *r)
+{
+    /*  set nginx request pointer to current lua thread's globals table */
+    ngx_http_lua_set_req(L, r);
+
+    /**
+     * we want to create empty environment for current script
+     *
+     * newt = {}
+     * newt["_G"] = newt
+     * setmetatable(newt, {__index = _G})
+     *
+     * if a function or symbol is not defined in our env, __index will lookup
+     * in the global env.
+     *
+     * all variables created in the script-env will be thrown away at the end
+     * of the script run.
+     * */
+    ngx_http_lua_create_new_global_table(L, 0 /* narr */, 1 /* nrec */);
+
+    /*  {{{ initialize ngx.* namespace */
+    lua_pushlightuserdata(L, &ngx_http_lua_headerfilterby_ngx_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_setfield(L, -2, "ngx");
+    /*  }}} */
+
+    /*  {{{ make new env inheriting main thread's globals table */
+    lua_newtable(L);    /*  the metatable for the new env */
+    lua_pushvalue(L, LUA_GLOBALSINDEX);
+    lua_setfield(L, -2, "__index");
+    lua_setmetatable(L, -2);    /*  setmetatable({}, {__index = _G}) */
+    /*  }}} */
+
+    lua_setfenv(L, -2);    /*  set new running env for the code closure */
+}
+
+
+ngx_int_t
+ngx_http_lua_header_filter_by_chunk(lua_State *L, ngx_http_request_t *r)
+{
+    ngx_int_t        rc;
+    u_char          *err_msg;
+    size_t           len;
+#if (NGX_PCRE)
+    ngx_pool_t      *old_pool;
+#endif
+
+    /*  initialize nginx context in Lua VM, code chunk at stack top    sp = 1 */
+    ngx_http_lua_header_filter_by_lua_env(L, r);
+
+#if (NGX_PCRE)
+    /* XXX: work-around to nginx regex subsystem */
+    old_pool = ngx_http_lua_pcre_malloc_init(r->pool);
+#endif
+
+    lua_pushcfunction(L, ngx_http_lua_traceback);
+    lua_insert(L, 1);  /* put it under chunk and args */
+
+    /*  protected call user code */
+    rc = lua_pcall(L, 0, 1, 1);
+
+    lua_remove(L, 1);  /* remove traceback function */
+
+#if (NGX_PCRE)
+    /* XXX: work-around to nginx regex subsystem */
+    ngx_http_lua_pcre_malloc_done(old_pool);
+#endif
+
+    if (rc != 0) {
+        /*  error occured when running loaded code */
+        err_msg = (u_char *) lua_tolstring(L, -1, &len);
+
+        if (err_msg == NULL) {
+            err_msg = (u_char *) "unknown reason";
+            len = sizeof("unknown reason") - 1;
+        }
+
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "failed to run header_filter_by_lua*: %*s", len, err_msg);
+
+        lua_settop(L, 0); /*  clear remaining elems on stack */
+
+        return NGX_ERROR;
+    }
+
+    /*  clear Lua stack */
+    lua_settop(L, 0);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_header_filter_inline(ngx_http_request_t *r)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    /*  load Lua inline script (w/ cache) sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, llcf->header_filter_src.value.data,
+                                       llcf->header_filter_src.value.len,
+                                       llcf->header_filter_src_key,
+                                       "header_filter_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_lua_header_filter_by_chunk(L, r);
+
+    dd("header filter by chunk returns %d", (int) rc);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_header_filter_file(ngx_http_request_t *r)
+{
+    lua_State                       *L;
+    ngx_int_t                        rc;
+    u_char                          *script_path;
+    ngx_http_lua_main_conf_t        *lmcf;
+    ngx_http_lua_loc_conf_t         *llcf;
+    ngx_str_t                        eval_src;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    /* Eval nginx variables in code path string first */
+    if (ngx_http_complex_value(r, &llcf->header_filter_src, &eval_src)
+        != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+    script_path = ngx_http_lua_rebase_path(r->pool, eval_src.data,
+                                           eval_src.len);
+
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    L = lmcf->lua;
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path,
+                                     llcf->header_filter_src_key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    /*  make sure we have a valid code chunk */
+    assert(lua_isfunction(L, -1));
+
+    rc = ngx_http_lua_header_filter_by_chunk(L, r);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_header_filter(ngx_http_request_t *r)
+{
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+    ngx_http_cleanup_t          *cln;
+    uint16_t                     old_context;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua header filter for user lua code, uri \"%V\"", &r->uri);
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->body_filter_handler) {
+        r->filter_need_in_memory = 1;
+    }
+
+    if (llcf->header_filter_handler == NULL) {
+        dd("no header filter handler found");
+        return ngx_http_next_header_filter(r);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    if (ctx->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            return NGX_ERROR;
+        }
+
+        cln->handler = ngx_http_lua_request_cleanup_handler;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+    }
+
+    old_context = ctx->context;
+    ctx->context = NGX_HTTP_LUA_CONTEXT_HEADER_FILTER;
+
+    dd("calling header filter handler");
+    rc = llcf->header_filter_handler(r);
+
+    ctx->context = old_context;
+
+    if (rc != NGX_OK) {
+        dd("calling header filter handler rc %d", (int)rc);
+        return NGX_ERROR;
+    }
+
+    return ngx_http_next_header_filter(r);
+}
+
+
+ngx_int_t
+ngx_http_lua_header_filter_init(void)
+{
+    dd("calling header filter init");
+    ngx_http_next_header_filter = ngx_http_top_header_filter;
+    ngx_http_top_header_filter = ngx_http_lua_header_filter;
+
+    return NGX_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headerfilterby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,29 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_HEADERFILTERBY_H_INCLUDED_
+#define _NGX_HTTP_LUA_HEADERFILTERBY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+extern ngx_http_output_header_filter_pt ngx_http_lua_next_filter_header_filter;
+
+
+ngx_int_t ngx_http_lua_header_filter_init(void);
+
+ngx_int_t ngx_http_lua_header_filter_by_chunk(lua_State *L,
+        ngx_http_request_t *r);
+
+ngx_int_t ngx_http_lua_header_filter_inline(ngx_http_request_t *r);
+
+ngx_int_t ngx_http_lua_header_filter_file(ngx_http_request_t *r);
+
+
+#endif /* _NGX_HTTP_LUA_HEADERFILTERBY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headers.c b/src/lua/lua-nginx-module/src/ngx_http_lua_headers.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headers.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headers.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,772 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_headers.h"
+#include "ngx_http_lua_headers_out.h"
+#include "ngx_http_lua_headers_in.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_ngx_req_http_version(lua_State *L);
+static int ngx_http_lua_ngx_req_raw_header(lua_State *L);
+static int ngx_http_lua_ngx_req_header_set_helper(lua_State *L);
+static int ngx_http_lua_ngx_header_get(lua_State *L);
+static int ngx_http_lua_ngx_header_set(lua_State *L);
+static int ngx_http_lua_ngx_req_get_headers(lua_State *L);
+static int ngx_http_lua_ngx_req_header_clear(lua_State *L);
+static int ngx_http_lua_ngx_req_header_set(lua_State *L);
+
+
+static int
+ngx_http_lua_ngx_req_http_version(lua_State *L)
+{
+    ngx_http_request_t          *r;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    switch (r->http_version) {
+    case NGX_HTTP_VERSION_9:
+        lua_pushnumber(L, 0.9);
+        break;
+
+    case NGX_HTTP_VERSION_10:
+        lua_pushnumber(L, 1.0);
+        break;
+
+    case NGX_HTTP_VERSION_11:
+        lua_pushnumber(L, 1.1);
+        break;
+
+    default:
+        lua_pushnil(L);
+        break;
+    }
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_req_raw_header(lua_State *L)
+{
+    int                          n;
+    u_char                      *data, *p, *last, *pos;
+    unsigned                     no_req_line = 0, found;
+    size_t                       size;
+    ngx_buf_t                   *b, *first = NULL;
+    ngx_int_t                    i;
+    ngx_connection_t            *c;
+    ngx_http_request_t          *r, *mr;
+    ngx_http_connection_t       *hc;
+
+    n = lua_gettop(L);
+    if (n > 0) {
+        no_req_line = lua_toboolean(L, 1);
+    }
+
+    dd("no req line: %d", (int) no_req_line);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    mr = r->main;
+    hc = mr->http_connection;
+    c = mr->connection;
+
+#if 0
+    dd("hc->nbusy: %d", (int) hc->nbusy);
+
+    dd("hc->busy: %p %p %p %p", hc->busy[0]->start, hc->busy[0]->pos,
+       hc->busy[0]->last, hc->busy[0]->end);
+
+    dd("request line: %p %p", mr->request_line.data,
+       mr->request_line.data + mr->request_line.len);
+
+    dd("header in: %p %p %p %p", mr->header_in->start,
+       mr->header_in->pos, mr->header_in->last,
+       mr->header_in->end);
+
+    dd("c->buffer: %p %p %p %p", c->buffer->start,
+       c->buffer->pos, c->buffer->last,
+       c->buffer->end);
+#endif
+
+    size = 0;
+    b = c->buffer;
+
+    if (mr->request_line.data >= b->start
+        && mr->request_line.data + mr->request_line.len + 2 <= b->pos)
+    {
+        first = b;
+
+        if (mr->header_in == b) {
+            size += mr->header_end + 2 - mr->request_line.data;
+
+        } else {
+            /* the subsequent part of the header is in the large header
+             * buffers */
+#if 1
+            p = b->pos;
+            size += p - mr->request_line.data;
+
+            /* skip truncated header entries (if any) */
+            while (b->pos > b->start && b->pos[-1] != LF) {
+                b->pos--;
+                size--;
+            }
+#endif
+        }
+    }
+
+    if (hc->nbusy) {
+        b = NULL;
+        for (i = 0; i < hc->nbusy; i++) {
+            b = hc->busy[i];
+
+            dd("busy buf: %d: [%.*s]", (int) i, (int) (b->pos - b->start),
+               b->start);
+
+            if (first == NULL) {
+                if (mr->request_line.data >= b->pos
+                    || mr->request_line.data
+                       + mr->request_line.len + 2
+                       <= b->start)
+                {
+                    continue;
+                }
+
+                dd("found first at %d", (int) i);
+                first = b;
+            }
+
+            if (b == mr->header_in) {
+                size += mr->header_end + 2 - b->start;
+                break;
+            }
+
+            size += b->pos - b->start;
+        }
+    }
+
+    data = lua_newuserdata(L, size);
+    last = data;
+
+    b = c->buffer;
+    if (first == b) {
+        if (mr->header_in == b) {
+            pos = mr->header_end + 2;
+
+        } else {
+            pos = b->pos;
+        }
+
+        if (no_req_line) {
+            last = ngx_copy(data,
+                            mr->request_line.data
+                            + mr->request_line.len + 2,
+                            pos - mr->request_line.data
+                            - mr->request_line.len - 2);
+
+        } else {
+            last = ngx_copy(data, mr->request_line.data,
+                            pos - mr->request_line.data);
+        }
+
+        for (p = data; p != last; p++) {
+            if (*p == '\0') {
+                if (p + 1 != last && *(p + 1) == LF) {
+                    *p = CR;
+
+                } else {
+                    *p = ':';
+                }
+            }
+        }
+    }
+
+    if (hc->nbusy) {
+        found = (b == c->buffer);
+        for (i = 0; i < hc->nbusy; i++) {
+            b = hc->busy[i];
+
+            if (!found) {
+                if (b != first) {
+                    continue;
+                }
+
+                dd("found first");
+                found = 1;
+            }
+
+            p = last;
+
+            if (b == mr->header_in) {
+                pos = mr->header_end + 2;
+
+            } else {
+                pos = b->pos;
+            }
+
+            if (b == first) {
+                dd("request line: %.*s", (int) mr->request_line.len,
+                   mr->request_line.data);
+
+                if (no_req_line) {
+                    last = ngx_copy(last,
+                                    mr->request_line.data
+                                    + mr->request_line.len + 2,
+                                    pos - mr->request_line.data
+                                    - mr->request_line.len - 2);
+
+                } else {
+                    last = ngx_copy(last,
+                                    mr->request_line.data,
+                                    pos - mr->request_line.data);
+
+                }
+
+            } else {
+                last = ngx_copy(last, b->start, pos - b->start);
+            }
+
+#if 1
+            /* skip truncated header entries (if any) */
+            while (last > p && last[-1] != LF) {
+                last--;
+            }
+#endif
+
+            for (; p != last; p++) {
+                if (*p == '\0') {
+                    if (p + 1 == last) {
+                        /* XXX this should not happen */
+                        dd("found string end!!");
+
+                    } else if (*(p + 1) == LF) {
+                        *p = CR;
+
+                    } else {
+                        *p = ':';
+                    }
+                }
+            }
+
+            if (b == mr->header_in) {
+                break;
+            }
+        }
+    }
+
+    if (last - data > (ssize_t) size) {
+        return luaL_error(L, "buffer error: %d", (int) (last - data - size));
+    }
+
+    lua_pushlstring(L, (char *) data, last - data);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_req_get_headers(lua_State *L)
+{
+    ngx_list_part_t              *part;
+    ngx_table_elt_t              *header;
+    ngx_http_request_t           *r;
+    ngx_uint_t                    i;
+    int                           n;
+    int                           max;
+    int                           raw = 0;
+    int                           count = 0;
+
+    n = lua_gettop(L);
+
+    if (n >= 1) {
+        if (lua_isnil(L, 1)) {
+            max = NGX_HTTP_LUA_MAX_HEADERS;
+
+        } else {
+            max = luaL_checkinteger(L, 1);
+        }
+
+        if (n >= 2) {
+            raw = lua_toboolean(L, 2);
+        }
+
+    } else {
+        max = NGX_HTTP_LUA_MAX_HEADERS;
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    lua_createtable(L, 0, 4);
+
+    if (!raw) {
+        lua_pushlightuserdata(L, &ngx_http_lua_req_get_headers_metatable_key);
+        lua_rawget(L, LUA_REGISTRYINDEX);
+        lua_setmetatable(L, -2);
+    }
+
+    part = &r->headers_in.headers.part;
+    header = part->elts;
+
+    for (i = 0; /* void */; i++) {
+
+        dd("stack top: %d", lua_gettop(L));
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            header = part->elts;
+            i = 0;
+        }
+
+        if (raw) {
+            lua_pushlstring(L, (char *) header[i].key.data, header[i].key.len);
+
+        } else {
+            lua_pushlstring(L, (char *) header[i].lowcase_key,
+                            header[i].key.len);
+        }
+
+        /* stack: table key */
+
+        lua_pushlstring(L, (char *) header[i].value.data,
+                        header[i].value.len); /* stack: table key value */
+
+        ngx_http_lua_set_multi_value_table(L, -3);
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua request header: \"%V: %V\"",
+                       &header[i].key, &header[i].value);
+
+        if (max > 0 && ++count == max) {
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua hit request header limit %d", max);
+
+            return 1;
+        }
+    }
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_header_get(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *p;
+    ngx_str_t                    key;
+    ngx_uint_t                   i;
+    size_t                       len;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    /* we skip the first argument that is the table */
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    dd("key: %.*s, len %d", (int) len, p, (int) len);
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->transform_underscores_in_resp_headers) {
+        /* replace "_" with "-" */
+        for (i = 0; i < len; i++) {
+            if (p[i] == '_') {
+                p[i] = '-';
+            }
+        }
+    }
+
+    key.data = ngx_palloc(r->pool, len + 1);
+    if (key.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(key.data, p, len);
+
+    key.data[len] = '\0';
+
+    key.len = len;
+
+    return ngx_http_lua_get_output_header(L, r, &key);
+}
+
+
+static int
+ngx_http_lua_ngx_header_set(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *p;
+    ngx_str_t                    key;
+    ngx_str_t                    value;
+    ngx_uint_t                   i;
+    size_t                       len;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+    ngx_uint_t                   n;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx");
+    }
+
+    ngx_http_lua_check_fake_request2(L, r, ctx);
+
+    if (r->header_sent) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "attempt to "
+                      "set ngx.header.HEADER after sending out "
+                      "response headers");
+        return 0;
+    }
+
+    /* we skip the first argument that is the table */
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    dd("key: %.*s, len %d", (int) len, p, (int) len);
+
+    key.data = ngx_palloc(r->pool, len + 1);
+    if (key.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(key.data, p, len);
+    key.data[len] = '\0';
+    key.len = len;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->transform_underscores_in_resp_headers) {
+        /* replace "_" with "-" */
+        p = key.data;
+        for (i = 0; i < len; i++) {
+            if (p[i] == '_') {
+                p[i] = '-';
+            }
+        }
+    }
+
+    if (!ctx->headers_set) {
+        rc = ngx_http_set_content_type(r);
+        if (rc != NGX_OK) {
+            return luaL_error(L,
+                              "failed to set default content type: %d",
+                              (int) rc);
+        }
+
+        ctx->headers_set = 1;
+    }
+
+    if (lua_type(L, 3) == LUA_TNIL) {
+        value.data = NULL;
+        value.len = 0;
+
+    } else if (lua_type(L, 3) == LUA_TTABLE) {
+        n = luaL_getn(L, 3);
+        if (n == 0) {
+            value.data = NULL;
+            value.len = 0;
+
+        } else {
+            for (i = 1; i <= n; i++) {
+                dd("header value table index %d", (int) i);
+
+                lua_rawgeti(L, 3, i);
+                p = (u_char *) luaL_checklstring(L, -1, &len);
+
+                value.data = ngx_palloc(r->pool, len);
+                if (value.data == NULL) {
+                    return luaL_error(L, "out of memory");
+                }
+
+                ngx_memcpy(value.data, p, len);
+                value.len = len;
+
+                rc = ngx_http_lua_set_output_header(r, key, value,
+                                                    i == 1 /* override */);
+
+                if (rc == NGX_ERROR) {
+                    return luaL_error(L,
+                                      "failed to set header %s (error: %d)",
+                                      key.data, (int) rc);
+                }
+            }
+
+            return 0;
+        }
+
+    } else {
+        p = (u_char *) luaL_checklstring(L, 3, &len);
+        value.data = ngx_palloc(r->pool, len);
+        if (value.data == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        ngx_memcpy(value.data, p, len);
+        value.len = len;
+    }
+
+    dd("key: %.*s, value: %.*s",
+       (int) key.len, key.data, (int) value.len, value.data);
+
+    rc = ngx_http_lua_set_output_header(r, key, value, 1 /* override */);
+
+    if (rc == NGX_ERROR) {
+        return luaL_error(L, "failed to set header %s (error: %d)",
+                          key.data, (int) rc);
+    }
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_req_header_clear(lua_State *L)
+{
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one arguments, but seen %d",
+                          lua_gettop(L));
+    }
+
+    lua_pushnil(L);
+
+    return ngx_http_lua_ngx_req_header_set_helper(L);
+}
+
+
+static int
+ngx_http_lua_ngx_req_header_set(lua_State *L)
+{
+    if (lua_gettop(L) != 2) {
+        return luaL_error(L, "expecting two arguments, but seen %d",
+                          lua_gettop(L));
+    }
+
+    return ngx_http_lua_ngx_req_header_set_helper(L);
+}
+
+
+static int
+ngx_http_lua_ngx_req_header_set_helper(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *p;
+    ngx_str_t                    key;
+    ngx_str_t                    value;
+    ngx_uint_t                   i;
+    size_t                       len;
+    ngx_int_t                    rc;
+    ngx_uint_t                   n;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->http_version < NGX_HTTP_VERSION_10) {
+        return 0;
+    }
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    dd("key: %.*s, len %d", (int) len, p, (int) len);
+
+#if 0
+    /* replace "_" with "-" */
+    for (i = 0; i < len; i++) {
+        if (p[i] == '_') {
+            p[i] = '-';
+        }
+    }
+#endif
+
+    key.data = ngx_palloc(r->pool, len + 1);
+    if (key.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(key.data, p, len);
+
+    key.data[len] = '\0';
+
+    key.len = len;
+
+    if (lua_type(L, 2) == LUA_TNIL) {
+        value.data = NULL;
+        value.len = 0;
+
+    } else if (lua_type(L, 2) == LUA_TTABLE) {
+        n = luaL_getn(L, 2);
+        if (n == 0) {
+            value.data = NULL;
+            value.len = 0;
+
+        } else {
+            for (i = 1; i <= n; i++) {
+                dd("header value table index %d, top: %d", (int) i,
+                   lua_gettop(L));
+
+                lua_rawgeti(L, 2, i);
+                p = (u_char *) luaL_checklstring(L, -1, &len);
+
+                /*
+                 * we also copy the trailling '\0' char here because nginx
+                 * header values must be null-terminated
+                 * */
+
+                value.data = ngx_palloc(r->pool, len + 1);
+                if (value.data == NULL) {
+                    return luaL_error(L, "out of memory");
+                }
+
+                ngx_memcpy(value.data, p, len + 1);
+                value.len = len;
+
+                rc = ngx_http_lua_set_input_header(r, key, value,
+                                                   i == 1 /* override */);
+
+                if (rc == NGX_ERROR) {
+                    return luaL_error(L,
+                                      "failed to set header %s (error: %d)",
+                                      key.data, (int) rc);
+                }
+            }
+
+            return 0;
+        }
+
+    } else {
+
+        /*
+         * we also copy the trailling '\0' char here because nginx
+         * header values must be null-terminated
+         * */
+
+        p = (u_char *) luaL_checklstring(L, 2, &len);
+        value.data = ngx_palloc(r->pool, len + 1);
+        if (value.data == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        ngx_memcpy(value.data, p, len + 1);
+        value.len = len;
+    }
+
+    dd("key: %.*s, value: %.*s",
+       (int) key.len, key.data, (int) value.len, value.data);
+
+    rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */);
+
+    if (rc == NGX_ERROR) {
+        return luaL_error(L, "failed to set header %s (error: %d)",
+                          key.data, (int) rc);
+    }
+
+    return 0;
+}
+
+
+void
+ngx_http_lua_inject_resp_header_api(lua_State *L)
+{
+    lua_newtable(L);    /* .header */
+
+    lua_createtable(L, 0, 2); /* metatable for .header */
+    lua_pushcfunction(L, ngx_http_lua_ngx_header_get);
+    lua_setfield(L, -2, "__index");
+    lua_pushcfunction(L, ngx_http_lua_ngx_header_set);
+    lua_setfield(L, -2, "__newindex");
+    lua_setmetatable(L, -2);
+
+    lua_setfield(L, -2, "header");
+}
+
+
+void
+ngx_http_lua_inject_req_header_api(ngx_log_t *log, lua_State *L)
+{
+    int         rc;
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_http_version);
+    lua_setfield(L, -2, "http_version");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_raw_header);
+    lua_setfield(L, -2, "raw_header");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_header_clear);
+    lua_setfield(L, -2, "clear_header");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_header_set);
+    lua_setfield(L, -2, "set_header");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_headers);
+    lua_setfield(L, -2, "get_headers");
+
+    lua_pushlightuserdata(L, &ngx_http_lua_req_get_headers_metatable_key);
+    lua_createtable(L, 0, 1); /* metatable for ngx.req.get_headers(_, true) */
+
+    {
+        const char buf[] =
+            "local tb, key = ...\n"
+            "local new_key = string.gsub(string.lower(key), '_', '-')\n"
+            "if new_key ~= key then return tb[new_key] else return nil end";
+
+        rc = luaL_loadbuffer(L, buf, sizeof(buf) - 1,
+                             "ngx.req.get_headers __index");
+    }
+
+    if (rc != 0) {
+        ngx_log_error(NGX_LOG_ERR, log, 0,
+                      "failed to load Lua code of the metamethod for "
+                      "ngx.req.get_headers: %i: %s", rc, lua_tostring(L, -1));
+
+        lua_pop(L, 3);
+        return;
+    }
+
+    lua_setfield(L, -2, "__index");
+    lua_rawset(L, LUA_REGISTRYINDEX);
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headers.h b/src/lua/lua-nginx-module/src/ngx_http_lua_headers.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headers.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headers.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,21 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_HEADERS_H_INCLUDED_
+#define _NGX_HTTP_LUA_HEADERS_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_resp_header_api(lua_State *L);
+void ngx_http_lua_inject_req_header_api(ngx_log_t *log, lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_HEADERS_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.c b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,625 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include <nginx.h>
+#include "ngx_http_lua_headers_in.h"
+#include "ngx_http_lua_util.h"
+#include <ctype.h>
+
+
+static ngx_int_t ngx_http_set_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_header_helper(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value,
+    ngx_table_elt_t **output_header);
+static ngx_int_t ngx_http_set_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_user_agent_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_connection_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_cookie_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_clear_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_clear_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_host_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_lua_rm_header_helper(ngx_list_t *l,
+    ngx_list_part_t *cur, ngx_uint_t i);
+
+
+static ngx_http_lua_set_header_t  ngx_http_lua_set_handlers[] = {
+
+#if (NGX_HTTP_GZIP)
+    { ngx_string("Accept-Encoding"),
+                 offsetof(ngx_http_headers_in_t, accept_encoding),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Via"),
+                 offsetof(ngx_http_headers_in_t, via),
+                 ngx_http_set_builtin_header },
+#endif
+
+    { ngx_string("Host"),
+                 offsetof(ngx_http_headers_in_t, host),
+                 ngx_http_set_host_header },
+
+    { ngx_string("Connection"),
+                 offsetof(ngx_http_headers_in_t, connection),
+                 ngx_http_set_connection_header },
+
+    { ngx_string("If-Modified-Since"),
+                 offsetof(ngx_http_headers_in_t, if_modified_since),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("User-Agent"),
+                 offsetof(ngx_http_headers_in_t, user_agent),
+                 ngx_http_set_user_agent_header },
+
+    { ngx_string("Referer"),
+                 offsetof(ngx_http_headers_in_t, referer),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Content-Type"),
+                 offsetof(ngx_http_headers_in_t, content_type),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Range"),
+                 offsetof(ngx_http_headers_in_t, range),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("If-Range"),
+                 offsetof(ngx_http_headers_in_t, if_range),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Transfer-Encoding"),
+                 offsetof(ngx_http_headers_in_t, transfer_encoding),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Expect"),
+                 offsetof(ngx_http_headers_in_t, expect),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Authorization"),
+                 offsetof(ngx_http_headers_in_t, authorization),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Keep-Alive"),
+                 offsetof(ngx_http_headers_in_t, keep_alive),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Content-Length"),
+                 offsetof(ngx_http_headers_in_t, content_length),
+                 ngx_http_set_content_length_header },
+
+    { ngx_string("Cookie"),
+                 0,
+                 ngx_http_set_cookie_header },
+
+#if (NGX_HTTP_REALIP)
+    { ngx_string("X-Real-IP"),
+                 offsetof(ngx_http_headers_in_t, x_real_ip),
+                 ngx_http_set_builtin_header },
+#endif
+
+    { ngx_null_string, 0, ngx_http_set_header }
+};
+
+
+/* request time implementation */
+
+static ngx_int_t
+ngx_http_set_header(ngx_http_request_t *r, ngx_http_lua_header_val_t *hv,
+    ngx_str_t *value)
+{
+    return ngx_http_set_header_helper(r, hv, value, NULL);
+}
+
+
+static ngx_int_t
+ngx_http_set_header_helper(ngx_http_request_t *r, ngx_http_lua_header_val_t *hv,
+    ngx_str_t *value, ngx_table_elt_t **output_header)
+{
+    ngx_table_elt_t             *h;
+    ngx_list_part_t             *part;
+    ngx_uint_t                   i;
+    ngx_uint_t                   rc;
+
+    if (hv->no_override) {
+        goto new_header;
+    }
+
+retry:
+    part = &r->headers_in.headers.part;
+    h = part->elts;
+
+    for (i = 0; /* void */; i++) {
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            h = part->elts;
+            i = 0;
+        }
+
+        dd("i: %d, part: %p", (int) i, part);
+
+        if (h[i].key.len == hv->key.len
+            && ngx_strncasecmp(h[i].key.data, hv->key.data, h[i].key.len)
+               == 0)
+        {
+            if (value->len == 0) {
+                h[i].hash = 0;
+
+                rc = ngx_http_lua_rm_header_helper(&r->headers_in.headers,
+                                                   part, i);
+
+                if (rc == NGX_OK) {
+                    if (output_header) {
+                        *output_header = NULL;
+                    }
+
+                    goto retry;
+                }
+            }
+
+            h[i].value = *value;
+
+            if (output_header) {
+                *output_header = &h[i];
+                dd("setting existing builtin input header");
+            }
+
+            return NGX_OK;
+        }
+    }
+
+    if (value->len == 0) {
+        return NGX_OK;
+    }
+
+new_header:
+    h = ngx_list_push(&r->headers_in.headers);
+
+    if (h == NULL) {
+        return NGX_ERROR;
+    }
+
+    dd("created new header for %.*s", (int) hv->key.len, hv->key.data);
+
+    if (value->len == 0) {
+        h->hash = 0;
+
+    } else {
+        h->hash = hv->hash;
+    }
+
+    h->key = hv->key;
+    h->value = *value;
+
+    h->lowcase_key = ngx_pnalloc(r->pool, h->key.len);
+    if (h->lowcase_key == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
+
+    if (output_header) {
+        *output_header = h;
+
+        while (r != r->main) {
+            r->parent->headers_in = r->headers_in;
+            r = r->parent;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_set_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    ngx_table_elt_t             *h, **old;
+
+    dd("entered set_builtin_header (input)");
+
+    if (hv->offset) {
+        old = (ngx_table_elt_t **) ((char *) &r->headers_in + hv->offset);
+
+    } else {
+        old = NULL;
+    }
+
+    dd("old builtin ptr ptr: %p", old);
+    if (old) {
+        dd("old builtin ptr: %p", *old);
+    }
+
+    if (old == NULL || *old == NULL) {
+        dd("set normal header");
+        return ngx_http_set_header_helper(r, hv, value, old);
+    }
+
+    h = *old;
+
+    if (value->len == 0) {
+        h->hash = 0;
+        h->value = *value;
+
+        return ngx_http_set_header_helper(r, hv, value, old);
+    }
+
+    h->hash = hv->hash;
+    h->value = *value;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_set_host_header(ngx_http_request_t *r, ngx_http_lua_header_val_t *hv,
+    ngx_str_t *value)
+{
+    dd("server new value len: %d", (int) value->len);
+
+    r->headers_in.server = *value;
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_set_connection_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    r->headers_in.connection_type = 0;
+
+    if (value->len == 0) {
+        return ngx_http_set_builtin_header(r, hv, value);
+    }
+
+    if (ngx_strcasestrn(value->data, "close", 5 - 1)) {
+        r->headers_in.connection_type = NGX_HTTP_CONNECTION_CLOSE;
+        r->headers_in.keep_alive_n = -1;
+
+    } else if (ngx_strcasestrn(value->data, "keep-alive", 10 - 1)) {
+        r->headers_in.connection_type = NGX_HTTP_CONNECTION_KEEP_ALIVE;
+    }
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+/* borrowed the code from ngx_http_request.c:ngx_http_process_user_agent */
+static ngx_int_t
+ngx_http_set_user_agent_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    u_char  *user_agent, *msie;
+
+    /* clear existing settings */
+
+    r->headers_in.msie = 0;
+    r->headers_in.msie6 = 0;
+    r->headers_in.opera = 0;
+    r->headers_in.gecko = 0;
+    r->headers_in.chrome = 0;
+    r->headers_in.safari = 0;
+    r->headers_in.konqueror = 0;
+
+    if (value->len == 0) {
+        return ngx_http_set_builtin_header(r, hv, value);
+    }
+
+    /* check some widespread browsers */
+
+    user_agent = value->data;
+
+    msie = ngx_strstrn(user_agent, "MSIE ", 5 - 1);
+
+    if (msie && msie + 7 < user_agent + value->len) {
+
+        r->headers_in.msie = 1;
+
+        if (msie[6] == '.') {
+
+            switch (msie[5]) {
+            case '4':
+            case '5':
+                r->headers_in.msie6 = 1;
+                break;
+            case '6':
+                if (ngx_strstrn(msie + 8, "SV1", 3 - 1) == NULL) {
+                    r->headers_in.msie6 = 1;
+                }
+                break;
+            }
+        }
+    }
+
+    if (ngx_strstrn(user_agent, "Opera", 5 - 1)) {
+        r->headers_in.opera = 1;
+        r->headers_in.msie = 0;
+        r->headers_in.msie6 = 0;
+    }
+
+    if (!r->headers_in.msie && !r->headers_in.opera) {
+
+        if (ngx_strstrn(user_agent, "Gecko/", 6 - 1)) {
+            r->headers_in.gecko = 1;
+
+        } else if (ngx_strstrn(user_agent, "Chrome/", 7 - 1)) {
+            r->headers_in.chrome = 1;
+
+        } else if (ngx_strstrn(user_agent, "Safari/", 7 - 1)
+                   && ngx_strstrn(user_agent, "Mac OS X", 8 - 1))
+        {
+            r->headers_in.safari = 1;
+
+        } else if (ngx_strstrn(user_agent, "Konqueror", 9 - 1)) {
+            r->headers_in.konqueror = 1;
+        }
+    }
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_set_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    off_t           len;
+
+    if (value->len == 0) {
+        return ngx_http_clear_content_length_header(r, hv, value);
+    }
+
+    len = ngx_atosz(value->data, value->len);
+    if (len == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    dd("reset headers_in.content_length_n to %d", (int)len);
+
+    r->headers_in.content_length_n = len;
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_set_cookie_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    ngx_table_elt_t  **cookie, *h;
+
+    if (!hv->no_override && r->headers_in.cookies.nelts > 0) {
+        ngx_array_destroy(&r->headers_in.cookies);
+
+        if (ngx_array_init(&r->headers_in.cookies, r->pool, 2,
+                           sizeof(ngx_table_elt_t *))
+            != NGX_OK)
+        {
+            return NGX_ERROR;
+        }
+
+        dd("clear headers in cookies: %d", (int) r->headers_in.cookies.nelts);
+    }
+
+#if 1
+    if (r->headers_in.cookies.nalloc == 0) {
+        if (ngx_array_init(&r->headers_in.cookies, r->pool, 2,
+                           sizeof(ngx_table_elt_t *))
+            != NGX_OK)
+        {
+            return NGX_ERROR;
+        }
+    }
+#endif
+
+    if (ngx_http_set_header_helper(r, hv, value, &h) == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    if (value->len == 0) {
+        return NGX_OK;
+    }
+
+    dd("new cookie header: %p", h);
+
+    cookie = ngx_array_push(&r->headers_in.cookies);
+    if (cookie == NULL) {
+        return NGX_ERROR;
+    }
+
+    *cookie = h;
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_clear_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    r->headers_in.content_length_n = -1;
+
+    return ngx_http_clear_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_clear_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    value->len = 0;
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+ngx_int_t
+ngx_http_lua_set_input_header(ngx_http_request_t *r, ngx_str_t key,
+    ngx_str_t value, unsigned override)
+{
+    ngx_http_lua_header_val_t         hv;
+    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;
+
+    ngx_uint_t                        i;
+
+    dd("set header value: %.*s", (int) value.len, value.data);
+
+    hv.hash = ngx_hash_key_lc(key.data, key.len);
+    hv.key = key;
+
+    hv.offset = 0;
+    hv.no_override = !override;
+    hv.handler = NULL;
+
+    for (i = 0; handlers[i].name.len; i++) {
+        if (hv.key.len != handlers[i].name.len
+            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,
+                               handlers[i].name.len) != 0)
+        {
+            dd("hv key comparison: %s <> %s", handlers[i].name.data,
+               hv.key.data);
+
+            continue;
+        }
+
+        dd("Matched handler: %s %s", handlers[i].name.data, hv.key.data);
+
+        hv.offset = handlers[i].offset;
+        hv.handler = handlers[i].handler;
+
+        break;
+    }
+
+    if (handlers[i].name.len == 0 && handlers[i].handler) {
+        hv.offset = handlers[i].offset;
+        hv.handler = handlers[i].handler;
+    }
+
+#if 1
+    if (hv.handler == NULL) {
+        return NGX_ERROR;
+    }
+#endif
+
+    return hv.handler(r, &hv, &value);
+}
+
+
+static ngx_int_t
+ngx_http_lua_rm_header_helper(ngx_list_t *l, ngx_list_part_t *cur,
+    ngx_uint_t i)
+{
+    ngx_table_elt_t             *data;
+    ngx_list_part_t             *new, *part;
+
+    dd("list rm item: part %p, i %d, nalloc %d", cur, (int) i,
+       (int) l->nalloc);
+
+    data = cur->elts;
+
+    dd("cur: nelts %d, nalloc %d", (int) cur->nelts,
+       (int) l->nalloc);
+
+    dd("removing: \"%.*s:%.*s\"", (int) data[i].key.len, data[i].key.data,
+       (int) data[i].value.len, data[i].value.data);
+
+    if (i == 0) {
+        cur->elts = (char *) cur->elts + l->size;
+        cur->nelts--;
+
+        if (cur == l->last) {
+            if (cur->nelts == 0) {
+#if 1
+                part = &l->part;
+                while (part->next != cur) {
+                    if (part->next == NULL) {
+                        return NGX_ERROR;
+                    }
+                    part = part->next;
+                }
+
+                l->last = part;
+                part->next = NULL;
+                l->nalloc = part->nelts;
+#endif
+
+            } else {
+                l->nalloc = cur->nelts;
+            }
+
+            return NGX_OK;
+        }
+
+        if (cur->nelts == 0) {
+            part = &l->part;
+            while (part->next != cur) {
+                if (part->next == NULL) {
+                    return NGX_ERROR;
+                }
+                part = part->next;
+            }
+
+            part->next = cur->next;
+
+            return NGX_OK;
+        }
+
+        return NGX_OK;
+    }
+
+    if (i == cur->nelts - 1) {
+        dd("last entry in the part");
+
+        cur->nelts--;
+
+        if (cur == l->last) {
+            l->nalloc = cur->nelts;
+        }
+
+        return NGX_OK;
+    }
+
+    dd("the middle entry in the part");
+
+    new = ngx_palloc(l->pool, sizeof(ngx_list_part_t));
+    if (new == NULL) {
+        return NGX_ERROR;
+    }
+
+    new->elts = &data[i + 1];
+    new->nelts = cur->nelts - i - 1;
+    new->next = cur->next;
+
+    cur->nelts = i;
+    cur->next = new;
+
+    if (cur == l->last) {
+        l->last = new;
+        l->nalloc = new->nelts;
+    }
+
+    return NGX_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.h b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_in.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,22 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_HEADERS_IN_H_INCLUDED_
+#define _NGX_HTTP_LUA_HEADERS_IN_H_INCLUDED_
+
+
+#include <nginx.h>
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_set_input_header(ngx_http_request_t *r, ngx_str_t key,
+    ngx_str_t value, unsigned override);
+
+
+#endif /* _NGX_HTTP_LUA_HEADERS_IN_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.c b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,589 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include <nginx.h>
+#include "ngx_http_lua_headers_out.h"
+#include "ngx_http_lua_util.h"
+#include <ctype.h>
+
+
+static ngx_int_t ngx_http_set_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_header_helper(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value,
+    ngx_table_elt_t **output_header, unsigned no_create);
+static ngx_int_t ngx_http_set_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_builtin_multi_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_last_modified_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_set_content_type_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_clear_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_clear_last_modified_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+static ngx_int_t ngx_http_clear_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value);
+
+
+static ngx_http_lua_set_header_t  ngx_http_lua_set_handlers[] = {
+
+    { ngx_string("Server"),
+                 offsetof(ngx_http_headers_out_t, server),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Date"),
+                 offsetof(ngx_http_headers_out_t, date),
+                 ngx_http_set_builtin_header },
+
+#if 1
+    { ngx_string("Content-Encoding"),
+                 offsetof(ngx_http_headers_out_t, content_encoding),
+                 ngx_http_set_builtin_header },
+#endif
+
+    { ngx_string("Location"),
+                 offsetof(ngx_http_headers_out_t, location),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Refresh"),
+                 offsetof(ngx_http_headers_out_t, refresh),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Last-Modified"),
+                 offsetof(ngx_http_headers_out_t, last_modified),
+                 ngx_http_set_last_modified_header },
+
+    { ngx_string("Content-Range"),
+                 offsetof(ngx_http_headers_out_t, content_range),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Accept-Ranges"),
+                 offsetof(ngx_http_headers_out_t, accept_ranges),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("WWW-Authenticate"),
+                 offsetof(ngx_http_headers_out_t, www_authenticate),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Expires"),
+                 offsetof(ngx_http_headers_out_t, expires),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("E-Tag"),
+                 offsetof(ngx_http_headers_out_t, etag),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("ETag"),
+                 offsetof(ngx_http_headers_out_t, etag),
+                 ngx_http_set_builtin_header },
+
+    { ngx_string("Content-Length"),
+                 offsetof(ngx_http_headers_out_t, content_length),
+                 ngx_http_set_content_length_header },
+
+    { ngx_string("Content-Type"),
+                 offsetof(ngx_http_headers_out_t, content_type),
+                 ngx_http_set_content_type_header },
+
+    { ngx_string("Cache-Control"),
+                 offsetof(ngx_http_headers_out_t, cache_control),
+                 ngx_http_set_builtin_multi_header },
+
+    { ngx_null_string, 0, ngx_http_set_header }
+};
+
+
+/* request time implementation */
+
+static ngx_int_t
+ngx_http_set_header(ngx_http_request_t *r, ngx_http_lua_header_val_t *hv,
+    ngx_str_t *value)
+{
+    return ngx_http_set_header_helper(r, hv, value, NULL, 0);
+}
+
+
+static ngx_int_t
+ngx_http_set_header_helper(ngx_http_request_t *r, ngx_http_lua_header_val_t *hv,
+    ngx_str_t *value, ngx_table_elt_t **output_header,
+    unsigned no_create)
+{
+    ngx_table_elt_t             *h;
+    ngx_list_part_t             *part;
+    ngx_uint_t                   i;
+    unsigned                     matched = 0;
+
+    if (hv->no_override) {
+        goto new_header;
+    }
+
+#if 1
+    if (r->headers_out.location
+        && r->headers_out.location->value.len
+        && r->headers_out.location->value.data[0] == '/')
+    {
+        /* XXX ngx_http_core_find_config_phase, for example,
+         * may not initialize the "key" and "hash" fields
+         * for a nasty optimization purpose, and
+         * we have to work-around it here */
+
+        r->headers_out.location->hash = ngx_http_lua_location_hash;
+        ngx_str_set(&r->headers_out.location->key, "Location");
+    }
+#endif
+
+    part = &r->headers_out.headers.part;
+    h = part->elts;
+
+    for (i = 0; /* void */; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            h = part->elts;
+            i = 0;
+        }
+
+        if (h[i].hash != 0
+            && h[i].key.len == hv->key.len
+            && ngx_strncasecmp(hv->key.data, h[i].key.data, h[i].key.len) == 0)
+        {
+            dd("found out header %.*s", (int) h[i].key.len, h[i].key.data);
+
+            if (value->len == 0 || matched) {
+                dd("clearing normal header for %.*s", (int) hv->key.len,
+                   hv->key.data);
+
+                h[i].value.len = 0;
+                h[i].hash = 0;
+
+            } else {
+                dd("setting header to value %.*s", (int) value->len,
+                        value->data);
+
+                h[i].value = *value;
+                h[i].hash = hv->hash;
+            }
+
+            if (output_header) {
+                *output_header = &h[i];
+            }
+
+            /* return NGX_OK; */
+            matched = 1;
+        }
+    }
+
+    if (matched){
+        return NGX_OK;
+    }
+
+    if (no_create && value->len == 0) {
+        return NGX_OK;
+    }
+
+new_header:
+
+    /* XXX we still need to create header slot even if the value
+     * is empty because some builtin headers like Last-Modified
+     * relies on this to get cleared */
+
+    h = ngx_list_push(&r->headers_out.headers);
+
+    if (h == NULL) {
+        return NGX_ERROR;
+    }
+
+    if (value->len == 0) {
+        h->hash = 0;
+
+    } else {
+        h->hash = hv->hash;
+    }
+
+    h->key = hv->key;
+    h->value = *value;
+
+    h->lowcase_key = ngx_pnalloc(r->pool, h->key.len);
+    if (h->lowcase_key == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
+
+    if (output_header) {
+        *output_header = h;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_set_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    ngx_table_elt_t  *h, **old;
+
+    if (hv->offset) {
+        old = (ngx_table_elt_t **) ((char *) &r->headers_out + hv->offset);
+
+    } else {
+        old = NULL;
+    }
+
+    if (old == NULL || *old == NULL) {
+        return ngx_http_set_header_helper(r, hv, value, old, 0);
+    }
+
+    h = *old;
+
+    if (value->len == 0) {
+        dd("clearing the builtin header");
+
+        h->hash = 0;
+        h->value = *value;
+
+        return NGX_OK;
+    }
+
+    h->hash = hv->hash;
+    h->key = hv->key;
+    h->value = *value;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_set_builtin_multi_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    ngx_array_t      *pa;
+    ngx_table_elt_t  *ho, **ph;
+    ngx_uint_t        i;
+
+    pa = (ngx_array_t *) ((char *) &r->headers_out + hv->offset);
+
+    if (pa->elts == NULL) {
+        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *))
+            != NGX_OK)
+        {
+            return NGX_ERROR;
+        }
+    }
+
+    if (hv->no_override) {
+        ph = pa->elts;
+        for (i = 0; i < pa->nelts; i++) {
+            if (!ph[i]->hash) {
+                ph[i]->value = *value;
+                ph[i]->hash = hv->hash;
+                return NGX_OK;
+            }
+        }
+
+        goto create;
+    }
+
+    /* override old values (if any) */
+
+    if (pa->nelts > 0) {
+        ph = pa->elts;
+        for (i = 1; i < pa->nelts; i++) {
+            ph[i]->hash = 0;
+            ph[i]->value.len = 0;
+        }
+
+        ph[0]->value = *value;
+
+        if (value->len == 0) {
+            ph[0]->hash = 0;
+
+        } else {
+            ph[0]->hash = hv->hash;
+        }
+
+        return NGX_OK;
+    }
+
+create:
+    ph = ngx_array_push(pa);
+    if (ph == NULL) {
+        return NGX_ERROR;
+    }
+
+    ho = ngx_list_push(&r->headers_out.headers);
+    if (ho == NULL) {
+        return NGX_ERROR;
+    }
+
+    ho->value = *value;
+    ho->hash = hv->hash;
+    ngx_str_set(&ho->key, "Cache-Control");
+    *ph = ho;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_set_content_type_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    r->headers_out.content_type_len = value->len;
+    r->headers_out.content_type = *value;
+    r->headers_out.content_type_hash = hv->hash;
+    r->headers_out.content_type_lowcase = NULL;
+
+    value->len = 0;
+
+    return ngx_http_set_header_helper(r, hv, value, NULL, 1);
+}
+
+
+static ngx_int_t ngx_http_set_last_modified_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    if (value->len == 0) {
+        return ngx_http_clear_last_modified_header(r, hv, value);
+    }
+
+    r->headers_out.last_modified_time = ngx_http_parse_time(value->data,
+                                                            value->len);
+
+    dd("last modified time: %d", (int) r->headers_out.last_modified_time);
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_clear_last_modified_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    r->headers_out.last_modified_time = -1;
+
+    return ngx_http_clear_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_set_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    off_t           len;
+
+    if (value->len == 0) {
+        return ngx_http_clear_content_length_header(r, hv, value);
+    }
+
+    len = ngx_atosz(value->data, value->len);
+    if (len == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    r->headers_out.content_length_n = len;
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_clear_content_length_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    r->headers_out.content_length_n = -1;
+
+    return ngx_http_clear_builtin_header(r, hv, value);
+}
+
+
+static ngx_int_t
+ngx_http_clear_builtin_header(ngx_http_request_t *r,
+    ngx_http_lua_header_val_t *hv, ngx_str_t *value)
+{
+    value->len = 0;
+
+    return ngx_http_set_builtin_header(r, hv, value);
+}
+
+
+ngx_int_t
+ngx_http_lua_set_output_header(ngx_http_request_t *r, ngx_str_t key,
+    ngx_str_t value, unsigned override)
+{
+    ngx_http_lua_header_val_t         hv;
+    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;
+    ngx_uint_t                        i;
+
+    dd("set header value: %.*s", (int) value.len, value.data);
+
+    hv.hash = ngx_hash_key_lc(key.data, key.len);
+    hv.key = key;
+
+    hv.offset = 0;
+    hv.no_override = !override;
+    hv.handler = NULL;
+
+    for (i = 0; handlers[i].name.len; i++) {
+        if (hv.key.len != handlers[i].name.len
+            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,
+                               handlers[i].name.len) != 0)
+        {
+            dd("hv key comparison: %s <> %s", handlers[i].name.data,
+               hv.key.data);
+
+            continue;
+        }
+
+        dd("Matched handler: %s %s", handlers[i].name.data, hv.key.data);
+
+        hv.offset = handlers[i].offset;
+        hv.handler = handlers[i].handler;
+
+        break;
+    }
+
+    if (handlers[i].name.len == 0 && handlers[i].handler) {
+        hv.offset = handlers[i].offset;
+        hv.handler = handlers[i].handler;
+    }
+
+#if 1
+    if (hv.handler == NULL) {
+        return NGX_ERROR;
+    }
+#endif
+
+    return hv.handler(r, &hv, &value);
+}
+
+
+int
+ngx_http_lua_get_output_header(lua_State *L, ngx_http_request_t *r,
+    ngx_str_t *key)
+{
+    ngx_table_elt_t            *h;
+    ngx_list_part_t            *part;
+    ngx_uint_t                  i;
+    unsigned                    found;
+
+    dd("looking for response header \"%.*s\"", (int) key->len, key->data);
+
+    switch (key->len) {
+    case 14:
+        if (r->headers_out.content_length == NULL
+            && r->headers_out.content_length_n >= 0
+            && ngx_strncasecmp(key->data, (u_char *) "Content-Length", 14) == 0)
+        {
+            lua_pushinteger(L, (lua_Integer) r->headers_out.content_length_n);
+            return 1;
+        }
+
+        break;
+
+    case 12:
+        if (r->headers_out.content_type.len
+            && ngx_strncasecmp(key->data, (u_char *) "Content-Type", 12) == 0)
+        {
+            lua_pushlstring(L, (char *) r->headers_out.content_type.data,
+                            r->headers_out.content_type.len);
+            return 1;
+        }
+
+        break;
+
+    default:
+        break;
+    }
+
+    dd("not a built-in output header");
+
+    found = 0;
+
+#if 1
+    if (r->headers_out.location
+        && r->headers_out.location->value.len
+        && r->headers_out.location->value.data[0] == '/')
+    {
+        /* XXX ngx_http_core_find_config_phase, for example,
+         * may not initialize the "key" and "hash" fields
+         * for a nasty optimization purpose, and
+         * we have to work-around it here */
+
+        r->headers_out.location->hash = ngx_http_lua_location_hash;
+        ngx_str_set(&r->headers_out.location->key, "Location");
+    }
+#endif
+
+    part = &r->headers_out.headers.part;
+    h = part->elts;
+
+    for (i = 0; /* void */; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            h = part->elts;
+            i = 0;
+        }
+
+        if (h[i].hash == 0) {
+            continue;
+        }
+
+        if (h[i].hash != 0
+            && h[i].key.len == key->len
+            && ngx_strncasecmp(key->data, h[i].key.data, h[i].key.len) == 0)
+         {
+             if (!found) {
+                 found = 1;
+
+                 lua_pushlstring(L, (char *) h[i].value.data, h[i].value.len);
+                 continue;
+             }
+
+             if (found == 1) {
+                 lua_createtable(L, 4 /* narr */, 0);
+                 lua_insert(L, -2);
+                 lua_rawseti(L, -2, found);
+             }
+
+             found++;
+
+             lua_pushlstring(L, (char *) h[i].value.data, h[i].value.len);
+             lua_rawseti(L, -2, found);
+         }
+    }
+
+    if (found) {
+        return 1;
+    }
+
+    lua_pushnil(L);
+    return 1;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.h b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_headers_out.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,23 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_HEADERS_OUT_H_INCLUDED_
+#define _NGX_HTTP_LUA_HEADERS_OUT_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_set_output_header(ngx_http_request_t *r, ngx_str_t key,
+    ngx_str_t value, unsigned override);
+int ngx_http_lua_get_output_header(lua_State *L, ngx_http_request_t *r,
+    ngx_str_t *key);
+
+
+#endif /* _NGX_HTTP_LUA_HEADERS_OUT_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_initby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_initby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_initby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_initby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,128 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+
+#include "ddebug.h"
+#include "ngx_http_lua_initby.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_report(ngx_log_t *log, lua_State *L, int status);
+static int ngx_http_lua_do_call(ngx_log_t *log, lua_State *L);
+static int ngx_http_lua_swap_coroutine_api(ngx_log_t *log, lua_State *L);
+
+
+int
+ngx_http_lua_init_by_inline(ngx_log_t *log, ngx_http_lua_main_conf_t *lmcf,
+    lua_State *L)
+{
+    int         status;
+
+    status = ngx_http_lua_swap_coroutine_api(log, L);
+    if (status != 0) {
+        goto done;
+    }
+
+    status = luaL_loadbuffer(L, (char *) lmcf->init_src.data,
+                             lmcf->init_src.len, "init_by_lua")
+             || ngx_http_lua_do_call(log, L);
+
+    if (status != 0) {
+        goto done;
+    }
+
+    status = ngx_http_lua_swap_coroutine_api(log, L);
+
+done:
+    return ngx_http_lua_report(log, L, status);
+}
+
+
+int
+ngx_http_lua_init_by_file(ngx_log_t *log, ngx_http_lua_main_conf_t *lmcf,
+    lua_State *L)
+{
+    int         status;
+
+    status = ngx_http_lua_swap_coroutine_api(log, L);
+    if (status != 0) {
+        goto done;
+    }
+
+    status = luaL_loadfile(L, (char *) lmcf->init_src.data)
+             || ngx_http_lua_do_call(log, L);
+
+    if (status != 0) {
+        goto done;
+    }
+
+    status = ngx_http_lua_swap_coroutine_api(log, L);
+
+done:
+    return ngx_http_lua_report(log, L, status);
+}
+
+
+static int
+ngx_http_lua_report(ngx_log_t *log, lua_State *L, int status)
+{
+    const char      *msg;
+
+    if (status && !lua_isnil(L, -1)) {
+        msg = lua_tostring(L, -1);
+        if (msg == NULL) {
+            msg = "unknown error";
+        }
+
+        ngx_log_error(NGX_LOG_ERR, log, 0, "failed to run init_by_lua*: %s",
+                      msg);
+        lua_pop(L, 1);
+    }
+
+    /* force a full garbage-collection cycle */
+    lua_gc(L, LUA_GCCOLLECT, 0);
+
+    return status;
+}
+
+
+static int
+ngx_http_lua_do_call(ngx_log_t *log, lua_State *L)
+{
+    int     status, base;
+
+    base = lua_gettop(L);  /* function index */
+    lua_pushcfunction(L, ngx_http_lua_traceback);  /* push traceback function */
+    lua_insert(L, base);  /* put it under chunk and args */
+    status = lua_pcall(L, 0, 0, base);
+    lua_remove(L, base);
+
+    return status;
+}
+
+
+static int
+ngx_http_lua_swap_coroutine_api(ngx_log_t *log, lua_State *L)
+{
+    const char code[] = "do\n"
+                        "local keys = {'create', 'yield', 'resume', 'status'}"
+                        "for _, key in ipairs(keys) do\n"
+                           "local _key = '_' .. key\n"
+                           "local f = coroutine[_key]\n"
+                           "coroutine[_key] = coroutine[key]\n"
+                           "coroutine[key] = f\n"
+                        "end\n"
+                        "end";
+
+    return luaL_loadbuffer(L, code, sizeof(code) - 1, "swap coroutine api")
+           || ngx_http_lua_do_call(log, L);
+}
+
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_initby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_initby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_initby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_initby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,23 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_INITBY_H_INCLUDED_
+#define _NGX_HTTP_LUA_INITBY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+int ngx_http_lua_init_by_inline(ngx_log_t *log, ngx_http_lua_main_conf_t *lmcf,
+        lua_State *L);
+
+int ngx_http_lua_init_by_file(ngx_log_t *log, ngx_http_lua_main_conf_t *lmcf,
+        lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_INITBY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_logby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_logby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_logby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_logby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,248 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_directive.h"
+#include "ngx_http_lua_logby.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_time.h"
+#include "ngx_http_lua_log.h"
+#include "ngx_http_lua_regex.h"
+#include "ngx_http_lua_cache.h"
+#include "ngx_http_lua_headers.h"
+#include "ngx_http_lua_variable.h"
+#include "ngx_http_lua_string.h"
+#include "ngx_http_lua_misc.h"
+#include "ngx_http_lua_consts.h"
+#include "ngx_http_lua_shdict.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_exception.h"
+
+
+static ngx_int_t ngx_http_lua_log_by_chunk(lua_State *L, ngx_http_request_t *r);
+
+
+static void
+ngx_http_lua_log_by_lua_env(lua_State *L, ngx_http_request_t *r)
+{
+    /*  set nginx request pointer to current lua thread's globals table */
+    ngx_http_lua_set_req(L, r);
+
+    /**
+     * we want to create empty environment for current script
+     *
+	 * newt = {}
+	 * newt["_G"] = newt
+     * setmetatable(newt, {__index = _G})
+     *
+     * if a function or symbol is not defined in our env, __index will lookup
+     * in the global env.
+     *
+     * all variables created in the script-env will be thrown away at the end
+     * of the script run.
+     * */
+    ngx_http_lua_create_new_global_table(L, 0 /* narr */, 1 /* nrec */);
+
+    /*  {{{ make new env inheriting main thread's globals table */
+    lua_newtable(L);    /*  the metatable for the new env */
+    lua_pushvalue(L, LUA_GLOBALSINDEX);
+    lua_setfield(L, -2, "__index");
+    lua_setmetatable(L, -2);    /*  setmetatable({}, {__index = _G}) */
+    /*  }}} */
+
+    lua_setfenv(L, -2);    /*  set new running env for the code closure */
+}
+
+
+ngx_int_t
+ngx_http_lua_log_handler(ngx_http_request_t *r)
+{
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_int_t                    rc;
+    lua_State                   *L;
+    ngx_http_lua_ctx_t          *ctx;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua log handler, uri:\"%V\" c:%ud", &r->uri,
+                   r->main->count);
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->log_handler == NULL) {
+        dd("no log handler found");
+        return NGX_DECLINED;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    ctx->context = NGX_HTTP_LUA_CONTEXT_LOG;
+
+    dd("calling log handler");
+    rc = llcf->log_handler(r);
+
+    /* we must release the ngx.ctx table here because request cleanup runs
+     * before log phase handlers */
+
+    if (ctx->ctx_ref != LUA_NOREF) {
+        lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+        L = lmcf->lua;
+        ngx_http_lua_release_ngx_ctx_table(r->connection->log, L, ctx);
+    }
+
+    return rc;
+}
+
+
+ngx_int_t
+ngx_http_lua_log_handler_inline(ngx_http_request_t *r)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    dd("log by lua inline");
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    /*  load Lua inline script (w/ cache) sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, llcf->log_src.value.data,
+                                       llcf->log_src.value.len,
+                                       llcf->log_src_key, "log_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return ngx_http_lua_log_by_chunk(L, r);
+}
+
+
+ngx_int_t
+ngx_http_lua_log_handler_file(ngx_http_request_t *r)
+{
+    lua_State                       *L;
+    ngx_int_t                        rc;
+    u_char                          *script_path;
+    ngx_http_lua_main_conf_t        *lmcf;
+    ngx_http_lua_loc_conf_t         *llcf;
+    ngx_str_t                        eval_src;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (ngx_http_complex_value(r, &llcf->log_src, &eval_src) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    script_path = ngx_http_lua_rebase_path(r->pool, eval_src.data,
+                                           eval_src.len);
+
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    L = lmcf->lua;
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path, llcf->log_src_key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return ngx_http_lua_log_by_chunk(L, r);
+}
+
+
+ngx_int_t
+ngx_http_lua_log_by_chunk(lua_State *L, ngx_http_request_t *r)
+{
+    ngx_int_t        rc;
+    u_char          *err_msg;
+    size_t           len;
+#if (NGX_PCRE)
+    ngx_pool_t      *old_pool;
+#endif
+
+    /*  set Lua VM panic handler */
+    lua_atpanic(L, ngx_http_lua_atpanic);
+
+    NGX_LUA_EXCEPTION_TRY {
+
+        /* initialize nginx context in Lua VM, code chunk at stack top sp = 1 */
+        ngx_http_lua_log_by_lua_env(L, r);
+
+#if (NGX_PCRE)
+        /* XXX: work-around to nginx regex subsystem */
+        old_pool = ngx_http_lua_pcre_malloc_init(r->pool);
+#endif
+
+        lua_pushcfunction(L, ngx_http_lua_traceback);
+        lua_insert(L, 1);  /* put it under chunk and args */
+
+        /*  protected call user code */
+        rc = lua_pcall(L, 0, 1, 1);
+
+        lua_remove(L, 1);  /* remove traceback function */
+
+#if (NGX_PCRE)
+        /* XXX: work-around to nginx regex subsystem */
+        ngx_http_lua_pcre_malloc_done(old_pool);
+#endif
+
+        if (rc != 0) {
+            /*  error occured when running loaded code */
+            err_msg = (u_char *) lua_tolstring(L, -1, &len);
+
+            if (err_msg == NULL) {
+                err_msg = (u_char *) "unknown reason";
+                len = sizeof("unknown reason") - 1;
+            }
+
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "failed to run log_by_lua*: %*s", len, err_msg);
+
+            lua_settop(L, 0);    /*  clear remaining elems on stack */
+
+            return NGX_ERROR;
+        }
+
+    } NGX_LUA_EXCEPTION_CATCH {
+
+        dd("nginx execution restored");
+        return NGX_ERROR;
+    }
+
+    /*  clear Lua stack */
+    lua_settop(L, 0);
+
+    return NGX_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_logby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_logby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_logby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_logby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,22 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_LOGBY_H_INCLUDED_
+#define _NGX_HTTP_LUA_LOGBY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_log_handler(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_log_handler_inline(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_log_handler_file(ngx_http_request_t *r);
+void ngx_http_lua_inject_logby_ngx_api(ngx_conf_t *cf, lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_LOGBY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_log.c b/src/lua/lua-nginx-module/src/ngx_http_lua_log.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_log.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_log.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,300 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_log.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_print(lua_State *L);
+static int ngx_http_lua_ngx_log(lua_State *L);
+static int log_wrapper(ngx_log_t *log, const char *ident,
+    ngx_uint_t level, lua_State *L);
+static void ngx_http_lua_inject_log_consts(lua_State *L);
+
+
+/**
+ * Wrapper of nginx log functionality. Take a log level param and varargs of
+ * log message params.
+ *
+ * @param L Lua state pointer
+ * @retval always 0 (don't return values to Lua)
+ * */
+int
+ngx_http_lua_ngx_log(lua_State *L)
+{
+    ngx_log_t                   *log;
+    ngx_http_request_t          *r;
+    const char                  *msg;
+    int                          level;
+
+    r = ngx_http_lua_get_req(L);
+
+    if (r && r->connection && r->connection->log) {
+        log = r->connection->log;
+
+    } else {
+        log = ngx_cycle->log;
+    }
+
+    level = luaL_checkint(L, 1);
+    if (level < NGX_LOG_STDERR || level > NGX_LOG_DEBUG) {
+        msg = lua_pushfstring(L, "bad log level: %d", level);
+        return luaL_argerror(L, 1, msg);
+    }
+
+    /* remove log-level param from stack */
+    lua_remove(L, 1);
+
+    return log_wrapper(log, "[lua] ", (ngx_uint_t) level, L);
+}
+
+
+/**
+ * Override Lua print function, output message to nginx error logs. Equal to
+ * ngx.log(ngx.NOTICE, ...).
+ *
+ * @param L Lua state pointer
+ * @retval always 0 (don't return values to Lua)
+ * */
+int
+ngx_http_lua_print(lua_State *L)
+{
+    ngx_log_t                   *log;
+    ngx_http_request_t          *r;
+
+    r = ngx_http_lua_get_req(L);
+
+    if (r && r->connection && r->connection->log) {
+        log = r->connection->log;
+
+    } else {
+        log = ngx_cycle->log;
+    }
+
+    return log_wrapper(log, "[lua] ", NGX_LOG_NOTICE, L);
+}
+
+
+static int
+log_wrapper(ngx_log_t *log, const char *ident, ngx_uint_t level,
+    lua_State *L)
+{
+    u_char              *buf;
+    u_char              *p, *q;
+    ngx_str_t            name;
+    int                  nargs, i;
+    size_t               size, len;
+    size_t               src_len = 0;
+    int                  type;
+    const char          *msg;
+    lua_Debug            ar;
+
+    if (level > log->log_level) {
+        return 0;
+    }
+
+#if 1
+    /* add debug info */
+
+    lua_getstack(L, 1, &ar);
+    lua_getinfo(L, "Snl", &ar);
+
+    /* get the basename of the Lua source file path, stored in q */
+    name.data = (u_char *) ar.short_src;
+    if (name.data == NULL) {
+        name.len = 0;
+
+    } else {
+        p = name.data;
+        while (*p != '\0') {
+            if (*p == '/' || *p == '\\') {
+                name.data = p + 1;
+            }
+            p++;
+        }
+
+        name.len = p - name.data;
+    }
+
+#endif
+
+    nargs = lua_gettop(L);
+
+    size = name.len + NGX_INT_T_LEN + sizeof(":: ") - 1;
+
+    if (*ar.namewhat != '\0' && *ar.what == 'L') {
+        src_len = ngx_strlen(ar.name);
+        size += src_len + sizeof("(): ") - 1;
+    }
+
+    for (i = 1; i <= nargs; i++) {
+        type = lua_type(L, i);
+        switch (type) {
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+                lua_tolstring(L, i, &len);
+                size += len;
+                break;
+
+            case LUA_TNIL:
+                size += sizeof("nil") - 1;
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, i)) {
+                    size += sizeof("true") - 1;
+
+                } else {
+                    size += sizeof("false") - 1;
+                }
+
+                break;
+
+            case LUA_TLIGHTUSERDATA:
+                if (lua_touserdata(L, i) == NULL) {
+                    size += sizeof("null") - 1;
+                    break;
+                }
+
+                continue;
+
+            default:
+                msg = lua_pushfstring(L, "string, number, boolean, or nil "
+                                      "expected, got %s",
+                                      lua_typename(L, type));
+                return luaL_argerror(L, i, msg);
+        }
+    }
+
+    buf = lua_newuserdata(L, size);
+
+    p = ngx_copy(buf, name.data, name.len);
+
+    *p++ = ':';
+
+    p = ngx_snprintf(p, NGX_INT_T_LEN, "%d",
+                     ar.currentline ? ar.currentline : ar.linedefined);
+
+    *p++ = ':'; *p++ = ' ';
+
+    if (*ar.namewhat != '\0' && *ar.what == 'L') {
+        p = ngx_copy(p, ar.name, src_len);
+        *p++ = '(';
+        *p++ = ')';
+        *p++ = ':';
+        *p++ = ' ';
+    }
+
+    for (i = 1; i <= nargs; i++) {
+        type = lua_type(L, i);
+        switch (type) {
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+                q = (u_char *) lua_tolstring(L, i, &len);
+                p = ngx_copy(p, q, len);
+                break;
+
+            case LUA_TNIL:
+                *p++ = 'n';
+                *p++ = 'i';
+                *p++ = 'l';
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, i)) {
+                    *p++ = 't';
+                    *p++ = 'r';
+                    *p++ = 'u';
+                    *p++ = 'e';
+
+                } else {
+                    *p++ = 'f';
+                    *p++ = 'a';
+                    *p++ = 'l';
+                    *p++ = 's';
+                    *p++ = 'e';
+                }
+
+                break;
+
+            case LUA_TLIGHTUSERDATA:
+                *p++ = 'n';
+                *p++ = 'u';
+                *p++ = 'l';
+                *p++ = 'l';
+
+                break;
+
+            default:
+                return luaL_error(L, "impossible to reach here");
+        }
+    }
+
+    if (p - buf > (off_t) size) {
+        return luaL_error(L, "buffer error: %d > %d", (int) (p - buf),
+                          (int) size);
+    }
+
+    ngx_log_error(level, log, 0, "%s%*s", ident, (size_t) (p - buf), buf);
+
+    return 0;
+}
+
+
+void
+ngx_http_lua_inject_log_api(lua_State *L)
+{
+    ngx_http_lua_inject_log_consts(L);
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_log);
+    lua_setfield(L, -2, "log");
+
+    lua_pushcfunction(L, ngx_http_lua_print);
+    lua_setglobal(L, "print");
+}
+
+
+static void
+ngx_http_lua_inject_log_consts(lua_State *L)
+{
+    /* {{{ nginx log level constants */
+    lua_pushinteger(L, NGX_LOG_STDERR);
+    lua_setfield(L, -2, "STDERR");
+
+    lua_pushinteger(L, NGX_LOG_EMERG);
+    lua_setfield(L, -2, "EMERG");
+
+    lua_pushinteger(L, NGX_LOG_ALERT);
+    lua_setfield(L, -2, "ALERT");
+
+    lua_pushinteger(L, NGX_LOG_CRIT);
+    lua_setfield(L, -2, "CRIT");
+
+    lua_pushinteger(L, NGX_LOG_ERR);
+    lua_setfield(L, -2, "ERR");
+
+    lua_pushinteger(L, NGX_LOG_WARN);
+    lua_setfield(L, -2, "WARN");
+
+    lua_pushinteger(L, NGX_LOG_NOTICE);
+    lua_setfield(L, -2, "NOTICE");
+
+    lua_pushinteger(L, NGX_LOG_INFO);
+    lua_setfield(L, -2, "INFO");
+
+    lua_pushinteger(L, NGX_LOG_DEBUG);
+    lua_setfield(L, -2, "DEBUG");
+    /* }}} */
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_log.h b/src/lua/lua-nginx-module/src/ngx_http_lua_log.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_log.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_log.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_LOG_H_INCLUDED_
+#define _NGX_HTTP_LUA_LOG_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_log_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_LOG_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_misc.c b/src/lua/lua-nginx-module/src/ngx_http_lua_misc.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_misc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_misc.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,160 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_misc.h"
+#include "ngx_http_lua_ctx.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_ngx_get(lua_State *L);
+static int ngx_http_lua_ngx_set(lua_State *L);
+
+
+void
+ngx_http_lua_inject_misc_api(lua_State *L)
+{
+    /* ngx. getter and setter */
+    lua_createtable(L, 0, 2); /* metatable for .ngx */
+    lua_pushcfunction(L, ngx_http_lua_ngx_get);
+    lua_setfield(L, -2, "__index");
+    lua_pushcfunction(L, ngx_http_lua_ngx_set);
+    lua_setfield(L, -2, "__newindex");
+    lua_setmetatable(L, -2);
+}
+
+
+static int
+ngx_http_lua_ngx_get(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *p;
+    size_t                       len;
+    ngx_http_lua_ctx_t          *ctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    p = (u_char *) luaL_checklstring(L, -1, &len);
+
+    dd("ngx get %s", p);
+
+    if (len == sizeof("status") - 1
+        && ngx_strncmp(p, "status", sizeof("status") - 1) == 0)
+    {
+        ngx_http_lua_check_fake_request(L, r);
+        lua_pushnumber(L, (lua_Number) r->headers_out.status);
+        return 1;
+    }
+
+    if (len == sizeof("ctx") - 1
+        && ngx_strncmp(p, "ctx", sizeof("ctx") - 1) == 0)
+    {
+        return ngx_http_lua_ngx_get_ctx(L);
+    }
+
+    if (len == sizeof("is_subrequest") - 1
+        && ngx_strncmp(p, "is_subrequest", sizeof("is_subrequest") - 1) == 0)
+    {
+        lua_pushboolean(L, r != r->main);
+        return 1;
+    }
+
+    if (len == sizeof("headers_sent") - 1
+        && ngx_strncmp(p, "headers_sent", sizeof("headers_sent") - 1) == 0)
+    {
+        ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+        if (ctx == NULL) {
+            return luaL_error(L, "no ctx");
+        }
+
+        ngx_http_lua_check_fake_request2(L, r, ctx);
+
+        dd("headers sent: %d", r->header_sent);
+
+        lua_pushboolean(L, r->header_sent ? 1 : 0);
+        return 1;
+    }
+
+    dd("key %s not matched", p);
+
+    lua_pushnil(L);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_set(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *p;
+    size_t                       len;
+    ngx_http_lua_ctx_t          *ctx;
+
+    /* we skip the first argument that is the table */
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    if (len == sizeof("status") - 1
+        && ngx_strncmp(p, "status", sizeof("status") - 1) == 0)
+    {
+        r = ngx_http_lua_get_req(L);
+        if (r == NULL) {
+            return luaL_error(L, "no request object found");
+        }
+
+        ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+        if (r->header_sent) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "attempt to set ngx.status after sending out "
+                          "response headers");
+            return 0;
+        }
+
+        ngx_http_lua_check_fake_request2(L, r, ctx);
+
+        /* get the value */
+        r->headers_out.status = (ngx_uint_t) luaL_checknumber(L, 3);
+
+        if (r->headers_out.status == 101) {
+            /*
+             * XXX work-around a bug in the Nginx core that 101 does
+             * not have a default status line
+             */
+
+            ngx_str_set(&r->headers_out.status_line, "101 Switching Protocols");
+
+        } else {
+            r->headers_out.status_line.len = 0;
+        }
+
+        return 0;
+    }
+
+    if (len == sizeof("ctx") - 1
+        && ngx_strncmp(p, "ctx", sizeof("ctx") - 1) == 0)
+    {
+        r = ngx_http_lua_get_req(L);
+        if (r == NULL) {
+            return luaL_error(L, "no request object found");
+        }
+
+        return ngx_http_lua_ngx_set_ctx(L);
+    }
+
+    lua_rawset(L, -3);
+    return 0;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_misc.h b/src/lua/lua-nginx-module/src/ngx_http_lua_misc.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_misc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_misc.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_MISC_H_INCLUDED_
+#define _NGX_HTTP_LUA_MISC_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_misc_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_MISC_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_module.c b/src/lua/lua-nginx-module/src/ngx_http_lua_module.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_module.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_module.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,780 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_directive.h"
+#include "ngx_http_lua_capturefilter.h"
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_rewriteby.h"
+#include "ngx_http_lua_accessby.h"
+#include "ngx_http_lua_logby.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_headerfilterby.h"
+#include "ngx_http_lua_bodyfilterby.h"
+#include "ngx_http_lua_initby.h"
+#include "ngx_http_lua_probe.h"
+
+
+#if !defined(nginx_version) || nginx_version < 8054
+#error "at least nginx 0.8.54 is required"
+#endif
+
+
+static void *ngx_http_lua_create_main_conf(ngx_conf_t *cf);
+static char *ngx_http_lua_init_main_conf(ngx_conf_t *cf, void *conf);
+static void *ngx_http_lua_create_loc_conf(ngx_conf_t *cf);
+static char *ngx_http_lua_merge_loc_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+static char *ngx_http_lua_init_vm(ngx_conf_t *cf,
+    ngx_http_lua_main_conf_t *lmcf);
+static void ngx_http_lua_cleanup_vm(void *data);
+static ngx_int_t ngx_http_lua_init(ngx_conf_t *cf);
+static char *ngx_http_lua_lowat_check(ngx_conf_t *cf, void *post, void *data);
+
+
+static ngx_conf_post_t  ngx_http_lua_lowat_post =
+    { ngx_http_lua_lowat_check };
+
+
+static ngx_command_t ngx_http_lua_cmds[] = {
+
+    { ngx_string("lua_max_running_timers"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      offsetof(ngx_http_lua_main_conf_t, max_running_timers),
+      NULL },
+
+    { ngx_string("lua_max_pending_timers"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      offsetof(ngx_http_lua_main_conf_t, max_pending_timers),
+      NULL },
+
+    { ngx_string("lua_shared_dict"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE2,
+      ngx_http_lua_shared_dict,
+      0,
+      0,
+      NULL },
+
+#if (NGX_PCRE)
+    { ngx_string("lua_regex_cache_max_entries"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      offsetof(ngx_http_lua_main_conf_t, regex_cache_max_entries),
+      NULL },
+
+    { ngx_string("lua_regex_match_limit"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      offsetof(ngx_http_lua_main_conf_t, regex_match_limit),
+      NULL },
+#endif
+
+    { ngx_string("lua_package_cpath"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_http_lua_package_cpath,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("lua_package_path"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_http_lua_package_path,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("lua_code_cache"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_FLAG,
+      ngx_http_lua_code_cache,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, enable_code_cache),
+      NULL },
+
+    { ngx_string("lua_need_request_body"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, force_read_body),
+      NULL },
+
+    { ngx_string("lua_transform_underscores_in_response_headers"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, transform_underscores_in_resp_headers),
+      NULL },
+
+     { ngx_string("lua_socket_log_errors"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, log_socket_errors),
+      NULL },
+
+    { ngx_string("init_by_lua"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_http_lua_init_by_lua,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_init_by_inline },
+
+    { ngx_string("init_by_lua_file"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_http_lua_init_by_lua,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_init_by_file },
+
+#if defined(NDK) && NDK
+    /* set_by_lua $res <inline script> [$arg1 [$arg2 [...]]] */
+    { ngx_string("set_by_lua"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_SIF_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                       |NGX_CONF_2MORE,
+      ngx_http_lua_set_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_filter_set_by_lua_inline },
+
+    /* set_by_lua_file $res rel/or/abs/path/to/script [$arg1 [$arg2 [..]]] */
+    { ngx_string("set_by_lua_file"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_SIF_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                       |NGX_CONF_2MORE,
+      ngx_http_lua_set_by_lua_file,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_filter_set_by_lua_file },
+#endif
+
+    /* rewrite_by_lua <inline script> */
+    { ngx_string("rewrite_by_lua"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_rewrite_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_rewrite_handler_inline },
+
+    /* access_by_lua <inline script> */
+    { ngx_string("access_by_lua"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_access_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_access_handler_inline },
+
+    /* content_by_lua <inline script> */
+    { ngx_string("content_by_lua"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_http_lua_content_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_content_handler_inline },
+
+    /* log_by_lua <inline script> */
+    { ngx_string("log_by_lua"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_log_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_log_handler_inline },
+
+    { ngx_string("rewrite_by_lua_file"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_rewrite_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_rewrite_handler_file },
+
+    { ngx_string("rewrite_by_lua_no_postpone"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      offsetof(ngx_http_lua_main_conf_t, postponed_to_rewrite_phase_end),
+      NULL },
+
+    { ngx_string("access_by_lua_file"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_access_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_access_handler_file },
+
+    /* content_by_lua_file rel/or/abs/path/to/script */
+    { ngx_string("content_by_lua_file"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_http_lua_content_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_content_handler_file },
+
+    { ngx_string("log_by_lua_file"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_log_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_log_handler_file },
+
+    /* header_filter_by_lua <inline script> */
+    { ngx_string("header_filter_by_lua"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_header_filter_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_header_filter_inline },
+
+    { ngx_string("header_filter_by_lua_file"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_header_filter_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_header_filter_file },
+
+    { ngx_string("body_filter_by_lua"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_body_filter_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_body_filter_inline },
+
+    { ngx_string("body_filter_by_lua_file"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_lua_body_filter_by_lua,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      (void *) ngx_http_lua_body_filter_file },
+
+    { ngx_string("lua_socket_keepalive_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+          |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, keepalive_timeout),
+      NULL },
+
+    { ngx_string("lua_socket_connect_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+          |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, connect_timeout),
+      NULL },
+
+    { ngx_string("lua_socket_send_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+          |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, send_timeout),
+      NULL },
+
+    { ngx_string("lua_socket_send_lowat"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+          |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, send_lowat),
+      &ngx_http_lua_lowat_post },
+
+    { ngx_string("lua_socket_buffer_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+          |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, buffer_size),
+      NULL },
+
+    { ngx_string("lua_socket_pool_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+                        |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, pool_size),
+      NULL },
+
+    { ngx_string("lua_socket_read_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF
+          |NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, read_timeout),
+      NULL },
+
+    { ngx_string("lua_http10_buffering"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, http10_buffering),
+      NULL },
+
+    { ngx_string("lua_check_client_abort"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_lua_loc_conf_t, check_client_abort),
+      NULL },
+
+    ngx_null_command
+};
+
+
+ngx_http_module_t ngx_http_lua_module_ctx = {
+    NULL,                             /*  preconfiguration */
+    ngx_http_lua_init,                /*  postconfiguration */
+
+    ngx_http_lua_create_main_conf,    /*  create main configuration */
+    ngx_http_lua_init_main_conf,      /*  init main configuration */
+
+    NULL,                             /*  create server configuration */
+    NULL,                             /*  merge server configuration */
+
+    ngx_http_lua_create_loc_conf,     /*  create location configuration */
+    ngx_http_lua_merge_loc_conf       /*  merge location configuration */
+};
+
+
+ngx_module_t ngx_http_lua_module = {
+    NGX_MODULE_V1,
+    &ngx_http_lua_module_ctx,   /*  module context */
+    ngx_http_lua_cmds,          /*  module directives */
+    NGX_HTTP_MODULE,            /*  module type */
+    NULL,                       /*  init master */
+    NULL,                       /*  init module */
+    NULL,                       /*  init process */
+    NULL,                       /*  init thread */
+    NULL,                       /*  exit thread */
+    NULL,                       /*  exit process */
+    NULL,                       /*  exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_int_t
+ngx_http_lua_init(ngx_conf_t *cf)
+{
+    ngx_int_t                   rc;
+    ngx_array_t                *arr;
+    ngx_http_handler_pt        *h;
+    ngx_http_core_main_conf_t  *cmcf;
+    ngx_http_lua_main_conf_t   *lmcf;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    if (lmcf->requires_capture_filter) {
+        rc = ngx_http_lua_capture_filter_init(cf);
+        if (rc != NGX_OK) {
+            return rc;
+        }
+    }
+
+    if (lmcf->postponed_to_rewrite_phase_end == NGX_CONF_UNSET) {
+        lmcf->postponed_to_rewrite_phase_end = 0;
+    }
+
+    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);
+
+    if (lmcf->requires_rewrite) {
+        h = ngx_array_push(&cmcf->phases[NGX_HTTP_REWRITE_PHASE].handlers);
+        if (h == NULL) {
+            return NGX_ERROR;
+        }
+
+        *h = ngx_http_lua_rewrite_handler;
+    }
+
+    if (lmcf->requires_access) {
+        h = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);
+        if (h == NULL) {
+            return NGX_ERROR;
+        }
+
+        *h = ngx_http_lua_access_handler;
+    }
+
+    dd("requires log: %d", (int) lmcf->requires_log);
+
+    if (lmcf->requires_log) {
+        arr = &cmcf->phases[NGX_HTTP_LOG_PHASE].handlers;
+        h = ngx_array_push(arr);
+        if (h == NULL) {
+            return NGX_ERROR;
+        }
+
+        if (arr->nelts > 1) {
+            h = arr->elts;
+            ngx_memmove(&h[1], h,
+                        (arr->nelts - 1) * sizeof(ngx_http_handler_pt));
+        }
+
+        *h = ngx_http_lua_log_handler;
+    }
+
+    if (lmcf->requires_header_filter) {
+        rc = ngx_http_lua_header_filter_init();
+        if (rc != NGX_OK) {
+            return rc;
+        }
+    }
+
+    if (lmcf->requires_body_filter) {
+        rc = ngx_http_lua_body_filter_init();
+        if (rc != NGX_OK) {
+            return rc;
+        }
+    }
+
+    if (lmcf->lua == NULL) {
+        dd("initializing lua vm");
+
+        if (ngx_http_lua_init_vm(cf, lmcf) != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
+                               "failed to initialize Lua VM");
+            return NGX_ERROR;
+        }
+
+        if (!lmcf->requires_shm && lmcf->init_handler) {
+            if (lmcf->init_handler(cf->log, lmcf, lmcf->lua) != 0) {
+                /* an error happened */
+                return NGX_ERROR;
+            }
+        }
+
+        dd("Lua VM initialized!");
+    }
+
+    return NGX_OK;
+}
+
+
+static char *
+ngx_http_lua_lowat_check(ngx_conf_t *cf, void *post, void *data)
+{
+#if (NGX_FREEBSD)
+    ssize_t *np = data;
+
+    if ((u_long) *np >= ngx_freebsd_net_inet_tcp_sendspace) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "\"fastcgi_send_lowat\" must be less than %d "
+                           "(sysctl net.inet.tcp.sendspace)",
+                           ngx_freebsd_net_inet_tcp_sendspace);
+
+        return NGX_CONF_ERROR;
+    }
+
+#elif !(NGX_HAVE_SO_SNDLOWAT)
+    ssize_t *np = data;
+
+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                       "\"fastcgi_send_lowat\" is not supported, ignored");
+
+    *np = 0;
+
+#endif
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_http_lua_create_main_conf(ngx_conf_t *cf)
+{
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    lmcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_lua_main_conf_t));
+    if (lmcf == NULL) {
+        return NULL;
+    }
+
+    /* set by ngx_pcalloc:
+     *      lmcf->lua = NULL;
+     *      lmcf->lua_path = { 0, NULL };
+     *      lmcf->lua_cpath = { 0, NULL };
+     *      lmcf->pending_timers = 0;
+     *      lmcf->running_timers = 0;
+     *      lmcf->watcher = NULL;
+     *      lmcf->regex_cache_entries = 0;
+     *      lmcf->shm_zones = NULL;
+     *      lmcf->init_handler = NULL;
+     *      lmcf->init_src = { 0, NULL };
+     *      lmcf->shm_zones_inited = 0;
+     *      lmcf->preload_hooks = NULL;
+     *      lmcf->requires_header_filter = 0;
+     *      lmcf->requires_body_filter = 0;
+     *      lmcf->requires_capture_filter = 0;
+     *      lmcf->requires_rewrite = 0;
+     *      lmcf->requires_access = 0;
+     *      lmcf->requires_log = 0;
+     *      lmcf->requires_shm = 0;
+     */
+
+    lmcf->pool = cf->pool;
+    lmcf->max_pending_timers = NGX_CONF_UNSET;
+    lmcf->max_running_timers = NGX_CONF_UNSET;
+#if (NGX_PCRE)
+    lmcf->regex_cache_max_entries = NGX_CONF_UNSET;
+    lmcf->regex_match_limit = NGX_CONF_UNSET;
+#endif
+    lmcf->postponed_to_rewrite_phase_end = NGX_CONF_UNSET;
+
+    dd("nginx Lua module main config structure initialized!");
+
+    return lmcf;
+}
+
+
+static char *
+ngx_http_lua_init_main_conf(ngx_conf_t *cf, void *conf)
+{
+    ngx_http_lua_main_conf_t *lmcf = conf;
+
+#if (NGX_PCRE)
+    if (lmcf->regex_cache_max_entries == NGX_CONF_UNSET) {
+        lmcf->regex_cache_max_entries = 1024;
+    }
+
+    if (lmcf->regex_match_limit == NGX_CONF_UNSET) {
+        lmcf->regex_match_limit = 0;
+    }
+#endif
+
+    if (lmcf->max_pending_timers == NGX_CONF_UNSET) {
+        lmcf->max_pending_timers = 1024;
+    }
+
+    if (lmcf->max_running_timers == NGX_CONF_UNSET) {
+        lmcf->max_running_timers = 256;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_http_lua_create_loc_conf(ngx_conf_t *cf)
+{
+    ngx_http_lua_loc_conf_t *conf;
+
+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_lua_loc_conf_t));
+    if (conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    /* set by ngx_pcalloc:
+     *      conf->access_src  = {{ 0, NULL }, NULL, NULL, NULL};
+     *      conf->access_src_key = NULL
+     *      conf->rewrite_src = {{ 0, NULL }, NULL, NULL, NULL};
+     *      conf->rewrite_src_key = NULL
+     *      conf->rewrite_handler = NULL;
+     *
+     *      conf->content_src = {{ 0, NULL }, NULL, NULL, NULL};
+     *      conf->content_src_key = NULL
+     *      conf->content_handler = NULL;
+     *
+     *      conf->log_src = {{ 0, NULL }, NULL, NULL, NULL};
+     *      conf->log_src_key = NULL
+     *      conf->log_handler = NULL;
+     *
+     *      conf->header_filter_src = {{ 0, NULL }, NULL, NULL, NULL};
+     *      conf->header_filter_src_key = NULL
+     *      conf->header_filter_handler = NULL;
+     *
+     *      conf->body_filter_src = {{ 0, NULL }, NULL, NULL, NULL};
+     *      conf->body_filter_src_key = NULL
+     *      conf->body_filter_handler = NULL;
+     */
+
+    conf->force_read_body    = NGX_CONF_UNSET;
+    conf->enable_code_cache  = NGX_CONF_UNSET;
+    conf->http10_buffering   = NGX_CONF_UNSET;
+    conf->check_client_abort = NGX_CONF_UNSET;
+
+    conf->keepalive_timeout = NGX_CONF_UNSET_MSEC;
+    conf->connect_timeout = NGX_CONF_UNSET_MSEC;
+    conf->send_timeout = NGX_CONF_UNSET_MSEC;
+    conf->read_timeout = NGX_CONF_UNSET_MSEC;
+    conf->send_lowat = NGX_CONF_UNSET_SIZE;
+    conf->buffer_size = NGX_CONF_UNSET_SIZE;
+    conf->pool_size = NGX_CONF_UNSET_UINT;
+
+    conf->transform_underscores_in_resp_headers = NGX_CONF_UNSET;
+    conf->log_socket_errors = NGX_CONF_UNSET;
+
+
+    return conf;
+}
+
+
+static char *
+ngx_http_lua_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_http_lua_loc_conf_t *prev = parent;
+    ngx_http_lua_loc_conf_t *conf = child;
+
+    if (conf->rewrite_src.value.len == 0) {
+        conf->rewrite_src = prev->rewrite_src;
+        conf->rewrite_handler = prev->rewrite_handler;
+        conf->rewrite_src_key = prev->rewrite_src_key;
+    }
+
+    if (conf->access_src.value.len == 0) {
+        conf->access_src = prev->access_src;
+        conf->access_handler = prev->access_handler;
+        conf->access_src_key = prev->access_src_key;
+    }
+
+    if (conf->content_src.value.len == 0) {
+        conf->content_src = prev->content_src;
+        conf->content_handler = prev->content_handler;
+        conf->content_src_key = prev->content_src_key;
+    }
+
+    if (conf->log_src.value.len == 0) {
+        conf->log_src = prev->log_src;
+        conf->log_handler = prev->log_handler;
+        conf->log_src_key = prev->log_src_key;
+    }
+
+    if (conf->header_filter_src.value.len == 0) {
+        conf->header_filter_src = prev->header_filter_src;
+        conf->header_filter_handler = prev->header_filter_handler;
+        conf->header_filter_src_key = prev->header_filter_src_key;
+    }
+
+    if (conf->body_filter_src.value.len == 0) {
+        conf->body_filter_src = prev->body_filter_src;
+        conf->body_filter_handler = prev->body_filter_handler;
+        conf->body_filter_src_key = prev->body_filter_src_key;
+    }
+
+    ngx_conf_merge_value(conf->force_read_body, prev->force_read_body, 0);
+    ngx_conf_merge_value(conf->enable_code_cache, prev->enable_code_cache, 1);
+    ngx_conf_merge_value(conf->http10_buffering, prev->http10_buffering, 1);
+    ngx_conf_merge_value(conf->check_client_abort, prev->check_client_abort, 0);
+
+    ngx_conf_merge_msec_value(conf->keepalive_timeout,
+                              prev->keepalive_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->connect_timeout,
+                              prev->connect_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->send_timeout,
+                              prev->send_timeout, 60000);
+
+    ngx_conf_merge_msec_value(conf->read_timeout,
+                              prev->read_timeout, 60000);
+
+    ngx_conf_merge_size_value(conf->send_lowat,
+                              prev->send_lowat, 0);
+
+    ngx_conf_merge_size_value(conf->buffer_size,
+                              prev->buffer_size,
+                              (size_t) ngx_pagesize);
+
+    ngx_conf_merge_uint_value(conf->pool_size, prev->pool_size, 30);
+
+    ngx_conf_merge_value(conf->transform_underscores_in_resp_headers,
+                         prev->transform_underscores_in_resp_headers, 1);
+
+    ngx_conf_merge_value(conf->log_socket_errors, prev->log_socket_errors, 1);
+
+    return NGX_CONF_OK;
+}
+
+
+static void
+ngx_http_lua_cleanup_vm(void *data)
+{
+    lua_State *L = data;
+
+    if (L != NULL) {
+        lua_close(L);
+
+        dd("Lua VM closed!");
+    }
+}
+
+
+static char *
+ngx_http_lua_init_vm(ngx_conf_t *cf, ngx_http_lua_main_conf_t *lmcf)
+{
+    ngx_pool_cleanup_t              *cln;
+    ngx_http_lua_preload_hook_t     *hook;
+    lua_State                       *L;
+    ngx_uint_t                       i;
+
+    ngx_http_lua_content_length_hash =
+        ngx_http_lua_hash_literal("content-length");
+
+    ngx_http_lua_location_hash = ngx_http_lua_hash_literal("location");
+
+    /* add new cleanup handler to config mem pool */
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    /* create new Lua VM instance */
+    lmcf->lua = ngx_http_lua_new_state(cf, lmcf);
+    if (lmcf->lua == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    /* register cleanup handler for Lua VM */
+    cln->handler = ngx_http_lua_cleanup_vm;
+    cln->data = lmcf->lua;
+
+    if (lmcf->preload_hooks) {
+
+        /* register the 3rd-party module's preload hooks */
+
+        L = lmcf->lua;
+
+        lua_getglobal(L, "package");
+        lua_getfield(L, -1, "preload");
+
+        hook = lmcf->preload_hooks->elts;
+
+        for (i = 0; i < lmcf->preload_hooks->nelts; i++) {
+
+            ngx_http_lua_probe_register_preload_package(L, hook[i].package);
+
+            lua_pushcfunction(L, hook[i].loader);
+            lua_setfield(L, -2, (char *) hook[i].package);
+        }
+
+        lua_pop(L, 2);
+    }
+
+    return NGX_CONF_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.c b/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,184 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_ndk.h"
+#include "ngx_http_lua_util.h"
+
+
+#if defined(NDK) && NDK
+
+
+static ndk_set_var_value_pt ngx_http_lookup_ndk_set_var_directive(u_char *name,
+    size_t name_len);
+static int ngx_http_lua_ndk_set_var_get(lua_State *L);
+static int ngx_http_lua_ndk_set_var_set(lua_State *L);
+static int ngx_http_lua_run_set_var_directive(lua_State *L);
+
+
+int
+ngx_http_lua_ndk_set_var_get(lua_State *L)
+{
+    ndk_set_var_value_pt                 func;
+    size_t                               len;
+    u_char                              *p;
+
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    dd("ndk.set_var metatable __index: %s", p);
+
+    func = ngx_http_lookup_ndk_set_var_directive(p, len);
+
+    if (func == NULL) {
+        return luaL_error(L, "ndk.set_var: directive \"%s\" not found "
+                          "or does not use ndk_set_var_value", p);
+    }
+
+    lua_pushvalue(L, -1); /* table key key */
+    lua_pushvalue(L, -1); /* table key key key */
+    lua_pushlightuserdata(L, (void *) func); /* table key key key func */
+    lua_pushcclosure(L, ngx_http_lua_run_set_var_directive, 2);
+        /* table key key closure */
+    lua_rawset(L, 1); /* table key */
+    lua_rawget(L, 1); /* table closure */
+
+    return 1;
+}
+
+
+int
+ngx_http_lua_ndk_set_var_set(lua_State *L)
+{
+    return luaL_error(L, "Not allowed");
+}
+
+
+int
+ngx_http_lua_run_set_var_directive(lua_State *L)
+{
+    ngx_int_t                            rc;
+    ndk_set_var_value_pt                 func;
+    ngx_str_t                            res;
+    ngx_http_variable_value_t            arg;
+    u_char                              *p;
+    size_t                               len;
+    ngx_http_request_t                  *r;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+#if 1
+    ngx_memzero(&arg, sizeof(ngx_http_variable_value_t));
+
+    arg.valid = 1;
+#endif
+
+    arg.data = (u_char *) luaL_checklstring(L, 1, &len);
+    arg.len = len;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    p = (u_char *) luaL_checklstring(L, lua_upvalueindex(1), &len);
+
+    dd("calling set_var func for %s", p);
+
+    func = (ndk_set_var_value_pt) lua_touserdata(L, lua_upvalueindex(2));
+
+    rc = func(r, &res, &arg);
+
+    if (rc != NGX_OK) {
+        return luaL_error(L, "calling directive %s failed with code %d",
+                          p, (int) rc);
+    }
+
+    lua_pushlstring(L, (char *) res.data, res.len);
+
+    return 1;
+}
+
+
+static ndk_set_var_value_pt
+ngx_http_lookup_ndk_set_var_directive(u_char *name,
+    size_t name_len)
+{
+    ndk_set_var_t           *filter;
+    ngx_uint_t               i;
+    ngx_module_t            *module;
+    ngx_command_t           *cmd;
+
+    for (i = 0; ngx_modules[i]; i++) {
+        module = ngx_modules[i];
+        if (module->type != NGX_HTTP_MODULE) {
+            continue;
+        }
+
+        cmd = ngx_modules[i]->commands;
+        if (cmd == NULL) {
+            continue;
+        }
+
+        for ( /* void */ ; cmd->name.len; cmd++) {
+            if (cmd->set != ndk_set_var_value) {
+                continue;
+            }
+
+            filter = cmd->post;
+            if (filter == NULL) {
+                continue;
+            }
+
+            if (cmd->name.len != name_len
+                || ngx_strncmp(cmd->name.data, name, name_len) != 0)
+            {
+                continue;
+            }
+
+            return (ndk_set_var_value_pt)(filter->func);
+        }
+    }
+
+    return NULL;
+}
+
+
+void
+ngx_http_lua_inject_ndk_api(lua_State *L)
+{
+    lua_createtable(L, 0, 1 /* nrec */);    /* ndk.* */
+
+    lua_newtable(L);    /* .set_var */
+
+    lua_createtable(L, 0, 2 /* nrec */); /* metatable for .set_var */
+    lua_pushcfunction(L, ngx_http_lua_ndk_set_var_get);
+    lua_setfield(L, -2, "__index");
+    lua_pushcfunction(L, ngx_http_lua_ndk_set_var_set);
+    lua_setfield(L, -2, "__newindex");
+    lua_setmetatable(L, -2);
+
+    lua_setfield(L, -2, "set_var");
+
+    lua_getglobal(L, "package"); /* ndk package */
+    lua_getfield(L, -1, "loaded"); /* ndk package loaded */
+    lua_pushvalue(L, -3); /* ndk package loaded ndk */
+    lua_setfield(L, -2, "ndk"); /* ndk package loaded */
+    lua_pop(L, 2);
+
+    lua_setglobal(L, "ndk");
+}
+
+
+#endif /* defined(NDK) && NDK */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.h b/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_ndk.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,21 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_NDK_H_INCLUDED_
+#define _NGX_HTTP_LUA_NDK_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+#if defined(NDK) && NDK
+void ngx_http_lua_inject_ndk_api(lua_State *L);
+#endif
+
+
+#endif /* _NGX_HTTP_LUA_NDK_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_output.c b/src/lua/lua-nginx-module/src/ngx_http_lua_output.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_output.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_output.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,815 @@
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+#include "ngx_http_lua_output.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_contentby.h"
+#include <math.h>
+
+
+static int ngx_http_lua_ngx_say(lua_State *L);
+static int ngx_http_lua_ngx_print(lua_State *L);
+static int ngx_http_lua_ngx_flush(lua_State *L);
+static int ngx_http_lua_ngx_eof(lua_State *L);
+static int ngx_http_lua_ngx_send_headers(lua_State *L);
+static int ngx_http_lua_ngx_echo(lua_State *L, unsigned newline);
+static void ngx_http_lua_flush_cleanup(void *data);
+
+
+static int
+ngx_http_lua_ngx_print(lua_State *L)
+{
+    dd("calling lua print");
+    return ngx_http_lua_ngx_echo(L, 0);
+}
+
+
+static int
+ngx_http_lua_ngx_say(lua_State *L)
+{
+    dd("calling");
+    return ngx_http_lua_ngx_echo(L, 1);
+}
+
+
+static int
+ngx_http_lua_ngx_echo(lua_State *L, unsigned newline)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    const char                  *p;
+    size_t                       len;
+    size_t                       size;
+    ngx_buf_t                   *b;
+    ngx_chain_t                 *cl;
+    ngx_int_t                    rc;
+    int                          i;
+    int                          nargs;
+    int                          type;
+    const char                  *msg;
+    ngx_buf_tag_t                tag;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    if (ctx->acquired_raw_req_socket) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "raw request socket acquired");
+        return 2;
+    }
+
+    if (r->header_only) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "header only");
+        return 2;
+    }
+
+    if (ctx->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "seen eof");
+        return 2;
+    }
+
+    nargs = lua_gettop(L);
+    size = 0;
+
+    for (i = 1; i <= nargs; i++) {
+
+        type = lua_type(L, i);
+
+        switch (type) {
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+
+                lua_tolstring(L, i, &len);
+                size += len;
+                break;
+
+            case LUA_TNIL:
+
+                size += sizeof("nil") - 1;
+                break;
+
+            case LUA_TBOOLEAN:
+
+                if (lua_toboolean(L, i)) {
+                    size += sizeof("true") - 1;
+
+                } else {
+                    size += sizeof("false") - 1;
+                }
+
+                break;
+
+            case LUA_TTABLE:
+
+                size += ngx_http_lua_calc_strlen_in_table(L, i, i,
+                                                          0 /* strict */);
+                break;
+
+            case LUA_TLIGHTUSERDATA:
+
+                dd("userdata: %p", lua_touserdata(L, i));
+
+                if (lua_touserdata(L, i) == NULL) {
+                    size += sizeof("null") - 1;
+                    break;
+                }
+
+                continue;
+
+            default:
+
+                msg = lua_pushfstring(L, "string, number, boolean, nil, "
+                                      "ngx.null, or array table expected, "
+                                      "but got %s", lua_typename(L, type));
+
+                return luaL_argerror(L, i, msg);
+        }
+    }
+
+    if (newline) {
+        size += sizeof("\n") - 1;
+    }
+
+    if (size == 0) {
+        /* do nothing for empty strings */
+        lua_pushinteger(L, 1);
+        return 1;
+    }
+
+    tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+    cl = ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                          &ctx->free_bufs, size, tag);
+
+    if (cl == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    b = cl->buf;
+
+    for (i = 1; i <= nargs; i++) {
+        type = lua_type(L, i);
+        switch (type) {
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+                p = lua_tolstring(L, i, &len);
+                b->last = ngx_copy(b->last, (u_char *) p, len);
+                break;
+
+            case LUA_TNIL:
+                *b->last++ = 'n';
+                *b->last++ = 'i';
+                *b->last++ = 'l';
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, i)) {
+                    *b->last++ = 't';
+                    *b->last++ = 'r';
+                    *b->last++ = 'u';
+                    *b->last++ = 'e';
+
+                } else {
+                    *b->last++ = 'f';
+                    *b->last++ = 'a';
+                    *b->last++ = 'l';
+                    *b->last++ = 's';
+                    *b->last++ = 'e';
+                }
+
+                break;
+
+            case LUA_TTABLE:
+                b->last = ngx_http_lua_copy_str_in_table(L, i, b->last);
+                break;
+
+            case LUA_TLIGHTUSERDATA:
+                *b->last++ = 'n';
+                *b->last++ = 'u';
+                *b->last++ = 'l';
+                *b->last++ = 'l';
+                break;
+
+            default:
+                return luaL_error(L, "impossible to reach here");
+        }
+    }
+
+    if (newline) {
+        *b->last++ = '\n';
+    }
+
+#if 0
+    if (b->last != b->end) {
+        return luaL_error(L, "buffer error: %p != %p", b->last, b->end);
+    }
+#endif
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   newline ? "lua say response" : "lua print response");
+
+    rc = ngx_http_lua_send_chain_link(r, ctx, cl);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "nginx output filter error");
+        return 2;
+    }
+
+    dd("downstream write: %d, buf len: %d", (int) rc,
+       (int) (b->last - b->pos));
+
+    if (!ctx->out) {
+#if nginx_version >= 1001004
+        ngx_chain_update_chains(r->pool,
+#else
+        ngx_chain_update_chains(
+#endif
+                                &ctx->free_bufs, &ctx->busy_bufs, &cl, tag);
+
+        dd("out lua buf tag: %p, buffered: %x, busy bufs: %p",
+           &ngx_http_lua_module, (int) r->connection->buffered,
+           ctx->busy_bufs);
+    }
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+size_t
+ngx_http_lua_calc_strlen_in_table(lua_State *L, int index, int arg_i,
+    unsigned strict)
+{
+    double              key;
+    int                 max;
+    int                 i;
+    int                 type;
+    size_t              size;
+    size_t              len;
+    const char         *msg;
+
+    if (index < 0) {
+        index = lua_gettop(L) + index + 1;
+    }
+
+    dd("table index: %d", index);
+
+    max = 0;
+
+    lua_pushnil(L); /* stack: table key */
+    while (lua_next(L, index) != 0) { /* stack: table key value */
+        dd("key type: %s", luaL_typename(L, -2));
+
+        if (lua_type(L, -2) == LUA_TNUMBER) {
+
+            key = lua_tonumber(L, -2);
+
+            dd("key value: %d", (int) key);
+
+            if (floor(key) == key && key >= 1) {
+                if (key > max) {
+                    max = (int) key;
+                }
+
+                lua_pop(L, 1); /* stack: table key */
+                continue;
+            }
+        }
+
+        /* not an array (non positive integer key) */
+        lua_pop(L, 2); /* stack: table */
+
+        msg = lua_pushfstring(L, "non-array table found");
+        luaL_argerror(L, arg_i, msg);
+        return 0;
+    }
+
+    size = 0;
+
+    for (i = 1; i <= max; i++) {
+        lua_rawgeti(L, index, i); /* stack: table value */
+        type = lua_type(L, -1);
+
+        switch (type) {
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+
+                lua_tolstring(L, -1, &len);
+                size += len;
+                break;
+
+            case LUA_TNIL:
+
+                if (strict) {
+                    goto bad_type;
+                }
+
+                size += sizeof("nil") - 1;
+                break;
+
+            case LUA_TBOOLEAN:
+
+                if (strict) {
+                    goto bad_type;
+                }
+
+                if (lua_toboolean(L, -1)) {
+                    size += sizeof("true") - 1;
+
+                } else {
+                    size += sizeof("false") - 1;
+                }
+
+                break;
+
+            case LUA_TTABLE:
+
+                size += ngx_http_lua_calc_strlen_in_table(L, -1, arg_i, strict);
+                break;
+
+            case LUA_TLIGHTUSERDATA:
+
+                if (strict) {
+                    goto bad_type;
+                }
+
+                if (lua_touserdata(L, -1) == NULL) {
+                    size += sizeof("null") - 1;
+                    break;
+                }
+
+                continue;
+
+            default:
+
+bad_type:
+                msg = lua_pushfstring(L, "bad data type %s found",
+                        lua_typename(L, type));
+                return luaL_argerror(L, arg_i, msg);
+        }
+
+        lua_pop(L, 1); /* stack: table */
+    }
+
+    return size;
+}
+
+
+u_char *
+ngx_http_lua_copy_str_in_table(lua_State *L, int index, u_char *dst)
+{
+    double               key;
+    int                  max;
+    int                  i;
+    int                  type;
+    size_t               len;
+    u_char              *p;
+
+    if (index < 0) {
+        index = lua_gettop(L) + index + 1;
+    }
+
+    max = 0;
+
+    lua_pushnil(L); /* stack: table key */
+    while (lua_next(L, index) != 0) { /* stack: table key value */
+        key = lua_tonumber(L, -2);
+        if (key > max) {
+            max = (int) key;
+        }
+
+        lua_pop(L, 1); /* stack: table key */
+    }
+
+    for (i = 1; i <= max; i++) {
+        lua_rawgeti(L, index, i); /* stack: table value */
+        type = lua_type(L, -1);
+        switch (type) {
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+                p = (u_char *) lua_tolstring(L, -1, &len);
+                dst = ngx_copy(dst, p, len);
+                break;
+
+            case LUA_TNIL:
+                *dst++ = 'n';
+                *dst++ = 'i';
+                *dst++ = 'l';
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, -1)) {
+                    *dst++ = 't';
+                    *dst++ = 'r';
+                    *dst++ = 'u';
+                    *dst++ = 'e';
+
+                } else {
+                    *dst++ = 'f';
+                    *dst++ = 'a';
+                    *dst++ = 'l';
+                    *dst++ = 's';
+                    *dst++ = 'e';
+                }
+
+                break;
+
+            case LUA_TTABLE:
+                dst = ngx_http_lua_copy_str_in_table(L, -1, dst);
+                break;
+
+            case LUA_TLIGHTUSERDATA:
+
+                *dst++ = 'n';
+                *dst++ = 'u';
+                *dst++ = 'l';
+                *dst++ = 'l';
+                break;
+
+            default:
+                luaL_error(L, "impossible to reach here");
+                return NULL;
+        }
+
+        lua_pop(L, 1); /* stack: table */
+    }
+
+    return dst;
+}
+
+
+/**
+ * Force flush out response content
+ * */
+static int
+ngx_http_lua_ngx_flush(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_buf_t                   *buf;
+    ngx_chain_t                 *cl;
+    ngx_int_t                    rc;
+    int                          n;
+    unsigned                     wait = 0;
+    ngx_event_t                 *wev;
+    ngx_http_core_loc_conf_t    *clcf;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    n = lua_gettop(L);
+    if (n > 1) {
+        return luaL_error(L, "attempt to pass %d arguments, but accepted 0 "
+                "or 1", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+
+    if (n == 1 && r == r->main) {
+        luaL_checktype(L, 1, LUA_TBOOLEAN);
+        wait = lua_toboolean(L, 1);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    if (ctx->acquired_raw_req_socket) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "raw request socket acquired");
+        return 2;
+    }
+
+    coctx = ctx->cur_co_ctx;
+    if (coctx == NULL) {
+        return luaL_error(L, "no co ctx found");
+    }
+
+    if (r->header_only) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "header only");
+        return 2;
+    }
+
+    if (ctx->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "seen eof");
+        return 2;
+    }
+
+    if (ctx->buffering) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua http 1.0 buffering makes ngx.flush() a no-op");
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "buffering");
+        return 2;
+    }
+
+#if 1
+    if (!r->header_sent) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "nothing to flush");
+        return 2;
+    }
+#endif
+
+    if (ctx->flush_buf) {
+        cl = ctx->flush_buf;
+
+    } else {
+        dd("allocating new flush buf");
+        buf = ngx_calloc_buf(r->pool);
+        if (buf == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        buf->flush = 1;
+
+        dd("allocating new flush chain");
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        cl->next = NULL;
+        cl->buf = buf;
+
+        ctx->flush_buf = cl;
+    }
+
+    rc = ngx_http_lua_send_chain_link(r, ctx, cl);
+
+    dd("send chain: %d", (int) rc);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "nginx output filter error");
+        return 2;
+    }
+
+    dd("wait:%d, rc:%d, buffered:%d", wait, (int) rc, r->connection->buffered);
+
+    if (wait && r->connection->buffered) {
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                "lua flush requires waiting: buffered 0x%uxd",
+                (int) r->connection->buffered);
+
+        coctx->flushing = 1;
+        ctx->flushing_coros++;
+
+        if (ctx->entered_content_phase) {
+            /* mimic ngx_http_set_write_handler */
+            r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+        } else {
+            r->write_event_handler = ngx_http_core_run_phases;
+        }
+
+        wev = r->connection->write;
+
+        if (wev->ready && wev->delayed) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "delayed");
+            return 2;
+        }
+
+        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+        if (!wev->delayed) {
+            ngx_add_timer(wev, clcf->send_timeout);
+        }
+
+        if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {
+            if (wev->timer_set) {
+                ngx_del_timer(wev);
+            }
+
+            lua_pushnil(L);
+            lua_pushliteral(L, "connection broken");
+            return 2;
+        }
+
+        coctx->cleanup = ngx_http_lua_flush_cleanup;
+        coctx->data = r;
+
+        return lua_yield(L, 0);
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua flush asynchronously");
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+/**
+ * Send last_buf, terminate output stream
+ * */
+static int
+ngx_http_lua_ngx_eof(lua_State *L)
+{
+    ngx_http_request_t      *r;
+    ngx_http_lua_ctx_t      *ctx;
+    ngx_int_t                rc;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    if (lua_gettop(L) != 0) {
+        return luaL_error(L, "no argument is expected");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    if (ctx->acquired_raw_req_socket) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "raw request socket acquired");
+        return 2;
+    }
+
+    if (ctx->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "seen eof");
+        return 2;
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua send eof");
+
+    rc = ngx_http_lua_send_chain_link(r, ctx, NULL /* indicate last_buf */);
+
+    dd("send chain: %d", (int) rc);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "nginx output filter error");
+        return 2;
+    }
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+void
+ngx_http_lua_inject_output_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_send_headers);
+    lua_setfield(L, -2, "send_headers");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_print);
+    lua_setfield(L, -2, "print");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_say);
+    lua_setfield(L, -2, "say");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_flush);
+    lua_setfield(L, -2, "flush");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_eof);
+    lua_setfield(L, -2, "eof");
+}
+
+
+/**
+ * Send out headers
+ * */
+static int
+ngx_http_lua_ngx_send_headers(lua_State *L)
+{
+    ngx_int_t                rc;
+    ngx_http_request_t      *r;
+    ngx_http_lua_ctx_t      *ctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    if (!r->header_sent) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua send headers");
+
+        rc = ngx_http_lua_send_header_if_needed(r, ctx);
+        if (rc == NGX_ERROR || rc > NGX_OK) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "nginx output filter error");
+            return 2;
+        }
+    }
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+ngx_int_t
+ngx_http_lua_flush_resume_helper(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    c = r->connection;
+
+    ctx->cur_co_ctx->cleanup = NULL;
+
+    /* push the return value 1 */
+    lua_pushinteger(ctx->cur_co_ctx->co, 1);
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, 1);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    /* rc == NGX_ERROR || rc >= NGX_OK */
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
+static void
+ngx_http_lua_flush_cleanup(void *data)
+{
+    ngx_http_request_t                      *r;
+    ngx_event_t                             *wev;
+    ngx_http_lua_ctx_t                      *ctx;
+    ngx_http_lua_co_ctx_t                   *coctx = data;
+
+    coctx->flushing = 0;
+
+    r = coctx->data;
+    if (r == NULL) {
+        return;
+    }
+
+    wev = r->connection->write;
+
+    if (wev && wev->timer_set) {
+        ngx_del_timer(wev);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return;
+    }
+
+    ctx->flushing_coros--;
+}
+
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_output.h b/src/lua/lua-nginx-module/src/ngx_http_lua_output.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_output.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_output.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,28 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_OUTPUT_H_INCLUDED_
+#define _NGX_HTTP_LUA_OUTPUT_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_output_api(lua_State *L);
+
+size_t ngx_http_lua_calc_strlen_in_table(lua_State *L, int index, int arg_i,
+    unsigned strict);
+
+u_char * ngx_http_lua_copy_str_in_table(lua_State *L, int index, u_char *dst);
+
+ngx_int_t ngx_http_lua_flush_resume_helper(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+
+
+#endif /* _NGX_HTTP_LUA_OUTPUT_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.c b/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,106 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_pcrefix.h"
+#include "stdio.h"
+
+#if (NGX_PCRE)
+
+static ngx_pool_t *ngx_http_lua_pcre_pool = NULL;
+
+static void *(*old_pcre_malloc)(size_t);
+static void (*old_pcre_free)(void *ptr);
+
+
+/* XXX: work-around to nginx regex subsystem, must init a memory pool
+ * to use PCRE functions. As PCRE still has memory-leaking problems,
+ * and nginx overwrote pcre_malloc/free hooks with its own static
+ * functions, so nobody else can reuse nginx regex subsystem... */
+static void *
+ngx_http_lua_pcre_malloc(size_t size)
+{
+    dd("lua pcre pool is %p", ngx_http_lua_pcre_pool);
+
+    if (ngx_http_lua_pcre_pool) {
+        return ngx_palloc(ngx_http_lua_pcre_pool, size);
+    }
+
+    fprintf(stderr, "error: lua pcre malloc failed due to empty pcre pool");
+
+    return NULL;
+}
+
+
+static void
+ngx_http_lua_pcre_free(void *ptr)
+{
+    dd("lua pcre pool is %p", ngx_http_lua_pcre_pool);
+
+    if (ngx_http_lua_pcre_pool) {
+        ngx_pfree(ngx_http_lua_pcre_pool, ptr);
+        return;
+    }
+
+    fprintf(stderr, "error: lua pcre free failed due to empty pcre pool");
+}
+
+
+ngx_pool_t *
+ngx_http_lua_pcre_malloc_init(ngx_pool_t *pool)
+{
+    ngx_pool_t          *old_pool;
+
+    if (pcre_malloc != ngx_http_lua_pcre_malloc) {
+
+        dd("overriding nginx pcre malloc and free");
+
+        ngx_http_lua_pcre_pool = pool;
+
+        old_pcre_malloc = pcre_malloc;
+        old_pcre_free = pcre_free;
+
+        pcre_malloc = ngx_http_lua_pcre_malloc;
+        pcre_free = ngx_http_lua_pcre_free;
+
+        return NULL;
+    }
+
+    dd("lua pcre pool was %p", ngx_http_lua_pcre_pool);
+
+    old_pool = ngx_http_lua_pcre_pool;
+    ngx_http_lua_pcre_pool = pool;
+
+    dd("lua pcre pool is %p", ngx_http_lua_pcre_pool);
+
+    return old_pool;
+}
+
+
+void
+ngx_http_lua_pcre_malloc_done(ngx_pool_t *old_pool)
+{
+    dd("lua pcre pool was %p", ngx_http_lua_pcre_pool);
+
+    ngx_http_lua_pcre_pool = old_pool;
+
+    dd("lua pcre pool is %p", ngx_http_lua_pcre_pool);
+
+    if (old_pool == NULL) {
+        pcre_malloc = old_pcre_malloc;
+        pcre_free = old_pcre_free;
+    }
+}
+
+#endif /* NGX_PCRE */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.h b/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_pcrefix.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,23 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_PCREFIX_H_INCLUDED_
+#define _NGX_HTTP_LUA_PCREFIX_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+#if (NGX_PCRE)
+ngx_pool_t *ngx_http_lua_pcre_malloc_init(ngx_pool_t *pool);
+void ngx_http_lua_pcre_malloc_done(ngx_pool_t *old_pool);
+#endif
+
+
+#endif /* _NGX_HTTP_LUA_PCREFIX_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_phase.c b/src/lua/lua-nginx-module/src/ngx_http_lua_phase.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_phase.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_phase.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,90 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_phase.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_ctx.h"
+
+
+static int ngx_http_lua_ngx_get_phase(lua_State *L);
+
+
+static int
+ngx_http_lua_ngx_get_phase(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+
+    r = ngx_http_lua_get_req(L);
+
+    /* If we have no request object, assume we are called from the "init"
+     * phase. */
+
+    if (r == NULL) {
+        lua_pushlstring(L, (char *) "init", sizeof("init") - 1);
+        return 1;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    switch (ctx->context) {
+    case NGX_HTTP_LUA_CONTEXT_SET:
+        lua_pushliteral(L, "set");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_REWRITE:
+        lua_pushliteral(L, "rewrite");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_ACCESS:
+        lua_pushliteral(L, "access");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_CONTENT:
+        lua_pushliteral(L, "content");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_LOG:
+        lua_pushliteral(L, "log");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_HEADER_FILTER:
+        lua_pushliteral(L, "header_filter");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_BODY_FILTER:
+        lua_pushliteral(L, "body_filter");
+        break;
+
+    case NGX_HTTP_LUA_CONTEXT_TIMER:
+        lua_pushliteral(L, "timer");
+        break;
+
+    default:
+        return luaL_error(L, "unknown phase: %d", (int) ctx->context);
+    }
+
+    return 1;
+}
+
+
+void
+ngx_http_lua_inject_phase_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_get_phase);
+    lua_setfield(L, -2, "get_phase");
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_phase.h b/src/lua/lua-nginx-module/src/ngx_http_lua_phase.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_phase.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_phase.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,13 @@
+#ifndef _NGX_HTTP_LUA_PHASE_H_INCLUDED_
+#define _NGX_HTTP_LUA_PHASE_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_phase_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_PHASE_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_probe.h b/src/lua/lua-nginx-module/src/ngx_http_lua_probe.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_probe.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_probe.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,85 @@
+/*
+ * automatically generated from the file dtrace/ngx_lua_provider.d by the
+ *  gen-dtrace-probe-header tool in the nginx-devel-utils project:
+ *  https://github.com/agentzh/nginx-devel-utils
+ */
+
+#ifndef _NGX_HTTP_LUA_PROBE_H_INCLUDED_
+#define _NGX_HTTP_LUA_PROBE_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+#if defined(NGX_DTRACE) && NGX_DTRACE
+
+#include <ngx_dtrace_provider.h>
+
+#define ngx_http_lua_probe_info(s)                                           \
+    NGINX_LUA_HTTP_LUA_INFO(s)
+
+#define ngx_http_lua_probe_register_preload_package(L, pkg)                  \
+    NGINX_LUA_HTTP_LUA_REGISTER_PRELOAD_PACKAGE(L, pkg)
+
+#define ngx_http_lua_probe_req_socket_consume_preread(r, data, len)          \
+    NGINX_LUA_HTTP_LUA_REQ_SOCKET_CONSUME_PREREAD(r, data, len)
+
+#define ngx_http_lua_probe_user_coroutine_create(r, parent, child)           \
+    NGINX_LUA_HTTP_LUA_USER_COROUTINE_CREATE(r, parent, child)
+
+#define ngx_http_lua_probe_user_coroutine_resume(r, parent, child)           \
+    NGINX_LUA_HTTP_LUA_USER_COROUTINE_RESUME(r, parent, child)
+
+#define ngx_http_lua_probe_user_coroutine_yield(r, parent, child)            \
+    NGINX_LUA_HTTP_LUA_USER_COROUTINE_YIELD(r, parent, child)
+
+#define ngx_http_lua_probe_thread_yield(r, L)                                \
+    NGINX_LUA_HTTP_LUA_THREAD_YIELD(r, L)
+
+#define ngx_http_lua_probe_socket_tcp_send_start(r, u, data, len)            \
+    NGINX_LUA_HTTP_LUA_SOCKET_TCP_SEND_START(r, u, data, len)
+
+#define ngx_http_lua_probe_socket_tcp_receive_done(r, u, data, len)          \
+    NGINX_LUA_HTTP_LUA_SOCKET_TCP_RECEIVE_DONE(r, u, data, len)
+
+#define ngx_http_lua_probe_socket_tcp_setkeepalive_buf_unread(r, u, data, len)\
+    NGINX_LUA_HTTP_LUA_SOCKET_TCP_SETKEEPALIVE_BUF_UNREAD(r, u, data, len)
+
+#define ngx_http_lua_probe_user_thread_spawn(r, creator, newthread)          \
+    NGINX_LUA_HTTP_LUA_USER_THREAD_SPAWN(r, creator, newthread)
+
+#define ngx_http_lua_probe_thread_delete(r, thread, ctx)                     \
+    NGINX_LUA_HTTP_LUA_THREAD_DELETE(r, thread, ctx)
+
+#define ngx_http_lua_probe_run_posted_thread(r, thread, status)              \
+    NGINX_LUA_HTTP_LUA_RUN_POSTED_THREAD(r, thread, status)
+
+#define ngx_http_lua_probe_coroutine_done(r, co, success)                    \
+    NGINX_LUA_HTTP_LUA_COROUTINE_DONE(r, co, success)
+
+#define ngx_http_lua_probe_user_thread_wait(parent, child)                   \
+    NGINX_LUA_HTTP_LUA_USER_THREAD_WAIT(parent, child)
+
+#else /* !(NGX_DTRACE) */
+
+#define ngx_http_lua_probe_info(s)
+#define ngx_http_lua_probe_register_preload_package(L, pkg)
+#define ngx_http_lua_probe_req_socket_consume_preread(r, data, len)
+#define ngx_http_lua_probe_user_coroutine_create(r, parent, child)
+#define ngx_http_lua_probe_user_coroutine_resume(r, parent, child)
+#define ngx_http_lua_probe_user_coroutine_yield(r, parent, child)
+#define ngx_http_lua_probe_thread_yield(r, L)
+#define ngx_http_lua_probe_socket_tcp_send_start(r, u, data, len)
+#define ngx_http_lua_probe_socket_tcp_receive_done(r, u, data, len)
+#define ngx_http_lua_probe_socket_tcp_setkeepalive_buf_unread(r, u, data, len)
+#define ngx_http_lua_probe_user_thread_spawn(r, creator, newthread)
+#define ngx_http_lua_probe_thread_delete(r, thread, ctx)
+#define ngx_http_lua_probe_run_posted_thread(r, thread, status)
+#define ngx_http_lua_probe_coroutine_done(r, co, success)
+#define ngx_http_lua_probe_user_thread_wait(parent, child)
+
+#endif
+
+#endif /* _NGX_HTTP_LUA_PROBE_H_INCLUDED_ */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_regex.c b/src/lua/lua-nginx-module/src/ngx_http_lua_regex.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_regex.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_regex.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,1995 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#if (NGX_PCRE)
+
+#include "ngx_http_lua_regex.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_script.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_util.h"
+#include <pcre.h>
+
+
+#if (PCRE_MAJOR > 8) || (PCRE_MAJOR == 8 && PCRE_MINOR >= 21)
+#   define LUA_HAVE_PCRE_JIT 1
+#else
+#   define LUA_HAVE_PCRE_JIT 0
+#endif
+
+
+#if (PCRE_MAJOR >= 6)
+#   define LUA_HAVE_PCRE_DFA 1
+#else
+#   define LUA_HAVE_PCRE_DFA 0
+#endif
+
+
+#define NGX_LUA_RE_COMPILE_ONCE      (1<<0)
+#define NGX_LUA_RE_MODE_DFA          (1<<1)
+#define NGX_LUA_RE_MODE_JIT          (1<<2)
+#define NGX_LUA_RE_MODE_DUPNAMES     (1<<3)
+#define NGX_LUA_RE_NO_UTF8_CHECK     (1<<4)
+
+#define NGX_LUA_RE_DFA_MODE_WORKSPACE_COUNT (100)
+
+
+typedef struct {
+    pcre                         *regex;
+    pcre_extra                   *regex_sd;
+    int                           ncaptures;
+    int                          *captures;
+
+    ngx_http_lua_complex_value_t    *replace;
+} ngx_http_lua_regex_t;
+
+
+typedef struct {
+    ngx_str_t     pattern;
+    ngx_pool_t   *pool;
+    ngx_int_t     options;
+
+    pcre         *regex;
+    int           captures;
+    ngx_str_t     err;
+} ngx_http_lua_regex_compile_t;
+
+
+typedef struct {
+    ngx_http_cleanup_pt     *cleanup;
+    ngx_http_request_t      *request;
+    pcre                    *regex;
+    pcre_extra              *regex_sd;
+    int                      ncaptures;
+    int                     *captures;
+    int                      captures_len;
+    uint8_t                  flags;
+} ngx_http_lua_regex_ctx_t;
+
+
+static int ngx_http_lua_ngx_re_gmatch_iterator(lua_State *L);
+static ngx_uint_t ngx_http_lua_ngx_re_parse_opts(lua_State *L,
+    ngx_http_lua_regex_compile_t *re, ngx_str_t *opts, int narg);
+static int ngx_http_lua_ngx_re_sub_helper(lua_State *L, unsigned global);
+static int ngx_http_lua_ngx_re_match(lua_State *L);
+static int ngx_http_lua_ngx_re_gmatch(lua_State *L);
+static int ngx_http_lua_ngx_re_sub(lua_State *L);
+static int ngx_http_lua_ngx_re_gsub(lua_State *L);
+static void ngx_http_lua_regex_free_study_data(ngx_pool_t *pool,
+    pcre_extra *sd);
+static ngx_int_t ngx_http_lua_regex_compile(ngx_http_lua_regex_compile_t *rc);
+static void ngx_http_lua_ngx_re_gmatch_cleanup(void *data);
+static int ngx_http_lua_ngx_re_gmatch_gc(lua_State *L);
+static void ngx_http_lua_re_collect_named_captures(lua_State *L,
+    u_char *name_table, int name_count, int name_entry_size,
+    unsigned flags, ngx_str_t *subj);
+
+
+#define ngx_http_lua_regex_exec(re, e, s, start, captures, size, opts)       \
+    pcre_exec(re, e, (const char *) (s)->data, (s)->len, start, opts,        \
+              captures, size)
+
+
+#define ngx_http_lua_regex_dfa_exec(re, e, s, start, captures, size, ws,     \
+                                    wscount, opts)                           \
+    pcre_dfa_exec(re, e, (const char *) (s)->data, (s)->len, start, opts,    \
+                  captures, size, ws, wscount)
+
+
+static int
+ngx_http_lua_ngx_re_match(lua_State *L)
+{
+    /* u_char                      *p; */
+    ngx_http_request_t          *r;
+    ngx_str_t                    subj;
+    ngx_str_t                    pat;
+    ngx_str_t                    opts;
+    ngx_http_lua_regex_t        *re;
+    const char                  *msg;
+    ngx_int_t                    rc;
+    ngx_uint_t                   n;
+    int                          i;
+    ngx_int_t                    pos = 0;
+    int                          nargs;
+    int                         *cap = NULL;
+    int                          ovecsize;
+    ngx_uint_t                   flags;
+    ngx_pool_t                  *pool, *old_pool;
+    ngx_http_lua_main_conf_t    *lmcf;
+    u_char                       errstr[NGX_MAX_CONF_ERRSTR + 1];
+    pcre_extra                  *sd = NULL;
+    int                          name_entry_size = 0, name_count;
+    u_char                      *name_table = NULL;
+    int                          exec_opts;
+
+    ngx_http_lua_regex_compile_t      re_comp;
+
+    nargs = lua_gettop(L);
+
+    if (nargs != 2 && nargs != 3 && nargs != 4) {
+        return luaL_error(L, "expecting two or three or four arguments, "
+                          "but got %d", nargs);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    subj.data = (u_char *) luaL_checklstring(L, 1, &subj.len);
+    pat.data = (u_char *) luaL_checklstring(L, 2, &pat.len);
+
+    ngx_memzero(&re_comp, sizeof(ngx_http_lua_regex_compile_t));
+
+    if (nargs >= 3) {
+        opts.data = (u_char *) luaL_checklstring(L, 3, &opts.len);
+
+        if (nargs == 4) {
+            luaL_checktype(L, 4, LUA_TTABLE);
+            lua_getfield(L, 4, "pos");
+            if (lua_isnumber(L, -1)) {
+                pos = (ngx_int_t) lua_tointeger(L, -1);
+                if (pos < 0) {
+                    pos = 0;
+                }
+
+            } else if (lua_isnil(L, -1)) {
+                pos = 0;
+
+            } else {
+                msg = lua_pushfstring(L, "bad pos field type in the ctx table "
+                                      "argument: %s", luaL_typename(L, -1));
+
+                return luaL_argerror(L, 4, msg);
+            }
+
+            lua_pop(L, 1);
+        }
+
+    } else {
+        opts.data = (u_char *) "";
+        opts.len = 0;
+    }
+
+    re_comp.options = 0;
+
+    flags = ngx_http_lua_ngx_re_parse_opts(L, &re_comp, &opts, 3);
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    if (flags & NGX_LUA_RE_COMPILE_ONCE) {
+        pool = lmcf->pool;
+
+        dd("server pool %p", lmcf->pool);
+
+        lua_pushlightuserdata(L, &ngx_http_lua_regex_cache_key);
+        lua_rawget(L, LUA_REGISTRYINDEX); /* table */
+
+        lua_pushliteral(L, "m");
+        lua_pushvalue(L, 2); /* table regex */
+
+        dd("options size: %d", (int) sizeof(re_comp.options));
+
+        lua_pushlstring(L, (char *) &re_comp.options, sizeof(re_comp.options));
+                /* table regex opts */
+
+        lua_concat(L, 3); /* table key */
+        lua_pushvalue(L, -1); /* table key key */
+
+        dd("regex cache key: %.*s", (int) (pat.len + sizeof(re_comp.options)),
+           lua_tostring(L, -1));
+
+        lua_rawget(L, -3); /* table key re */
+        re = lua_touserdata(L, -1);
+
+        lua_pop(L, 1); /* table key */
+
+        if (re) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua regex cache hit for match regex \"%s\" with "
+                           "options \"%s\"", pat.data, opts.data);
+
+            lua_pop(L, 2);
+
+            dd("restoring regex %p, ncaptures %d,  captures %p", re->regex,
+               re->ncaptures, re->captures);
+
+            re_comp.regex = re->regex;
+            sd = re->regex_sd;
+            re_comp.captures = re->ncaptures;
+            cap = re->captures;
+
+            if (flags & NGX_LUA_RE_MODE_DFA) {
+                ovecsize = 2;
+
+            } else {
+                ovecsize = (re->ncaptures + 1) * 3;
+            }
+
+            goto exec;
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua regex cache miss for match regex \"%s\" "
+                       "with options \"%s\"", pat.data, opts.data);
+
+        if (lmcf->regex_cache_entries >= lmcf->regex_cache_max_entries) {
+
+            if (lmcf->regex_cache_entries == lmcf->regex_cache_max_entries) {
+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                              "lua exceeding regex cache max entries (%i)",
+                              lmcf->regex_cache_max_entries);
+
+                lmcf->regex_cache_entries++;
+            }
+
+            pool = r->pool;
+            flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+        }
+
+    } else {
+        pool = r->pool;
+    }
+
+    dd("pool %p, r pool %p", pool, r->pool);
+
+    re_comp.pattern = pat;
+    re_comp.err.len = NGX_MAX_CONF_ERRSTR;
+    re_comp.err.data = errstr;
+    re_comp.pool = pool;
+
+    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua compiling match regex \"%s\" with options \"%s\" "
+                   "(compile once: %d) (dfa mode: %d) (jit mode: %d)",
+                   pat.data, opts.data,
+                   (flags & NGX_LUA_RE_COMPILE_ONCE) != 0,
+                   (flags & NGX_LUA_RE_MODE_DFA) != 0,
+                   (flags & NGX_LUA_RE_MODE_JIT) != 0);
+
+    old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+    rc = ngx_http_lua_regex_compile(&re_comp);
+
+    ngx_http_lua_pcre_malloc_done(old_pool);
+
+    if (rc != NGX_OK) {
+        dd("compile failed");
+
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *) re_comp.err.data, re_comp.err.len);
+        return 2;
+    }
+
+#if (LUA_HAVE_PCRE_JIT)
+
+    if (flags & NGX_LUA_RE_MODE_JIT) {
+
+        old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+        sd = pcre_study(re_comp.regex, PCRE_STUDY_JIT_COMPILE, &msg);
+
+        ngx_http_lua_pcre_malloc_done(old_pool);
+
+#   if (NGX_DEBUG)
+        dd("sd = %p", sd);
+
+        if (msg != NULL) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre study failed with PCRE_STUDY_JIT_COMPILE: "
+                           "%s (%p)", msg, sd);
+        }
+
+        if (sd != NULL) {
+            int         jitted;
+
+            old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+            pcre_fullinfo(re_comp.regex, sd, PCRE_INFO_JIT, &jitted);
+
+            ngx_http_lua_pcre_malloc_done(old_pool);
+
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre JIT compiling result: %d", jitted);
+        }
+#   endif /* !(NGX_DEBUG) */
+
+    } else {
+        old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+        sd = pcre_study(re_comp.regex, 0, &msg);
+
+        ngx_http_lua_pcre_malloc_done(old_pool);
+
+#   if (NGX_DEBUG)
+        dd("sd = %p", sd);
+
+        if (msg != NULL) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre_study failed with PCRE_STUDY_JIT_COMPILE: "
+                           "%s (%p)", msg, sd);
+        }
+#   endif /* NGX_DEBUG */
+    }
+
+#else  /* !(LUA_HAVE_PCRE_JIT) */
+
+    if (flags & NGX_LUA_RE_MODE_JIT) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "your pcre build does not have JIT support and "
+                       "the \"j\" regex option is ignored");
+    }
+
+#endif /* LUA_HAVE_PCRE_JIT */
+
+    if (sd && lmcf->regex_match_limit > 0) {
+        sd->flags |= PCRE_EXTRA_MATCH_LIMIT;
+        sd->match_limit = lmcf->regex_match_limit;
+    }
+
+    dd("compile done, captures %d", (int) re_comp.captures);
+
+    if (flags & NGX_LUA_RE_MODE_DFA) {
+        ovecsize = 2;
+
+    } else {
+        ovecsize = (re_comp.captures + 1) * 3;
+    }
+
+    dd("allocating cap with size: %d", (int) ovecsize);
+
+    cap = ngx_palloc(pool, ovecsize * sizeof(int));
+
+    if (cap == NULL) {
+        flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+        msg = "no memory";
+        goto error;
+    }
+
+    if (flags & NGX_LUA_RE_COMPILE_ONCE) {
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua saving compiled regex (%d captures) into the cache "
+                       "(entries %i)", re_comp.captures,
+                       lmcf->regex_cache_entries);
+
+        re = ngx_palloc(pool, sizeof(ngx_http_lua_regex_t));
+        if (re == NULL) {
+            msg = "no memory";
+            goto error;
+        }
+
+        dd("saving regex %p, ncaptures %d,  captures %p", re_comp.regex,
+                re_comp.captures, cap);
+
+        re->regex = re_comp.regex;
+        re->regex_sd = sd;
+        re->ncaptures = re_comp.captures;
+        re->captures = cap;
+        re->replace = NULL;
+
+        lua_pushlightuserdata(L, re); /* table key value */
+        lua_rawset(L, -3); /* table */
+        lua_pop(L, 1);
+
+        if (lmcf) {
+            lmcf->regex_cache_entries++;
+        }
+    }
+
+exec:
+    if (pcre_fullinfo(re_comp.regex, NULL, PCRE_INFO_NAMECOUNT,
+                      &name_count) != 0)
+    {
+        msg = "cannot acquire named subpattern count";
+        goto error;
+    }
+
+    if (name_count > 0) {
+        if (pcre_fullinfo(re_comp.regex, NULL, PCRE_INFO_NAMEENTRYSIZE,
+                          &name_entry_size) != 0)
+        {
+            msg = "cannot acquire named subpattern entry size";
+            goto error;
+        }
+
+        if (pcre_fullinfo(re_comp.regex, NULL, PCRE_INFO_NAMETABLE,
+                          &name_table) != 0)
+        {
+            msg = "cannot acquire named subpattern table";
+            goto error;
+        }
+    }
+
+    if (flags & NGX_LUA_RE_NO_UTF8_CHECK) {
+        exec_opts = PCRE_NO_UTF8_CHECK;
+
+    } else {
+        exec_opts = 0;
+    }
+
+    if (flags & NGX_LUA_RE_MODE_DFA) {
+
+#if LUA_HAVE_PCRE_DFA
+
+        int ws[NGX_LUA_RE_DFA_MODE_WORKSPACE_COUNT];
+        rc = ngx_http_lua_regex_dfa_exec(re_comp.regex, sd, &subj,
+                                         (int) pos, cap, ovecsize, ws,
+                                         sizeof(ws)/sizeof(ws[0]), exec_opts);
+
+#else /* LUA_HAVE_PCRE_DFA */
+
+        msg = "at least pcre 6.0 is required for the DFA mode";
+        goto error;
+
+#endif /* LUA_HAVE_PCRE_DFA */
+
+    } else {
+        rc = ngx_http_lua_regex_exec(re_comp.regex, sd, &subj, (int) pos, cap,
+                                     ovecsize, exec_opts);
+    }
+
+    if (rc == NGX_REGEX_NO_MATCHED) {
+        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "regex \"%V\" not matched on string \"%V\" starting "
+                       "from %i", &pat, &subj, pos);
+
+        if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+            if (sd) {
+                ngx_http_lua_regex_free_study_data(pool, sd);
+            }
+
+            ngx_pfree(pool, re_comp.regex);
+            ngx_pfree(pool, cap);
+        }
+
+        lua_pushnil(L);
+        return 1;
+    }
+
+    if (rc < 0) {
+        msg = lua_pushfstring(L, ngx_regex_exec_n " failed: %d", (int) rc);
+        goto error;
+    }
+
+    if (rc == 0) {
+        if (flags & NGX_LUA_RE_MODE_DFA) {
+            rc = 1;
+
+        } else {
+            msg = "capture size too small";
+            goto error;
+        }
+    }
+
+    dd("rc = %d", (int) rc);
+
+    lua_createtable(L, rc - 1 /* narr */, 1 /* nrec */);
+
+    for (i = 0, n = 0; i < rc; i++, n += 2) {
+        dd("capture %d: %d %d", i, cap[n], cap[n + 1]);
+        if (cap[n] < 0) {
+            lua_pushnil(L);
+
+        } else {
+            lua_pushlstring(L, (char *) &subj.data[cap[n]],
+                            cap[n + 1] - cap[n]);
+
+            dd("pushing capture %s at %d", lua_tostring(L, -1), (int) i);
+        }
+
+        lua_rawseti(L, -2, (int) i);
+    }
+
+    if (name_count > 0) {
+        ngx_http_lua_re_collect_named_captures(L, name_table, name_count,
+                                               name_entry_size, flags, &subj);
+    }
+
+    if (nargs == 4) { /* having ctx table */
+        pos = cap[1];
+        lua_pushinteger(L, (lua_Integer) pos);
+        lua_setfield(L, 4, "pos");
+    }
+
+    if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+
+        if (sd) {
+            ngx_http_lua_regex_free_study_data(pool, sd);
+        }
+
+        ngx_pfree(pool, re_comp.regex);
+        ngx_pfree(pool, cap);
+    }
+
+    return 1;
+
+error:
+    if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+        if (sd) {
+            ngx_http_lua_regex_free_study_data(pool, sd);
+        }
+
+        if (re_comp.regex) {
+            ngx_pfree(pool, re_comp.regex);
+        }
+
+        if (cap) {
+            ngx_pfree(pool, cap);
+        }
+    }
+
+    lua_pushnil(L);
+    lua_pushstring(L, msg);
+    return 2;
+}
+
+
+static int
+ngx_http_lua_ngx_re_gmatch(lua_State *L)
+{
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_request_t          *r;
+    ngx_str_t                    subj;
+    ngx_str_t                    pat;
+    ngx_str_t                    opts;
+    int                          ovecsize;
+    ngx_http_lua_regex_t        *re;
+    ngx_http_lua_regex_ctx_t    *ctx;
+    const char                  *msg;
+    int                          nargs;
+    ngx_int_t                    flags;
+    int                         *cap = NULL;
+    ngx_int_t                    rc;
+    ngx_pool_t                  *pool, *old_pool;
+    u_char                       errstr[NGX_MAX_CONF_ERRSTR + 1];
+    pcre_extra                  *sd = NULL;
+    ngx_http_cleanup_t          *cln;
+
+    ngx_http_lua_regex_compile_t      re_comp;
+
+    nargs = lua_gettop(L);
+
+    if (nargs != 2 && nargs != 3) {
+        return luaL_error(L, "expecting two or three arguments, but got %d",
+                nargs);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    subj.data = (u_char *) luaL_checklstring(L, 1, &subj.len);
+    pat.data = (u_char *) luaL_checklstring(L, 2, &pat.len);
+
+    if (nargs == 3) {
+        opts.data = (u_char *) luaL_checklstring(L, 3, &opts.len);
+        lua_pop(L, 1);
+
+    } else {
+        opts.data = (u_char *) "";
+        opts.len = 0;
+    }
+
+    /* stack: subj regex */
+
+    re_comp.options = 0;
+
+    flags = ngx_http_lua_ngx_re_parse_opts(L, &re_comp, &opts, 3);
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    if (flags & NGX_LUA_RE_COMPILE_ONCE) {
+        pool = lmcf->pool;
+
+        dd("server pool %p", lmcf->pool);
+
+        lua_pushlightuserdata(L, &ngx_http_lua_regex_cache_key);
+        lua_rawget(L, LUA_REGISTRYINDEX); /* table */
+
+        lua_pushliteral(L, "m");
+        lua_pushvalue(L, 2); /* table regex */
+
+        dd("options size: %d", (int) sizeof(re_comp.options));
+
+        lua_pushlstring(L, (char *) &re_comp.options,
+                        sizeof(re_comp.options)); /* table regex opts */
+
+        lua_concat(L, 3); /* table key */
+        lua_pushvalue(L, -1); /* table key key */
+
+        dd("regex cache key: %.*s", (int) (pat.len + sizeof(re_comp.options)),
+           lua_tostring(L, -1));
+
+        lua_rawget(L, -3); /* table key re */
+        re = lua_touserdata(L, -1);
+
+        lua_pop(L, 1); /* table key */
+
+        if (re) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua regex cache hit for match regex \"%s\" "
+                           "with options \"%s\"", pat.data, opts.data);
+
+            lua_pop(L, 2);
+
+            dd("restoring regex %p, ncaptures %d,  captures %p", re->regex,
+               re->ncaptures, re->captures);
+
+            re_comp.regex = re->regex;
+            sd = re->regex_sd;
+            re_comp.captures = re->ncaptures;
+            cap = re->captures;
+
+            if (flags & NGX_LUA_RE_MODE_DFA) {
+                ovecsize = 2;
+
+            } else {
+                ovecsize = (re->ncaptures + 1) * 3;
+            }
+
+            goto compiled;
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua regex cache miss for match regex \"%s\" "
+                       "with options \"%s\"", pat.data, opts.data);
+
+        if (lmcf->regex_cache_entries >= lmcf->regex_cache_max_entries) {
+
+            if (lmcf->regex_cache_entries == lmcf->regex_cache_max_entries) {
+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                              "lua exceeding regex cache max entries (%i)",
+                              lmcf->regex_cache_max_entries);
+
+                lmcf->regex_cache_entries++;
+            }
+
+            pool = r->pool;
+            flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+        }
+
+    } else {
+        pool = r->pool;
+    }
+
+    re_comp.pattern = pat;
+    re_comp.err.len = NGX_MAX_CONF_ERRSTR;
+    re_comp.err.data = errstr;
+    re_comp.pool = pool;
+
+    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua compiling gmatch regex \"%s\" with options \"%s\" "
+                   "(compile once: %d) (dfa mode: %d) (jit mode: %d)",
+                   pat.data, opts.data,
+                   (flags & NGX_LUA_RE_COMPILE_ONCE) != 0,
+                   (flags & NGX_LUA_RE_MODE_DFA) != 0,
+                   (flags & NGX_LUA_RE_MODE_JIT) != 0);
+
+    old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+    rc = ngx_http_lua_regex_compile(&re_comp);
+
+    ngx_http_lua_pcre_malloc_done(old_pool);
+
+    if (rc != NGX_OK) {
+        dd("compile failed");
+
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *) re_comp.err.data, re_comp.err.len);
+        return 2;
+    }
+
+#if LUA_HAVE_PCRE_JIT
+
+    if (flags & NGX_LUA_RE_MODE_JIT) {
+
+        old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+        sd = pcre_study(re_comp.regex, PCRE_STUDY_JIT_COMPILE, &msg);
+
+        ngx_http_lua_pcre_malloc_done(old_pool);
+
+#   if (NGX_DEBUG)
+        dd("sd = %p", sd);
+
+        if (msg != NULL) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre_study failed with PCRE_STUDY_JIT_COMPILE: "
+                           "%s (%p)", msg, sd);
+        }
+
+        if (sd != NULL) {
+            int         jitted;
+
+            old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+            pcre_fullinfo(re_comp.regex, sd, PCRE_INFO_JIT, &jitted);
+
+            ngx_http_lua_pcre_malloc_done(old_pool);
+
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre JIT compiling result: %d", jitted);
+        }
+#   endif /* NGX_DEBUG */
+
+    } else {
+
+        old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+        sd = pcre_study(re_comp.regex, 0, &msg);
+
+        ngx_http_lua_pcre_malloc_done(old_pool);
+
+#   if (NGX_DEBUG)
+        dd("sd = %p", sd);
+
+        if (msg != NULL) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre study failed with PCRE_STUDY_JIT_COMPILE: "
+                           "%s (%p)", msg, sd);
+        }
+#   endif /* NGX_DEBUG */
+    }
+
+#else  /* LUA_HAVE_PCRE_JIT */
+
+    if (flags & NGX_LUA_RE_MODE_JIT) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "your pcre build does not have JIT support and "
+                       "the \"j\" regex option is ignored");
+    }
+
+#endif /* LUA_HAVE_PCRE_JIT */
+
+    if (sd && lmcf->regex_match_limit > 0) {
+        sd->flags |= PCRE_EXTRA_MATCH_LIMIT;
+        sd->match_limit = lmcf->regex_match_limit;
+    }
+
+    dd("compile done, captures %d", re_comp.captures);
+
+    if (flags & NGX_LUA_RE_MODE_DFA) {
+        ovecsize = 2;
+
+    } else {
+        ovecsize = (re_comp.captures + 1) * 3;
+    }
+
+    cap = ngx_palloc(pool, ovecsize * sizeof(int));
+    if (cap == NULL) {
+        flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+        msg = "no memory";
+        goto error;
+    }
+
+    if (flags & NGX_LUA_RE_COMPILE_ONCE) {
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua saving compiled regex (%d captures) into the cache "
+                       "(entries %i)", re_comp.captures,
+                       lmcf->regex_cache_entries);
+
+        re = ngx_palloc(pool, sizeof(ngx_http_lua_regex_t));
+        if (re == NULL) {
+            msg = "no memory";
+            goto error;
+        }
+
+        dd("saving regex %p, ncaptures %d,  captures %p", re_comp.regex,
+           re_comp.captures, cap);
+
+        re->regex = re_comp.regex;
+        re->regex_sd = sd;
+        re->ncaptures = re_comp.captures;
+        re->captures = cap;
+        re->replace = NULL;
+
+        lua_pushlightuserdata(L, re); /* table key value */
+        lua_rawset(L, -3); /* table */
+        lua_pop(L, 1);
+
+        if (lmcf) {
+            lmcf->regex_cache_entries++;
+        }
+    }
+
+compiled:
+    lua_settop(L, 1);
+
+    ctx = lua_newuserdata(L, sizeof(ngx_http_lua_regex_ctx_t));
+
+    ctx->request = r;
+    ctx->regex = re_comp.regex;
+    ctx->regex_sd = sd;
+    ctx->ncaptures = re_comp.captures;
+    ctx->captures = cap;
+    ctx->captures_len = ovecsize;
+    ctx->flags = (uint8_t) flags;
+
+    if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+        lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */
+        lua_pushcfunction(L, ngx_http_lua_ngx_re_gmatch_gc);
+        lua_setfield(L, -2, "__gc");
+        lua_setmetatable(L, -2);
+
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            msg = "no memory";
+            goto error;
+        }
+
+        cln->handler = ngx_http_lua_ngx_re_gmatch_cleanup;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+
+    } else {
+        ctx->cleanup = NULL;
+    }
+
+    lua_pushinteger(L, 0);
+
+    /* upvalues in order: subj ctx offset */
+    lua_pushcclosure(L, ngx_http_lua_ngx_re_gmatch_iterator, 3);
+
+    return 1;
+
+error:
+    if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+        if (sd) {
+            ngx_http_lua_regex_free_study_data(pool, sd);
+        }
+
+        if (re_comp.regex) {
+            ngx_pfree(pool, re_comp.regex);
+        }
+
+        if (cap) {
+            ngx_pfree(pool, cap);
+        }
+    }
+
+    lua_pushnil(L);
+    lua_pushstring(L, msg);
+    return 2;
+}
+
+
+static int
+ngx_http_lua_ngx_re_gmatch_iterator(lua_State *L)
+{
+    ngx_http_lua_regex_ctx_t    *ctx;
+    ngx_http_request_t          *r;
+    int                         *cap;
+    ngx_int_t                    rc;
+    ngx_uint_t                   n;
+    int                          i;
+    ngx_str_t                    subj;
+    int                          offset;
+    const char                  *msg = NULL;
+    int                          name_entry_size = 0, name_count;
+    u_char                      *name_table = NULL;
+    int                          exec_opts;
+
+    /* upvalues in order: subj ctx offset */
+
+    subj.data = (u_char *) lua_tolstring(L, lua_upvalueindex(1), &subj.len);
+    ctx = (ngx_http_lua_regex_ctx_t *) lua_touserdata(L, lua_upvalueindex(2));
+    offset = (int) lua_tointeger(L, lua_upvalueindex(3));
+
+    if (offset < 0) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    cap = ctx->captures;
+
+    dd("offset %d, r %p, subj %s", (int) offset, ctx->request, subj.data);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    if (r != ctx->request || r->pool != ctx->request->pool) {
+        return luaL_error(L, "attempt to use ngx.re.gmatch iterator in a "
+                          "request that did not create it");
+    }
+
+    dd("regex exec...");
+
+    if (pcre_fullinfo(ctx->regex, NULL, PCRE_INFO_NAMECOUNT,
+                      &name_count) != 0)
+    {
+        msg = "cannot acquire named subpattern count";
+        goto error;
+    }
+
+    if (name_count > 0) {
+        if (pcre_fullinfo(ctx->regex, NULL, PCRE_INFO_NAMEENTRYSIZE,
+                          &name_entry_size) != 0)
+        {
+            msg = "cannot acquire named subpattern entry size";
+            goto error;
+        }
+
+        if (pcre_fullinfo(ctx->regex, NULL, PCRE_INFO_NAMETABLE,
+                          &name_table) != 0)
+        {
+            msg = "cannot acquire named subpattern table";
+            goto error;
+        }
+    }
+
+    if (ctx->flags & NGX_LUA_RE_NO_UTF8_CHECK) {
+        exec_opts = PCRE_NO_UTF8_CHECK;
+
+    } else {
+        exec_opts = 0;
+    }
+
+    if (ctx->flags & NGX_LUA_RE_MODE_DFA) {
+
+#if LUA_HAVE_PCRE_DFA
+
+        int ws[NGX_LUA_RE_DFA_MODE_WORKSPACE_COUNT];
+
+        rc = ngx_http_lua_regex_dfa_exec(ctx->regex, ctx->regex_sd, &subj,
+                                         offset, cap, ctx->captures_len, ws,
+                                         sizeof(ws)/sizeof(ws[0]), exec_opts);
+
+#else /* LUA_HAVE_PCRE_DFA */
+        msg = "at least pcre 6.0 is required for the DFA mode";
+        goto error;
+
+#endif /* LUA_HAVE_PCRE_DFA */
+
+    } else {
+        rc = ngx_http_lua_regex_exec(ctx->regex, ctx->regex_sd, &subj,
+                                     offset, cap, ctx->captures_len,
+                                     exec_opts);
+    }
+
+    if (rc == NGX_REGEX_NO_MATCHED) {
+        /* set upvalue "offset" to -1 */
+        lua_pushinteger(L, -1);
+        lua_replace(L, lua_upvalueindex(3));
+
+        if (!(ctx->flags & NGX_LUA_RE_COMPILE_ONCE)) {
+            if (ctx->regex_sd) {
+                ngx_http_lua_regex_free_study_data(r->pool, ctx->regex_sd);
+                ctx->regex_sd = NULL;
+            }
+
+            ngx_pfree(r->pool, cap);
+        }
+
+        lua_pushnil(L);
+        return 1;
+    }
+
+    if (rc < 0) {
+        msg = lua_pushfstring(L, ngx_regex_exec_n " failed: %d", (int) rc);
+        goto error;
+    }
+
+    if (rc == 0) {
+        if (ctx->flags & NGX_LUA_RE_MODE_DFA) {
+            rc = 1;
+
+        } else {
+            goto error;
+        }
+    }
+
+    dd("rc = %d", (int) rc);
+
+    lua_createtable(L, rc - 1 /* narr */, 1 /* nrec */);
+
+    for (i = 0, n = 0; i < rc; i++, n += 2) {
+        dd("capture %d: %d %d", i, cap[n], cap[n + 1]);
+        if (cap[n] < 0) {
+            lua_pushnil(L);
+
+        } else {
+            lua_pushlstring(L, (char *) &subj.data[cap[n]],
+                            cap[n + 1] - cap[n]);
+
+            dd("pushing capture %s at %d", lua_tostring(L, -1), (int) i);
+        }
+
+        lua_rawseti(L, -2, (int) i);
+    }
+
+    if (name_count > 0) {
+        ngx_http_lua_re_collect_named_captures(L, name_table, name_count,
+                                               name_entry_size, ctx->flags,
+                                               &subj);
+    }
+
+    offset = cap[1];
+    if (offset == cap[0]) {
+        offset++;
+    }
+
+    if (offset > (ssize_t) subj.len) {
+        offset = -1;
+
+        if (!(ctx->flags & NGX_LUA_RE_COMPILE_ONCE)) {
+            if (ctx->regex_sd) {
+                ngx_http_lua_regex_free_study_data(r->pool, ctx->regex_sd);
+                ctx->regex_sd = NULL;
+            }
+
+            ngx_pfree(r->pool, cap);
+        }
+    }
+
+    lua_pushinteger(L, offset);
+    lua_replace(L, lua_upvalueindex(3));
+
+    return 1;
+
+error:
+    lua_pushinteger(L, -1);
+    lua_replace(L, lua_upvalueindex(3));
+
+    if (!(ctx->flags & NGX_LUA_RE_COMPILE_ONCE)) {
+        if (ctx->regex_sd) {
+            ngx_http_lua_regex_free_study_data(r->pool, ctx->regex_sd);
+            ctx->regex_sd = NULL;
+        }
+
+        ngx_pfree(r->pool, cap);
+    }
+
+    lua_pushnil(L);
+    lua_pushstring(L, msg);
+    return 2;
+}
+
+
+static ngx_uint_t
+ngx_http_lua_ngx_re_parse_opts(lua_State *L, ngx_http_lua_regex_compile_t *re,
+    ngx_str_t *opts, int narg)
+{
+    u_char          *p;
+    const char      *msg;
+    ngx_uint_t       flags;
+
+    flags = 0;
+    p = opts->data;
+
+    while (*p != '\0') {
+        switch (*p) {
+            case 'i':
+                re->options |= NGX_REGEX_CASELESS;
+                break;
+
+            case 's':
+                re->options |= PCRE_DOTALL;
+                break;
+
+            case 'm':
+                re->options |= PCRE_MULTILINE;
+                break;
+
+            case 'u':
+                re->options |= PCRE_UTF8;
+                break;
+
+            case 'U':
+                re->options |= PCRE_UTF8;
+                flags |= NGX_LUA_RE_NO_UTF8_CHECK;
+                break;
+
+            case 'x':
+                re->options |= PCRE_EXTENDED;
+                break;
+
+            case 'o':
+                flags |= NGX_LUA_RE_COMPILE_ONCE;
+                break;
+
+            case 'j':
+                flags |= NGX_LUA_RE_MODE_JIT;
+                break;
+
+            case 'd':
+                flags |= NGX_LUA_RE_MODE_DFA;
+                break;
+
+            case 'a':
+                re->options |= PCRE_ANCHORED;
+                break;
+
+#if (PCRE_MAJOR > 8) || (PCRE_MAJOR == 8 && PCRE_MINOR >= 12)
+            case 'D':
+                re->options |= PCRE_DUPNAMES;
+                flags |= NGX_LUA_RE_MODE_DUPNAMES;
+                break;
+
+            case 'J':
+                re->options |= PCRE_JAVASCRIPT_COMPAT;
+                break;
+#endif
+
+            default:
+                msg = lua_pushfstring(L, "unknown flag \"%c\"", *p);
+                return luaL_argerror(L, narg, msg);
+        }
+
+        p++;
+    }
+
+    /* pcre does not support JIT for DFA mode yet,
+     * so if DFA mode is specified, we turn off JIT automatically
+     * */
+    if ((flags & NGX_LUA_RE_MODE_JIT) && (flags & NGX_LUA_RE_MODE_DFA)) {
+        flags &= ~NGX_LUA_RE_MODE_JIT;
+    }
+
+    return flags;
+}
+
+
+static int
+ngx_http_lua_ngx_re_sub(lua_State *L)
+{
+    return ngx_http_lua_ngx_re_sub_helper(L, 0 /* global */);
+}
+
+
+static int
+ngx_http_lua_ngx_re_gsub(lua_State *L)
+{
+    return ngx_http_lua_ngx_re_sub_helper(L, 1 /* global */);
+}
+
+
+static int
+ngx_http_lua_ngx_re_sub_helper(lua_State *L, unsigned global)
+{
+    ngx_http_lua_regex_t        *re;
+    ngx_http_request_t          *r;
+    ngx_str_t                    subj;
+    ngx_str_t                    pat;
+    ngx_str_t                    opts;
+    ngx_str_t                    tpl;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_pool_t                  *pool, *old_pool;
+    const char                  *msg;
+    ngx_int_t                    rc;
+    ngx_uint_t                   n;
+    ngx_int_t                    i;
+    int                          nargs;
+    int                         *cap = NULL;
+    int                          ovecsize;
+    int                          type;
+    unsigned                     func;
+    int                          offset;
+    int                          cp_offset;
+    size_t                       count;
+    luaL_Buffer                  luabuf;
+    ngx_int_t                    flags;
+    u_char                      *p;
+    u_char                       errstr[NGX_MAX_CONF_ERRSTR + 1];
+    pcre_extra                  *sd = NULL;
+    int                          name_entry_size = 0, name_count;
+    u_char                      *name_table = NULL;
+    int                          exec_opts;
+
+    ngx_http_lua_regex_compile_t               re_comp;
+    ngx_http_lua_complex_value_t              *ctpl = NULL;
+    ngx_http_lua_compile_complex_value_t       ccv;
+
+    nargs = lua_gettop(L);
+
+    if (nargs != 3 && nargs != 4) {
+        return luaL_error(L, "expecting three or four arguments, but got %d",
+                nargs);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    subj.data = (u_char *) luaL_checklstring(L, 1, &subj.len);
+    pat.data = (u_char *) luaL_checklstring(L, 2, &pat.len);
+
+    func = 0;
+
+    type = lua_type(L, 3);
+    switch (type) {
+        case LUA_TFUNCTION:
+            func = 1;
+            tpl.len = 0;
+            tpl.data = (u_char *) "";
+            break;
+
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            tpl.data = (u_char *) lua_tolstring(L, 3, &tpl.len);
+            break;
+
+        default:
+            msg = lua_pushfstring(L, "string, number, or function expected, "
+                                  "got %s", lua_typename(L, type));
+            return luaL_argerror(L, 3, msg);
+    }
+
+    ngx_memzero(&re_comp, sizeof(ngx_http_lua_regex_compile_t));
+
+    if (nargs == 4) {
+        opts.data = (u_char *) luaL_checklstring(L, 4, &opts.len);
+        lua_pop(L, 1);
+
+    } else { /* nargs == 3 */
+        opts.data = (u_char *) "";
+        opts.len = 0;
+    }
+
+    /* stack: subj regex repl */
+
+    re_comp.options = 0;
+
+    flags = ngx_http_lua_ngx_re_parse_opts(L, &re_comp, &opts, 4);
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    if (flags & NGX_LUA_RE_COMPILE_ONCE) {
+        pool = lmcf->pool;
+
+        dd("server pool %p", lmcf->pool);
+
+        lua_pushlightuserdata(L, &ngx_http_lua_regex_cache_key);
+        lua_rawget(L, LUA_REGISTRYINDEX); /* table */
+
+        lua_pushliteral(L, "s");
+        lua_pushinteger(L, tpl.len);
+        lua_pushliteral(L, ":");
+        lua_pushvalue(L, 2);
+
+        if (tpl.len != 0) {
+            lua_pushvalue(L, 3);
+        }
+
+        dd("options size: %d", (int) sizeof(re_comp.options));
+
+        lua_pushlstring(L, (char *) &re_comp.options, sizeof(re_comp.options));
+                /* table regex opts */
+
+        if (tpl.len == 0) {
+            lua_concat(L, 5); /* table key */
+
+        } else {
+            lua_concat(L, 6); /* table key */
+        }
+
+        lua_pushvalue(L, -1); /* table key key */
+
+        dd("regex cache key: %.*s", (int) (pat.len + sizeof(re_comp.options)),
+           lua_tostring(L, -1));
+
+        lua_rawget(L, -3); /* table key re */
+        re = lua_touserdata(L, -1);
+
+        lua_pop(L, 1); /* table key */
+
+        if (re) {
+            ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua regex cache hit for sub regex \"%s\" with "
+                           "options \"%s\" and replace \"%s\"",
+                           pat.data, opts.data,
+                           func ? (u_char *) "<func>" : tpl.data);
+
+            lua_pop(L, 2);
+
+            dd("restoring regex %p, ncaptures %d,  captures %p", re->regex,
+               re->ncaptures, re->captures);
+
+            re_comp.regex = re->regex;
+            sd = re->regex_sd;
+            re_comp.captures = re->ncaptures;
+            cap = re->captures;
+            ctpl = re->replace;
+
+            if (flags & NGX_LUA_RE_MODE_DFA) {
+                ovecsize = 2;
+
+            } else {
+                ovecsize = (re->ncaptures + 1) * 3;
+            }
+
+            goto exec;
+        }
+
+        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua regex cache miss for %ssub regex \"%s\" with "
+                       "options \"%s\" and replace \"%s\"",
+                       global ? "g" : "", pat.data, opts.data,
+                       func ? (u_char *) "<func>" : tpl.data);
+
+        if (lmcf->regex_cache_entries >= lmcf->regex_cache_max_entries) {
+
+            if (lmcf->regex_cache_entries == lmcf->regex_cache_max_entries) {
+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                              "lua exceeding regex cache max entries (%i)",
+                              lmcf->regex_cache_max_entries);
+
+                lmcf->regex_cache_entries++;
+            }
+
+            pool = r->pool;
+            flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+        }
+
+    } else {
+        pool = r->pool;
+    }
+
+    re_comp.pattern = pat;
+    re_comp.err.len = NGX_MAX_CONF_ERRSTR;
+    re_comp.err.data = errstr;
+    re_comp.pool = pool;
+
+    dd("compiling regex");
+
+    ngx_log_debug6(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua compiling %ssub regex \"%s\" with options \"%s\" "
+                   "(compile once: %d) (dfa mode: %d) (jit mode: %d)",
+                   global ? "g" : "", pat.data, opts.data,
+                   (flags & NGX_LUA_RE_COMPILE_ONCE) != 0,
+                   (flags & NGX_LUA_RE_MODE_DFA) != 0,
+                   (flags & NGX_LUA_RE_MODE_JIT) != 0);
+
+    old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+    rc = ngx_http_lua_regex_compile(&re_comp);
+
+    ngx_http_lua_pcre_malloc_done(old_pool);
+
+    if (rc != NGX_OK) {
+        dd("compile failed");
+
+        lua_pushnil(L);
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *) re_comp.err.data, re_comp.err.len);
+        return 3;
+    }
+
+#if LUA_HAVE_PCRE_JIT
+
+    if (flags & NGX_LUA_RE_MODE_JIT) {
+
+        old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+        sd = pcre_study(re_comp.regex, PCRE_STUDY_JIT_COMPILE, &msg);
+
+        ngx_http_lua_pcre_malloc_done(old_pool);
+
+#   if (NGX_DEBUG)
+        dd("sd = %p", sd);
+
+        if (msg != NULL) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre study failed with PCRE_STUDY_JIT_COMPILE: "
+                           "%s (%p)", msg, sd);
+        }
+
+        if (sd != NULL) {
+            int         jitted;
+
+            old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+            pcre_fullinfo(re_comp.regex, sd, PCRE_INFO_JIT, &jitted);
+
+            ngx_http_lua_pcre_malloc_done(old_pool);
+
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre JIT compiling result: %d", jitted);
+        }
+#   endif /* NGX_DEBUG */
+
+    } else {
+
+        old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+        sd = pcre_study(re_comp.regex, 0, &msg);
+
+        ngx_http_lua_pcre_malloc_done(old_pool);
+
+#   if (NGX_DEBUG)
+        dd("sd = %p", sd);
+
+        if (msg != NULL) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "pcre_study failed with PCRE_STUDY_JIT_COMPILE: "
+                           "%s (%p)", msg, sd);
+        }
+#   endif /* NGX_DEBUG */
+    }
+
+#else  /* LUA_HAVE_PCRE_JIT */
+
+    if (flags & NGX_LUA_RE_MODE_JIT) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "your pcre build does not have JIT support and "
+                       "the \"j\" regex option is ignored");
+    }
+
+#endif /* LUA_HAVE_PCRE_JIT */
+
+    if (sd && lmcf->regex_match_limit > 0) {
+        sd->flags |= PCRE_EXTRA_MATCH_LIMIT;
+        sd->match_limit = lmcf->regex_match_limit;
+    }
+
+    dd("compile done, captures %d", re_comp.captures);
+
+    if (flags & NGX_LUA_RE_MODE_DFA) {
+        ovecsize = 2;
+
+    } else {
+        ovecsize = (re_comp.captures + 1) * 3;
+    }
+
+    cap = ngx_palloc(pool, ovecsize * sizeof(int));
+    if (cap == NULL) {
+        flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+        msg = "no memory";
+        goto error;
+    }
+
+    if (func) {
+        ctpl = NULL;
+
+    } else {
+        ctpl = ngx_palloc(pool, sizeof(ngx_http_lua_complex_value_t));
+        if (ctpl == NULL) {
+            flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+            msg = "no memory";
+            goto error;
+        }
+
+        if ((flags & NGX_LUA_RE_COMPILE_ONCE) && tpl.len != 0) {
+            /* copy the string buffer pointed to by tpl.data from Lua VM */
+            p = ngx_palloc(pool, tpl.len + 1);
+            if (p == NULL) {
+                flags &= ~NGX_LUA_RE_COMPILE_ONCE;
+                msg = "no memory";
+                goto error;
+            }
+
+            ngx_memcpy(p, tpl.data, tpl.len);
+            p[tpl.len] = '\0';
+
+            tpl.data = p;
+        }
+
+        ngx_memzero(&ccv, sizeof(ngx_http_lua_compile_complex_value_t));
+        ccv.pool = pool;
+        ccv.log = r->connection->log;
+        ccv.value = &tpl;
+        ccv.complex_value = ctpl;
+
+        if (ngx_http_lua_compile_complex_value(&ccv) != NGX_OK) {
+            ngx_pfree(pool, cap);
+            ngx_pfree(pool, ctpl);
+
+            if ((flags & NGX_LUA_RE_COMPILE_ONCE) && tpl.len != 0) {
+                ngx_pfree(pool, tpl.data);
+            }
+
+            if (sd) {
+                ngx_http_lua_regex_free_study_data(pool, sd);
+            }
+
+            ngx_pfree(pool, re_comp.regex);
+
+            lua_pushnil(L);
+            lua_pushnil(L);
+            lua_pushliteral(L, "failed to compile the replacement template");
+            return 3;
+        }
+    }
+
+    if (flags & NGX_LUA_RE_COMPILE_ONCE) {
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua saving compiled sub regex (%d captures) into "
+                       "the cache (entries %i)", re_comp.captures,
+                       lmcf->regex_cache_entries);
+
+        re = ngx_palloc(pool, sizeof(ngx_http_lua_regex_t));
+        if (re == NULL) {
+            msg = "no memory";
+            goto error;
+        }
+
+        dd("saving regex %p, ncaptures %d,  captures %p", re_comp.regex,
+           re_comp.captures, cap);
+
+        re->regex = re_comp.regex;
+        re->regex_sd = sd;
+        re->ncaptures = re_comp.captures;
+        re->captures = cap;
+        re->replace = ctpl;
+
+        lua_pushlightuserdata(L, re); /* table key value */
+        lua_rawset(L, -3); /* table */
+        lua_pop(L, 1);
+
+        if (lmcf) {
+            lmcf->regex_cache_entries++;
+        }
+    }
+
+exec:
+    count = 0;
+    offset = 0;
+    cp_offset = 0;
+
+    if (pcre_fullinfo(re_comp.regex, NULL, PCRE_INFO_NAMECOUNT,
+                      &name_count) != 0)
+    {
+        msg = "cannot acquire named subpattern count";
+        goto error;
+    }
+
+    if (name_count > 0) {
+        if (pcre_fullinfo(re_comp.regex, NULL, PCRE_INFO_NAMEENTRYSIZE,
+                          &name_entry_size) != 0)
+        {
+            msg = "cannot acquire named subpattern entry size";
+            goto error;
+        }
+
+        if (pcre_fullinfo(re_comp.regex, NULL, PCRE_INFO_NAMETABLE,
+                          &name_table) != 0)
+        {
+            msg = "cannot acquire named subpattern table";
+            goto error;
+        }
+    }
+
+    if (flags & NGX_LUA_RE_NO_UTF8_CHECK) {
+        exec_opts = PCRE_NO_UTF8_CHECK;
+
+    } else {
+        exec_opts = 0;
+    }
+
+    for (;;) {
+        if (flags & NGX_LUA_RE_MODE_DFA) {
+
+#if LUA_HAVE_PCRE_DFA
+
+            int ws[NGX_LUA_RE_DFA_MODE_WORKSPACE_COUNT];
+            rc = ngx_http_lua_regex_dfa_exec(re_comp.regex, sd, &subj,
+                                             offset, cap, ovecsize, ws,
+                                             sizeof(ws)/sizeof(ws[0]),
+                                             exec_opts);
+
+#else /* LUA_HAVE_PCRE_DFA */
+
+            msg = "at least pcre 6.0 is required for the DFA mode";
+            goto error;
+
+#endif /* LUA_HAVE_PCRE_DFA */
+
+        } else {
+            rc = ngx_http_lua_regex_exec(re_comp.regex, sd, &subj, offset, cap,
+                                         ovecsize, exec_opts);
+        }
+
+        if (rc == NGX_REGEX_NO_MATCHED) {
+            break;
+        }
+
+        if (rc < 0) {
+            msg = lua_pushfstring(L, ngx_regex_exec_n " failed: %d",
+                                  (int) rc);
+            goto error;
+        }
+
+        if (rc == 0) {
+            if (flags & NGX_LUA_RE_MODE_DFA) {
+                rc = 1;
+
+            } else {
+                msg = "capture size too small";
+                goto error;
+            }
+        }
+
+        dd("rc = %d", (int) rc);
+
+        count++;
+
+        if (count == 1) {
+            luaL_buffinit(L, &luabuf);
+        }
+
+        if (func) {
+            lua_pushvalue(L, 3);
+
+            lua_createtable(L, rc - 1 /* narr */, 1 /* nrec */);
+
+            for (i = 0, n = 0; i < rc; i++, n += 2) {
+                dd("capture %d: %d %d", (int) i, cap[n], cap[n + 1]);
+                if (cap[n] < 0) {
+                    lua_pushnil(L);
+
+                } else {
+                    lua_pushlstring(L, (char *) &subj.data[cap[n]],
+                                    cap[n + 1] - cap[n]);
+
+                    dd("pushing capture %s at %d", lua_tostring(L, -1),
+                       (int) i);
+                }
+
+                lua_rawseti(L, -2, (int) i);
+            }
+
+            if (name_count > 0) {
+                ngx_http_lua_re_collect_named_captures(L, name_table,
+                                                       name_count,
+                                                       name_entry_size,
+                                                       flags, &subj);
+            }
+
+            dd("stack size at call: %d", lua_gettop(L));
+
+            lua_call(L, 1 /* nargs */, 1 /* nresults */);
+            type = lua_type(L, -1);
+            switch (type) {
+                case LUA_TNUMBER:
+                case LUA_TSTRING:
+                    tpl.data = (u_char *) lua_tolstring(L, -1, &tpl.len);
+                    break;
+
+                default:
+                    msg = lua_pushfstring(L, "string or number expected to be "
+                                          "returned by the replace "
+                                          "function, got %s",
+                                          lua_typename(L, type));
+                    return luaL_argerror(L, 3, msg);
+            }
+
+            lua_insert(L, 1);
+
+            luaL_addlstring(&luabuf, (char *) &subj.data[cp_offset],
+                            cap[0] - cp_offset);
+
+            luaL_addlstring(&luabuf, (char *) tpl.data, tpl.len);
+
+            lua_remove(L, 1);
+
+            cp_offset = cap[1];
+            offset = cp_offset;
+            if (offset == cap[0]) {
+                offset++;
+                if (offset > (ssize_t) subj.len) {
+                    break;
+                }
+            }
+
+            if (global) {
+                continue;
+            }
+
+            break;
+        }
+
+        rc = ngx_http_lua_complex_value(r, &subj, cp_offset, rc, cap, ctpl,
+                &luabuf);
+
+        if (rc != NGX_OK) {
+            msg = lua_pushfstring(L, "failed to eval the template for "
+                                  "replacement: \"%s\"", tpl.data);
+            goto error;
+        }
+
+        cp_offset = cap[1];
+        offset = cp_offset;
+        if (offset == cap[0]) {
+            offset++;
+            if (offset > (ssize_t) subj.len) {
+                break;
+            }
+        }
+
+        if (global) {
+            continue;
+        }
+
+        break;
+    }
+
+    if (count == 0) {
+        dd("no match, just the original subject");
+        lua_settop(L, 1);
+
+    } else {
+        if (offset < (int) subj.len) {
+            dd("adding trailer: %s (len %d)", &subj.data[offset],
+               (int) (subj.len - offset));
+
+            luaL_addlstring(&luabuf, (char *) &subj.data[offset],
+                            subj.len - offset);
+        }
+
+        luaL_pushresult(&luabuf);
+
+        dd("the dst string: %s", lua_tostring(L, -1));
+    }
+
+    if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+        if (sd) {
+            ngx_http_lua_regex_free_study_data(pool, sd);
+        }
+
+        if (re_comp.regex) {
+            ngx_pfree(pool, re_comp.regex);
+        }
+
+        if (ctpl) {
+            ngx_pfree(pool, ctpl);
+        }
+
+        if (cap) {
+            ngx_pfree(pool, cap);
+        }
+    }
+
+    lua_pushinteger(L, count);
+    return 2;
+
+error:
+    if (!(flags & NGX_LUA_RE_COMPILE_ONCE)) {
+        if (sd) {
+            ngx_http_lua_regex_free_study_data(pool, sd);
+        }
+
+        if (re_comp.regex) {
+            ngx_pfree(pool, re_comp.regex);
+        }
+
+        if (ctpl) {
+            ngx_pfree(pool, ctpl);
+        }
+
+        if (cap) {
+            ngx_pfree(pool, cap);
+        }
+    }
+
+    lua_pushnil(L);
+    lua_pushnil(L);
+    lua_pushstring(L, msg);
+    return 3;
+}
+
+
+void
+ngx_http_lua_inject_regex_api(lua_State *L)
+{
+    /* ngx.re */
+
+    lua_createtable(L, 0, 4 /* nrec */);    /* .re */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_re_match);
+    lua_setfield(L, -2, "match");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_re_gmatch);
+    lua_setfield(L, -2, "gmatch");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_re_sub);
+    lua_setfield(L, -2, "sub");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_re_gsub);
+    lua_setfield(L, -2, "gsub");
+
+    lua_setfield(L, -2, "re");
+}
+
+
+static void
+ngx_http_lua_regex_free_study_data(ngx_pool_t *pool, pcre_extra *sd)
+{
+    ngx_pool_t              *old_pool;
+
+    old_pool = ngx_http_lua_pcre_malloc_init(pool);
+
+#if LUA_HAVE_PCRE_JIT
+    pcre_free_study(sd);
+#else
+    pcre_free(sd);
+#endif
+
+    ngx_http_lua_pcre_malloc_done(old_pool);
+}
+
+
+static ngx_int_t
+ngx_http_lua_regex_compile(ngx_http_lua_regex_compile_t *rc)
+{
+    int           n, erroff;
+    char         *p;
+    const char   *errstr;
+    pcre         *re;
+    ngx_pool_t   *old_pool;
+
+    old_pool = ngx_http_lua_pcre_malloc_init(rc->pool);
+
+    re = pcre_compile((const char *) rc->pattern.data, (int) rc->options,
+                      &errstr, &erroff, NULL);
+
+    ngx_http_lua_pcre_malloc_done(old_pool);
+
+    if (re == NULL) {
+        if ((size_t) erroff == rc->pattern.len) {
+           rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,
+                                      "pcre_compile() failed: %s in \"%V\"",
+                                      errstr, &rc->pattern)
+                         - rc->err.data;
+
+        } else {
+           rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,
+                                      "pcre_compile() failed: %s in \"%V\" "
+                                      "at \"%s\"", errstr, &rc->pattern,
+                                      rc->pattern.data + erroff)
+                         - rc->err.data;
+        }
+
+        return NGX_ERROR;
+    }
+
+    rc->regex = re;
+
+#if 1
+    n = pcre_fullinfo(re, NULL, PCRE_INFO_CAPTURECOUNT, &rc->captures);
+    if (n < 0) {
+        p = "pcre_fullinfo(\"%V\", PCRE_INFO_CAPTURECOUNT) failed: %d";
+        goto failed;
+    }
+#endif
+
+    return NGX_OK;
+
+failed:
+
+    rc->err.len = ngx_snprintf(rc->err.data, rc->err.len, p, &rc->pattern, n)
+                  - rc->err.data;
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_ngx_re_gmatch_cleanup(void *data)
+{
+    ngx_http_lua_regex_ctx_t    *ctx = data;
+
+    if (ctx) {
+        if (ctx->regex_sd) {
+            ngx_http_lua_regex_free_study_data(ctx->request->pool,
+                                               ctx->regex_sd);
+            ctx->regex_sd = NULL;
+        }
+
+        if (ctx->cleanup) {
+            *ctx->cleanup = NULL;
+            ctx->cleanup = NULL;
+        }
+
+        ctx->request = NULL;
+    }
+
+    return;
+}
+
+
+static int
+ngx_http_lua_ngx_re_gmatch_gc(lua_State *L)
+{
+    ngx_http_lua_regex_ctx_t    *ctx;
+
+    ctx = lua_touserdata(L, 1);
+
+    if (ctx && ctx->cleanup) {
+        ngx_http_lua_ngx_re_gmatch_cleanup(ctx);
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_re_collect_named_captures(lua_State *L, u_char *name_table,
+    int name_count, int name_entry_size, unsigned flags, ngx_str_t *subj)
+{
+    int              i, n;
+    size_t           len;
+    u_char          *name_entry;
+    char            *name;
+
+    for (i = 0; i < name_count; i++) {
+        dd("top: %d", lua_gettop(L));
+
+        name_entry = &name_table[i * name_entry_size];
+        n = (name_entry[0] << 8) | name_entry[1];
+        name = (char *) &name_entry[2];
+
+        lua_rawgeti(L, -1, n);
+        if (lua_isnil(L, -1)) {
+            lua_pop(L, 1);
+            continue;
+        }
+
+        if (flags & NGX_LUA_RE_MODE_DUPNAMES) {
+
+            lua_getfield(L, -2, name); /* big_tb cap small_tb */
+
+            if (lua_isnil(L, -1)) {
+                lua_pop(L, 1);
+
+                /* assuming named submatches are usually unique */
+                lua_createtable(L, 1 /* narr */, 0 /* nrec */);
+                lua_pushstring(L, name);
+                lua_pushvalue(L, -2); /* big_tb cap small_tb key small_tb */
+                lua_rawset(L, -5); /* big_tb cap small_tb */
+                len = 0;
+
+            } else {
+                len = lua_objlen(L, -1);
+            }
+
+            lua_pushvalue(L, -2); /* big_tb cap small_tb cap */
+            lua_rawseti(L, -2, (int) len + 1); /* big_tb cap small_tb */
+            lua_pop(L, 2);
+
+        } else {
+            lua_pushstring(L, name); /* big_tb cap key */
+            lua_pushvalue(L, -2); /* big_tb cap key cap */
+            lua_rawset(L, -4); /* big_tb cap */
+            lua_pop(L, 1);
+        }
+
+        dd("top 2: %d", lua_gettop(L));
+    }
+}
+
+#endif /* NGX_PCRE */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_regex.h b/src/lua/lua-nginx-module/src/ngx_http_lua_regex.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_regex.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_regex.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,22 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_REGEX_H_INCLUDED_
+#define _NGX_HTTP_LUA_REGEX_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+#include "ngx_http_lua_script.h"
+
+
+#if (NGX_PCRE)
+void ngx_http_lua_inject_regex_api(lua_State *L);
+#endif
+
+
+#endif /* _NGX_HTTP_LUA_REGEX_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.c b/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,1165 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+#include "ngx_http_lua_req_body.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_headers_in.h"
+
+
+static int ngx_http_lua_ngx_req_read_body(lua_State *L);
+static void ngx_http_lua_req_body_post_read(ngx_http_request_t *r);
+static int ngx_http_lua_ngx_req_discard_body(lua_State *L);
+static int ngx_http_lua_ngx_req_get_body_data(lua_State *L);
+static int ngx_http_lua_ngx_req_get_body_file(lua_State *L);
+static int ngx_http_lua_ngx_req_set_body_data(lua_State *L);
+static void ngx_http_lua_pool_cleanup_file(ngx_pool_t *p, ngx_fd_t fd);
+static int ngx_http_lua_ngx_req_set_body_file(lua_State *L);
+
+static int ngx_http_lua_ngx_req_init_body(lua_State *L);
+static int ngx_http_lua_ngx_req_append_body(lua_State *L);
+static int ngx_http_lua_ngx_req_body_finish(lua_State *L);
+static ngx_int_t ngx_http_lua_write_request_body(ngx_http_request_t *r,
+    ngx_chain_t *body);
+static ngx_int_t ngx_http_lua_read_body_resume(ngx_http_request_t *r);
+static void ngx_http_lua_req_body_cleanup(void *data);
+
+
+
+void
+ngx_http_lua_inject_req_body_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_read_body);
+    lua_setfield(L, -2, "read_body");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_discard_body);
+    lua_setfield(L, -2, "discard_body");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_body_data);
+    lua_setfield(L, -2, "get_body_data");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_body_file);
+    lua_setfield(L, -2, "get_body_file");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_set_body_data);
+    lua_setfield(L, -2, "set_body_data");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_set_body_file);
+    lua_setfield(L, -2, "set_body_file");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_init_body);
+    lua_setfield(L, -2, "init_body");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_append_body);
+    lua_setfield(L, -2, "append_body");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_body_finish);
+    lua_setfield(L, -2, "finish_body");
+}
+
+
+static int
+ngx_http_lua_ngx_req_read_body(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+    ngx_int_t                    rc;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    n = lua_gettop(L);
+
+    if (n != 0) {
+        return luaL_error(L, "expecting 0 arguments but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    r->request_body_in_single_buf = 1;
+    r->request_body_in_persistent_file = 1;
+    r->request_body_in_clean_file = 1;
+
+#if 1
+    if (r->request_body_in_file_only) {
+        r->request_body_file_log_level = 0;
+    }
+#endif
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    coctx = ctx->cur_co_ctx;
+    if (coctx == NULL) {
+        return luaL_error(L, "no co ctx found");
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+            "lua start to read buffered request body");
+
+    rc = ngx_http_read_client_request_body(r, ngx_http_lua_req_body_post_read);
+
+#if (nginx_version < 1002006) ||                                             \
+        (nginx_version >= 1003000 && nginx_version < 1003009)
+    r->main->count--;
+#endif
+
+    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        ctx->exit_code = rc;
+        ctx->exited = 1;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "http read client request body returned error code %i, "
+                       "exitting now", rc);
+
+        return lua_yield(L, 0);
+    }
+
+#if (nginx_version >= 1002006 && nginx_version < 1003000) ||                 \
+        nginx_version >= 1003009
+    r->main->count--;
+    dd("decrement r->main->count: %d", (int) r->main->count);
+#endif
+
+    if (rc == NGX_AGAIN) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua read buffered request body requires I/O "
+                       "interruptions");
+
+        ctx->waiting_more_body = 1;
+        ctx->downstream_co_ctx = coctx;
+
+        coctx->cleanup = ngx_http_lua_req_body_cleanup;
+        coctx->data = r;
+
+        return lua_yield(L, 0);
+    }
+
+    /* rc == NGX_OK */
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua has read buffered request body in a single run");
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_req_body_post_read(ngx_http_request_t *r)
+{
+    ngx_http_lua_ctx_t      *ctx;
+    ngx_http_lua_co_ctx_t   *coctx;
+
+    ngx_http_lua_loc_conf_t             *llcf;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua req body post read, c:%ud", r->main->count);
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (ctx->waiting_more_body) {
+        ctx->waiting_more_body = 0;
+
+        coctx = ctx->downstream_co_ctx;
+        ctx->cur_co_ctx = coctx;
+
+        coctx->cleanup = NULL;
+
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->check_client_abort) {
+            r->read_event_handler = ngx_http_lua_rd_check_broken_connection;
+
+        } else {
+            r->read_event_handler = ngx_http_block_reading;
+        }
+
+        if (ctx->entered_content_phase) {
+            (void) ngx_http_lua_read_body_resume(r);
+
+        } else {
+            ctx->resume_handler = ngx_http_lua_read_body_resume;
+            ngx_http_core_run_phases(r);
+        }
+    }
+}
+
+
+static int
+ngx_http_lua_ngx_req_discard_body(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_int_t                    rc;
+    int                          n;
+
+    n = lua_gettop(L);
+
+    if (n != 0) {
+        return luaL_error(L, "expecting 0 arguments but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    rc = ngx_http_discard_request_body(r);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return luaL_error(L, "failed to discard request body");
+    }
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_req_get_body_data(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+    size_t                       len;
+    ngx_chain_t                 *cl;
+    u_char                      *p;
+    u_char                      *buf;
+
+    n = lua_gettop(L);
+
+    if (n != 0) {
+        return luaL_error(L, "expecting 0 arguments but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->request_body == NULL
+        || r->request_body->temp_file
+        || r->request_body->bufs == NULL)
+    {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    cl = r->request_body->bufs;
+
+    if (cl->next == NULL) {
+        len = cl->buf->last - cl->buf->pos;
+
+        if (len == 0) {
+            lua_pushnil(L);
+            return 1;
+        }
+
+        lua_pushlstring(L, (char *) cl->buf->pos, len);
+        return 1;
+    }
+
+    /* found multi-buffer body */
+
+    len = 0;
+
+    for (; cl; cl = cl->next) {
+        dd("body chunk len: %d", (int) ngx_buf_size(cl->buf));
+        len += cl->buf->last - cl->buf->pos;
+    }
+
+    if (len == 0) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    buf = (u_char *) lua_newuserdata(L, len);
+
+    p = buf;
+    for (cl = r->request_body->bufs; cl; cl = cl->next) {
+        p = ngx_copy(p, cl->buf->pos, cl->buf->last - cl->buf->pos);
+    }
+
+    lua_pushlstring(L, (char *) buf, len);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_req_get_body_file(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+
+    n = lua_gettop(L);
+
+    if (n != 0) {
+        return luaL_error(L, "expecting 0 arguments but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->request_body == NULL || r->request_body->temp_file == NULL) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    dd("XXX file directio: %u, f:%u, m:%u, t:%u, end - pos %d, size %d",
+       r->request_body->temp_file->file.directio,
+       r->request_body->bufs->buf->in_file,
+       r->request_body->bufs->buf->memory,
+       r->request_body->bufs->buf->temporary,
+       (int) (r->request_body->bufs->buf->end -
+       r->request_body->bufs->buf->pos),
+       (int) ngx_buf_size(r->request_body->bufs->buf));
+
+    lua_pushlstring(L, (char *) r->request_body->temp_file->file.name.data,
+                    r->request_body->temp_file->file.name.len);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_req_set_body_data(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+    ngx_http_request_body_t     *rb;
+    ngx_temp_file_t             *tf;
+    ngx_buf_t                   *b;
+    ngx_str_t                    body, key, value;
+#if 1
+    ngx_int_t                    rc;
+#endif
+    ngx_chain_t                 *cl;
+    ngx_buf_tag_t                tag;
+
+    n = lua_gettop(L);
+
+    if (n != 1) {
+        return luaL_error(L, "expecting 1 arguments but seen %d", n);
+    }
+
+    body.data = (u_char *) luaL_checklstring(L, 1, &body.len);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->discard_body) {
+        return luaL_error(L, "request body already discarded asynchronously");
+    }
+
+    if (r->request_body == NULL) {
+        return luaL_error(L, "request body not read yet");
+    }
+
+    rb = r->request_body;
+
+    tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+    tf = rb->temp_file;
+
+    if (tf) {
+        if (tf->file.fd != NGX_INVALID_FILE) {
+
+            dd("cleaning temp file %.*s", (int) tf->file.name.len,
+               tf->file.name.data);
+
+            ngx_http_lua_pool_cleanup_file(r->pool, tf->file.fd);
+            tf->file.fd = NGX_INVALID_FILE;
+
+            dd("temp file cleaned: %.*s", (int) tf->file.name.len,
+               tf->file.name.data);
+        }
+
+        rb->temp_file = NULL;
+    }
+
+    if (body.len == 0) {
+
+        if (rb->bufs) {
+
+            for (cl = rb->bufs; cl; cl = cl->next) {
+                if (cl->buf->tag == tag && cl->buf->temporary) {
+
+                    dd("free old request body buffer: size:%d",
+                       (int) ngx_buf_size(cl->buf));
+
+                    ngx_pfree(r->pool, cl->buf->start);
+                    cl->buf->tag = (ngx_buf_tag_t) NULL;
+                    cl->buf->temporary = 0;
+                }
+            }
+        }
+
+        rb->bufs = NULL;
+        rb->buf = NULL;
+
+        dd("request body is set to empty string");
+        goto set_header;
+    }
+
+    if (rb->bufs) {
+
+        for (cl = rb->bufs; cl; cl = cl->next) {
+            if (cl->buf->tag == tag && cl->buf->temporary) {
+                dd("free old request body buffer: size:%d",
+                   (int) ngx_buf_size(cl->buf));
+
+                ngx_pfree(r->pool, cl->buf->start);
+                cl->buf->tag = (ngx_buf_tag_t) NULL;
+                cl->buf->temporary = 0;
+            }
+        }
+
+        rb->bufs->next = NULL;
+
+        b = rb->bufs->buf;
+
+        ngx_memzero(b, sizeof(ngx_buf_t));
+
+        b->temporary = 1;
+        b->tag = tag;
+
+        b->start = ngx_palloc(r->pool, body.len);
+        if (b->start == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+        b->end = b->start + body.len;
+
+        b->pos = b->start;
+        b->last = ngx_copy(b->pos, body.data, body.len);
+
+    } else {
+
+        rb->bufs = ngx_alloc_chain_link(r->pool);
+        if (rb->bufs == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+        rb->bufs->next = NULL;
+
+        b = ngx_create_temp_buf(r->pool, body.len);
+        b->tag = tag;
+        b->last = ngx_copy(b->pos, body.data, body.len);
+
+        rb->bufs->buf = b;
+        rb->buf = b;
+    }
+
+set_header:
+
+    /* override input header Content-Length (value must be null terminated) */
+
+    value.data = ngx_palloc(r->pool, NGX_SIZE_T_LEN + 1);
+    if (value.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    value.len = ngx_sprintf(value.data, "%uz", body.len) - value.data;
+    value.data[value.len] = '\0';
+
+    dd("setting request Content-Length to %.*s (%d)",
+       (int) value.len, value.data, (int) body.len);
+
+    r->headers_in.content_length_n = body.len;
+
+    if (r->headers_in.content_length) {
+        r->headers_in.content_length->value.data = value.data;
+        r->headers_in.content_length->value.len = value.len;
+
+    } else {
+
+        ngx_str_set(&key, "Content-Length");
+
+        rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */);
+        if (rc != NGX_OK) {
+            return luaL_error(L, "failed to reset the Content-Length "
+                              "input header");
+        }
+    }
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_req_init_body(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+    ngx_http_request_body_t     *rb;
+    size_t                       size;
+    lua_Integer                  num;
+#if 1
+    ngx_temp_file_t             *tf;
+#endif
+    ngx_http_core_loc_conf_t    *clcf;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 0) {
+        return luaL_error(L, "expecting 0 or 1 argument but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->discard_body) {
+        return luaL_error(L, "request body already discarded asynchronously");
+    }
+
+    if (r->request_body == NULL) {
+        return luaL_error(L, "request body not read yet");
+    }
+
+    if (n == 1) {
+        num = luaL_checkinteger(L, 1);
+        if (num <= 0) {
+            return luaL_error(L, "bad size argument: %d", (int) num);
+        }
+
+        size = (size_t) num;
+
+    } else {
+
+        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+        size = clcf->client_body_buffer_size;
+
+        size += size >> 2;
+
+        /* avoid allocating an unnecessary large buffer */
+        if (size > (size_t) r->headers_in.content_length_n) {
+            size = (size_t) r->headers_in.content_length_n;
+        }
+    }
+
+    rb = r->request_body;
+
+#if 1
+    tf = rb->temp_file;
+
+    if (tf) {
+        if (tf->file.fd != NGX_INVALID_FILE) {
+
+            dd("cleaning temp file %.*s", (int) tf->file.name.len,
+               tf->file.name.data);
+
+            ngx_http_lua_pool_cleanup_file(r->pool, tf->file.fd);
+
+            ngx_memzero(tf, sizeof(ngx_temp_file_t));
+
+            tf->file.fd = NGX_INVALID_FILE;
+
+            dd("temp file cleaned: %.*s", (int) tf->file.name.len,
+               tf->file.name.data);
+        }
+
+        rb->temp_file = NULL;
+    }
+#endif
+
+    r->request_body_in_clean_file = 1;
+
+    r->headers_in.content_length_n = 0;
+
+    rb->buf = ngx_create_temp_buf(r->pool, size);
+    if (rb->buf == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    rb->bufs = ngx_alloc_chain_link(r->pool);
+    if (rb->bufs == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    rb->bufs->buf = rb->buf;
+    rb->bufs->next = NULL;
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_req_append_body(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+    ngx_http_request_body_t     *rb;
+    ngx_str_t                   body;
+    size_t                      size, rest;
+    size_t                      offset = 0;
+
+    n = lua_gettop(L);
+
+    if (n != 1) {
+        return luaL_error(L, "expecting 1 arguments but seen %d", n);
+    }
+
+    body.data = (u_char *) luaL_checklstring(L, 1, &body.len);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->request_body == NULL
+        || r->request_body->buf == NULL
+        || r->request_body->bufs == NULL)
+    {
+        return luaL_error(L, "request_body not initalized");
+    }
+
+    rb = r->request_body;
+
+    rest = body.len;
+
+    while (rest > 0) {
+        if (rb->buf->last == rb->buf->end) {
+            if (ngx_http_lua_write_request_body(r, rb->bufs) != NGX_OK) {
+                return luaL_error(L, "fail to write file");
+            }
+
+            rb->buf->last = rb->buf->start;
+        }
+
+        size = rb->buf->end - rb->buf->last;
+
+        if (size > rest) {
+            size = rest;
+        }
+
+        ngx_memcpy(rb->buf->last, body.data + offset, size);
+
+        rb->buf->last += size;
+        rest -= size;
+        offset += size;
+        r->headers_in.content_length_n += size;
+    }
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_req_body_finish(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    int                          n;
+    ngx_http_request_body_t     *rb;
+    ngx_buf_t                   *b;
+    size_t                      size;
+    ngx_str_t                   value;
+    ngx_str_t                   key;
+    ngx_int_t                   rc;
+
+    n = lua_gettop(L);
+
+    if (n != 0) {
+        return luaL_error(L, "expecting 0 argument but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->request_body == NULL
+        || r->request_body->buf == NULL
+        || r->request_body->bufs == NULL)
+    {
+        return luaL_error(L, "request_body not initalized");
+    }
+
+    rb = r->request_body;
+
+    if (rb->temp_file) {
+
+        /* save the last part */
+
+        if (ngx_http_lua_write_request_body(r, rb->bufs) != NGX_OK) {
+            return luaL_error(L, "fail to write file");
+        }
+
+        b = ngx_calloc_buf(r->pool);
+        if (b == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        b->in_file = 1;
+        b->file_pos = 0;
+        b->file_last = rb->temp_file->file.offset;
+        b->file = &rb->temp_file->file;
+
+        if (rb->bufs->next) {
+            rb->bufs->next->buf = b;
+
+        } else {
+            rb->bufs->buf = b;
+        }
+    }
+
+    /* override input header Content-Length (value must be null terminated) */
+
+    value.data = ngx_palloc(r->pool, NGX_SIZE_T_LEN + 1);
+    if (value.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    size = (size_t) r->headers_in.content_length_n;
+
+    value.len = ngx_sprintf(value.data, "%uz", size) - value.data;
+    value.data[value.len] = '\0';
+
+    dd("setting request Content-Length to %.*s (%d)", (int) value.len,
+       value.data, (int) size);
+
+    if (r->headers_in.content_length) {
+        r->headers_in.content_length->value.data = value.data;
+        r->headers_in.content_length->value.len = value.len;
+
+    } else {
+
+        ngx_str_set(&key, "Content-Length");
+
+        rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */);
+        if (rc != NGX_OK) {
+            return luaL_error(L, "failed to reset the Content-Length "
+                              "input header");
+        }
+    }
+
+    return 0;
+
+}
+
+
+static void
+ngx_http_lua_pool_cleanup_file(ngx_pool_t *p, ngx_fd_t fd)
+{
+    ngx_pool_cleanup_t       *c;
+    ngx_pool_cleanup_file_t  *cf;
+
+    for (c = p->cleanup; c; c = c->next) {
+        if (c->handler == ngx_pool_cleanup_file
+            || c->handler == ngx_pool_delete_file)
+        {
+
+            cf = c->data;
+
+            if (cf->fd == fd) {
+                c->handler(cf);
+                c->handler = NULL;
+                return;
+            }
+        }
+    }
+}
+
+
+static int
+ngx_http_lua_ngx_req_set_body_file(lua_State *L)
+{
+    u_char                      *p;
+    ngx_http_request_t          *r;
+    int                          n;
+    ngx_http_request_body_t     *rb;
+    ngx_temp_file_t             *tf;
+    ngx_buf_t                   *b;
+    ngx_str_t                    name;
+    ngx_int_t                    rc;
+    int                          clean;
+    ngx_open_file_info_t         of;
+    ngx_str_t                    key, value;
+    ngx_pool_cleanup_t          *cln;
+    ngx_pool_cleanup_file_t     *clnf;
+    ngx_err_t                    err;
+    ngx_chain_t                 *cl;
+    ngx_buf_tag_t                tag;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting 1 or 2 arguments but seen %d", n);
+    }
+
+    p = (u_char *) luaL_checklstring(L, 1, &name.len);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    if (r->discard_body) {
+        return luaL_error(L, "request body already discarded asynchronously");
+    }
+
+    if (r->request_body == NULL) {
+        return luaL_error(L, "request body not read yet");
+    }
+
+    name.data = ngx_palloc(r->pool, name.len + 1);
+    if (name.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(name.data, p, name.len);
+    name.data[name.len] = '\0';
+
+    if (n == 2) {
+        luaL_checktype(L, 2, LUA_TBOOLEAN);
+        clean = lua_toboolean(L, 2);
+
+    } else {
+        clean = 0;
+    }
+
+    dd("clean: %d", (int) clean);
+
+    rb = r->request_body;
+
+    /* clean up existing r->request_body->bufs (if any) */
+
+    tag = (ngx_buf_tag_t) &ngx_http_lua_module;
+
+    if (rb->bufs) {
+        dd("XXX reusing buf");
+
+        for (cl = rb->bufs; cl; cl = cl->next) {
+            if (cl->buf->tag == tag && cl->buf->temporary) {
+                dd("free old request body buffer: size:%d",
+                   (int) ngx_buf_size(cl->buf));
+
+                ngx_pfree(r->pool, cl->buf->start);
+                cl->buf->tag = (ngx_buf_tag_t) NULL;
+                cl->buf->temporary = 0;
+            }
+        }
+
+        rb->bufs->next = NULL;
+        b = rb->bufs->buf;
+
+        ngx_memzero(b, sizeof(ngx_buf_t));
+
+        b->tag = tag;
+        rb->buf = NULL;
+
+    } else {
+
+        dd("XXX creating new buf");
+
+        rb->bufs = ngx_alloc_chain_link(r->pool);
+        if (rb->bufs == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+        rb->bufs->next = NULL;
+
+        b = ngx_calloc_buf(r->pool);
+        if (b == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        b->tag = tag;
+
+        rb->bufs->buf = b;
+        rb->buf = NULL;
+    }
+
+    b->last_in_chain = 1;
+
+    /* just make r->request_body->temp_file a bare stub */
+
+    tf = rb->temp_file;
+
+    if (tf) {
+        if (tf->file.fd != NGX_INVALID_FILE) {
+
+            dd("cleaning temp file %.*s", (int) tf->file.name.len,
+               tf->file.name.data);
+
+            ngx_http_lua_pool_cleanup_file(r->pool, tf->file.fd);
+
+            ngx_memzero(tf, sizeof(ngx_temp_file_t));
+
+            tf->file.fd = NGX_INVALID_FILE;
+
+            dd("temp file cleaned: %.*s", (int) tf->file.name.len,
+               tf->file.name.data);
+        }
+
+    } else {
+
+        tf = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t));
+        if (tf == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        tf->file.fd = NGX_INVALID_FILE;
+        rb->temp_file = tf;
+    }
+
+    /* read the file info and construct an in-file buf */
+
+    ngx_memzero(&of, sizeof(ngx_open_file_info_t));
+
+    of.directio = NGX_OPEN_FILE_DIRECTIO_OFF;
+
+    if (ngx_http_lua_open_and_stat_file(name.data, &of, r->connection->log)
+        != NGX_OK)
+    {
+        return luaL_error(L, "%s \"%s\" failed", of.failed, name.data);
+    }
+
+    dd("XXX new body file fd: %d", of.fd);
+
+    tf->file.fd = of.fd;
+    tf->file.name = name;
+    tf->file.log = r->connection->log;
+    tf->file.directio = 0;
+
+    if (of.size == 0) {
+        if (clean) {
+            if (ngx_delete_file(name.data) == NGX_FILE_ERROR) {
+                err = ngx_errno;
+
+                if (err != NGX_ENOENT) {
+                    ngx_log_error(NGX_LOG_CRIT, r->connection->log, err,
+                                  ngx_delete_file_n " \"%s\" failed",
+                                  name.data);
+                }
+            }
+        }
+
+        if (ngx_close_file(of.fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,
+                          ngx_close_file_n " \"%s\" failed", name.data);
+        }
+
+        r->request_body->bufs = NULL;
+        r->request_body->buf = NULL;
+
+        goto set_header;
+    }
+
+    /* register file cleanup hook */
+
+    cln = ngx_pool_cleanup_add(r->pool,
+                               sizeof(ngx_pool_cleanup_file_t));
+
+    if (cln == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    cln->handler = clean ? ngx_pool_delete_file : ngx_pool_cleanup_file;
+    clnf = cln->data;
+
+    clnf->fd = of.fd;
+    clnf->name = name.data;
+    clnf->log = r->pool->log;
+
+    b->file = &tf->file;
+    if (b->file == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    dd("XXX file size: %d", (int) of.size);
+
+    b->file_pos = 0;
+    b->file_last = of.size;
+
+    b->in_file = 1;
+
+    dd("buf file: %p, f:%u", b->file, b->in_file);
+
+set_header:
+    /* override input header Content-Length (value must be null terminated) */
+
+    value.data = ngx_palloc(r->pool, NGX_OFF_T_LEN + 1);
+    if (value.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    value.len = ngx_sprintf(value.data, "%O", of.size) - value.data;
+    value.data[value.len] = '\0';
+
+    r->headers_in.content_length_n = of.size;
+
+    if (r->headers_in.content_length) {
+        r->headers_in.content_length->value.data = value.data;
+        r->headers_in.content_length->value.len = value.len;
+
+    } else {
+
+        ngx_str_set(&key, "Content-Length");
+
+        rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */);
+        if (rc != NGX_OK) {
+            return luaL_error(L, "failed to reset the Content-Length "
+                              "input header");
+        }
+    }
+
+    return 0;
+}
+
+
+static ngx_int_t
+ngx_http_lua_write_request_body(ngx_http_request_t *r, ngx_chain_t *body)
+{
+    ssize_t                    n;
+    ngx_temp_file_t           *tf;
+    ngx_http_request_body_t   *rb;
+    ngx_http_core_loc_conf_t  *clcf;
+
+    rb = r->request_body;
+
+    if (rb->temp_file == NULL) {
+        tf = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t));
+        if (tf == NULL) {
+            return NGX_ERROR;
+        }
+
+        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+        tf->file.fd = NGX_INVALID_FILE;
+        tf->file.log = r->connection->log;
+        tf->path = clcf->client_body_temp_path;
+        tf->pool = r->pool;
+        tf->warn = "a client request body is buffered to a temporary file";
+        tf->log_level = r->request_body_file_log_level;
+        tf->persistent = 1;
+        tf->clean = 1;
+
+        if (r->request_body_file_group_access) {
+            tf->access = 0660;
+        }
+
+        rb->temp_file = tf;
+
+        if (body == NULL) {
+            /* empty body with r->request_body_in_file_only */
+
+            if (ngx_create_temp_file(&tf->file, tf->path, tf->pool,
+                                     tf->persistent, tf->clean, tf->access)
+                != NGX_OK)
+            {
+                return NGX_ERROR;
+            }
+
+            return NGX_OK;
+        }
+    }
+
+    n = ngx_write_chain_to_temp_file(rb->temp_file, body);
+
+    /* TODO: n == 0 or not complete and level event */
+
+    if (n == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    rb->temp_file->offset += n;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_read_body_resume(ngx_http_request_t *r)
+{
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    c = r->connection;
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, 0);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
+static void
+ngx_http_lua_req_body_cleanup(void *data)
+{
+    ngx_http_request_t                  *r;
+    ngx_http_lua_ctx_t                  *ctx;
+    ngx_http_lua_co_ctx_t               *coctx = data;
+
+    r = coctx->data;
+    if (r == NULL) {
+        return;
+    }
+
+    if (r->connection->read->timer_set) {
+        ngx_del_timer(r->connection->read);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return;
+    }
+
+    ctx->waiting_more_body = 0;
+    r->keepalive = 0;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.h b/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_req_body.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_REQ_BODY_H_INCLUDED_
+#define _NGX_HTTP_LUA_REQ_BODY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_req_body_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_REQ_BODY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.c b/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,148 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+
+
+#include "ddebug.h"
+#include "ngx_http_lua_req_method.h"
+#include "ngx_http_lua_subrequest.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_ngx_req_get_method(lua_State *L);
+static int ngx_http_lua_ngx_req_set_method(lua_State *L);
+
+
+void
+ngx_http_lua_inject_req_method_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_get_method);
+    lua_setfield(L, -2, "get_method");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_set_method);
+    lua_setfield(L, -2, "set_method");
+}
+
+
+static int
+ngx_http_lua_ngx_req_get_method(lua_State *L)
+{
+    int                      n;
+    ngx_http_request_t      *r;
+
+    n = lua_gettop(L);
+    if (n != 0) {
+        return luaL_error(L, "only one argument expected but got %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    lua_pushlstring(L, (char *) r->method_name.data, r->method_name.len);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_req_set_method(lua_State *L)
+{
+    int                  n;
+    int                  method;
+    ngx_http_request_t  *r;
+
+    n = lua_gettop(L);
+    if (n != 1) {
+        return luaL_error(L, "only one argument expected but got %d", n);
+    }
+
+    method = luaL_checkint(L, 1);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    r->method = method;
+
+    switch (method) {
+        case NGX_HTTP_GET:
+            r->method_name = ngx_http_lua_get_method;
+            break;
+
+        case NGX_HTTP_POST:
+            r->method_name = ngx_http_lua_post_method;
+            break;
+
+        case NGX_HTTP_PUT:
+            r->method_name = ngx_http_lua_put_method;
+            break;
+
+        case NGX_HTTP_HEAD:
+            r->method_name = ngx_http_lua_head_method;
+            break;
+
+        case NGX_HTTP_DELETE:
+            r->method_name = ngx_http_lua_delete_method;
+            break;
+
+        case NGX_HTTP_OPTIONS:
+            r->method_name = ngx_http_lua_options_method;
+            break;
+
+        case NGX_HTTP_MKCOL:
+            r->method_name = ngx_http_lua_mkcol_method;
+            break;
+
+        case NGX_HTTP_COPY:
+            r->method_name = ngx_http_lua_copy_method;
+            break;
+
+        case NGX_HTTP_MOVE:
+            r->method_name = ngx_http_lua_move_method;
+            break;
+
+        case NGX_HTTP_PROPFIND:
+            r->method_name = ngx_http_lua_propfind_method;
+            break;
+
+        case NGX_HTTP_PROPPATCH:
+            r->method_name = ngx_http_lua_proppatch_method;
+            break;
+
+        case NGX_HTTP_LOCK:
+            r->method_name = ngx_http_lua_lock_method;
+            break;
+
+        case NGX_HTTP_UNLOCK:
+            r->method_name = ngx_http_lua_unlock_method;
+            break;
+
+        case NGX_HTTP_PATCH:
+            r->method_name = ngx_http_lua_patch_method;
+            break;
+
+        case NGX_HTTP_TRACE:
+            r->method_name = ngx_http_lua_trace_method;
+            break;
+
+        default:
+            return luaL_error(L, "unsupported HTTP method: %d", method);
+
+    }
+
+    return 0;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.h b/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_req_method.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,19 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_METHOD_H_INCLUDED_
+#define _NGX_HTTP_LUA_METHOD_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_req_method_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_METHOD_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,319 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+#include <nginx.h>
+#include "ngx_http_lua_rewriteby.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_cache.h"
+
+
+static ngx_int_t ngx_http_lua_rewrite_by_chunk(lua_State *L,
+    ngx_http_request_t *r);
+
+
+ngx_int_t
+ngx_http_lua_rewrite_handler(ngx_http_request_t *r)
+{
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    /* XXX we need to take into account ngx_rewrite's location dump */
+    if (r->uri_changed) {
+        return NGX_DECLINED;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua rewrite handler, uri:\"%V\" c:%ud", &r->uri,
+                   r->main->count);
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    if (!lmcf->postponed_to_rewrite_phase_end) {
+        ngx_http_core_main_conf_t       *cmcf;
+        ngx_http_phase_handler_t        tmp;
+        ngx_http_phase_handler_t        *ph;
+        ngx_http_phase_handler_t        *cur_ph;
+        ngx_http_phase_handler_t        *last_ph;
+
+        lmcf->postponed_to_rewrite_phase_end = 1;
+
+        cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+        ph = cmcf->phase_engine.handlers;
+        cur_ph = &ph[r->phase_handler];
+        last_ph = &ph[cur_ph->next - 1];
+
+#if 0
+        if (cur_ph == last_ph) {
+            dd("XXX our handler is already the last rewrite phase handler");
+        }
+#endif
+
+        if (cur_ph < last_ph) {
+            dd("swaping the contents of cur_ph and last_ph...");
+
+            tmp      = *cur_ph;
+
+            memmove(cur_ph, cur_ph + 1,
+                (last_ph - cur_ph) * sizeof (ngx_http_phase_handler_t));
+
+            *last_ph = tmp;
+
+            r->phase_handler--; /* redo the current ph */
+
+            return NGX_DECLINED;
+        }
+    }
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->rewrite_handler == NULL) {
+        dd("no rewrite handler found");
+        return NGX_DECLINED;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+    }
+
+    dd("entered? %d", (int) ctx->entered_rewrite_phase);
+
+    if (ctx->entered_rewrite_phase) {
+        dd("rewriteby: calling wev handler");
+        rc = ctx->resume_handler(r);
+        dd("rewriteby: wev handler returns %d", (int) rc);
+
+        if (rc == NGX_OK) {
+            return NGX_DECLINED;
+        }
+
+        return rc;
+    }
+
+    if (ctx->waiting_more_body) {
+        return NGX_DONE;
+    }
+
+    if (llcf->force_read_body && !ctx->read_body_done) {
+        r->request_body_in_single_buf = 1;
+        r->request_body_in_persistent_file = 1;
+        r->request_body_in_clean_file = 1;
+
+        rc = ngx_http_read_client_request_body(r,
+                                       ngx_http_lua_generic_phase_post_read);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+#if (nginx_version < 1002006) ||                                             \
+        (nginx_version >= 1003000 && nginx_version < 1003009)
+            r->main->count--;
+#endif
+
+            return rc;
+        }
+
+        if (rc == NGX_AGAIN) {
+            ctx->waiting_more_body = 1;
+            return NGX_DONE;
+        }
+    }
+
+    dd("calling rewrite handler");
+    return llcf->rewrite_handler(r);
+}
+
+
+ngx_int_t
+ngx_http_lua_rewrite_handler_inline(ngx_http_request_t *r)
+{
+    lua_State                   *L;
+    ngx_int_t                    rc;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    dd("rewrite by lua inline");
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    L = lmcf->lua;
+
+    /*  load Lua inline script (w/ cache) sp = 1 */
+    rc = ngx_http_lua_cache_loadbuffer(L, llcf->rewrite_src.value.data,
+                                       llcf->rewrite_src.value.len,
+                                       llcf->rewrite_src_key,
+                                       "rewrite_by_lua",
+                                       llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    return ngx_http_lua_rewrite_by_chunk(L, r);
+}
+
+
+ngx_int_t
+ngx_http_lua_rewrite_handler_file(ngx_http_request_t *r)
+{
+    lua_State                       *L;
+    ngx_int_t                        rc;
+    u_char                          *script_path;
+    ngx_http_lua_main_conf_t        *lmcf;
+    ngx_http_lua_loc_conf_t         *llcf;
+    ngx_str_t                        eval_src;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (ngx_http_complex_value(r, &llcf->rewrite_src, &eval_src) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    script_path = ngx_http_lua_rebase_path(r->pool, eval_src.data,
+                                           eval_src.len);
+
+    if (script_path == NULL) {
+        return NGX_ERROR;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+    L = lmcf->lua;
+
+    /*  load Lua script file (w/ cache)        sp = 1 */
+    rc = ngx_http_lua_cache_loadfile(L, script_path, llcf->rewrite_src_key,
+                                     llcf->enable_code_cache ? 1 : 0);
+
+    if (rc != NGX_OK) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    return ngx_http_lua_rewrite_by_chunk(L, r);
+}
+
+
+static ngx_int_t
+ngx_http_lua_rewrite_by_chunk(lua_State *L, ngx_http_request_t *r)
+{
+    int                      co_ref;
+    lua_State               *co;
+    ngx_int_t                rc;
+    ngx_connection_t        *c;
+    ngx_http_lua_ctx_t      *ctx;
+    ngx_http_cleanup_t      *cln;
+
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    /*  {{{ new coroutine to handle request */
+    co = ngx_http_lua_new_thread(r, L, &co_ref);
+
+    if (co == NULL) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "lua: failed to create new coroutine to handle request");
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    /*  move code closure to new coroutine */
+    lua_xmove(L, co, 1);
+
+    /*  set closure's env table to new coroutine's globals table */
+    lua_pushvalue(co, LUA_GLOBALSINDEX);
+    lua_setfenv(co, -2);
+
+    /*  save nginx request in coroutine globals table */
+    ngx_http_lua_set_req(co, r);
+
+    /*  {{{ initialize request context */
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    dd("ctx = %p", ctx);
+
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_http_lua_reset_ctx(r, L, ctx);
+
+    ctx->entered_rewrite_phase = 1;
+
+    ctx->cur_co_ctx = &ctx->entry_co_ctx;
+    ctx->cur_co_ctx->co = co;
+    ctx->cur_co_ctx->co_ref = co_ref;
+
+    /*  }}} */
+
+    /*  {{{ register request cleanup hooks */
+    if (ctx->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        cln->handler = ngx_http_lua_request_cleanup_handler;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+    }
+    /*  }}} */
+
+    ctx->context = NGX_HTTP_LUA_CONTEXT_REWRITE;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->check_client_abort) {
+        r->read_event_handler = ngx_http_lua_rd_check_broken_connection;
+
+    } else {
+        r->read_event_handler = ngx_http_block_reading;
+    }
+
+    rc = ngx_http_lua_run_thread(L, r, ctx, 0);
+
+    if (rc == NGX_ERROR || rc > NGX_OK) {
+        return rc;
+    }
+
+    c = r->connection;
+
+    if (rc == NGX_AGAIN) {
+        rc = ngx_http_lua_run_posted_threads(c, L, r, ctx);
+
+        if (rc == NGX_OK) {
+            return NGX_DECLINED;
+        }
+
+        return rc;
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        rc = ngx_http_lua_run_posted_threads(c, L, r, ctx);
+
+        if (rc == NGX_OK) {
+            return NGX_DECLINED;
+        }
+
+        return rc;
+    }
+
+    return NGX_DECLINED;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_rewriteby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,22 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_REWRITEBY_H_INCLUDED_
+#define _NGX_HTTP_LUA_REWRITEBY_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_rewrite_handler(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_rewrite_handler_inline(ngx_http_request_t *r);
+ngx_int_t ngx_http_lua_rewrite_handler_file(ngx_http_request_t *r);
+
+
+#endif /* _NGX_HTTP_LUA_REWRITEBY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_script.c b/src/lua/lua-nginx-module/src/ngx_http_lua_script.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_script.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_script.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,538 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_script.h"
+
+
+static void * ngx_http_lua_script_add_code(ngx_array_t *codes, size_t size);
+static size_t ngx_http_lua_script_copy_len_code(
+    ngx_http_lua_script_engine_t *e);
+static void ngx_http_lua_script_copy_code(ngx_http_lua_script_engine_t *e);
+static ngx_int_t ngx_http_lua_script_add_copy_code(
+    ngx_http_lua_script_compile_t *sc, ngx_str_t *value, ngx_uint_t last);
+static ngx_int_t ngx_http_lua_script_compile(ngx_http_lua_script_compile_t *sc);
+static ngx_int_t ngx_http_lua_script_add_capture_code(
+    ngx_http_lua_script_compile_t *sc, ngx_uint_t n);
+static size_t ngx_http_lua_script_copy_capture_len_code(
+    ngx_http_lua_script_engine_t *e);
+static void ngx_http_lua_script_copy_capture_code(
+    ngx_http_lua_script_engine_t *e);
+static ngx_int_t ngx_http_lua_script_done(ngx_http_lua_script_compile_t *sc);
+static ngx_int_t ngx_http_lua_script_init_arrays(
+    ngx_http_lua_script_compile_t *sc);
+
+
+ngx_int_t
+ngx_http_lua_compile_complex_value(ngx_http_lua_compile_complex_value_t *ccv)
+{
+    ngx_str_t                  *v;
+    ngx_uint_t                  i, n, nv;
+    ngx_array_t                 lengths, values, *pl, *pv;
+
+    ngx_http_lua_script_compile_t   sc;
+
+    v = ccv->value;
+
+    nv = 0;
+
+    for (i = 0; i < v->len; i++) {
+        if (v->data[i] == '$') {
+            nv++;
+        }
+    }
+
+    ccv->complex_value->value = *v;
+    ccv->complex_value->lengths = NULL;
+    ccv->complex_value->values = NULL;
+
+    if (nv == 0) {
+        return NGX_OK;
+    }
+
+    n = nv * (2 * sizeof(ngx_http_lua_script_copy_code_t)
+                  + sizeof(ngx_http_lua_script_capture_code_t))
+        + sizeof(uintptr_t);
+
+    if (ngx_array_init(&lengths, ccv->pool, n, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    n = (nv * (2 * sizeof(ngx_http_lua_script_copy_code_t)
+                   + sizeof(ngx_http_lua_script_capture_code_t))
+                + sizeof(uintptr_t)
+                + sizeof(uintptr_t) - 1)
+            & ~(sizeof(uintptr_t) - 1);
+
+    if (ngx_array_init(&values, ccv->pool, n, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    pl = &lengths;
+    pv = &values;
+
+    ngx_memzero(&sc, sizeof(ngx_http_lua_script_compile_t));
+
+    sc.pool = ccv->pool;
+    sc.log = ccv->log;
+    sc.source = v;
+    sc.lengths = &pl;
+    sc.values = &pv;
+    sc.complete_lengths = 1;
+    sc.complete_values = 1;
+
+    if (ngx_http_lua_script_compile(&sc) != NGX_OK) {
+        ngx_array_destroy(&lengths);
+        ngx_array_destroy(&values);
+        return NGX_ERROR;
+    }
+
+    ccv->complex_value->lengths = lengths.elts;
+    ccv->complex_value->values = values.elts;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_complex_value(ngx_http_request_t *r, ngx_str_t *subj,
+    size_t offset, ngx_int_t count, int *cap,
+    ngx_http_lua_complex_value_t *val, luaL_Buffer *luabuf)
+{
+    size_t                            len;
+    u_char                           *p;
+    ngx_http_lua_script_code_pt       code;
+    ngx_http_lua_script_len_code_pt   lcode;
+    ngx_http_lua_script_engine_t      e;
+
+    if (val->lengths == NULL) {
+        luaL_addlstring(luabuf, (char *) &subj->data[offset], cap[0] - offset);
+        luaL_addlstring(luabuf, (char *) val->value.data, val->value.len);
+
+        return NGX_OK;
+    }
+
+    ngx_memzero(&e, sizeof(ngx_http_lua_script_engine_t));
+
+    e.log = r->connection->log;
+    e.ncaptures = count * 2;
+    e.captures = cap;
+    e.captures_data = subj->data;
+
+    e.ip = val->lengths;
+
+    len = 0;
+
+    while (*(uintptr_t *) e.ip) {
+        lcode = *(ngx_http_lua_script_len_code_pt *) e.ip;
+        len += lcode(&e);
+    }
+
+    p = ngx_pnalloc(r->pool, len);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    e.ip = val->values;
+    e.pos = p;
+
+    while (*(uintptr_t *) e.ip) {
+        code = *(ngx_http_lua_script_code_pt *) e.ip;
+        code((ngx_http_lua_script_engine_t *) &e);
+    }
+
+    luaL_addlstring(luabuf, (char *) &subj->data[offset], cap[0] - offset);
+    luaL_addlstring(luabuf, (char *) p, len);
+
+    ngx_pfree(r->pool, p);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_script_compile(ngx_http_lua_script_compile_t *sc)
+{
+    u_char       ch;
+    ngx_str_t    name;
+    ngx_uint_t   i, bracket;
+    unsigned     num_var;
+    ngx_uint_t   n = 0;
+
+    if (ngx_http_lua_script_init_arrays(sc) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    for (i = 0; i < sc->source->len; /* void */ ) {
+
+        name.len = 0;
+
+        if (sc->source->data[i] == '$') {
+
+            if (++i == sc->source->len) {
+                goto invalid_variable;
+            }
+
+            if (sc->source->data[i] == '$') {
+                name.data = &sc->source->data[i];
+                i++;
+                name.len++;
+
+                if (ngx_http_lua_script_add_copy_code(sc, &name,
+                                                      (i == sc->source->len))
+                    != NGX_OK)
+                {
+                    return NGX_ERROR;
+                }
+
+                continue;
+            }
+
+            if (sc->source->data[i] >= '0' && sc->source->data[i] <= '9') {
+                num_var = 1;
+                n = 0;
+
+            } else {
+                num_var = 0;
+            }
+
+            if (sc->source->data[i] == '{') {
+                bracket = 1;
+
+                if (++i == sc->source->len) {
+                    goto invalid_variable;
+                }
+
+                if (sc->source->data[i] >= '0' && sc->source->data[i] <= '9') {
+                    num_var = 1;
+                    n = 0;
+                }
+
+                name.data = &sc->source->data[i];
+
+            } else {
+                bracket = 0;
+                name.data = &sc->source->data[i];
+            }
+
+            for ( /* void */ ; i < sc->source->len; i++, name.len++) {
+                ch = sc->source->data[i];
+
+                if (ch == '}' && bracket) {
+                    i++;
+                    bracket = 0;
+                    break;
+                }
+
+                if (num_var) {
+                    if (ch >= '0' && ch <= '9') {
+                        n = n * 10 + (ch - '0');
+                        continue;
+                    }
+
+                    break;
+                }
+
+                /* not a number variable like $1, $2, etc */
+
+                if ((ch >= 'A' && ch <= 'Z')
+                    || (ch >= 'a' && ch <= 'z')
+                    || (ch >= '0' && ch <= '9')
+                    || ch == '_')
+                {
+                    continue;
+                }
+
+                break;
+            }
+
+            if (bracket) {
+                ngx_log_error(NGX_LOG_ERR, sc->log, 0,
+                              "the closing bracket in \"%V\" "
+                              "variable is missing", &name);
+                return NGX_ERROR;
+            }
+
+            if (name.len == 0) {
+                goto invalid_variable;
+            }
+
+            if (!num_var) {
+                ngx_log_error(NGX_LOG_ERR, sc->log, 0,
+                              "attempt to use named capturing variable "
+                              "\"%V\" (named captures not supported yet)",
+                              &name);
+
+                return NGX_ERROR;
+            }
+
+            sc->variables++;
+
+            if (ngx_http_lua_script_add_capture_code(sc, n) != NGX_OK) {
+                return NGX_ERROR;
+            }
+
+            continue;
+        }
+
+        name.data = &sc->source->data[i];
+
+        while (i < sc->source->len) {
+
+            if (sc->source->data[i] == '$') {
+                break;
+            }
+
+            i++;
+            name.len++;
+        }
+
+        if (ngx_http_lua_script_add_copy_code(sc, &name, (i == sc->source->len))
+            != NGX_OK)
+        {
+            return NGX_ERROR;
+        }
+    }
+
+    return ngx_http_lua_script_done(sc);
+
+invalid_variable:
+
+    ngx_log_error(NGX_LOG_ERR, sc->log, 0,
+                  "lua script: invalid capturing variable name found in \"%V\"",
+                  sc->source);
+
+    return NGX_ERROR;
+}
+
+
+static ngx_int_t
+ngx_http_lua_script_add_copy_code(ngx_http_lua_script_compile_t *sc,
+    ngx_str_t *value, ngx_uint_t last)
+{
+    size_t                            size, len;
+    ngx_http_lua_script_copy_code_t  *code;
+
+    len = value->len;
+
+    code = ngx_http_lua_script_add_code(*sc->lengths,
+                                    sizeof(ngx_http_lua_script_copy_code_t));
+    if (code == NULL) {
+        return NGX_ERROR;
+    }
+
+    code->code = (ngx_http_lua_script_code_pt)
+                 ngx_http_lua_script_copy_len_code;
+    code->len = len;
+
+    size = (sizeof(ngx_http_lua_script_copy_code_t) + len +
+            sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1);
+
+    code = ngx_http_lua_script_add_code(*sc->values, size);
+    if (code == NULL) {
+        return NGX_ERROR;
+    }
+
+    code->code = ngx_http_lua_script_copy_code;
+    code->len = len;
+
+    ngx_memcpy((u_char *) code + sizeof(ngx_http_lua_script_copy_code_t),
+               value->data, value->len);
+
+    return NGX_OK;
+}
+
+
+static size_t
+ngx_http_lua_script_copy_len_code(ngx_http_lua_script_engine_t *e)
+{
+    ngx_http_lua_script_copy_code_t  *code;
+
+    code = (ngx_http_lua_script_copy_code_t *) e->ip;
+
+    e->ip += sizeof(ngx_http_lua_script_copy_code_t);
+
+    return code->len;
+}
+
+
+static void
+ngx_http_lua_script_copy_code(ngx_http_lua_script_engine_t *e)
+{
+    u_char                           *p;
+    ngx_http_lua_script_copy_code_t  *code;
+
+    code = (ngx_http_lua_script_copy_code_t *) e->ip;
+
+    p = e->pos;
+
+    if (!e->skip) {
+        e->pos = ngx_copy(p, e->ip + sizeof(ngx_http_lua_script_copy_code_t),
+                          code->len);
+    }
+
+    e->ip += sizeof(ngx_http_lua_script_copy_code_t)
+          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, e->log, 0,
+                   "lua script copy: \"%*s\"", e->pos - p, p);
+}
+
+
+static ngx_int_t
+ngx_http_lua_script_add_capture_code(ngx_http_lua_script_compile_t *sc,
+    ngx_uint_t n)
+{
+    ngx_http_lua_script_capture_code_t  *code;
+
+    code = ngx_http_lua_script_add_code(*sc->lengths,
+                                  sizeof(ngx_http_lua_script_capture_code_t));
+    if (code == NULL) {
+        return NGX_ERROR;
+    }
+
+    code->code = (ngx_http_lua_script_code_pt)
+                 ngx_http_lua_script_copy_capture_len_code;
+    code->n = 2 * n;
+
+    code = ngx_http_lua_script_add_code(*sc->values,
+                                  sizeof(ngx_http_lua_script_capture_code_t));
+    if (code == NULL) {
+        return NGX_ERROR;
+    }
+
+    code->code = ngx_http_lua_script_copy_capture_code;
+    code->n = 2 * n;
+
+    return NGX_OK;
+}
+
+
+static size_t
+ngx_http_lua_script_copy_capture_len_code(ngx_http_lua_script_engine_t *e)
+{
+    int                                  *cap;
+    ngx_uint_t                            n;
+    ngx_http_lua_script_capture_code_t   *code;
+
+    code = (ngx_http_lua_script_capture_code_t *) e->ip;
+
+    e->ip += sizeof(ngx_http_lua_script_capture_code_t);
+
+    n = code->n;
+
+    if (n < e->ncaptures) {
+        cap = e->captures;
+        return cap[n + 1] - cap[n];
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_script_copy_capture_code(ngx_http_lua_script_engine_t *e)
+{
+    int                                  *cap;
+    u_char                               *p, *pos;
+    ngx_uint_t                            n;
+    ngx_http_lua_script_capture_code_t   *code;
+
+    code = (ngx_http_lua_script_capture_code_t *) e->ip;
+
+    e->ip += sizeof(ngx_http_lua_script_capture_code_t);
+
+    n = code->n;
+
+    pos = e->pos;
+
+    if (n < e->ncaptures) {
+
+        cap = e->captures;
+        p = e->captures_data;
+
+        e->pos = ngx_copy(pos, &p[cap[n]], cap[n + 1] - cap[n]);
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, e->log, 0,
+                   "lua script capture: \"%*s\"", e->pos - pos, pos);
+}
+
+
+static ngx_int_t
+ngx_http_lua_script_init_arrays(ngx_http_lua_script_compile_t *sc)
+{
+    ngx_uint_t   n;
+
+    if (*sc->lengths == NULL) {
+        n = sc->variables * (2 * sizeof(ngx_http_lua_script_copy_code_t)
+                             + sizeof(ngx_http_lua_script_capture_code_t))
+            + sizeof(uintptr_t);
+
+        *sc->lengths = ngx_array_create(sc->pool, n, 1);
+        if (*sc->lengths == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    if (*sc->values == NULL) {
+        n = (sc->variables * (2 * sizeof(ngx_http_lua_script_copy_code_t)
+                              + sizeof(ngx_http_lua_script_capture_code_t))
+                + sizeof(uintptr_t)
+                + sizeof(uintptr_t) - 1)
+            & ~(sizeof(uintptr_t) - 1);
+
+        *sc->values = ngx_array_create(sc->pool, n, 1);
+        if (*sc->values == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    sc->variables = 0;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_script_done(ngx_http_lua_script_compile_t *sc)
+{
+    uintptr_t   *code;
+
+    if (sc->complete_lengths) {
+        code = ngx_http_lua_script_add_code(*sc->lengths, sizeof(uintptr_t));
+        if (code == NULL) {
+            return NGX_ERROR;
+        }
+
+        *code = (uintptr_t) NULL;
+    }
+
+    if (sc->complete_values) {
+        code = ngx_http_lua_script_add_code(*sc->values, sizeof(uintptr_t));
+        if (code == NULL) {
+            return NGX_ERROR;
+        }
+
+        *code = (uintptr_t) NULL;
+    }
+
+    return NGX_OK;
+}
+
+
+static void *
+ngx_http_lua_script_add_code(ngx_array_t *codes, size_t size)
+{
+    return ngx_array_push_n(codes, size);
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_script.h b/src/lua/lua-nginx-module/src/ngx_http_lua_script.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_script.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_script.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,86 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_SCRIPT_H_INCLUDED_
+#define _NGX_HTTP_LUA_SCRIPT_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+typedef struct {
+    ngx_log_t                  *log;
+    ngx_pool_t                 *pool;
+    ngx_str_t                  *source;
+
+    ngx_array_t               **lengths;
+    ngx_array_t               **values;
+
+    ngx_uint_t                  variables;
+
+    unsigned                    complete_lengths:1;
+    unsigned                    complete_values:1;
+} ngx_http_lua_script_compile_t;
+
+
+typedef struct {
+    ngx_str_t                   value;
+    void                       *lengths;
+    void                       *values;
+} ngx_http_lua_complex_value_t;
+
+
+typedef struct {
+    ngx_log_t                       *log;
+    ngx_pool_t                      *pool;
+    ngx_str_t                       *value;
+    ngx_http_lua_complex_value_t    *complex_value;
+} ngx_http_lua_compile_complex_value_t;
+
+
+typedef struct {
+    u_char                     *ip;
+    u_char                     *pos;
+
+    ngx_str_t                   buf;
+
+    int                        *captures;
+    ngx_uint_t                  ncaptures;
+    u_char                     *captures_data;
+
+    unsigned                    skip:1;
+
+    ngx_log_t                  *log;
+} ngx_http_lua_script_engine_t;
+
+
+typedef void (*ngx_http_lua_script_code_pt) (ngx_http_lua_script_engine_t *e);
+typedef size_t (*ngx_http_lua_script_len_code_pt)
+    (ngx_http_lua_script_engine_t *e);
+
+
+typedef struct {
+    ngx_http_lua_script_code_pt     code;
+    uintptr_t                       len;
+} ngx_http_lua_script_copy_code_t;
+
+
+typedef struct {
+    ngx_http_lua_script_code_pt     code;
+    uintptr_t                       n;
+} ngx_http_lua_script_capture_code_t;
+
+
+ngx_int_t ngx_http_lua_compile_complex_value(
+        ngx_http_lua_compile_complex_value_t *ccv);
+ngx_int_t ngx_http_lua_complex_value(ngx_http_request_t *r, ngx_str_t *subj,
+        size_t offset, ngx_int_t count, int *cap,
+        ngx_http_lua_complex_value_t *val, luaL_Buffer *luabuf);
+
+
+#endif /* _NGX_HTTP_LUA_SCRIPT_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_setby.c b/src/lua/lua-nginx-module/src/ngx_http_lua_setby.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_setby.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_setby.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,246 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_setby.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_time.h"
+#include "ngx_http_lua_log.h"
+#include "ngx_http_lua_regex.h"
+#include "ngx_http_lua_variable.h"
+#include "ngx_http_lua_string.h"
+#include "ngx_http_lua_misc.h"
+#include "ngx_http_lua_consts.h"
+#include "ngx_http_lua_shdict.h"
+#include "ngx_http_lua_util.h"
+
+
+static void ngx_http_lua_set_by_lua_env(lua_State *L, ngx_http_request_t *r,
+    size_t nargs, ngx_http_variable_value_t *args);
+
+
+/* chars whose addresses are used as keys in Lua VM regsitry */
+static char ngx_http_lua_setby_nargs_key;
+static char ngx_http_lua_setby_args_key;
+
+
+ngx_int_t
+ngx_http_lua_set_by_chunk(lua_State *L, ngx_http_request_t *r, ngx_str_t *val,
+    ngx_http_variable_value_t *args, size_t nargs, ngx_str_t *script)
+{
+    size_t           i;
+    ngx_int_t        rc;
+    u_char          *err_msg;
+    size_t           len;
+    u_char          *data;
+#if (NGX_PCRE)
+    ngx_pool_t      *old_pool;
+#endif
+
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_cleanup_t          *cln;
+
+    dd("nargs: %d", (int) nargs);
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (ctx == NULL) {
+        ctx = ngx_http_lua_create_ctx(r);
+        if (ctx == NULL) {
+            return NGX_ERROR;
+        }
+
+    } else {
+        ngx_http_lua_reset_ctx(r, L, ctx);
+    }
+
+    if (ctx->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            return NGX_ERROR;
+        }
+
+        cln->handler = ngx_http_lua_request_cleanup_handler;
+        cln->data = ctx;
+        ctx->cleanup = &cln->handler;
+    }
+
+    ctx->context = NGX_HTTP_LUA_CONTEXT_SET;
+
+    dd("set Lua VM panic handler");
+
+    lua_atpanic(L, ngx_http_lua_atpanic);
+
+    NGX_LUA_EXCEPTION_TRY {
+        dd("initialize nginx context in Lua VM, code chunk at "
+           "stack top    sp = 1");
+        ngx_http_lua_set_by_lua_env(L, r, nargs, args);
+
+        /*  passing directive arguments to the user code */
+        for (i = 0; i < nargs; i++) {
+            lua_pushlstring(L, (const char *) args[i].data, args[i].len);
+        }
+
+#if (NGX_PCRE)
+        /* XXX: work-around to nginx regex subsystem */
+        old_pool = ngx_http_lua_pcre_malloc_init(r->pool);
+#endif
+
+        lua_pushcfunction(L, ngx_http_lua_traceback);
+        lua_insert(L, 1);  /* put it under chunk and args */
+
+        dd("protected call user code");
+
+        rc = lua_pcall(L, nargs, 1, 1);
+
+        dd("after protected call user code");
+
+        lua_remove(L, 1);  /* remove traceback function */
+
+#if (NGX_PCRE)
+        /* XXX: work-around to nginx regex subsystem */
+        ngx_http_lua_pcre_malloc_done(old_pool);
+#endif
+
+        if (rc != 0) {
+            /*  error occured when running loaded code */
+            err_msg = (u_char *) lua_tolstring(L, -1, &len);
+
+            if (err_msg == NULL) {
+                err_msg = (u_char *) "unknown reason";
+                len = sizeof("unknown reason") - 1;
+            }
+
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "failed to run set_by_lua*: %*s", len, err_msg);
+
+            lua_settop(L, 0);    /*  clear remaining elems on stack */
+
+            return NGX_ERROR;
+        }
+
+        data = (u_char *) lua_tolstring(L, -1, &len);
+
+        if (data) {
+            val->data = ngx_palloc(r->pool, len);
+            if (val->data == NULL) {
+                return NGX_ERROR;
+            }
+
+            ngx_memcpy(val->data, data, len);
+            val->len = len;
+
+        } else {
+            val->data = NULL;
+            val->len = 0;
+        }
+
+    } NGX_LUA_EXCEPTION_CATCH {
+
+        dd("nginx execution restored");
+        return NGX_ERROR;
+    }
+
+    /*  clear Lua stack */
+    lua_settop(L, 0);
+
+    return NGX_OK;
+}
+
+
+int
+ngx_http_lua_setby_param_get(lua_State *L)
+{
+    int         idx;
+    int         n;
+
+    ngx_http_variable_value_t       *v;
+
+    idx = luaL_checkint(L, 2);
+    idx--;
+
+    /*  get number of args from globals */
+    lua_pushlightuserdata(L, &ngx_http_lua_setby_nargs_key);
+    lua_rawget(L, LUA_GLOBALSINDEX);
+    n = (int) lua_tointeger(L, -1);
+
+    /*  get args from globals */
+    lua_pushlightuserdata(L, &ngx_http_lua_setby_args_key);
+    lua_rawget(L, LUA_GLOBALSINDEX);
+    v = lua_touserdata(L, -1);
+
+    if (idx < 0 || idx > n - 1) {
+        lua_pushnil(L);
+
+    } else {
+        lua_pushlstring(L, (const char *) (v[idx].data), v[idx].len);
+    }
+
+    return 1;
+}
+
+
+/**
+ * Set environment table for the given code closure.
+ *
+ * Before:
+ *         | code closure | <- top
+ *         |      ...     |
+ *
+ * After:
+ *         | code closure | <- top
+ *         |      ...     |
+ * */
+static void
+ngx_http_lua_set_by_lua_env(lua_State *L, ngx_http_request_t *r, size_t nargs,
+    ngx_http_variable_value_t *args)
+{
+    /*  set nginx request pointer to current lua thread's globals table */
+    ngx_http_lua_set_req(L, r);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_setby_nargs_key);
+    lua_pushinteger(L, nargs);
+    lua_rawset(L, LUA_GLOBALSINDEX);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_setby_args_key);
+    lua_pushlightuserdata(L, args);
+    lua_rawset(L, LUA_GLOBALSINDEX);
+
+    /**
+     * we want to create empty environment for current script
+     *
+     * newt = {}
+     * newt["_G"] = newt
+     * setmetatable(newt, {__index = _G})
+     *
+     * if a function or symbol is not defined in our env, __index will lookup
+     * in the global env.
+     *
+     * all variables created in the script-env will be thrown away at the end
+     * of the script run.
+     * */
+    ngx_http_lua_create_new_global_table(L, 0 /* narr */, 1 /* nrec */);
+
+    /*  {{{ make new env inheriting main thread's globals table */
+    /* the metatable for the new env */
+    lua_createtable(L, 0 /* narr */, 1 /* nrec */);
+    lua_pushvalue(L, LUA_GLOBALSINDEX);
+    lua_setfield(L, -2, "__index");
+    lua_setmetatable(L, -2);    /*  setmetatable(newt, {__index = _G}) */
+    /*  }}} */
+
+    lua_setfenv(L, -2);    /*  set new running env for the code closure */
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_setby.h b/src/lua/lua-nginx-module/src/ngx_http_lua_setby.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_setby.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_setby.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,15 @@
+#ifndef _NGX_HTTP_LUA_SET_BY_H_INCLUDED_
+#define _NGX_HTTP_LUA_SET_BY_H_INCLUDED_
+
+#include "ngx_http_lua_common.h"
+
+
+ngx_int_t ngx_http_lua_set_by_chunk(lua_State *L, ngx_http_request_t *r,
+    ngx_str_t *val, ngx_http_variable_value_t *args, size_t nargs,
+    ngx_str_t *script);
+int ngx_http_lua_setby_param_get(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_SET_BY_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.c b/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,1348 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_shdict.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_api.h"
+
+
+static int ngx_http_lua_shdict_set(lua_State *L);
+static int ngx_http_lua_shdict_safe_set(lua_State *L);
+static int ngx_http_lua_shdict_get(lua_State *L);
+static int ngx_http_lua_shdict_get_stale(lua_State *L);
+static int ngx_http_lua_shdict_get_helper(lua_State *L, int get_stale);
+static int ngx_http_lua_shdict_expire(ngx_http_lua_shdict_ctx_t *ctx,
+    ngx_uint_t n);
+static ngx_int_t ngx_http_lua_shdict_lookup(ngx_shm_zone_t *shm_zone,
+    ngx_uint_t hash, u_char *kdata, size_t klen,
+    ngx_http_lua_shdict_node_t **sdp);
+static int ngx_http_lua_shdict_set_helper(lua_State *L, int flags);
+static int ngx_http_lua_shdict_add(lua_State *L);
+static int ngx_http_lua_shdict_safe_add(lua_State *L);
+static int ngx_http_lua_shdict_replace(lua_State *L);
+static int ngx_http_lua_shdict_incr(lua_State *L);
+static int ngx_http_lua_shdict_delete(lua_State *L);
+static int ngx_http_lua_shdict_flush_all(lua_State *L);
+static int ngx_http_lua_shdict_flush_expired(lua_State *L);
+static int ngx_http_lua_shdict_get_keys(lua_State *L);
+
+
+#define NGX_HTTP_LUA_SHDICT_ADD         0x0001
+#define NGX_HTTP_LUA_SHDICT_REPLACE     0x0002
+#define NGX_HTTP_LUA_SHDICT_SAFE_STORE  0x0004
+
+
+ngx_int_t
+ngx_http_lua_shdict_init_zone(ngx_shm_zone_t *shm_zone, void *data)
+{
+    ngx_http_lua_shdict_ctx_t  *octx = data;
+
+    size_t                      len;
+    ngx_http_lua_shdict_ctx_t  *ctx;
+    ngx_http_lua_main_conf_t   *lmcf;
+
+    dd("init zone");
+
+    ctx = shm_zone->data;
+
+    if (octx) {
+        ctx->sh = octx->sh;
+        ctx->shpool = octx->shpool;
+
+        goto done;
+    }
+
+    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
+
+    if (shm_zone->shm.exists) {
+        ctx->sh = ctx->shpool->data;
+
+        goto done;
+    }
+
+    ctx->sh = ngx_slab_alloc(ctx->shpool, sizeof(ngx_http_lua_shdict_shctx_t));
+    if (ctx->sh == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->shpool->data = ctx->sh;
+
+    ngx_rbtree_init(&ctx->sh->rbtree, &ctx->sh->sentinel,
+                    ngx_http_lua_shdict_rbtree_insert_value);
+
+    ngx_queue_init(&ctx->sh->queue);
+
+    len = sizeof(" in lua_shared_dict zone \"\"") + shm_zone->shm.name.len;
+
+    ctx->shpool->log_ctx = ngx_slab_alloc(ctx->shpool, len);
+    if (ctx->shpool->log_ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_sprintf(ctx->shpool->log_ctx, " in lua_shared_dict zone \"%V\"%Z",
+                &shm_zone->shm.name);
+
+done:
+    dd("get lmcf");
+
+    lmcf = ctx->main_conf;
+
+    dd("lmcf->lua: %p", lmcf->lua);
+
+    lmcf->shm_zones_inited++;
+
+    if (lmcf->shm_zones_inited == lmcf->shm_zones->nelts
+        && lmcf->init_handler)
+    {
+        if (lmcf->init_handler(ctx->log, lmcf, lmcf->lua) != 0) {
+            /* an error happened */
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+void
+ngx_http_lua_shdict_rbtree_insert_value(ngx_rbtree_node_t *temp,
+    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
+{
+    ngx_rbtree_node_t          **p;
+    ngx_http_lua_shdict_node_t   *sdn, *sdnt;
+
+    for ( ;; ) {
+
+        if (node->key < temp->key) {
+
+            p = &temp->left;
+
+        } else if (node->key > temp->key) {
+
+            p = &temp->right;
+
+        } else { /* node->key == temp->key */
+
+            sdn = (ngx_http_lua_shdict_node_t *) &node->color;
+            sdnt = (ngx_http_lua_shdict_node_t *) &temp->color;
+
+            p = ngx_memn2cmp(sdn->data, sdnt->data, sdn->key_len,
+                             sdnt->key_len) < 0 ? &temp->left : &temp->right;
+        }
+
+        if (*p == sentinel) {
+            break;
+        }
+
+        temp = *p;
+    }
+
+    *p = node;
+    node->parent = temp;
+    node->left = sentinel;
+    node->right = sentinel;
+    ngx_rbt_red(node);
+}
+
+
+static ngx_int_t
+ngx_http_lua_shdict_lookup(ngx_shm_zone_t *shm_zone, ngx_uint_t hash,
+    u_char *kdata, size_t klen, ngx_http_lua_shdict_node_t **sdp)
+{
+    ngx_int_t                    rc;
+    ngx_time_t                  *tp;
+    uint64_t                     now;
+    int64_t                      ms;
+    ngx_rbtree_node_t           *node, *sentinel;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_http_lua_shdict_node_t  *sd;
+
+    ctx = shm_zone->data;
+
+    node = ctx->sh->rbtree.root;
+    sentinel = ctx->sh->rbtree.sentinel;
+
+    while (node != sentinel) {
+
+        if (hash < node->key) {
+            node = node->left;
+            continue;
+        }
+
+        if (hash > node->key) {
+            node = node->right;
+            continue;
+        }
+
+        /* hash == node->key */
+
+        sd = (ngx_http_lua_shdict_node_t *) &node->color;
+
+        rc = ngx_memn2cmp(kdata, sd->data, klen, (size_t) sd->key_len);
+
+        if (rc == 0) {
+            ngx_queue_remove(&sd->queue);
+            ngx_queue_insert_head(&ctx->sh->queue, &sd->queue);
+
+            *sdp = sd;
+
+            dd("node expires: %lld", (long long) sd->expires);
+
+            if (sd->expires != 0) {
+                tp = ngx_timeofday();
+
+                now = (uint64_t) tp->sec * 1000 + tp->msec;
+                ms = sd->expires - now;
+
+                dd("time to live: %lld", (long long) ms);
+
+                if (ms < 0) {
+                    dd("node already expired");
+                    return NGX_DONE;
+                }
+            }
+
+            return NGX_OK;
+        }
+
+        node = (rc < 0) ? node->left : node->right;
+    }
+
+    *sdp = NULL;
+
+    return NGX_DECLINED;
+}
+
+
+static int
+ngx_http_lua_shdict_expire(ngx_http_lua_shdict_ctx_t *ctx, ngx_uint_t n)
+{
+    ngx_time_t                  *tp;
+    uint64_t                     now;
+    ngx_queue_t                 *q;
+    int64_t                      ms;
+    ngx_rbtree_node_t           *node;
+    ngx_http_lua_shdict_node_t  *sd;
+    int                          freed = 0;
+
+    tp = ngx_timeofday();
+
+    now = (uint64_t) tp->sec * 1000 + tp->msec;
+
+    /*
+     * n == 1 deletes one or two expired entries
+     * n == 0 deletes oldest entry by force
+     *        and one or two zero rate entries
+     */
+
+    while (n < 3) {
+
+        if (ngx_queue_empty(&ctx->sh->queue)) {
+            return freed;
+        }
+
+        q = ngx_queue_last(&ctx->sh->queue);
+
+        sd = ngx_queue_data(q, ngx_http_lua_shdict_node_t, queue);
+
+        if (n++ != 0) {
+
+            if (sd->expires == 0) {
+                return freed;
+            }
+
+            ms = sd->expires - now;
+            if (ms > 0) {
+                return freed;
+            }
+        }
+
+        ngx_queue_remove(q);
+
+        node = (ngx_rbtree_node_t *)
+                   ((u_char *) sd - offsetof(ngx_rbtree_node_t, color));
+
+        ngx_rbtree_delete(&ctx->sh->rbtree, node);
+
+        ngx_slab_free_locked(ctx->shpool, node);
+
+        freed++;
+    }
+
+    return freed;
+}
+
+
+void
+ngx_http_lua_inject_shdict_api(ngx_http_lua_main_conf_t *lmcf, lua_State *L)
+{
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_uint_t                   i;
+    ngx_shm_zone_t             **zone;
+
+    if (lmcf->shm_zones != NULL) {
+        lua_createtable(L, 0, lmcf->shm_zones->nelts /* nrec */);
+                /* ngx.shared */
+
+        lua_createtable(L, 0 /* narr */, 13 /* nrec */); /* shared mt */
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_get);
+        lua_setfield(L, -2, "get");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_get_stale);
+        lua_setfield(L, -2, "get_stale");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_set);
+        lua_setfield(L, -2, "set");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_safe_set);
+        lua_setfield(L, -2, "safe_set");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_add);
+        lua_setfield(L, -2, "add");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_safe_add);
+        lua_setfield(L, -2, "safe_add");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_replace);
+        lua_setfield(L, -2, "replace");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_incr);
+        lua_setfield(L, -2, "incr");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_delete);
+        lua_setfield(L, -2, "delete");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_flush_all);
+        lua_setfield(L, -2, "flush_all");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_flush_expired);
+        lua_setfield(L, -2, "flush_expired");
+
+        lua_pushcfunction(L, ngx_http_lua_shdict_get_keys);
+        lua_setfield(L, -2, "get_keys");
+
+        lua_pushvalue(L, -1); /* shared mt mt */
+        lua_setfield(L, -2, "__index"); /* shared mt */
+
+        zone = lmcf->shm_zones->elts;
+
+        for (i = 0; i < lmcf->shm_zones->nelts; i++) {
+            ctx = zone[i]->data;
+
+            lua_pushlstring(L, (char *) ctx->name.data, ctx->name.len);
+                /* shared mt key */
+
+            lua_pushlightuserdata(L, zone[i]); /* shared mt key ud */
+            lua_pushvalue(L, -3); /* shared mt key ud mt */
+            lua_setmetatable(L, -2); /* shared mt key ud */
+            lua_rawset(L, -4); /* shared mt */
+        }
+
+        lua_pop(L, 1); /* shared */
+
+    } else {
+        lua_newtable(L);    /* ngx.shared */
+    }
+
+    lua_setfield(L, -2, "shared");
+}
+
+
+static int
+ngx_http_lua_shdict_get(lua_State *L)
+{
+  return ngx_http_lua_shdict_get_helper(L, 0 /* stale */);
+}
+
+
+static int
+ngx_http_lua_shdict_get_stale(lua_State *L)
+{
+  return ngx_http_lua_shdict_get_helper(L, 1 /* stale */);
+}
+
+
+static int
+ngx_http_lua_shdict_get_helper(lua_State *L, int get_stale)
+{
+    int                          n;
+    ngx_str_t                    name;
+    ngx_str_t                    key;
+    uint32_t                     hash;
+    ngx_int_t                    rc;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_http_lua_shdict_node_t  *sd;
+    ngx_str_t                    value;
+    int                          value_type;
+    lua_Number                   num;
+    u_char                       c;
+    ngx_shm_zone_t              *zone;
+    uint32_t                     user_flags = 0;
+
+    n = lua_gettop(L);
+
+    if (n != 2) {
+        return luaL_error(L, "expecting exactly two arguments, "
+                          "but only seen %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);
+
+    zone = lua_touserdata(L, 1);
+    if (zone == NULL) {
+        return luaL_error(L, "bad user data for the ngx_shm_zone_t pointer");
+    }
+
+    ctx = zone->data;
+
+    name = ctx->name;
+
+    key.data = (u_char *) luaL_checklstring(L, 2, &key.len);
+
+    if (key.len == 0) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    if (key.len > 65535) {
+        return luaL_error(L,
+                          "the key argument is more than 65535 bytes: \"%s\"",
+                          key.data);
+    }
+
+    hash = ngx_crc32_short(key.data, key.len);
+
+#if (NGX_DEBUG)
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
+                   "fetching key \"%V\" in shared dict \"%V\"", &key, &name);
+#endif /* NGX_DEBUG */
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+#if 1
+    if (!get_stale) {
+        ngx_http_lua_shdict_expire(ctx, 1);
+    }
+#endif
+
+    rc = ngx_http_lua_shdict_lookup(zone, hash, key.data, key.len, &sd);
+
+    dd("shdict lookup returns %d", (int) rc);
+
+    if (rc == NGX_DECLINED || (rc == NGX_DONE && !get_stale)) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+        lua_pushnil(L);
+        return 1;
+    }
+
+    /* rc == NGX_OK || (rc == NGX_DONE && get_stale) */
+
+    value_type = sd->value_type;
+
+    dd("data: %p", sd->data);
+    dd("key len: %d", (int) sd->key_len);
+
+    value.data = sd->data + sd->key_len;
+    value.len = (size_t) sd->value_len;
+
+    switch (value_type) {
+    case LUA_TSTRING:
+
+        lua_pushlstring(L, (char *) value.data, value.len);
+        break;
+
+    case LUA_TNUMBER:
+
+        if (value.len != sizeof(lua_Number)) {
+
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+            return luaL_error(L, "bad lua number value size found for key %s "
+                              "in shared_dict %s: %lu", key.data, name.data,
+                              (unsigned long) value.len);
+        }
+
+        num = *(lua_Number *) value.data;
+
+        lua_pushnumber(L, num);
+        break;
+
+    case LUA_TBOOLEAN:
+
+        if (value.len != sizeof(u_char)) {
+
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+            return luaL_error(L, "bad lua boolean value size found for key %s "
+                              "in shared_dict %s: %lu", key.data, name.data,
+                              (unsigned long) value.len);
+        }
+
+        c = *value.data;
+
+        lua_pushboolean(L, c ? 1 : 0);
+        break;
+
+    default:
+
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+        return luaL_error(L, "bad value type found for key %s in "
+                          "shared_dict %s: %d", key.data, name.data,
+                          value_type);
+    }
+
+    user_flags = sd->user_flags;
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+    if (get_stale) {
+
+        /* always return value, flags, stale */
+
+        if (user_flags) {
+            lua_pushinteger(L, (lua_Integer) user_flags);
+
+        } else {
+            lua_pushnil(L);
+        }
+
+        lua_pushboolean(L, rc == NGX_DONE);
+        return 3;
+    }
+
+    if (user_flags) {
+        lua_pushinteger(L, (lua_Integer) user_flags);
+        return 2;
+    }
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_shdict_delete(lua_State *L)
+{
+    int             n;
+
+    n = lua_gettop(L);
+
+    if (n != 2) {
+        return luaL_error(L, "expecting 2 arguments, "
+                          "but only seen %d", n);
+    }
+
+    lua_pushnil(L);
+
+    return ngx_http_lua_shdict_set_helper(L, 0);
+}
+
+
+static int
+ngx_http_lua_shdict_flush_all(lua_State *L)
+{
+    ngx_queue_t                 *q;
+    ngx_http_lua_shdict_node_t  *sd;
+    int                          n;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_shm_zone_t              *zone;
+
+    n = lua_gettop(L);
+
+    if (n != 1) {
+        return luaL_error(L, "expecting 1 argument, but seen %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);
+
+    zone = lua_touserdata(L, 1);
+    if (zone == NULL) {
+        return luaL_error(L, "bad user data for the ngx_shm_zone_t pointer");
+    }
+
+    ctx = zone->data;
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+    for (q = ngx_queue_head(&ctx->sh->queue);
+         q != ngx_queue_sentinel(&ctx->sh->queue);
+         q = ngx_queue_next(q))
+    {
+        sd = ngx_queue_data(q, ngx_http_lua_shdict_node_t, queue);
+        sd->expires = 1;
+    }
+
+    ngx_http_lua_shdict_expire(ctx, 0);
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_shdict_flush_expired(lua_State *L)
+{
+    ngx_queue_t                 *q, *prev;
+    ngx_http_lua_shdict_node_t  *sd;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_shm_zone_t              *zone;
+    ngx_time_t                  *tp;
+    int                          freed = 0;
+    int                          attempts = 0;
+    ngx_rbtree_node_t           *node;
+    uint64_t                     now;
+    int                          n;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting 1 or 2 argument(s), but saw %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);
+
+    zone = lua_touserdata(L, 1);
+    if (zone == NULL) {
+        return luaL_error(L, "bad user data for the ngx_shm_zone_t pointer");
+    }
+
+    if (n == 2) {
+        attempts = luaL_checkint(L, 2);
+    }
+
+    ctx = zone->data;
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+    if (ngx_queue_empty(&ctx->sh->queue)) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+        lua_pushnumber(L, 0);
+        return 1;
+    }
+
+    tp = ngx_timeofday();
+
+    now = (uint64_t) tp->sec * 1000 + tp->msec;
+
+    q = ngx_queue_last(&ctx->sh->queue);
+
+    while (q != ngx_queue_sentinel(&ctx->sh->queue)) {
+        prev = ngx_queue_prev(q);
+
+        sd = ngx_queue_data(q, ngx_http_lua_shdict_node_t, queue);
+
+        if (sd->expires != 0 && sd->expires <= now) {
+            ngx_queue_remove(q);
+
+            node = (ngx_rbtree_node_t *)
+                ((u_char *) sd - offsetof(ngx_rbtree_node_t, color));
+
+            ngx_rbtree_delete(&ctx->sh->rbtree, node);
+            ngx_slab_free_locked(ctx->shpool, node);
+            freed++;
+
+            if (attempts && freed == attempts) {
+                break;
+            }
+        }
+
+        q = prev;
+    }
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+    lua_pushnumber(L, freed);
+    return 1;
+}
+
+
+/*
+ * This trades CPU for memory. This is potentially slow. O(2n)
+ */
+
+static int
+ngx_http_lua_shdict_get_keys(lua_State *L)
+{
+    ngx_queue_t                 *q, *prev;
+    ngx_http_lua_shdict_node_t  *sd;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_shm_zone_t              *zone;
+    ngx_time_t                  *tp;
+    int                          total = 0;
+    int                          attempts = 1024;
+    uint64_t                     now;
+    int                          n;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting 1 or 2 argument(s), "
+                          "but saw %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);
+
+    zone = lua_touserdata(L, 1);
+    if (zone == NULL) {
+        return luaL_error(L, "bad user data for the ngx_shm_zone_t pointer");
+    }
+
+    if (n == 2) {
+        attempts = luaL_checkint(L, 2);
+    }
+
+    ctx = zone->data;
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+    if (ngx_queue_empty(&ctx->sh->queue)) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+        lua_createtable(L, 0, 0);
+        return 1;
+    }
+
+    tp = ngx_timeofday();
+
+    now = (uint64_t) tp->sec * 1000 + tp->msec;
+
+    /* first run through: get total number of elements we need to allocate */
+
+    q = ngx_queue_last(&ctx->sh->queue);
+
+    while (q != ngx_queue_sentinel(&ctx->sh->queue)) {
+        prev = ngx_queue_prev(q);
+
+        sd = ngx_queue_data(q, ngx_http_lua_shdict_node_t, queue);
+
+        if (sd->expires == 0 || sd->expires > now) {
+            total++;
+            if (attempts && total == attempts) {
+                break;
+            }
+        }
+
+        q = prev;
+    }
+
+    lua_createtable(L, total, 0);
+
+    /* second run through: add keys to table */
+
+    total = 0;
+    q = ngx_queue_last(&ctx->sh->queue);
+
+    while (q != ngx_queue_sentinel(&ctx->sh->queue)) {
+        prev = ngx_queue_prev(q);
+
+        sd = ngx_queue_data(q, ngx_http_lua_shdict_node_t, queue);
+
+        if (sd->expires == 0 || sd->expires > now) {
+            lua_pushlstring(L, (char *) sd->data, sd->key_len);
+            lua_rawseti(L, -2, ++total);
+            if (attempts && total == attempts) {
+                break;
+            }
+        }
+
+        q = prev;
+    }
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+    /* table is at top of stack */
+    return 1;
+}
+
+
+static int
+ngx_http_lua_shdict_add(lua_State *L)
+{
+    return ngx_http_lua_shdict_set_helper(L, NGX_HTTP_LUA_SHDICT_ADD);
+}
+
+
+static int
+ngx_http_lua_shdict_safe_add(lua_State *L)
+{
+    return ngx_http_lua_shdict_set_helper(L, NGX_HTTP_LUA_SHDICT_ADD
+                                          |NGX_HTTP_LUA_SHDICT_SAFE_STORE);
+}
+
+
+static int
+ngx_http_lua_shdict_replace(lua_State *L)
+{
+    return ngx_http_lua_shdict_set_helper(L, NGX_HTTP_LUA_SHDICT_REPLACE);
+}
+
+
+static int
+ngx_http_lua_shdict_set(lua_State *L)
+{
+    return ngx_http_lua_shdict_set_helper(L, 0);
+}
+
+
+static int
+ngx_http_lua_shdict_safe_set(lua_State *L)
+{
+    return ngx_http_lua_shdict_set_helper(L, NGX_HTTP_LUA_SHDICT_SAFE_STORE);
+}
+
+
+static int
+ngx_http_lua_shdict_set_helper(lua_State *L, int flags)
+{
+    int                          i, n;
+    ngx_str_t                    name;
+    ngx_str_t                    key;
+    uint32_t                     hash;
+    ngx_int_t                    rc;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_http_lua_shdict_node_t  *sd;
+    ngx_str_t                    value;
+    int                          value_type;
+    lua_Number                   num;
+    u_char                       c;
+    lua_Number                   exptime = 0;
+    u_char                      *p;
+    ngx_rbtree_node_t           *node;
+    ngx_time_t                  *tp;
+    ngx_shm_zone_t              *zone;
+    int                          forcible = 0;
+                         /* indicates whether to foricibly override other
+                          * valid entries */
+    int32_t                      user_flags = 0;
+
+    n = lua_gettop(L);
+
+    if (n != 3 && n != 4 && n != 5) {
+        return luaL_error(L, "expecting 3, 4 or 5 arguments, "
+                          "but only seen %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);
+
+    zone = lua_touserdata(L, 1);
+    if (zone == NULL) {
+        return luaL_error(L, "bad user data for the ngx_shm_zone_t pointer");
+    }
+
+    ctx = zone->data;
+
+    name = ctx->name;
+
+    key.data = (u_char *) luaL_checklstring(L, 2, &key.len);
+
+    if (key.len == 0) {
+        return luaL_error(L, "attempt to use empty keys");
+    }
+
+    if (key.len > 65535) {
+        return luaL_error(L, "the key argument is more than 65535 bytes: %d",
+                          (int) key.len);
+    }
+
+    hash = ngx_crc32_short(key.data, key.len);
+
+    value_type = lua_type(L, 3);
+
+    switch (value_type) {
+    case LUA_TSTRING:
+        value.data = (u_char *) lua_tolstring(L, 3, &value.len);
+        break;
+
+    case LUA_TNUMBER:
+        value.len = sizeof(lua_Number);
+        num = lua_tonumber(L, 3);
+        value.data = (u_char *) &num;
+        break;
+
+    case LUA_TBOOLEAN:
+        value.len = sizeof(u_char);
+        c = lua_toboolean(L, 3) ? 1 : 0;
+        value.data = &c;
+        break;
+
+    case LUA_TNIL:
+        if (flags & (NGX_HTTP_LUA_SHDICT_ADD|NGX_HTTP_LUA_SHDICT_REPLACE)) {
+            return luaL_error(L, "attempt to add or replace nil values");
+        }
+
+        value.len = 0;
+        value.data = NULL;
+        break;
+
+    default:
+        return luaL_error(L, "unsupported value type for key \"%s\" in "
+                          "shared_dict \"%s\": %s", key.data, name.data,
+                          lua_typename(L, value_type));
+    }
+
+    if (n >= 4) {
+        exptime = luaL_checknumber(L, 4);
+        if (exptime < 0) {
+            exptime = 0;
+        }
+    }
+
+    if (n == 5) {
+        user_flags = (uint32_t) luaL_checkinteger(L, 5);
+    }
+
+    dd("looking up key %s in shared dict %s", key.data, name.data);
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+#if 1
+    ngx_http_lua_shdict_expire(ctx, 1);
+#endif
+
+    rc = ngx_http_lua_shdict_lookup(zone, hash, key.data, key.len, &sd);
+
+    dd("shdict lookup returned %d", (int) rc);
+
+    if (flags & NGX_HTTP_LUA_SHDICT_REPLACE) {
+
+        if (rc == NGX_DECLINED || rc == NGX_DONE) {
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+            lua_pushboolean(L, 0);
+            lua_pushliteral(L, "not found");
+            lua_pushboolean(L, forcible);
+            return 3;
+        }
+
+        /* rc == NGX_OK */
+
+        goto replace;
+    }
+
+    if (flags & NGX_HTTP_LUA_SHDICT_ADD) {
+
+        if (rc == NGX_OK) {
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+            lua_pushboolean(L, 0);
+            lua_pushliteral(L, "exists");
+            lua_pushboolean(L, forcible);
+            return 3;
+        }
+
+        if (rc == NGX_DONE) {
+            /* exists but expired */
+
+            dd("go to replace");
+            goto replace;
+        }
+
+        /* rc == NGX_DECLINED */
+
+        dd("go to insert");
+        goto insert;
+    }
+
+    if (rc == NGX_OK || rc == NGX_DONE) {
+
+        if (value_type == LUA_TNIL) {
+            goto remove;
+        }
+
+replace:
+        if (value.data && value.len == (size_t) sd->value_len) {
+
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
+                           "lua shared dict set: found old entry and value "
+                           "size matched, reusing it");
+
+            ngx_queue_remove(&sd->queue);
+            ngx_queue_insert_head(&ctx->sh->queue, &sd->queue);
+
+            sd->key_len = (u_short) key.len;
+
+            if (exptime > 0) {
+                tp = ngx_timeofday();
+                sd->expires = (uint64_t) tp->sec * 1000 + tp->msec
+                              + (uint64_t) (exptime * 1000);
+
+            } else {
+                sd->expires = 0;
+            }
+
+            sd->user_flags = user_flags;
+
+            sd->value_len = (uint32_t) value.len;
+
+            dd("setting value type to %d", value_type);
+
+            sd->value_type = (uint8_t) value_type;
+
+            p = ngx_copy(sd->data, key.data, key.len);
+            ngx_memcpy(p, value.data, value.len);
+
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+            lua_pushboolean(L, 1);
+            lua_pushnil(L);
+            lua_pushboolean(L, forcible);
+            return 3;
+        }
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
+                       "lua shared dict set: found old entry bug value size "
+                       "NOT matched, removing it first");
+
+remove:
+        ngx_queue_remove(&sd->queue);
+
+        node = (ngx_rbtree_node_t *)
+                   ((u_char *) sd - offsetof(ngx_rbtree_node_t, color));
+
+        ngx_rbtree_delete(&ctx->sh->rbtree, node);
+
+        ngx_slab_free_locked(ctx->shpool, node);
+
+    }
+
+insert:
+    /* rc == NGX_DECLINED or value size unmatch */
+
+    if (value.data == NULL) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+        lua_pushboolean(L, 1);
+        lua_pushnil(L);
+        lua_pushboolean(L, 0);
+        return 3;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
+                   "lua shared dict set: creating a new entry");
+
+    n = offsetof(ngx_rbtree_node_t, color)
+        + offsetof(ngx_http_lua_shdict_node_t, data)
+        + key.len
+        + value.len;
+
+    node = ngx_slab_alloc_locked(ctx->shpool, n);
+
+    if (node == NULL) {
+
+        if (flags & NGX_HTTP_LUA_SHDICT_SAFE_STORE) {
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+            lua_pushnil(L);
+            lua_pushliteral(L, "no memory");
+            return 2;
+        }
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
+                       "lua shared dict set: overriding non-expired items "
+                       "due to memory shortage for entry \"%V\"", &name);
+
+        for (i = 0; i < 30; i++) {
+            if (ngx_http_lua_shdict_expire(ctx, 0) == 0) {
+                break;
+            }
+
+            forcible = 1;
+
+            node = ngx_slab_alloc_locked(ctx->shpool, n);
+            if (node != NULL) {
+                goto allocated;
+            }
+        }
+
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+        lua_pushboolean(L, 0);
+        lua_pushliteral(L, "no memory");
+        lua_pushboolean(L, forcible);
+        return 3;
+    }
+
+allocated:
+    sd = (ngx_http_lua_shdict_node_t *) &node->color;
+
+    node->key = hash;
+    sd->key_len = (u_short) key.len;
+
+    if (exptime > 0) {
+        tp = ngx_timeofday();
+        sd->expires = (uint64_t) tp->sec * 1000 + tp->msec
+                      + (uint64_t) (exptime * 1000);
+
+    } else {
+        sd->expires = 0;
+    }
+
+    sd->user_flags = user_flags;
+
+    sd->value_len = (uint32_t) value.len;
+
+    dd("setting value type to %d", value_type);
+
+    sd->value_type = (uint8_t) value_type;
+
+    p = ngx_copy(sd->data, key.data, key.len);
+    ngx_memcpy(p, value.data, value.len);
+
+    ngx_rbtree_insert(&ctx->sh->rbtree, node);
+
+    ngx_queue_insert_head(&ctx->sh->queue, &sd->queue);
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+    lua_pushboolean(L, 1);
+    lua_pushnil(L);
+    lua_pushboolean(L, forcible);
+    return 3;
+}
+
+
+static int
+ngx_http_lua_shdict_incr(lua_State *L)
+{
+    int                          n;
+    ngx_str_t                    key;
+    uint32_t                     hash;
+    ngx_int_t                    rc;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_http_lua_shdict_node_t  *sd;
+    lua_Number                   num;
+    u_char                      *p;
+    ngx_shm_zone_t              *zone;
+    lua_Number                   value;
+
+    n = lua_gettop(L);
+
+    if (n != 3) {
+        return luaL_error(L, "expecting 3 arguments, but only seen %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);
+
+    zone = lua_touserdata(L, 1);
+    if (zone == NULL) {
+        return luaL_error(L, "bad user data for the ngx_shm_zone_t pointer");
+    }
+
+    ctx = zone->data;
+
+    key.data = (u_char *) luaL_checklstring(L, 2, &key.len);
+
+    if (key.len == 0) {
+        return luaL_error(L, "attempt to use empty keys");
+    }
+
+    if (key.len > 65535) {
+        return luaL_error(L, "the key argument is more than 65535 bytes: %d",
+                          (int) key.len);
+    }
+
+    hash = ngx_crc32_short(key.data, key.len);
+
+    value = luaL_checknumber(L, 3);
+
+    dd("looking up key %.*s in shared dict %.*s", (int) key.len, key.data,
+       (int) ctx->name.len, ctx->name.data);
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+#if 1
+    ngx_http_lua_shdict_expire(ctx, 1);
+#endif
+
+    rc = ngx_http_lua_shdict_lookup(zone, hash, key.data, key.len, &sd);
+
+    dd("shdict lookup returned %d", (int) rc);
+
+    if (rc == NGX_DECLINED || rc == NGX_DONE) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "not found");
+        return 2;
+    }
+
+    /* rc == NGX_OK */
+
+    if (sd->value_type != LUA_TNUMBER || sd->value_len != sizeof(lua_Number)) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "not a number");
+        return 2;
+    }
+
+    ngx_queue_remove(&sd->queue);
+    ngx_queue_insert_head(&ctx->sh->queue, &sd->queue);
+
+    dd("setting value type to %d", (int) sd->value_type);
+
+    p = sd->data + key.len;
+
+    num = *(lua_Number *) p;
+    num += value;
+
+    ngx_memcpy(p, (lua_Number *) &num, sizeof(lua_Number));
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+    lua_pushnumber(L, num);
+    lua_pushnil(L);
+    return 2;
+}
+
+
+ngx_int_t
+ngx_http_lua_shared_dict_get(ngx_shm_zone_t *zone, u_char *key_data,
+    size_t key_len, ngx_http_lua_value_t *value)
+{
+    u_char                      *data;
+    size_t                       len;
+    uint32_t                     hash;
+    ngx_int_t                    rc;
+    ngx_http_lua_shdict_ctx_t   *ctx;
+    ngx_http_lua_shdict_node_t  *sd;
+
+    if (zone == NULL) {
+        return NGX_ERROR;
+    }
+
+    hash = ngx_crc32_short(key_data, key_len);
+
+    ctx = zone->data;
+
+    ngx_shmtx_lock(&ctx->shpool->mutex);
+
+    rc = ngx_http_lua_shdict_lookup(zone, hash, key_data, key_len, &sd);
+
+    dd("shdict lookup returned %d", (int) rc);
+
+    if (rc == NGX_DECLINED || rc == NGX_DONE) {
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+
+        return rc;
+    }
+
+    /* rc == NGX_OK */
+
+    value->type = sd->value_type;
+
+    dd("type: %d", (int) value->type);
+
+    data = sd->data + sd->key_len;
+    len = (size_t) sd->value_len;
+
+    switch (value->type) {
+    case LUA_TSTRING:
+
+        if (value->value.s.data == NULL || value->value.s.len == 0) {
+            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "no string buffer "
+                          "initialized");
+            return NGX_ERROR;
+        }
+
+        if (len > value->value.s.len) {
+            len = value->value.s.len;
+
+        } else {
+            value->value.s.len = len;
+        }
+
+        ngx_memcpy(value->value.s.data, data, len);
+        break;
+
+    case LUA_TNUMBER:
+
+        if (len != sizeof(lua_Number)) {
+            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "bad lua number "
+                          "value size found for key %*s: %lu", key_len,
+                          key_data, (unsigned long) len);
+
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(&value->value.b, data, len);
+        break;
+
+    case LUA_TBOOLEAN:
+
+        if (len != sizeof(u_char)) {
+            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "bad lua boolean "
+                          "value size found for key %*s: %lu", key_len,
+                          key_data, (unsigned long) len);
+
+            ngx_shmtx_unlock(&ctx->shpool->mutex);
+            return NGX_ERROR;
+        }
+
+        value->value.b = *data;
+        break;
+
+    default:
+        ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "bad lua value type "
+                      "found for key %*s: %d", key_len, key_data,
+                      (int) value->type);
+
+        ngx_shmtx_unlock(&ctx->shpool->mutex);
+        return NGX_ERROR;
+    }
+
+    ngx_shmtx_unlock(&ctx->shpool->mutex);
+    return NGX_OK;
+}
+
+
+ngx_shm_zone_t *
+ngx_http_lua_find_zone(u_char *name_data, size_t name_len)
+{
+    ngx_str_t                       *name;
+    ngx_uint_t                       i;
+    ngx_shm_zone_t                  *zone;
+    volatile ngx_list_part_t        *part;
+
+    part = &ngx_cycle->shared_memory.part;
+    zone = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            zone = part->elts;
+            i = 0;
+        }
+
+        name = &zone[i].shm.name;
+
+        dd("name: [%.*s] %d", (int) name->len, name->data, (int) name->len);
+        dd("name2: [%.*s] %d", (int) name_len, name_data, (int) name_len);
+
+        if (name->len == name_len
+            && ngx_strncmp(name->data, name_data, name_len) == 0)
+        {
+            return zone;
+        }
+    }
+
+    return NULL;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.h b/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_shdict.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,52 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_SHDICT_H_INCLUDED_
+#define _NGX_HTTP_LUA_SHDICT_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+typedef struct {
+    u_char                       color;
+    u_char                       dummy;
+    u_short                      key_len;
+    ngx_queue_t                  queue;
+    uint64_t                     expires;
+    uint8_t                      value_type;
+    uint32_t                     value_len;
+    uint32_t                     user_flags;
+    u_char                       data[1];
+} ngx_http_lua_shdict_node_t;
+
+
+typedef struct {
+    ngx_rbtree_t                  rbtree;
+    ngx_rbtree_node_t             sentinel;
+    ngx_queue_t                   queue;
+} ngx_http_lua_shdict_shctx_t;
+
+
+typedef struct {
+    ngx_http_lua_shdict_shctx_t  *sh;
+    ngx_slab_pool_t              *shpool;
+    ngx_str_t                     name;
+    ngx_http_lua_main_conf_t     *main_conf;
+    ngx_log_t                    *log;
+} ngx_http_lua_shdict_ctx_t;
+
+
+ngx_int_t ngx_http_lua_shdict_init_zone(ngx_shm_zone_t *shm_zone, void *data);
+void ngx_http_lua_shdict_rbtree_insert_value(ngx_rbtree_node_t *temp,
+    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);
+void ngx_http_lua_inject_shdict_api(ngx_http_lua_main_conf_t *lmcf,
+    lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_SHDICT_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.c b/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,184 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_sleep.h"
+#include "ngx_http_lua_contentby.h"
+
+
+static int ngx_http_lua_ngx_sleep(lua_State *L);
+static void ngx_http_lua_sleep_handler(ngx_event_t *ev);
+static void ngx_http_lua_sleep_cleanup(void *data);
+static ngx_int_t ngx_http_lua_sleep_resume(ngx_http_request_t *r);
+
+
+static int
+ngx_http_lua_ngx_sleep(lua_State *L)
+{
+    int                          n;
+    ngx_int_t                    delay; /* in msec */
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    n = lua_gettop(L);
+    if (n != 1) {
+        return luaL_error(L, "attempt to pass %d arguments, but accepted 1", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    delay = (ngx_int_t) (luaL_checknumber(L, 1) * 1000);
+
+    if (delay < 0) {
+        return luaL_error(L, "invalid sleep duration \"%d\"", delay);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    coctx = ctx->cur_co_ctx;
+    if (coctx == NULL) {
+        return luaL_error(L, "no co ctx found");
+    }
+
+    coctx->data = r;
+
+    coctx->sleep.handler = ngx_http_lua_sleep_handler;
+    coctx->sleep.data = coctx;
+    coctx->sleep.log = r->connection->log;
+
+    dd("adding timer with delay %lu ms, r:%.*s", (unsigned long) delay,
+       (int) r->uri.len, r->uri.data);
+
+    ngx_add_timer(&coctx->sleep, (ngx_msec_t) delay);
+
+    coctx->cleanup = ngx_http_lua_sleep_cleanup;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua ready to sleep for %d ms", delay);
+
+    return lua_yield(L, 0);
+}
+
+
+void
+ngx_http_lua_sleep_handler(ngx_event_t *ev)
+{
+    ngx_connection_t        *c;
+    ngx_http_request_t      *r;
+    ngx_http_lua_ctx_t      *ctx;
+    ngx_http_log_ctx_t      *log_ctx;
+    ngx_http_lua_co_ctx_t   *coctx;
+
+    coctx = ev->data;
+
+    r = coctx->data;
+    c = r->connection;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (ctx == NULL) {
+        return;
+    }
+
+    log_ctx = c->log->data;
+    log_ctx->current_request = r;
+
+    coctx->cleanup = NULL;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua sleep timer expired: \"%V?%V\"", &r->uri, &r->args);
+
+    ctx->cur_co_ctx = coctx;
+
+    if (ctx->entered_content_phase) {
+        (void) ngx_http_lua_sleep_resume(r);
+
+    } else {
+        ctx->resume_handler = ngx_http_lua_sleep_resume;
+        ngx_http_core_run_phases(r);
+    }
+
+    ngx_http_run_posted_requests(c);
+}
+
+
+void
+ngx_http_lua_inject_sleep_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_sleep);
+    lua_setfield(L, -2, "sleep");
+}
+
+
+static void
+ngx_http_lua_sleep_cleanup(void *data)
+{
+    ngx_http_lua_co_ctx_t          *coctx = data;
+
+    if (coctx->sleep.timer_set) {
+        dd("cleanup: deleting timer for ngx.sleep");
+
+        ngx_del_timer(&coctx->sleep);
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_sleep_resume(ngx_http_request_t *r)
+{
+    ngx_connection_t            *c;
+    ngx_int_t                    rc;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    c = r->connection;
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, 0);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.h b/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_sleep.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_SLEEP_H_INCLUDED_
+#define _NGX_HTTP_LUA_SLEEP_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_sleep_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_SLEEP_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.c b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,4256 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_socket_tcp.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_output.h"
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_probe.h"
+
+
+#if 1
+#undef ngx_http_lua_probe_info
+#define ngx_http_lua_probe_info(msg)
+#endif
+
+
+static int ngx_http_lua_socket_tcp(lua_State *L);
+static int ngx_http_lua_socket_tcp_connect(lua_State *L);
+static int ngx_http_lua_socket_tcp_receive(lua_State *L);
+static int ngx_http_lua_socket_tcp_send(lua_State *L);
+static int ngx_http_lua_socket_tcp_close(lua_State *L);
+static int ngx_http_lua_socket_tcp_setoption(lua_State *L);
+static int ngx_http_lua_socket_tcp_settimeout(lua_State *L);
+static void ngx_http_lua_socket_tcp_handler(ngx_event_t *ev);
+static ngx_int_t ngx_http_lua_socket_tcp_get_peer(ngx_peer_connection_t *pc,
+    void *data);
+static void ngx_http_lua_socket_read_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static void ngx_http_lua_socket_send_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static void ngx_http_lua_socket_connected_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static void ngx_http_lua_socket_tcp_cleanup(void *data);
+static void ngx_http_lua_req_socket_cleanup(void *data);
+static void ngx_http_lua_socket_tcp_finalize(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static ngx_int_t ngx_http_lua_socket_send(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static ngx_int_t ngx_http_lua_socket_test_connect(ngx_http_request_t *r,
+    ngx_connection_t *c);
+static void ngx_http_lua_socket_handle_error(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, ngx_uint_t ft_type);
+static void ngx_http_lua_socket_handle_success(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static int ngx_http_lua_socket_tcp_send_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L);
+static int ngx_http_lua_socket_tcp_connect_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L);
+static void ngx_http_lua_socket_dummy_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static ngx_int_t ngx_http_lua_socket_tcp_read(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static void ngx_http_lua_socket_read_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static int ngx_http_lua_socket_tcp_receive_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L);
+static ngx_int_t ngx_http_lua_socket_read_line(void *data, ssize_t bytes);
+static void ngx_http_lua_socket_resolve_handler(ngx_resolver_ctx_t *ctx);
+static int ngx_http_lua_socket_resolve_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L);
+static int ngx_http_lua_socket_error_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L);
+static ngx_int_t ngx_http_lua_socket_read_all(void *data, ssize_t bytes);
+static ngx_int_t ngx_http_lua_socket_read_until(void *data, ssize_t bytes);
+static ngx_int_t ngx_http_lua_socket_read_chunk(void *data, ssize_t bytes);
+static int ngx_http_lua_socket_tcp_receiveuntil(lua_State *L);
+static int ngx_http_lua_socket_receiveuntil_iterator(lua_State *L);
+static ngx_int_t ngx_http_lua_socket_compile_pattern(u_char *data, size_t len,
+    ngx_http_lua_socket_compiled_pattern_t *cp, ngx_log_t *log);
+static int ngx_http_lua_socket_cleanup_compiled_pattern(lua_State *L);
+static int ngx_http_lua_req_socket(lua_State *L);
+static void ngx_http_lua_req_socket_rev_handler(ngx_http_request_t *r);
+static int ngx_http_lua_socket_tcp_getreusedtimes(lua_State *L);
+static int ngx_http_lua_socket_tcp_setkeepalive(lua_State *L);
+static ngx_int_t ngx_http_lua_get_keepalive_peer(ngx_http_request_t *r,
+    lua_State *L, int key_index,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static void ngx_http_lua_socket_keepalive_dummy_handler(ngx_event_t *ev);
+static ngx_int_t ngx_http_lua_socket_keepalive_close_handler(ngx_event_t *ev);
+static void ngx_http_lua_socket_keepalive_rev_handler(ngx_event_t *ev);
+static void ngx_http_lua_socket_free_pool(ngx_log_t *log,
+    ngx_http_lua_socket_pool_t *spool);
+static int ngx_http_lua_socket_tcp_upstream_destroy(lua_State *L);
+static int ngx_http_lua_socket_downstream_destroy(lua_State *L);
+static ngx_int_t ngx_http_lua_socket_push_input_data(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_socket_tcp_upstream_t *u,
+    lua_State *L);
+static ngx_int_t ngx_http_lua_socket_add_pending_data(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, u_char *pos, size_t len, u_char *pat,
+    int prefix, int old_state);
+static ngx_int_t ngx_http_lua_socket_add_input_buffer(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u);
+static ngx_int_t ngx_http_lua_socket_insert_buffer(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, u_char *pat, size_t prefix);
+static ngx_int_t ngx_http_lua_socket_tcp_resume(ngx_http_request_t *r);
+static void ngx_http_lua_tcp_resolve_cleanup(void *data);
+static void ngx_http_lua_tcp_socket_cleanup(void *data);
+
+
+enum {
+    SOCKET_CTX_INDEX = 1,
+    SOCKET_TIMEOUT_INDEX = 2,
+    SOCKET_KEY_INDEX = 3
+};
+
+
+static char ngx_http_lua_req_socket_metatable_key;
+static char ngx_http_lua_raw_req_socket_metatable_key;
+static char ngx_http_lua_tcp_socket_metatable_key;
+
+
+void
+ngx_http_lua_inject_socket_tcp_api(ngx_log_t *log, lua_State *L)
+{
+    ngx_int_t         rc;
+
+    lua_createtable(L, 0, 3 /* nrec */);    /* ngx.socket */
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp);
+    lua_setfield(L, -2, "tcp");
+
+    {
+        const char  buf[] = "local sock = ngx.socket.tcp()"
+                            " local ok, err = sock:connect(...)"
+                            " if ok then return sock else return nil, err end";
+
+        rc = luaL_loadbuffer(L, buf, sizeof(buf) - 1, "ngx.socket.connect");
+    }
+
+    if (rc != NGX_OK) {
+        ngx_log_error(NGX_LOG_CRIT, log, 0,
+                      "failed to load Lua code for ngx.socket.connect(): %i",
+                      rc);
+
+    } else {
+        lua_setfield(L, -2, "connect");
+    }
+
+    lua_setfield(L, -2, "socket");
+
+    /* {{{req socket object metatable */
+    lua_pushlightuserdata(L, &ngx_http_lua_req_socket_metatable_key);
+    lua_createtable(L, 0 /* narr */, 3 /* nrec */);
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_receive);
+    lua_setfield(L, -2, "receive");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_receiveuntil);
+    lua_setfield(L, -2, "receiveuntil");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_settimeout);
+    lua_setfield(L, -2, "settimeout"); /* ngx socket mt */
+
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -2, "__index");
+
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+
+    /* {{{raw req socket object metatable */
+    lua_pushlightuserdata(L, &ngx_http_lua_raw_req_socket_metatable_key);
+    lua_createtable(L, 0 /* narr */, 4 /* nrec */);
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_receive);
+    lua_setfield(L, -2, "receive");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_receiveuntil);
+    lua_setfield(L, -2, "receiveuntil");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_send);
+    lua_setfield(L, -2, "send");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_settimeout);
+    lua_setfield(L, -2, "settimeout"); /* ngx socket mt */
+
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -2, "__index");
+
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+
+    /* {{{tcp object metatable */
+    lua_pushlightuserdata(L, &ngx_http_lua_tcp_socket_metatable_key);
+    lua_createtable(L, 0 /* narr */, 10 /* nrec */);
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_connect);
+    lua_setfield(L, -2, "connect");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_receive);
+    lua_setfield(L, -2, "receive");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_receiveuntil);
+    lua_setfield(L, -2, "receiveuntil");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_send);
+    lua_setfield(L, -2, "send");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_close);
+    lua_setfield(L, -2, "close");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_setoption);
+    lua_setfield(L, -2, "setoption");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_settimeout);
+    lua_setfield(L, -2, "settimeout"); /* ngx socket mt */
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_getreusedtimes);
+    lua_setfield(L, -2, "getreusedtimes");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_tcp_setkeepalive);
+    lua_setfield(L, -2, "setkeepalive");
+
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -2, "__index");
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+}
+
+
+void
+ngx_http_lua_inject_req_socket_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_req_socket);
+    lua_setfield(L, -2, "socket");
+}
+
+
+static int
+ngx_http_lua_socket_tcp(lua_State *L)
+{
+    ngx_http_request_t      *r;
+    ngx_http_lua_ctx_t      *ctx;
+
+    if (lua_gettop(L) != 0) {
+        return luaL_error(L, "expecting zero arguments, but got %d",
+                          lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    lua_createtable(L, 3 /* narr */, 1 /* nrec */);
+    lua_pushlightuserdata(L, &ngx_http_lua_tcp_socket_metatable_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_setmetatable(L, -2);
+
+    dd("top: %d", lua_gettop(L));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_connect(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_str_t                    host;
+    int                          port;
+    ngx_resolver_ctx_t          *rctx, temp;
+    ngx_http_core_loc_conf_t    *clcf;
+    int                          saved_top;
+    int                          n;
+    u_char                      *p;
+    size_t                       len;
+    ngx_url_t                    url;
+    ngx_int_t                    rc;
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_peer_connection_t       *pc;
+    int                          timeout;
+    unsigned                     custom_pool;
+    int                          key_index;
+    const char                  *msg;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    ngx_http_lua_socket_tcp_upstream_t      *u;
+
+    n = lua_gettop(L);
+    if (n != 2 && n != 3 && n != 4) {
+        return luaL_error(L, "ngx.socket connect: expecting 2, 3, or 4 "
+                          "arguments (including the object), but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    host.data = ngx_palloc(r->pool, len + 1);
+    if (host.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    host.len = len;
+
+    ngx_memcpy(host.data, p, len);
+    host.data[len] = '\0';
+
+    key_index = 2;
+    custom_pool = 0;
+
+    if (lua_type(L, n) == LUA_TTABLE) {
+
+        /* found the last optional option table */
+
+        lua_getfield(L, n, "pool");
+
+        switch (lua_type(L, -1)) {
+        case LUA_TNUMBER:
+            lua_tostring(L, -1);
+
+        case LUA_TSTRING:
+            custom_pool = 1;
+
+            lua_pushvalue(L, -1);
+            lua_rawseti(L, 1, SOCKET_KEY_INDEX);
+
+            key_index = n + 1;
+
+            break;
+
+        case LUA_TNIL:
+            lua_pop(L, 2);
+            break;
+
+        default:
+            msg = lua_pushfstring(L, "bad \"pool\" option type: %s",
+                                  luaL_typename(L, -1));
+            luaL_argerror(L, n, msg);
+            break;
+        }
+
+        n--;
+    }
+
+    if (n == 3) {
+        port = luaL_checkinteger(L, 3);
+
+        if (port < 0 || port > 65536) {
+            lua_pushnil(L);
+            lua_pushfstring(L, "bad port number: %d", port);
+            return 2;
+        }
+
+        if (!custom_pool) {
+            lua_pushliteral(L, ":");
+            lua_insert(L, 3);
+            lua_concat(L, 3);
+        }
+
+        dd("socket key: %s", lua_tostring(L, -1));
+
+    } else { /* n == 2 */
+        port = 0;
+    }
+
+    if (!custom_pool) {
+        /* the key's index is 2 */
+
+        lua_pushvalue(L, 2);
+        lua_rawseti(L, 1, SOCKET_KEY_INDEX);
+    }
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u) {
+        if (u->waiting) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "socket busy");
+            return 2;
+        }
+
+        if (u->body_downstream || u->raw_downstream) {
+            return luaL_error(L, "attempt to re-connect a request socket");
+        }
+
+        if (u->peer.connection) {
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua tcp socket reconnect without shutting down");
+
+            ngx_http_lua_socket_tcp_finalize(r, u);
+        }
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua reuse socket upstream ctx");
+
+    } else {
+        u = lua_newuserdata(L, sizeof(ngx_http_lua_socket_tcp_upstream_t));
+        if (u == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+#if 1
+        lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */
+        lua_pushcfunction(L, ngx_http_lua_socket_tcp_upstream_destroy);
+        lua_setfield(L, -2, "__gc");
+        lua_setmetatable(L, -2);
+#endif
+
+        lua_rawseti(L, 1, SOCKET_CTX_INDEX);
+    }
+
+    ngx_memzero(u, sizeof(ngx_http_lua_socket_tcp_upstream_t));
+
+    coctx = ctx->cur_co_ctx;
+
+    u->request = r; /* set the controlling request */
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    u->conf = llcf;
+
+    pc = &u->peer;
+
+    pc->log = r->connection->log;
+    pc->log_error = NGX_ERROR_ERR;
+
+    dd("lua peer connection log: %p", pc->log);
+
+    lua_rawgeti(L, 1, SOCKET_TIMEOUT_INDEX);
+    timeout = (ngx_int_t) lua_tointeger(L, -1);
+    lua_pop(L, 1);
+
+    if (timeout > 0) {
+        u->send_timeout = (ngx_msec_t) timeout;
+        u->read_timeout = (ngx_msec_t) timeout;
+        u->connect_timeout = (ngx_msec_t) timeout;
+
+    } else {
+        u->read_timeout = u->conf->read_timeout;
+        u->send_timeout = u->conf->send_timeout;
+        u->connect_timeout = u->conf->connect_timeout;
+    }
+
+    rc = ngx_http_lua_get_keepalive_peer(r, L, key_index, u);
+
+    if (rc == NGX_OK) {
+        lua_pushinteger(L, 1);
+        return 1;
+    }
+
+    if (rc == NGX_ERROR) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "error in get keepalive peer");
+        return 2;
+    }
+
+    /* rc == NGX_DECLINED */
+
+    ngx_memzero(&url, sizeof(ngx_url_t));
+
+    url.url.len = host.len;
+    url.url.data = host.data;
+    url.default_port = (in_port_t) port;
+    url.no_resolve = 1;
+
+    if (ngx_parse_url(r->pool, &url) != NGX_OK) {
+        lua_pushnil(L);
+
+        if (url.err) {
+            lua_pushfstring(L, "failed to parse host name \"%s\": %s",
+                            host.data, url.err);
+
+        } else {
+            lua_pushfstring(L, "failed to parse host name \"%s\"", host.data);
+        }
+
+        return 2;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket connect timeout: %M", u->connect_timeout);
+
+    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));
+    if (u->resolved == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    if (url.addrs && url.addrs[0].sockaddr) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket network address given directly");
+
+        u->resolved->sockaddr = url.addrs[0].sockaddr;
+        u->resolved->socklen = url.addrs[0].socklen;
+        u->resolved->naddrs = 1;
+        u->resolved->host = url.addrs[0].name;
+
+    } else {
+        u->resolved->host = host;
+        u->resolved->port = (in_port_t) port;
+    }
+
+    if (u->resolved->sockaddr) {
+        rc = ngx_http_lua_socket_resolve_retval_handler(r, u, L);
+        if (rc == NGX_AGAIN) {
+            return lua_yield(L, 0);
+        }
+
+        return rc;
+    }
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    temp.name = host;
+    rctx = ngx_resolve_start(clcf->resolver, &temp);
+    if (rctx == NULL) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+        lua_pushnil(L);
+        lua_pushliteral(L, "failed to start the resolver");
+        return 2;
+    }
+
+    if (rctx == NGX_NO_RESOLVER) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+        lua_pushnil(L);
+        lua_pushfstring(L, "no resolver defined to resolve \"%s\"", host.data);
+        return 2;
+    }
+
+    rctx->name = host;
+    rctx->type = NGX_RESOLVE_A;
+    rctx->handler = ngx_http_lua_socket_resolve_handler;
+    rctx->data = u;
+    rctx->timeout = clcf->resolver_timeout;
+
+    u->resolved->ctx = rctx;
+    u->co_ctx = ctx->cur_co_ctx;
+
+    coctx->data = u;
+
+    saved_top = lua_gettop(L);
+
+    coctx->cleanup = ngx_http_lua_tcp_resolve_cleanup;
+
+    if (ngx_resolve_name(rctx) != NGX_OK) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket fail to run resolver immediately");
+
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+
+        u->resolved->ctx = NULL;
+        lua_pushnil(L);
+        lua_pushfstring(L, "%s could not be resolved", host.data);
+
+        return 2;
+    }
+
+    if (u->waiting == 1) {
+        /* resolved and already connecting */
+        return lua_yield(L, 0);
+    }
+
+    n = lua_gettop(L) - saved_top;
+    if (n) {
+        /* errors occurred during resolving or connecting
+         * or already connected */
+        return n;
+    }
+
+    /* still resolving */
+
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_resolve_retval_handler;
+
+    dd("setting data to %p", u);
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    return lua_yield(L, 0);
+}
+
+
+static void
+ngx_http_lua_socket_resolve_handler(ngx_resolver_ctx_t *ctx)
+{
+    ngx_http_request_t                  *r;
+    ngx_connection_t                    *c;
+    ngx_http_upstream_resolved_t        *ur;
+    ngx_http_lua_ctx_t                  *lctx;
+    lua_State                           *L;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+    u_char                              *p;
+    size_t                               len;
+    struct sockaddr_in                  *sin;
+    ngx_uint_t                           i;
+    unsigned                             waiting;
+
+    u = ctx->data;
+    r = u->request;
+    c = r->connection;
+    ur = u->resolved;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua tcp socket resolve handler");
+
+    lctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (lctx == NULL) {
+        return;
+    }
+
+    lctx->cur_co_ctx = u->co_ctx;
+
+    u->co_ctx->cleanup = NULL;
+
+    L = lctx->cur_co_ctx->co;
+
+    waiting = u->waiting;
+
+    if (ctx->state) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "lua tcp socket resolver error: %s (waiting: %d)",
+                       ngx_resolver_strerror(ctx->state), (int) u->waiting);
+
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *) ctx->name.data, ctx->name.len);
+        lua_pushfstring(L, " could not be resolved (%d: %s)",
+                        (int) ctx->state,
+                        ngx_resolver_strerror(ctx->state));
+        lua_concat(L, 2);
+
+        u->prepare_retvals = ngx_http_lua_socket_error_retval_handler;
+        ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_RESOLVER);
+
+        if (waiting) {
+            ngx_http_run_posted_requests(c);
+        }
+
+        return;
+    }
+
+    ur->naddrs = ctx->naddrs;
+    ur->addrs = ctx->addrs;
+
+#if (NGX_DEBUG)
+    {
+    in_addr_t   addr;
+    ngx_uint_t  i;
+
+    for (i = 0; i < ctx->naddrs; i++) {
+        dd("addr i: %d %p", (int) i,  &ctx->addrs[i]);
+
+        addr = ntohl(ctx->addrs[i]);
+
+        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "name was resolved to %ud.%ud.%ud.%ud",
+                       (addr >> 24) & 0xff, (addr >> 16) & 0xff,
+                       (addr >> 8) & 0xff, addr & 0xff);
+    }
+    }
+#endif
+
+    if (ur->naddrs == 0) {
+        ngx_resolve_name_done(ctx);
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "name cannot be resolved to a address");
+
+        if (waiting) {
+            ngx_http_run_posted_requests(c);
+        }
+
+        return;
+    }
+
+    if (ur->naddrs == 1) {
+        i = 0;
+
+    } else {
+        i = ngx_random() % ur->naddrs;
+    }
+
+    dd("selected addr index: %d", (int) i);
+
+    len = NGX_INET_ADDRSTRLEN + sizeof(":65536") - 1;
+
+    p = ngx_pnalloc(r->pool, len + sizeof(struct sockaddr_in));
+    if (p == NULL) {
+        ngx_resolve_name_done(ctx);
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "out of memory");
+
+        if (waiting) {
+            ngx_http_run_posted_requests(c);
+        }
+
+        return;
+    }
+
+    sin = (struct sockaddr_in *) &p[len];
+    ngx_memzero(sin, sizeof(struct sockaddr_in));
+
+    len = ngx_inet_ntop(AF_INET, &ur->addrs[i], p, NGX_INET_ADDRSTRLEN);
+    len = ngx_sprintf(&p[len], ":%d", ur->port) - p;
+
+    sin->sin_family = AF_INET;
+    sin->sin_port = htons(ur->port);
+    sin->sin_addr.s_addr = ur->addrs[i];
+
+    ur->sockaddr = (struct sockaddr *) sin;
+    ur->socklen = sizeof(struct sockaddr_in);
+
+    ur->host.data = p;
+    ur->host.len = len;
+    ur->naddrs = 1;
+
+    ur->ctx = NULL;
+
+    ngx_resolve_name_done(ctx);
+
+    u->waiting = 0;
+
+    if (waiting) {
+        lctx->resume_handler = ngx_http_lua_socket_tcp_resume;
+        r->write_event_handler(r);
+        ngx_http_run_posted_requests(c);
+
+    } else {
+        (void) ngx_http_lua_socket_resolve_retval_handler(r, u, L);
+    }
+}
+
+
+static int
+ngx_http_lua_socket_resolve_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L)
+{
+    ngx_http_lua_ctx_t              *ctx;
+    ngx_peer_connection_t           *pc;
+    ngx_connection_t                *c;
+    ngx_http_cleanup_t              *cln;
+    ngx_http_upstream_resolved_t    *ur;
+    ngx_int_t                        rc;
+    ngx_http_lua_co_ctx_t           *coctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket resolve retval handler");
+
+    if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_RESOLVER) {
+        return 2;
+    }
+
+    pc = &u->peer;
+
+    ur = u->resolved;
+
+    if (ur->sockaddr) {
+        pc->sockaddr = ur->sockaddr;
+        pc->socklen = ur->socklen;
+        pc->name = &ur->host;
+
+    } else {
+        lua_pushnil(L);
+        lua_pushliteral(L, "resolver not working");
+        return 2;
+    }
+
+    pc->get = ngx_http_lua_socket_tcp_get_peer;
+
+    rc = ngx_event_connect_peer(pc);
+
+    if (rc == NGX_ERROR) {
+        u->socket_errno = ngx_socket_errno;
+    }
+
+    if (u->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+            lua_pushnil(L);
+            lua_pushliteral(L, "out of memory");
+            return 2;
+        }
+
+        cln->handler = ngx_http_lua_socket_tcp_cleanup;
+        cln->data = u;
+        u->cleanup = &cln->handler;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket connect: %i", rc);
+
+    if (rc == NGX_ERROR) {
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    if (rc == NGX_BUSY) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+        lua_pushnil(L);
+        lua_pushliteral(L, "no live connection");
+        return 2;
+    }
+
+    if (rc == NGX_DECLINED) {
+        dd("socket errno: %d", (int) ngx_socket_errno);
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+        u->socket_errno = ngx_socket_errno;
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    /* rc == NGX_OK || rc == NGX_AGAIN */
+
+    c = pc->connection;
+
+    c->data = u;
+
+    c->write->handler = ngx_http_lua_socket_tcp_handler;
+    c->read->handler = ngx_http_lua_socket_tcp_handler;
+
+    u->write_event_handler = ngx_http_lua_socket_connected_handler;
+    u->read_event_handler = ngx_http_lua_socket_connected_handler;
+
+    c->sendfile &= r->connection->sendfile;
+
+    c->pool = r->pool;
+    c->log = r->connection->log;
+    c->read->log = c->log;
+    c->write->log = c->log;
+
+    /* init or reinit the ngx_output_chain() and ngx_chain_writer() contexts */
+
+#if 0
+    u->writer.out = NULL;
+    u->writer.last = &u->writer.out;
+#endif
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    coctx = ctx->cur_co_ctx;
+
+    dd("setting data to %p", u);
+
+    coctx->data = u;
+
+    if (rc == NGX_OK) {
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket connected: fd:%d", (int) c->fd);
+
+        /* We should delete the current write/read event
+         * here because the socket object may not be used immediately
+         * on the Lua land, thus causing hot spin around level triggered
+         * event poll and wasting CPU cycles. */
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            ngx_http_lua_socket_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_ERROR);
+            lua_pushnil(L);
+            lua_pushliteral(L, "failed to handle write event");
+            return 2;
+        }
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            ngx_http_lua_socket_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_ERROR);
+            lua_pushnil(L);
+            lua_pushliteral(L, "failed to handle write event");
+            return 2;
+        }
+
+        u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+        u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+
+        lua_pushinteger(L, 1);
+        return 1;
+    }
+
+    /* rc == NGX_AGAIN */
+
+    coctx->cleanup = ngx_http_lua_tcp_socket_cleanup;
+
+    ngx_add_timer(c->write, u->connect_timeout);
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    u->co_ctx = ctx->cur_co_ctx;
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_tcp_connect_retval_handler;
+
+    dd("setting data to %p", u);
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static int
+ngx_http_lua_socket_error_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L)
+{
+    ngx_uint_t       ft_type;
+    u_char           errstr[NGX_MAX_ERROR_STR];
+    u_char          *p;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket error retval handler");
+
+    if (u->co_ctx) {
+        u->co_ctx->cleanup = NULL;
+    }
+
+    ft_type = u->ft_type;
+
+    if (u->no_close) {
+        u->no_close = 0;
+        u->ft_type = 0;
+
+    } else {
+        ngx_http_lua_socket_tcp_finalize(r, u);
+    }
+
+    if (ft_type & NGX_HTTP_LUA_SOCKET_FT_RESOLVER) {
+        return 2;
+    }
+
+    lua_pushnil(L);
+
+    if (ft_type & NGX_HTTP_LUA_SOCKET_FT_TIMEOUT) {
+        lua_pushliteral(L, "timeout");
+
+    } else if (ft_type & NGX_HTTP_LUA_SOCKET_FT_CLOSED) {
+        lua_pushliteral(L, "closed");
+
+    } else if (ft_type & NGX_HTTP_LUA_SOCKET_FT_BUFTOOSMALL) {
+        lua_pushliteral(L, "buffer too small");
+
+    } else if (ft_type & NGX_HTTP_LUA_SOCKET_FT_NOMEM) {
+        lua_pushliteral(L, "out of memory");
+
+    } else if (ft_type & NGX_HTTP_LUA_SOCKET_FT_CLIENTABORT) {
+        lua_pushliteral(L, "client aborted");
+
+    } else {
+
+        if (u->socket_errno) {
+#if (nginx_version >= 1000000)
+            p = ngx_strerror(u->socket_errno, errstr, sizeof(errstr));
+#else
+            p = ngx_strerror_r(u->socket_errno, errstr, sizeof(errstr));
+#endif
+            /* for compatibility with LuaSocket */
+            ngx_strlow(errstr, errstr, p - errstr);
+            lua_pushlstring(L, (char *) errstr, p - errstr);
+
+        } else {
+            lua_pushliteral(L, "error");
+        }
+    }
+
+    return 2;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_connect_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L)
+{
+    if (u->ft_type) {
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_receive(lua_State *L)
+{
+    ngx_http_request_t                  *r;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+    ngx_int_t                            rc;
+    ngx_http_lua_ctx_t                  *ctx;
+    int                                  n;
+    ngx_str_t                            pat;
+    lua_Integer                          bytes;
+    char                                *p;
+    int                                  typ;
+    ngx_http_lua_loc_conf_t             *llcf;
+    ngx_http_lua_co_ctx_t               *coctx;
+
+    n = lua_gettop(L);
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting 1 or 2 arguments "
+                          "(including the object), but got %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket calling receive() method");
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+
+    if (u == NULL || u->peer.connection == NULL || u->ft_type || u->eof) {
+
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "attempt to receive data on a closed socket: u:%p, "
+                          "c:%p, ft:%ui eof:%ud",
+                          u, u ? u->peer.connection : NULL, u ? u->ft_type : 0,
+                          u ? u->eof : 0);
+        }
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket read timeout: %M", u->read_timeout);
+
+    if (n > 1) {
+        if (lua_isnumber(L, 2)) {
+            typ = LUA_TNUMBER;
+
+        } else {
+            typ = lua_type(L, 2);
+        }
+
+        switch (typ) {
+        case LUA_TSTRING:
+            pat.data = (u_char *) luaL_checklstring(L, 2, &pat.len);
+            if (pat.len != 2 || pat.data[0] != '*') {
+                p = (char *) lua_pushfstring(L, "bad pattern argument: %s",
+                                             (char *) pat.data);
+
+                return luaL_argerror(L, 2, p);
+            }
+
+            switch (pat.data[1]) {
+            case 'l':
+                u->input_filter = ngx_http_lua_socket_read_line;
+                break;
+
+            case 'a':
+                u->input_filter = ngx_http_lua_socket_read_all;
+                break;
+
+            default:
+                return luaL_argerror(L, 2, "bad pattern argument");
+                break;
+            }
+
+            u->length = 0;
+            u->rest = 0;
+
+            break;
+
+        case LUA_TNUMBER:
+            bytes = lua_tointeger(L, 2);
+            if (bytes < 0) {
+                return luaL_argerror(L, 2, "bad pattern argument");
+            }
+
+#if 1
+            if (bytes == 0) {
+                lua_pushliteral(L, "");
+                return 1;
+            }
+#endif
+
+            u->input_filter = ngx_http_lua_socket_read_chunk;
+            u->length = (size_t) bytes;
+            u->rest = u->length;
+
+            break;
+
+        default:
+            return luaL_argerror(L, 2, "bad pattern argument");
+            break;
+        }
+
+    } else {
+        u->input_filter = ngx_http_lua_socket_read_line;
+        u->length = 0;
+        u->rest = 0;
+    }
+
+    u->input_filter_ctx = u;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (u->bufs_in == NULL) {
+        u->bufs_in =
+            ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                             &ctx->free_recv_bufs,
+                                             u->conf->buffer_size,
+                                             (ngx_buf_tag_t)
+                                             &ngx_http_lua_module);
+
+        if (u->bufs_in == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        u->buf_in = u->bufs_in;
+        u->buffer = *u->buf_in->buf;
+    }
+
+    dd("tcp receive: buf_in: %p, bufs_in: %p", u->buf_in, u->bufs_in);
+
+    if (u->raw_downstream || u->body_downstream) {
+        r->read_event_handler = ngx_http_lua_req_socket_rev_handler;
+    }
+
+    u->waiting = 0;
+
+    rc = ngx_http_lua_socket_tcp_read(r, u);
+
+    if (rc == NGX_ERROR) {
+        dd("read failed: %d", (int) u->ft_type);
+        rc = ngx_http_lua_socket_tcp_receive_retval_handler(r, u, L);
+        dd("tcp receive retval returned: %d", (int) rc);
+        return rc;
+    }
+
+    if (rc == NGX_OK) {
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket receive done in a single run");
+
+        return ngx_http_lua_socket_tcp_receive_retval_handler(r, u, L);
+    }
+
+    /* rc == NGX_AGAIN */
+
+    u->read_event_handler = ngx_http_lua_socket_read_handler;
+    u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    ctx->cur_co_ctx->cleanup = ngx_http_lua_tcp_socket_cleanup;
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    u->co_ctx = ctx->cur_co_ctx;
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_tcp_receive_retval_handler;
+
+    coctx = ctx->cur_co_ctx;
+
+    dd("setting data to %p, coctx:%p", u, coctx);
+
+    coctx->data = u;
+
+    if (u->raw_downstream || u->body_downstream) {
+        ctx->downstream_co_ctx = coctx;
+    }
+
+    return lua_yield(L, 0);
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_read_chunk(void *data, ssize_t bytes)
+{
+    ngx_http_lua_socket_tcp_upstream_t      *u = data;
+
+    ngx_buf_t                   *b;
+#if (NGX_DEBUG)
+    ngx_http_request_t          *r;
+
+    r = u->request;
+#endif
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket read chunk %z", bytes);
+
+    if (bytes == 0) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_CLOSED;
+        return NGX_ERROR;
+    }
+
+    b = &u->buffer;
+
+    if (bytes >= (ssize_t) u->rest) {
+
+        u->buf_in->buf->last += u->rest;
+        b->pos += u->rest;
+        u->rest = 0;
+
+        return NGX_OK;
+    }
+
+    /* bytes < u->rest */
+
+    u->buf_in->buf->last += bytes;
+    b->pos += bytes;
+    u->rest -= bytes;
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_read_all(void *data, ssize_t bytes)
+{
+    ngx_http_lua_socket_tcp_upstream_t      *u = data;
+
+    ngx_buf_t                   *b;
+#if (NGX_DEBUG)
+    ngx_http_request_t          *r;
+
+    r = u->request;
+#endif
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket read all");
+
+    if (bytes == 0) {
+        return NGX_OK;
+    }
+
+    b = &u->buffer;
+
+    u->buf_in->buf->last += bytes;
+    b->pos += bytes;
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_read_line(void *data, ssize_t bytes)
+{
+    ngx_http_lua_socket_tcp_upstream_t      *u = data;
+
+    ngx_buf_t                   *b;
+    u_char                      *dst;
+    u_char                       c;
+#if (NGX_DEBUG)
+    u_char                      *begin;
+#endif
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, u->request->connection->log, 0,
+                   "lua tcp socket read line");
+
+    if (bytes == 0) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_CLOSED;
+        return NGX_ERROR;
+    }
+
+    b = &u->buffer;
+
+#if (NGX_DEBUG)
+    begin = b->pos;
+#endif
+
+    dd("already read: %p: %.*s", u->buf_in,
+            (int) (u->buf_in->buf->last - u->buf_in->buf->pos),
+            u->buf_in->buf->pos);
+
+    dd("data read: %.*s", (int) bytes, b->pos);
+
+    dst = u->buf_in->buf->last;
+
+    while (bytes--) {
+
+        c = *b->pos++;
+
+        switch (c) {
+        case '\n':
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, u->request->connection->log, 0,
+                           "lua tcp socket read the final line part: \"%*s\"",
+                           b->pos - 1 - begin, begin);
+
+            u->buf_in->buf->last = dst;
+
+            dd("read a line: %p: %.*s", u->buf_in,
+                    (int) (u->buf_in->buf->last - u->buf_in->buf->pos),
+                    u->buf_in->buf->pos);
+
+            return NGX_OK;
+
+        case '\r':
+            /* ignore it */
+            break;
+
+        default:
+            *dst++ = c;
+            break;
+        }
+    }
+
+#if (NGX_DEBUG)
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, u->request->connection->log, 0,
+                   "lua tcp socket read partial line data: %*s",
+                   dst - begin, begin);
+#endif
+
+    u->buf_in->buf->last = dst;
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_tcp_read(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_buf_t                   *b;
+    ngx_event_t                 *rev;
+    size_t                       size;
+    ssize_t                      n;
+    unsigned                     read;
+    off_t                        preread = 0;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    c = u->peer.connection;
+    rev = c->read;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua tcp socket read data: waiting: %d", (int) u->waiting);
+
+    b = &u->buffer;
+    read = 0;
+
+    for ( ;; ) {
+
+        size = b->last - b->pos;
+
+        if (size || u->eof) {
+
+            rc = u->input_filter(u->input_filter_ctx, size);
+
+            if (rc == NGX_OK) {
+
+                ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "lua tcp socket receive done: wait:%d, eof:%d, "
+                               "uri:\"%V?%V\"", (int) u->waiting, (int) u->eof,
+                               &r->uri, &r->args);
+
+                if (u->body_downstream
+                    && b->last == b->pos
+                    && r->request_body->rest == 0)
+                {
+
+                    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+                    if (llcf->check_client_abort) {
+                        rc = ngx_http_lua_check_broken_connection(r, rev);
+
+                        if (rc == NGX_OK) {
+                            goto success;
+                        }
+
+                        if (rc == NGX_HTTP_CLIENT_CLOSED_REQUEST) {
+                            ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_CLIENTABORT);
+
+                        } else {
+                            ngx_http_lua_socket_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_ERROR);
+                        }
+
+                        return NGX_ERROR;
+                    }
+                }
+
+#if 1
+                if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+                    ngx_http_lua_socket_handle_error(r, u,
+                                     NGX_HTTP_LUA_SOCKET_FT_ERROR);
+                    return NGX_ERROR;
+                }
+#endif
+
+success:
+                ngx_http_lua_socket_handle_success(r, u);
+                return NGX_OK;
+            }
+
+            if (rc == NGX_ERROR) {
+                dd("input filter error: ft_type:%d waiting:%d",
+                   (int) u->ft_type, (int) u->waiting);
+
+                ngx_http_lua_socket_handle_error(r, u,
+                                                 NGX_HTTP_LUA_SOCKET_FT_ERROR);
+                return NGX_ERROR;
+            }
+
+            /* rc == NGX_AGAIN */
+
+            if (u->body_downstream && r->request_body->rest == 0) {
+                u->eof = 1;
+            }
+
+            continue;
+        }
+
+        if (read && !rev->ready) {
+            rc = NGX_AGAIN;
+            break;
+        }
+
+        size = b->end - b->last;
+
+        if (size == 0) {
+            rc = ngx_http_lua_socket_add_input_buffer(r, u);
+            if (rc == NGX_ERROR) {
+                ngx_http_lua_socket_handle_error(r, u,
+                                                 NGX_HTTP_LUA_SOCKET_FT_NOMEM);
+
+                return NGX_ERROR;
+            }
+
+            b = &u->buffer;
+            size = (size_t) (b->end - b->last);
+        }
+
+        if (u->raw_downstream) {
+            preread = r->header_in->last - r->header_in->pos;
+
+            if (preread) {
+
+                if ((off_t) size > preread) {
+                    size = (size_t) preread;
+                }
+
+                ngx_http_lua_probe_req_socket_consume_preread(r,
+                                                              r->header_in->pos,
+                                                              size);
+
+                b->last = ngx_copy(b->last, r->header_in->pos, size);
+                r->header_in->pos += size;
+                continue;
+            }
+
+        } else if (u->body_downstream) {
+
+            if (r->request_body->rest == 0) {
+
+                dd("request body rest is zero");
+
+                u->eof = 1;
+
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "lua request body exhausted");
+
+                continue;
+            }
+
+            /* try to process the preread body */
+
+            preread = r->header_in->last - r->header_in->pos;
+
+            if (preread) {
+
+                /* there is the pre-read part of the request body */
+
+                ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "http client request body preread %O", preread);
+
+                if (preread >= r->request_body->rest) {
+                    preread = r->request_body->rest;
+                }
+
+                if ((off_t) size > preread) {
+                    size = (size_t) preread;
+                }
+
+                ngx_http_lua_probe_req_socket_consume_preread(r,
+                                                              r->header_in->pos,
+                                                              size);
+
+                b->last = ngx_copy(b->last, r->header_in->pos, size);
+
+                r->header_in->pos += size;
+                r->request_length += size;
+
+                if (r->request_body->rest) {
+                    r->request_body->rest -= size;
+                }
+
+                continue;
+            }
+
+            if (size > (size_t) r->request_body->rest) {
+                size = (size_t) r->request_body->rest;
+            }
+        }
+
+#if 1
+        if (rev->active && !rev->ready) {
+            rc = NGX_AGAIN;
+            break;
+        }
+#endif
+
+        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket try to recv data %uz: \"%V?%V\"",
+                       size, &r->uri, &r->args);
+
+        n = c->recv(c, b->last, size);
+
+        dd("read event ready: %d", (int) c->read->ready);
+
+        read = 1;
+
+        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket recv returned %d: \"%V?%V\"",
+                       (int) n, &r->uri, &r->args);
+
+        if (n == NGX_AGAIN) {
+            rc = NGX_AGAIN;
+            dd("socket recv busy");
+            break;
+        }
+
+        if (n == 0) {
+
+            if (u->raw_downstream || u->body_downstream) {
+
+                llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+                if (llcf->check_client_abort) {
+
+                    ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_CLIENTABORT);
+                    return NGX_ERROR;
+                }
+
+                /* llcf->check_client_abort == 0 */
+
+                if (u->body_downstream && r->request_body->rest) {
+                    ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_CLIENTABORT);
+                    return NGX_ERROR;
+                }
+            }
+
+            u->eof = 1;
+
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua tcp socket closed");
+
+            continue;
+        }
+
+        if (n == NGX_ERROR) {
+            u->socket_errno = ngx_socket_errno;
+            ngx_http_lua_socket_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_ERROR);
+            return NGX_ERROR;
+        }
+
+        b->last += n;
+
+        if (u->body_downstream) {
+            r->request_length += n;
+            r->request_body->rest -= n;
+        }
+    }
+
+#if 1
+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+        ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return NGX_ERROR;
+    }
+#endif
+
+    if (rev->active) {
+        ngx_add_timer(rev, u->read_timeout);
+
+    } else if (rev->timer_set) {
+        ngx_del_timer(rev);
+    }
+
+    return rc;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_send(lua_State *L)
+{
+    ngx_int_t                            rc;
+    ngx_http_request_t                  *r;
+    u_char                              *p;
+    size_t                               len;
+    ngx_chain_t                         *cl;
+    ngx_http_lua_ctx_t                  *ctx;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+    int                                  type;
+    const char                          *msg;
+    ngx_buf_t                           *b;
+    ngx_http_lua_loc_conf_t             *llcf;
+    ngx_http_lua_co_ctx_t               *coctx;
+
+    /* TODO: add support for the optional "i" and "j" arguments */
+
+    if (lua_gettop(L) != 2) {
+        return luaL_error(L, "expecting 2 arguments (including the object), "
+                          "but got %d", lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u == NULL || u->peer.connection == NULL || u->ft_type || u->eof) {
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "attempt to send data on a closed socket: u:%p, "
+                          "c:%p, ft:%ui eof:%ud",
+                          u, u ? u->peer.connection : NULL, u ? u->ft_type : 0,
+                          u ? u->eof : 0);
+        }
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    if (u->raw_downstream && r->connection->buffered) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    if (u->body_downstream) {
+        return luaL_error(L, "attempt to write to request sockets");
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket send timeout: %M", u->send_timeout);
+
+    type = lua_type(L, 2);
+    switch (type) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            lua_tolstring(L, 2, &len);
+            break;
+
+        case LUA_TTABLE:
+            len = ngx_http_lua_calc_strlen_in_table(L, 2, 2, 1 /* strict */);
+            break;
+
+        default:
+            msg = lua_pushfstring(L, "string, number, boolean, nil, "
+                                  "or array table expected, got %s",
+                                  lua_typename(L, type));
+
+            return luaL_argerror(L, 2, msg);
+    }
+
+    if (len == 0) {
+        lua_pushinteger(L, 0);
+        return 1;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    cl = ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                          &ctx->free_bufs, len,
+                                          (ngx_buf_tag_t)
+                                          &ngx_http_lua_module);
+
+    if (cl == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    b = cl->buf;
+
+    switch (type) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            p = (u_char *) lua_tolstring(L, -1, &len);
+            b->last = ngx_copy(b->last, (u_char *) p, len);
+            break;
+
+        case LUA_TTABLE:
+            b->last = ngx_http_lua_copy_str_in_table(L, -1, b->last);
+            break;
+
+        default:
+            return luaL_error(L, "impossible to reach here");
+    }
+
+    u->request_bufs = cl;
+
+    u->request_len = len;
+    u->ft_type = 0;
+
+    /* mimic ngx_http_upstream_init_request here */
+
+#if 1
+    u->waiting = 0;
+#endif
+
+    ngx_http_lua_probe_socket_tcp_send_start(r, u, b->pos, len);
+
+    rc = ngx_http_lua_socket_send(r, u);
+
+    dd("socket send returned %d", (int) rc);
+
+    if (rc == NGX_ERROR) {
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    if (rc == NGX_OK) {
+        lua_pushinteger(L, len);
+        return 1;
+    }
+
+    /* rc == NGX_AGAIN */
+
+    ctx->cur_co_ctx->cleanup = ngx_http_lua_tcp_socket_cleanup;
+    ctx->writing_raw_req_socket = 1;
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    u->co_ctx = ctx->cur_co_ctx;
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_tcp_send_retval_handler;
+
+    dd("setting data to %p", u);
+
+    coctx = ctx->cur_co_ctx;
+    coctx->data = u;
+
+    return lua_yield(L, 0);
+}
+
+
+static int
+ngx_http_lua_socket_tcp_send_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket send return value handler");
+
+    if (u->ft_type) {
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    lua_pushinteger(L, u->request_len);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_receive_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L)
+{
+    int                          n;
+    ngx_int_t                    rc;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_event_t                 *ev;
+
+    ngx_http_lua_loc_conf_t             *llcf;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket receive return value handler");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+#if 1
+    if (u->raw_downstream || u->body_downstream) {
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->check_client_abort) {
+
+            r->read_event_handler = ngx_http_lua_rd_check_broken_connection;
+
+            ev = r->connection->read;
+
+            dd("rev active: %d", ev->active);
+
+            if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && !ev->active) {
+                if (ngx_add_event(ev, NGX_READ_EVENT, 0) != NGX_OK) {
+                    lua_pushnil(L);
+                    lua_pushliteral(L, "failed to add event");
+                    return 2;
+                }
+            }
+
+        } else {
+            /* llcf->check_client_abort == 0 */
+            r->read_event_handler = ngx_http_block_reading;
+        }
+    }
+#endif
+
+    if (u->ft_type) {
+
+        if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_TIMEOUT) {
+            u->no_close = 1;
+        }
+
+        dd("u->bufs_in: %p", u->bufs_in);
+
+        if (u->bufs_in) {
+            rc = ngx_http_lua_socket_push_input_data(r, ctx, u, L);
+            if (rc == NGX_ERROR) {
+                lua_pushnil(L);
+                lua_pushliteral(L, "out of memory");
+                return 2;
+            }
+
+            (void) ngx_http_lua_socket_error_retval_handler(r, u, L);
+
+            lua_pushvalue(L, -3);
+            lua_remove(L, -4);
+            return 3;
+        }
+
+        n = ngx_http_lua_socket_error_retval_handler(r, u, L);
+        lua_pushliteral(L, "");
+        return n + 1;
+    }
+
+    rc = ngx_http_lua_socket_push_input_data(r, ctx, u, L);
+    if (rc == NGX_ERROR) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "out of memory");
+        return 2;
+    }
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_close(lua_State *L)
+{
+    ngx_http_request_t                  *r;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting 1 argument "
+                          "(including the object) but seen %d", lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u == NULL || u->peer.connection == NULL || u->ft_type || u->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    if (u->raw_downstream || u->body_downstream) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "attempt to close a request socket");
+        return 2;
+    }
+
+    ngx_http_lua_socket_tcp_finalize(r, u);
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_setoption(lua_State *L)
+{
+    /* TODO */
+    return 0;
+}
+
+
+static int
+ngx_http_lua_socket_tcp_settimeout(lua_State *L)
+{
+    int                     n;
+    ngx_int_t               timeout;
+
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+
+    n = lua_gettop(L);
+
+    if (n != 2) {
+        return luaL_error(L, "ngx.socket settimout: expecting at least 2 "
+                          "arguments (including the object) but seen %d",
+                          lua_gettop(L));
+    }
+
+    timeout = (ngx_int_t) lua_tonumber(L, 2);
+
+    lua_rawseti(L, 1, SOCKET_TIMEOUT_INDEX);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+
+    if (u) {
+        if (timeout > 0) {
+            u->read_timeout = (ngx_msec_t) timeout;
+            u->send_timeout = (ngx_msec_t) timeout;
+            u->connect_timeout = (ngx_msec_t) timeout;
+
+        } else {
+            u->read_timeout = u->conf->read_timeout;
+            u->send_timeout = u->conf->send_timeout;
+            u->connect_timeout = u->conf->connect_timeout;
+        }
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_socket_tcp_handler(ngx_event_t *ev)
+{
+    ngx_connection_t                *c;
+    ngx_http_request_t              *r;
+    ngx_http_log_ctx_t              *ctx;
+
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+
+    c = ev->data;
+    u = c->data;
+    r = u->request;
+    c = r->connection;
+
+    ctx = c->log->data;
+    ctx->current_request = r;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket handler for \"%V?%V\", wev %d", &r->uri,
+                   &r->args, (int) ev->write);
+
+    if (ev->write) {
+        u->write_event_handler(r, u);
+
+    } else {
+        u->read_event_handler(r, u);
+    }
+
+    ngx_http_run_posted_requests(c);
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_tcp_get_peer(ngx_peer_connection_t *pc, void *data)
+{
+    /* empty */
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_socket_read_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_connection_t            *c;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    c = u->peer.connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket read handler");
+
+    if (c->read->timedout) {
+        c->read->timedout = 0;
+
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "lua tcp socket read timed out");
+        }
+
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_TIMEOUT);
+        return;
+    }
+
+#if 1
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+#endif
+
+    if (u->buffer.start != NULL) {
+        (void) ngx_http_lua_socket_tcp_read(r, u);
+    }
+}
+
+
+static void
+ngx_http_lua_socket_send_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_connection_t            *c;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    c = u->peer.connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket send handler");
+
+    if (c->write->timedout) {
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "lua tcp socket write timed out");
+        }
+
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_TIMEOUT);
+        return;
+    }
+
+    if (u->request_bufs) {
+        (void) ngx_http_lua_socket_send(r, u);
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_send(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_int_t                    n;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_buf_t                   *b;
+
+    c = u->peer.connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket send data");
+
+    dd("lua connection log: %p", c->log);
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return NGX_ERROR;
+    }
+
+    b = u->request_bufs->buf;
+
+    for (;;) {
+        n = c->send(c, b->pos, b->last - b->pos);
+
+        if (n >= 0) {
+            b->pos += n;
+
+            if (b->pos == b->last) {
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                               "lua tcp socket sent all the data");
+
+                if (c->write->timer_set) {
+                    ngx_del_timer(c->write);
+                }
+
+
+#if defined(nginx_version) && nginx_version >= 1001004
+                ngx_chain_update_chains(r->pool,
+#else
+                ngx_chain_update_chains(
+#endif
+                                        &ctx->free_bufs, &ctx->busy_bufs,
+                                        &u->request_bufs,
+                                        (ngx_buf_tag_t) &ngx_http_lua_module);
+
+                u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+
+                if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+                    ngx_http_lua_socket_handle_error(r, u,
+                                                NGX_HTTP_LUA_SOCKET_FT_ERROR);
+                    return NGX_ERROR;
+                }
+
+                ngx_http_lua_socket_handle_success(r, u);
+                return NGX_OK;
+            }
+
+            /* keep sending more data */
+            continue;
+        }
+
+        /* NGX_ERROR || NGX_AGAIN */
+        break;
+    }
+
+    if (n == NGX_ERROR) {
+        u->socket_errno = ngx_socket_errno;
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return NGX_ERROR;
+    }
+
+    /* n == NGX_AGAIN */
+
+    if (u->raw_downstream) {
+        ctx->writing_raw_req_socket = 1;
+    }
+
+    u->write_event_handler = ngx_http_lua_socket_send_handler;
+    u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    ngx_add_timer(c->write, u->send_timeout);
+
+    if (ngx_handle_write_event(c->write, u->conf->send_lowat) != NGX_OK) {
+        ngx_http_lua_socket_handle_error(r, u,
+                                         NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return NGX_ERROR;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static void
+ngx_http_lua_socket_handle_success(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_http_lua_ctx_t          *ctx;
+
+#if 1
+    u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+    u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+#endif
+
+    if (u->co_ctx) {
+        u->co_ctx->cleanup = NULL;
+    }
+
+#if 0
+    if (u->eof) {
+        ngx_http_lua_socket_tcp_finalize(r, u);
+    }
+#endif
+
+    if (u->waiting) {
+        u->waiting = 0;
+
+        ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+        if (ctx == NULL) {
+            return;
+        }
+
+        ctx->resume_handler = ngx_http_lua_socket_tcp_resume;
+        ctx->cur_co_ctx = u->co_ctx;
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket waking up the current request");
+
+        r->write_event_handler(r);
+    }
+}
+
+
+static void
+ngx_http_lua_socket_handle_error(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, ngx_uint_t ft_type)
+{
+    ngx_http_lua_ctx_t          *ctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket handle error");
+
+    u->ft_type |= ft_type;
+
+#if 0
+    ngx_http_lua_socket_tcp_finalize(r, u);
+#endif
+
+    if (u->co_ctx) {
+        u->co_ctx->cleanup = NULL;
+    }
+
+    u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+    u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    if (u->waiting) {
+        u->waiting = 0;
+
+        ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+        if (ctx == NULL) {
+            return;
+        }
+
+        ctx->resume_handler = ngx_http_lua_socket_tcp_resume;
+        ctx->cur_co_ctx = u->co_ctx;
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket waking up the current request");
+
+        r->write_event_handler(r);
+    }
+}
+
+
+static void
+ngx_http_lua_socket_connected_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    c = u->peer.connection;
+
+    if (c->write->timedout) {
+
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "lua tcp socket connect timed out");
+        }
+
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_TIMEOUT);
+        return;
+    }
+
+    if (c->write->timer_set) {
+        ngx_del_timer(c->write);
+    }
+
+    rc = ngx_http_lua_socket_test_connect(r, c);
+    if (rc != NGX_OK) {
+        if (rc > 0) {
+            u->socket_errno = (ngx_err_t) rc;
+        }
+
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket connected");
+
+    /* We should delete the current write/read event
+     * here because the socket object may not be used immediately
+     * on the Lua land, thus causing hot spin around level triggered
+     * event poll and wasting CPU cycles. */
+
+    if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return;
+    }
+
+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+        ngx_http_lua_socket_handle_error(r, u, NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return;
+    }
+
+    ngx_http_lua_socket_handle_success(r, u);
+}
+
+
+static void
+ngx_http_lua_socket_tcp_cleanup(void *data)
+{
+    ngx_http_lua_socket_tcp_upstream_t  *u = data;
+
+    ngx_http_request_t  *r;
+
+    r = u->request;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "cleanup lua tcp socket upstream request: \"%V\"", &r->uri);
+
+    ngx_http_lua_socket_tcp_finalize(r, u);
+}
+
+
+static void
+ngx_http_lua_socket_tcp_finalize(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_http_lua_socket_pool_t          *spool;
+    ngx_chain_t                         *cl;
+    ngx_chain_t                        **ll;
+    ngx_http_lua_ctx_t                  *ctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua finalize socket");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (ctx && u->bufs_in) {
+
+        ll = &u->bufs_in;
+        for (cl = u->bufs_in; cl; cl = cl->next) {
+            dd("bufs_in chain: %p, next %p", cl, cl->next);
+            cl->buf->pos = cl->buf->last;
+            ll = &cl->next;
+        }
+
+        dd("ctx: %p", ctx);
+        dd("free recv bufs: %p", ctx->free_recv_bufs);
+        *ll = ctx->free_recv_bufs;
+        ctx->free_recv_bufs = u->bufs_in;
+        u->bufs_in = NULL;
+        u->buf_in = NULL;
+        ngx_memzero(&u->buffer, sizeof(ngx_buf_t));
+    }
+
+    if (u->cleanup) {
+        *u->cleanup = NULL;
+        u->cleanup = NULL;
+    }
+
+    if (u->raw_downstream || u->body_downstream) {
+        if (r->connection->read->timer_set) {
+            ngx_del_timer(r->connection->read);
+        }
+
+        u->peer.connection = NULL;
+        return;
+    }
+
+    if (u->resolved && u->resolved->ctx) {
+        ngx_resolve_name_done(u->resolved->ctx);
+        u->resolved->ctx = NULL;
+    }
+
+    if (u->peer.free) {
+        u->peer.free(&u->peer, u->peer.data, 0);
+    }
+
+    if (u->peer.connection) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua close socket connection");
+
+        ngx_close_connection(u->peer.connection);
+        u->peer.connection = NULL;
+
+        if (!u->reused) {
+            return;
+        }
+
+        spool = u->socket_pool;
+        if (spool == NULL) {
+            return;
+        }
+
+        spool->active_connections--;
+
+        if (spool->active_connections == 0) {
+            ngx_http_lua_socket_free_pool(r->connection->log, spool);
+        }
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_test_connect(ngx_http_request_t *r, ngx_connection_t *c)
+{
+    int              err;
+    socklen_t        len;
+
+    ngx_http_lua_loc_conf_t     *llcf;
+
+#if (NGX_HAVE_KQUEUE)
+
+    ngx_event_t     *ev;
+
+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT)  {
+        dd("pending eof: (%p)%d (%p)%d", c->write, c->write->pending_eof,
+            c->read, c->read->pending_eof);
+
+        if (c->write->pending_eof) {
+            ev = c->write;
+
+        } else if (c->read->pending_eof) {
+            ev = c->read;
+
+        } else {
+            ev = NULL;
+        }
+
+        if (ev) {
+            llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+            if (llcf->log_socket_errors) {
+                (void) ngx_connection_error(c, ev->kq_errno,
+                                            "kevent() reported that "
+                                            "connect() failed");
+            }
+            return ev->kq_errno;
+        }
+
+    } else
+#endif
+    {
+        err = 0;
+        len = sizeof(int);
+
+        /*
+         * BSDs and Linux return 0 and set a pending error in err
+         * Solaris returns -1 and sets errno
+         */
+
+        if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, (void *) &err, &len)
+            == -1)
+        {
+            err = ngx_errno;
+        }
+
+        if (err) {
+            llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+            if (llcf->log_socket_errors) {
+                (void) ngx_connection_error(c, err, "connect() failed");
+            }
+            return err;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_socket_dummy_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket dummy handler");
+}
+
+
+static int
+ngx_http_lua_socket_tcp_receiveuntil(lua_State *L)
+{
+    ngx_http_request_t                  *r;
+    int                                  n;
+    ngx_str_t                            pat;
+    ngx_int_t                            rc;
+    size_t                               size;
+    unsigned                             inclusive = 0;
+
+    ngx_http_lua_socket_compiled_pattern_t     *cp;
+
+    n = lua_gettop(L);
+    if (n != 2 && n != 3) {
+        return luaL_error(L, "expecting 2 or 3 arguments "
+                          "(including the object), but got %d", n);
+    }
+
+    if (n == 3) {
+        /* check out the options table */
+
+        luaL_checktype(L, 3, LUA_TTABLE);
+
+        lua_getfield(L, 3, "inclusive");
+
+        switch (lua_type(L, -1)) {
+            case LUA_TNIL:
+                /* do nothing */
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, -1)) {
+                    inclusive = 1;
+                }
+                break;
+
+            default:
+                return luaL_error(L, "bad \"inclusive\" option value type: %s",
+                                  luaL_typename(L, -1));
+
+        }
+
+        lua_pop(L, 2);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket calling receiveuntil() method");
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    pat.data = (u_char *) luaL_checklstring(L, 2, &pat.len);
+    if (pat.len == 0) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "pattern is empty");
+        return 2;
+    }
+
+    size = sizeof(ngx_http_lua_socket_compiled_pattern_t);
+
+    cp = lua_newuserdata(L, size);
+    if (cp == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */
+    lua_pushcfunction(L, ngx_http_lua_socket_cleanup_compiled_pattern);
+    lua_setfield(L, -2, "__gc");
+    lua_setmetatable(L, -2);
+
+    ngx_memzero(cp, size);
+
+    cp->inclusive = inclusive;
+
+    rc = ngx_http_lua_socket_compile_pattern(pat.data, pat.len, cp,
+                                             r->connection->log);
+
+    if (rc != NGX_OK) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "failed to compile pattern");
+        return 2;
+    }
+
+    lua_pushcclosure(L, ngx_http_lua_socket_receiveuntil_iterator, 3);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_receiveuntil_iterator(lua_State *L)
+{
+    ngx_http_request_t                  *r;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+    ngx_int_t                            rc;
+    ngx_http_lua_ctx_t                  *ctx;
+    lua_Integer                          bytes;
+    int                                  n;
+    ngx_http_lua_co_ctx_t               *coctx;
+
+    ngx_http_lua_socket_compiled_pattern_t     *cp;
+
+    n = lua_gettop(L);
+    if (n > 1) {
+        return luaL_error(L, "expecting 0 or 1 arguments, "
+                          "but seen %d", n);
+    }
+
+    if (n >= 1) {
+        bytes = luaL_checkinteger(L, 1);
+        if (bytes < 0) {
+            bytes = 0;
+        }
+
+    } else {
+        bytes = 0;
+    }
+
+    lua_rawgeti(L, lua_upvalueindex(1), SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u == NULL || u->peer.connection == NULL || u->ft_type || u->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    r = u->request;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket receiveuntil iterator");
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket read timeout: %M", u->read_timeout);
+
+    u->input_filter = ngx_http_lua_socket_read_until;
+
+    cp = lua_touserdata(L, lua_upvalueindex(3));
+
+    dd("checking existing state: %d", cp->state);
+
+    if (cp->state == -1) {
+        cp->state = 0;
+
+        lua_pushnil(L);
+        lua_pushnil(L);
+        lua_pushnil(L);
+        return 3;
+    }
+
+    cp->upstream = u;
+
+    cp->pattern.data =
+        (u_char *) lua_tolstring(L, lua_upvalueindex(2),
+                                 &cp->pattern.len);
+
+    u->input_filter_ctx = cp;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    if (u->bufs_in == NULL) {
+        u->bufs_in =
+            ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                             &ctx->free_recv_bufs,
+                                             u->conf->buffer_size,
+                                             (ngx_buf_tag_t)
+                                             &ngx_http_lua_module);
+
+        if (u->bufs_in == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        u->buf_in = u->bufs_in;
+        u->buffer = *u->buf_in->buf;
+    }
+
+    u->length = (size_t) bytes;
+    u->rest = u->length;
+
+    if (u->raw_downstream || u->body_downstream) {
+        r->read_event_handler = ngx_http_lua_req_socket_rev_handler;
+    }
+
+    u->waiting = 0;
+
+    rc = ngx_http_lua_socket_tcp_read(r, u);
+
+    if (rc == NGX_ERROR) {
+        dd("read failed: %d", (int) u->ft_type);
+        rc = ngx_http_lua_socket_tcp_receive_retval_handler(r, u, L);
+        dd("tcp receive retval returned: %d", (int) rc);
+        return rc;
+    }
+
+    if (rc == NGX_OK) {
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket receive done in a single run");
+
+        return ngx_http_lua_socket_tcp_receive_retval_handler(r, u, L);
+    }
+
+    /* rc == NGX_AGAIN */
+
+    u->read_event_handler = ngx_http_lua_socket_read_handler;
+    u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    ctx->cur_co_ctx->cleanup = ngx_http_lua_tcp_socket_cleanup;
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    u->co_ctx = ctx->cur_co_ctx;
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_tcp_receive_retval_handler;
+
+    coctx = ctx->cur_co_ctx;
+
+    dd("setting data to %p", u);
+
+    coctx->data = u;
+
+    if (u->raw_downstream || u->body_downstream) {
+        ctx->downstream_co_ctx = coctx;
+    }
+
+    return lua_yield(L, 0);
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_compile_pattern(u_char *data, size_t len,
+    ngx_http_lua_socket_compiled_pattern_t *cp, ngx_log_t *log)
+{
+    size_t              i;
+    size_t              prefix_len;
+    size_t              size;
+    unsigned            found;
+    int                 cur_state, new_state;
+
+    ngx_http_lua_dfa_edge_t         *edge;
+    ngx_http_lua_dfa_edge_t        **last = NULL;
+
+    cp->pattern.len = len;
+
+    if (len <= 2) {
+        return NGX_OK;
+    }
+
+    for (i = 1; i < len; i++) {
+        prefix_len = 1;
+
+        while (prefix_len <= len - i - 1) {
+
+            if (ngx_memcmp(data, &data[i], prefix_len) == 0) {
+                if (data[prefix_len] == data[i + prefix_len]) {
+                    prefix_len++;
+                    continue;
+                }
+
+                cur_state = i + prefix_len;
+                new_state = prefix_len + 1;
+
+                if (cp->recovering == NULL) {
+                    size = sizeof(void *) * (len - 2);
+                    cp->recovering = ngx_alloc(size, log);
+                    if (cp->recovering == NULL) {
+                        return NGX_ERROR;
+                    }
+
+                    ngx_memzero(cp->recovering, size);
+                }
+
+                edge = cp->recovering[cur_state - 2];
+
+                found = 0;
+
+                if (edge == NULL) {
+                    last = &cp->recovering[cur_state - 2];
+
+                } else {
+
+                    for (; edge; edge = edge->next) {
+                        last = &edge->next;
+
+                        if (edge->chr == data[prefix_len]) {
+                            found = 1;
+
+                            if (edge->new_state < new_state) {
+                                edge->new_state = new_state;
+                            }
+
+                            break;
+                        }
+                    }
+                }
+
+                if (!found) {
+                    ngx_log_debug7(NGX_LOG_DEBUG_HTTP, log, 0,
+                                   "lua tcp socket read until recovering point:"
+                                   " on state %d (%*s), if next is '%c', then "
+                                   "recover to state %d (%*s)", cur_state,
+                                   (size_t) cur_state, data, data[prefix_len],
+                                   new_state, (size_t) new_state, data);
+
+                    edge = ngx_alloc(sizeof(ngx_http_lua_dfa_edge_t), log);
+                    edge->chr = data[prefix_len];
+                    edge->new_state = new_state;
+                    edge->next = NULL;
+
+                    *last = edge;
+                }
+
+                break;
+            }
+
+            break;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_read_until(void *data, ssize_t bytes)
+{
+    ngx_http_lua_socket_compiled_pattern_t     *cp = data;
+
+    ngx_http_lua_socket_tcp_upstream_t      *u;
+    ngx_http_request_t                      *r;
+    ngx_buf_t                               *b;
+    u_char                                   c;
+    u_char                                  *pat;
+    size_t                                   pat_len;
+    int                                      i;
+    int                                      state;
+    int                                      old_state = 0; /* just to make old
+                                                               gcc happy */
+    ngx_http_lua_dfa_edge_t                 *edge;
+    unsigned                                 matched;
+    ngx_int_t                                rc;
+
+    u = cp->upstream;
+    r = u->request;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket read until");
+
+    if (bytes == 0) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_CLOSED;
+        return NGX_ERROR;
+    }
+
+    b = &u->buffer;
+
+    pat = cp->pattern.data;
+    pat_len = cp->pattern.len;
+    state = cp->state;
+
+    i = 0;
+    while (i < bytes) {
+        c = b->pos[i];
+
+        dd("%d: read char %d, state: %d", i, c, state);
+
+        if (c == pat[state]) {
+            i++;
+            state++;
+
+            if (state == (int) pat_len) {
+                /* already matched the whole pattern */
+                dd("pat len: %d", (int) pat_len);
+
+                b->pos += i;
+
+                if (u->length) {
+                    cp->state = -1;
+
+                } else {
+                    cp->state = 0;
+                }
+
+                if (cp->inclusive) {
+                    rc = ngx_http_lua_socket_add_pending_data(r, u, b->pos, 0,
+                                                              pat, state,
+                                                              state);
+
+                    if (rc != NGX_OK) {
+                        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+                        return NGX_ERROR;
+                    }
+                }
+
+                return NGX_OK;
+            }
+
+            continue;
+        }
+
+        if (state == 0) {
+            u->buf_in->buf->last++;
+
+            i++;
+
+            if (u->length && --u->rest == 0) {
+                cp->state = state;
+                b->pos += i;
+                return NGX_OK;
+            }
+
+            continue;
+        }
+
+        matched = 0;
+
+        if (cp->recovering && state >= 2) {
+            dd("accessing state: %d, index: %d", state, state - 2);
+            for (edge = cp->recovering[state - 2]; edge; edge = edge->next) {
+
+                if (edge->chr == c) {
+                    dd("matched '%c' and jumping to state %d", c,
+                       edge->new_state);
+
+                    old_state = state;
+                    state = edge->new_state;
+                    matched = 1;
+                    break;
+                }
+            }
+        }
+
+        if (!matched) {
+#if 1
+            dd("adding pending data: %.*s", state, pat);
+            rc = ngx_http_lua_socket_add_pending_data(r, u, b->pos, i, pat,
+                                                      state, state);
+
+            if (rc != NGX_OK) {
+                u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+                return NGX_ERROR;
+            }
+
+#endif
+
+            if (u->length) {
+                if (u->rest <= (size_t) state) {
+                    u->rest = 0;
+                    cp->state = 0;
+                    b->pos += i;
+                    return NGX_OK;
+
+                } else {
+                    u->rest -= state;
+                }
+            }
+
+            state = 0;
+            continue;
+        }
+
+        /* matched */
+
+        dd("adding pending data: %.*s", (int) (old_state + 1 - state),
+           (char *) pat);
+
+        rc = ngx_http_lua_socket_add_pending_data(r, u, b->pos, i, pat,
+                                                  old_state + 1 - state,
+                                                  old_state);
+
+        if (rc != NGX_OK) {
+            u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+            return NGX_ERROR;
+        }
+
+        i++;
+
+        if (u->length) {
+            if (u->rest <= (size_t) state) {
+                u->rest = 0;
+                cp->state = state;
+                b->pos += i;
+                return NGX_OK;
+
+            } else {
+                u->rest -= state;
+            }
+        }
+
+        continue;
+    }
+
+    b->pos += i;
+    cp->state = state;
+
+    return NGX_AGAIN;
+}
+
+
+static int
+ngx_http_lua_socket_cleanup_compiled_pattern(lua_State *L)
+{
+    ngx_http_lua_socket_compiled_pattern_t      *cp;
+
+    ngx_http_lua_dfa_edge_t         *edge, *p;
+    unsigned                         i;
+
+    dd("cleanup compiled pattern");
+
+    cp = lua_touserdata(L, 1);
+    if (cp == NULL || cp->recovering == NULL) {
+        return 0;
+    }
+
+    dd("pattern len: %d", (int) cp->pattern.len);
+
+    for (i = 0; i < cp->pattern.len - 2; i++) {
+        edge = cp->recovering[i];
+
+        while (edge) {
+            p = edge;
+            edge = edge->next;
+
+            dd("freeing edge %p", p);
+
+            ngx_free(p);
+
+            dd("edge: %p", edge);
+        }
+    }
+
+#if 1
+    ngx_free(cp->recovering);
+    cp->recovering = NULL;
+#endif
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_req_socket(lua_State *L)
+{
+    int                              n, raw;
+    ngx_peer_connection_t           *pc;
+    ngx_http_lua_loc_conf_t         *llcf;
+    ngx_connection_t                *c;
+    ngx_http_request_t              *r;
+    ngx_http_lua_ctx_t              *ctx;
+    ngx_http_request_body_t         *rb;
+    ngx_http_cleanup_t              *cln;
+    ngx_http_lua_co_ctx_t           *coctx;
+#if nginx_version >= 1003013
+    int                              tcp_nodelay;
+    ngx_http_core_loc_conf_t        *clcf;
+#endif
+
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+
+    n = lua_gettop(L);
+    if (n == 0) {
+        raw = 0;
+
+    } else if (n == 1) {
+        raw = lua_toboolean(L, 1);
+        lua_pop(L, 1);
+
+    } else {
+        return luaL_error(L, "expecting zero arguments, but got %d",
+                          lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+
+    if (r != r->main) {
+        return luaL_error(L, "attempt to read the request body in a "
+                          "subrequest");
+    }
+
+#if (NGX_HTTP_SPDY)
+    if (r->spdy_stream) {
+        return luaL_error(L, "spdy not supported yet");
+    }
+#endif
+
+#if nginx_version >= 1003009
+    if (r->headers_in.chunked) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "chunked request bodies not supported yet");
+        return 2;
+    }
+#endif
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    c = r->connection;
+
+    if (raw) {
+#if !defined(nginx_version) || nginx_version < 1003013
+        lua_pushnil(L);
+        lua_pushliteral(L, "nginx version too old");
+        return 2;
+#else
+        if (!r->request_body) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "requesty body not read yet");
+            return 2;
+        }
+
+        if (c->buffered) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "pending data to write");
+            return 2;
+        }
+
+        if (ctx->buffering) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "http 1.0 buffering");
+            return 2;
+        }
+
+        if (!r->header_sent) {
+            /* prevent other parts of nginx from sending out
+             * the response header */
+            r->header_sent = 1;
+        }
+
+        dd("ctx acquired raw req socket: %d", ctx->acquired_raw_req_socket);
+
+        if (ctx->acquired_raw_req_socket) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "duplicate call");
+            return 2;
+        }
+
+        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+        if (clcf->tcp_nodelay) {
+            tcp_nodelay = 1;
+
+            if (c->tcp_nodelay == NGX_TCP_NODELAY_UNSET) {
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                               "lua raw req socket tcp_nodelay");
+
+                if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,
+                               (const void *) &tcp_nodelay, sizeof(int))
+                    == -1)
+                {
+                    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+                    if (llcf->log_socket_errors) {
+                        ngx_connection_error(c, ngx_socket_errno,
+                                             "setsockopt(TCP_NODELAY) "
+                                             "failed");
+                    }
+
+                    lua_pushnil(L);
+                    lua_pushliteral(L, "setsocketopt tcp_nodelay failed");
+                    return 2;
+                }
+
+                c->tcp_nodelay = NGX_TCP_NODELAY_SET;
+            }
+        }
+
+        ctx->acquired_raw_req_socket = 1;
+        r->keepalive = 0;
+        r->lingering_close = 1;
+#endif
+
+    } else {
+        /* request body reader */
+
+        if (r->request_body) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "request body already exists");
+            return 2;
+        }
+
+        if (r->discard_body) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "request body discarded");
+            return 2;
+        }
+
+        dd("req content length: %d", (int) r->headers_in.content_length_n);
+
+        if (r->headers_in.content_length_n <= 0) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "no body");
+            return 2;
+        }
+
+        if (ngx_http_lua_test_expect(r) != NGX_OK) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "test expect failed");
+            return 2;
+        }
+
+        /* prevent other request body reader from running */
+
+        rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
+        if (rb == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        rb->rest = r->headers_in.content_length_n;
+
+        r->request_body = rb;
+    }
+
+    lua_createtable(L, 3 /* narr */, 1 /* nrec */); /* the object */
+
+    if (raw) {
+        lua_pushlightuserdata(L, &ngx_http_lua_raw_req_socket_metatable_key);
+
+    } else {
+        lua_pushlightuserdata(L, &ngx_http_lua_req_socket_metatable_key);
+    }
+
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_setmetatable(L, -2);
+
+    u = lua_newuserdata(L, sizeof(ngx_http_lua_socket_tcp_upstream_t));
+    if (u == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+#if 1
+    lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */
+    lua_pushcfunction(L, ngx_http_lua_socket_downstream_destroy);
+    lua_setfield(L, -2, "__gc");
+    lua_setmetatable(L, -2);
+#endif
+
+    lua_rawseti(L, 1, SOCKET_CTX_INDEX);
+
+    ngx_memzero(u, sizeof(ngx_http_lua_socket_tcp_upstream_t));
+
+    if (raw) {
+        u->raw_downstream = 1;
+
+    } else {
+        u->body_downstream = 1;
+    }
+
+    coctx = ctx->cur_co_ctx;
+
+    u->request = r;
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    u->conf = llcf;
+
+    u->read_timeout = u->conf->read_timeout;
+    u->connect_timeout = u->conf->connect_timeout;
+    u->send_timeout = u->conf->send_timeout;
+
+    cln = ngx_http_cleanup_add(r, 0);
+    if (cln == NULL) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+        lua_pushnil(L);
+        lua_pushliteral(L, "out of memory");
+        return 2;
+    }
+
+    cln->handler = ngx_http_lua_req_socket_cleanup;
+    cln->data = u;
+    u->cleanup = &cln->handler;
+
+    pc = &u->peer;
+
+    pc->log = c->log;
+    pc->log_error = NGX_ERROR_ERR;
+
+    pc->connection = c;
+
+    dd("setting data to %p", u);
+
+    coctx->data = u;
+    ctx->downstream_co_ctx = coctx;
+
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    if (raw) {
+        if (c->write->timer_set) {
+            ngx_del_timer(c->write);
+        }
+    }
+
+    lua_settop(L, 1);
+    return 1;
+}
+
+
+static void
+ngx_http_lua_req_socket_rev_handler(ngx_http_request_t *r)
+{
+    ngx_http_lua_ctx_t                  *ctx;
+    ngx_http_lua_co_ctx_t               *coctx;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua request socket read event handler");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return;
+    }
+
+    coctx = ctx->downstream_co_ctx;
+    u = coctx->data;
+
+    if (u) {
+        u->read_event_handler(r, u);
+    }
+}
+
+
+static int
+ngx_http_lua_socket_tcp_getreusedtimes(lua_State *L)
+{
+    ngx_http_lua_socket_tcp_upstream_t    *u;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting 1 argument "
+                          "(including the object), but got %d", lua_gettop(L));
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+
+    if (u == NULL || u->peer.connection == NULL || u->ft_type || u->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    lua_pushinteger(L, u->reused);
+    return 1;
+}
+
+
+static int ngx_http_lua_socket_tcp_setkeepalive(lua_State *L)
+{
+    ngx_http_lua_main_conf_t            *lmcf;
+    ngx_http_lua_loc_conf_t             *llcf;
+    ngx_http_lua_socket_tcp_upstream_t  *u;
+    ngx_connection_t                    *c;
+    ngx_http_lua_socket_pool_t          *spool;
+    size_t                               size;
+    ngx_str_t                            key;
+    ngx_uint_t                           i;
+    ngx_queue_t                         *q;
+    ngx_peer_connection_t               *pc;
+    u_char                              *p;
+    ngx_http_request_t                  *r;
+    ngx_msec_t                           timeout;
+    ngx_uint_t                           pool_size;
+    int                                  n;
+    ngx_int_t                            rc;
+    ngx_buf_t                           *b;
+
+    ngx_http_lua_socket_pool_item_t     *items, *item;
+
+    n = lua_gettop(L);
+
+    if (n < 1 || n > 3) {
+        return luaL_error(L, "expecting 1 to 3 arguments "
+                          "(including the object), but got %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_socket_pool_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+
+    lua_rawgeti(L, 1, SOCKET_KEY_INDEX);
+    key.data = (u_char *) lua_tolstring(L, -1, &key.len);
+    if (key.data == NULL) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "key not found");
+        return 2;
+    }
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    /* stack: obj cache key */
+
+    pc = &u->peer;
+    c = pc->connection;
+
+    if (u == NULL || c == NULL || u->ft_type || u->eof) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    b = &u->buffer;
+
+    if (b->start && ngx_buf_size(b)) {
+        ngx_http_lua_probe_socket_tcp_setkeepalive_buf_unread(r, u, b->pos,
+                                                              b->last - b->pos);
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "unread data in buffer");
+        return 2;
+    }
+
+    if (c->read->eof
+        || c->read->error
+        || c->read->timedout
+        || c->write->error
+        || c->write->timedout)
+    {
+        lua_pushnil(L);
+        lua_pushliteral(L, "invalid connection");
+        return 2;
+    }
+
+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "failed to handle read event");
+        return 2;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                   "lua tcp socket set keepalive: saving connection %p", c);
+
+    dd("saving connection to key %s", lua_tostring(L, -1));
+
+    lua_pushvalue(L, -1);
+    lua_rawget(L, -3);
+    spool = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    /* stack: obj timeout? size? cache key */
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (spool == NULL) {
+        /* create a new socket pool for the current peer key */
+
+        if (n == 3) {
+            pool_size = luaL_checkinteger(L, 3);
+
+        } else {
+            pool_size = llcf->pool_size;
+        }
+
+        if (pool_size == 0) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "zero pool size");
+            return 2;
+        }
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket connection pool size: %ui", pool_size);
+
+        size = sizeof(ngx_http_lua_socket_pool_t) + key.len
+               + sizeof(ngx_http_lua_socket_pool_item_t)
+               * pool_size;
+
+        spool = lua_newuserdata(L, size);
+        if (spool == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                       "lua tcp socket keepalive create connection pool for key"
+                       " \"%s\"", lua_tostring(L, -2));
+
+        lua_rawset(L, -3);
+
+        lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+        spool->conf = lmcf;
+        spool->active_connections = 0;
+
+        ngx_queue_init(&spool->cache);
+        ngx_queue_init(&spool->free);
+
+        p = ngx_copy(spool->key, key.data, key.len);
+        *p++ = '\0';
+
+        items = (ngx_http_lua_socket_pool_item_t *) p;
+
+        for (i = 0; i < pool_size; i++) {
+            ngx_queue_insert_head(&spool->free, &items[i].queue);
+            items[i].socket_pool = spool;
+        }
+    }
+
+    if (ngx_queue_empty(&spool->free)) {
+
+        q = ngx_queue_last(&spool->cache);
+        ngx_queue_remove(q);
+        spool->active_connections--;
+
+        item = ngx_queue_data(q, ngx_http_lua_socket_pool_item_t, queue);
+
+        ngx_close_connection(item->connection);
+
+    } else {
+        q = ngx_queue_head(&spool->free);
+        ngx_queue_remove(q);
+
+        item = ngx_queue_data(q, ngx_http_lua_socket_pool_item_t, queue);
+    }
+
+    item->connection = c;
+    ngx_queue_insert_head(&spool->cache, q);
+
+    if (!u->reused) {
+        spool->active_connections++;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                   "lua tcp socket clear current socket connection");
+
+    pc->connection = NULL;
+
+#if 0
+    if (u->cleanup) {
+        *u->cleanup = NULL;
+        u->cleanup = NULL;
+    }
+#endif
+
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    if (c->write->timer_set) {
+        ngx_del_timer(c->write);
+    }
+
+    if (n >= 2) {
+        timeout = (ngx_msec_t) luaL_checkinteger(L, 2);
+
+    } else {
+        timeout = llcf->keepalive_timeout;
+    }
+
+#if (NGX_DEBUG)
+    if (timeout == 0) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket keepalive timeout: unlimited");
+    }
+#endif
+
+    if (timeout) {
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua tcp socket keepalive timeout: %M ms", timeout);
+
+        ngx_add_timer(c->read, timeout);
+    }
+
+    c->write->handler = ngx_http_lua_socket_keepalive_dummy_handler;
+    c->read->handler = ngx_http_lua_socket_keepalive_rev_handler;
+
+    c->data = item;
+    c->idle = 1;
+    c->log = ngx_cycle->log;
+    c->read->log = ngx_cycle->log;
+    c->write->log = ngx_cycle->log;
+
+    item->socklen = pc->socklen;
+    ngx_memcpy(&item->sockaddr, pc->sockaddr, pc->socklen);
+    item->reused = u->reused;
+
+    if (c->read->ready) {
+        rc = ngx_http_lua_socket_keepalive_close_handler(c->read);
+        if (rc != NGX_OK) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "connection in dubious state");
+            return 2;
+        }
+    }
+
+#if 1
+    ngx_http_lua_socket_tcp_finalize(r, u);
+#endif
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static ngx_int_t
+ngx_http_lua_get_keepalive_peer(ngx_http_request_t *r, lua_State *L,
+    int key_index, ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_http_lua_socket_pool_item_t     *item;
+    ngx_http_lua_socket_pool_t          *spool;
+    ngx_http_cleanup_t                  *cln;
+    ngx_queue_t                         *q;
+    int                                  top;
+    ngx_peer_connection_t               *pc;
+    ngx_connection_t                    *c;
+
+    top = lua_gettop(L);
+
+    if (key_index < 0) {
+        key_index = top + key_index + 1;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket pool get keepalive peer");
+
+    pc = &u->peer;
+
+    lua_pushlightuserdata(L, &ngx_http_lua_socket_pool_key);
+    lua_rawget(L, LUA_REGISTRYINDEX); /* table */
+    lua_pushvalue(L, key_index); /* key */
+    lua_rawget(L, -2);
+
+    spool = lua_touserdata(L, -1);
+    if (spool == NULL) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                       "lua tcp socket keepalive connection pool not found");
+        lua_settop(L, top);
+        return NGX_DECLINED;
+    }
+
+    u->socket_pool = spool;
+
+    if (!ngx_queue_empty(&spool->cache)) {
+        q = ngx_queue_head(&spool->cache);
+
+        item = ngx_queue_data(q, ngx_http_lua_socket_pool_item_t, queue);
+        c = item->connection;
+
+        ngx_queue_remove(q);
+        ngx_queue_insert_head(&spool->free, q);
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                       "lua tcp socket get keepalive peer: using connection %p,"
+                       " fd:%d", c, c->fd);
+
+        c->idle = 0;
+        c->log = pc->log;
+        c->read->log = pc->log;
+        c->write->log = pc->log;
+        c->data = u;
+
+#if 1
+        c->write->handler = ngx_http_lua_socket_tcp_handler;
+        c->read->handler = ngx_http_lua_socket_tcp_handler;
+#endif
+
+        if (c->read->timer_set) {
+            ngx_del_timer(c->read);
+        }
+
+        pc->connection = c;
+        pc->cached = 1;
+
+        u->reused = item->reused + 1;
+
+#if 1
+        u->write_event_handler = ngx_http_lua_socket_dummy_handler;
+        u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+#endif
+
+        if (u->cleanup == NULL) {
+            cln = ngx_http_cleanup_add(r, 0);
+            if (cln == NULL) {
+                u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+                lua_settop(L, top);
+                return NGX_ERROR;
+            }
+
+            cln->handler = ngx_http_lua_socket_tcp_cleanup;
+            cln->data = u;
+            u->cleanup = &cln->handler;
+        }
+
+        lua_settop(L, top);
+
+        return NGX_OK;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                   "lua tcp socket keepalive: connection pool empty");
+
+    lua_settop(L, top);
+
+    return NGX_DECLINED;
+}
+
+
+static void
+ngx_http_lua_socket_keepalive_dummy_handler(ngx_event_t *ev)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,
+                   "keepalive dummy handler");
+}
+
+
+static void
+ngx_http_lua_socket_keepalive_rev_handler(ngx_event_t *ev)
+{
+    (void) ngx_http_lua_socket_keepalive_close_handler(ev);
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_keepalive_close_handler(ngx_event_t *ev)
+{
+    ngx_http_lua_socket_pool_item_t     *item;
+    ngx_http_lua_socket_pool_t          *spool;
+
+    int                n;
+    char               buf[1];
+    ngx_connection_t  *c;
+
+    c = ev->data;
+
+    if (c->close) {
+        goto close;
+    }
+
+    if (c->read->timedout) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,
+                       "lua tcp socket keepalive max idle timeout");
+
+        goto close;
+    }
+
+    dd("read event ready: %d", (int) c->read->ready);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,
+                   "lua tcp socket keepalive close handler check stale events");
+
+    n = recv(c->fd, buf, 1, MSG_PEEK);
+
+    if (n == -1 && ngx_socket_errno == NGX_EAGAIN) {
+        /* stale event */
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            goto close;
+        }
+
+        return NGX_OK;
+    }
+
+close:
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ev->log, 0,
+                   "lua tcp socket keepalive close handler: fd:%d", c->fd);
+
+    item = c->data;
+    spool = item->socket_pool;
+
+    ngx_close_connection(c);
+
+    ngx_queue_remove(&item->queue);
+    ngx_queue_insert_head(&spool->free, &item->queue);
+    spool->active_connections--;
+
+    dd("keepalive: active connections: %u",
+       (unsigned) spool->active_connections);
+
+    if (spool->active_connections == 0) {
+        ngx_http_lua_socket_free_pool(ev->log, spool);
+    }
+
+    return NGX_DECLINED;
+}
+
+
+static void
+ngx_http_lua_socket_free_pool(ngx_log_t *log, ngx_http_lua_socket_pool_t *spool)
+{
+    lua_State                           *L;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+                   "lua tcp socket keepalive: free connection pool for \"%s\"",
+                   spool->key);
+
+    L = spool->conf->lua;
+
+    lua_pushlightuserdata(L, &ngx_http_lua_socket_pool_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_pushstring(L, (char *) spool->key);
+    lua_pushnil(L);
+    lua_rawset(L, -3);
+    lua_pop(L, 1);
+}
+
+
+static int
+ngx_http_lua_socket_tcp_upstream_destroy(lua_State *L)
+{
+    ngx_http_lua_socket_tcp_upstream_t      *u;
+
+    dd("upstream destroy triggered by Lua GC");
+
+    u = lua_touserdata(L, 1);
+    if (u == NULL) {
+        return 0;
+    }
+
+    if (u->cleanup) {
+        ngx_http_lua_socket_tcp_cleanup(u); /* it will clear u->cleanup */
+    }
+
+    return 0;
+}
+
+
+static int
+ngx_http_lua_socket_downstream_destroy(lua_State *L)
+{
+    ngx_http_lua_socket_tcp_upstream_t     *u;
+
+    dd("upstream destroy triggered by Lua GC");
+
+    u = lua_touserdata(L, 1);
+    if (u == NULL) {
+        return 0;
+    }
+
+    if (u->cleanup) {
+        ngx_http_lua_req_socket_cleanup(u); /* it will clear u->cleanup */
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_req_socket_cleanup(void *data)
+{
+    ngx_http_lua_socket_tcp_upstream_t  *u = data;
+
+#if (NGX_DEBUG)
+    ngx_http_request_t  *r;
+
+    r = u->request;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "cleanup lua tcp socket downstream request: \"%V\"",
+                   &r->uri);
+#endif
+
+    if (u->cleanup) {
+        *u->cleanup = NULL;
+        u->cleanup = NULL;
+    }
+
+    if (u->peer.connection) {
+        u->peer.connection = NULL;
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_push_input_data(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_socket_tcp_upstream_t *u,
+    lua_State *L)
+{
+    ngx_chain_t             *cl;
+    ngx_chain_t            **ll;
+    size_t                   size;
+    ngx_buf_t               *b;
+    size_t                   nbufs;
+    u_char                  *p;
+    u_char                  *last;
+
+    if (!u->bufs_in) {
+        lua_pushliteral(L, "");
+        ngx_http_lua_probe_socket_tcp_receive_done(r, u, (u_char *) "", 0);
+        return NGX_OK;
+    }
+
+    dd("bufs_in: %p, buf_in: %p", u->bufs_in, u->buf_in);
+
+    size = 0;
+    nbufs = 0;
+    ll = NULL;
+
+    for (cl = u->bufs_in; cl; cl = cl->next) {
+        b = cl->buf;
+        size += b->last - b->pos;
+
+        if (cl->next) {
+            ll = &cl->next;
+        }
+
+        nbufs++;
+    }
+
+    dd("size: %d, nbufs: %d", (int) size, (int) nbufs);
+
+    if (size == 0) {
+        lua_pushliteral(L, "");
+
+        ngx_http_lua_probe_socket_tcp_receive_done(r, u, (u_char *) "", 0);
+
+        goto done;
+    }
+
+    if (nbufs == 1) {
+        b = u->buf_in->buf;
+
+        lua_pushlstring(L, (char *) b->pos, size);
+
+        dd("copying input data chunk from %p: \"%.*s\"", u->buf_in, (int) size,
+                b->pos);
+
+        ngx_http_lua_probe_socket_tcp_receive_done(r, u, b->pos, size);
+
+        goto done;
+    }
+
+    /* nbufs > 1 */
+
+    dd("WARN: allocate a big memory: %d", (int) size);
+
+    p = ngx_palloc(r->pool, size);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    last = p;
+    for (cl = u->bufs_in; cl; cl = cl->next) {
+        b = cl->buf;
+        last = ngx_copy(last, b->pos, b->last - b->pos);
+
+        dd("copying input data chunk from %p: \"%.*s\"", cl,
+           (int) (b->last - b->pos), b->pos);
+    }
+
+    lua_pushlstring(L, (char *) p, size);
+
+    ngx_http_lua_probe_socket_tcp_receive_done(r, u, p, size);
+
+    ngx_pfree(r->pool, p);
+
+done:
+    if (nbufs > 1 && ll) {
+        dd("recycle buffers: %d", (int) (nbufs - 1));
+
+        *ll = ctx->free_recv_bufs;
+        ctx->free_recv_bufs = u->bufs_in;
+        u->bufs_in = u->buf_in;
+    }
+
+    if (u->buffer.pos == u->buffer.last) {
+        dd("resetting u->buffer pos & last");
+        u->buffer.pos = u->buffer.start;
+        u->buffer.last = u->buffer.start;
+    }
+
+    u->buf_in->buf->last = u->buffer.pos;
+    u->buf_in->buf->pos = u->buffer.pos;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_add_input_buffer(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u)
+{
+    ngx_chain_t             *cl;
+    ngx_http_lua_ctx_t      *ctx;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    cl = ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                          &ctx->free_recv_bufs,
+                                          u->conf->buffer_size,
+                                          (ngx_buf_tag_t)
+                                          &ngx_http_lua_module);
+
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    u->buf_in->next = cl;
+    u->buf_in = cl;
+    u->buffer = *cl->buf;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_add_pending_data(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, u_char *pos, size_t len, u_char *pat,
+    int prefix, int old_state)
+{
+    u_char          *last;
+    ngx_buf_t       *b;
+
+    dd("resuming data: %d: [%.*s]", prefix, prefix, pat);
+
+    last = &pos[len];
+
+    b = u->buf_in->buf;
+
+    if (last - b->last == old_state) {
+        b->last += prefix;
+        return NGX_OK;
+    }
+
+    dd("need more buffers because %d != %d", (int) (last - b->last),
+       (int) old_state);
+
+    if (ngx_http_lua_socket_insert_buffer(r, u, pat, prefix) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    b->pos = last;
+    b->last = last;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t ngx_http_lua_socket_insert_buffer(ngx_http_request_t *r,
+    ngx_http_lua_socket_tcp_upstream_t *u, u_char *pat, size_t prefix)
+{
+    ngx_chain_t             *cl, *new_cl, **ll;
+    ngx_http_lua_ctx_t      *ctx;
+    size_t                   size;
+    ngx_buf_t               *b;
+
+    if (prefix <= u->conf->buffer_size) {
+        size = u->conf->buffer_size;
+
+    } else {
+        size = prefix;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    new_cl = ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                              &ctx->free_recv_bufs,
+                                              size,
+                                              (ngx_buf_tag_t)
+                                              &ngx_http_lua_module);
+
+    if (new_cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    b = new_cl->buf;
+
+    b->last = ngx_copy(b->last, pat, prefix);
+
+    dd("copy resumed data to %p: %d: \"%.*s\"",
+       new_cl, (int) (b->last - b->pos), (int) (b->last - b->pos), b->pos);
+
+    dd("before resuming data: bufs_in %p, buf_in %p, buf_in next %p",
+       u->bufs_in, u->buf_in, u->buf_in->next);
+
+    ll = &u->bufs_in;
+    for (cl = u->bufs_in; cl->next; cl = cl->next) {
+        ll = &cl->next;
+    }
+
+    *ll = new_cl;
+    new_cl->next = u->buf_in;
+
+    dd("after resuming data: bufs_in %p, buf_in %p, buf_in next %p",
+       u->bufs_in, u->buf_in, u->buf_in->next);
+
+#if (DDEBUG)
+    for (cl = u->bufs_in; cl; cl = cl->next) {
+        b = cl->buf;
+
+        dd("result buf after resuming data: %p: %.*s", cl,
+           (int) ngx_buf_size(b), b->pos);
+    }
+#endif
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_tcp_resume(ngx_http_request_t *r)
+{
+    int                          nret;
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ngx_http_lua_socket_tcp_upstream_t      *u;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp operation done, resuming lua thread");
+
+    coctx = ctx->cur_co_ctx;
+
+#if 0
+    ngx_http_lua_probe_info("tcp resume");
+#endif
+
+    dd("coctx: %p", coctx);
+
+    u = coctx->data;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua tcp socket calling prepare retvals handler %p, "
+                   "u:%p", u->prepare_retvals, u);
+
+    nret = u->prepare_retvals(r, u, ctx->cur_co_ctx->co);
+    if (nret == NGX_AGAIN) {
+        return NGX_DONE;
+    }
+
+    c = r->connection;
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, nret);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c,lmcf->lua, r, ctx);
+    }
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
+static void
+ngx_http_lua_tcp_resolve_cleanup(void *data)
+{
+    ngx_resolver_ctx_t                      *rctx;
+    ngx_http_lua_socket_tcp_upstream_t      *u;
+    ngx_http_lua_co_ctx_t                   *coctx = data;
+
+    u = coctx->data;
+    if (u == NULL) {
+        return;
+    }
+
+    rctx = u->resolved->ctx;
+    if (rctx == NULL) {
+        return;
+    }
+
+    ngx_resolve_name_done(rctx);
+}
+
+
+static void
+ngx_http_lua_tcp_socket_cleanup(void *data)
+{
+    ngx_http_lua_socket_tcp_upstream_t      *u;
+    ngx_http_lua_co_ctx_t                   *coctx = data;
+
+    u = coctx->data;
+    if (u == NULL) {
+        return;
+    }
+
+    if (u->request == NULL) {
+        return;
+    }
+
+    ngx_http_lua_socket_tcp_finalize(u->request, u);
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.h b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_tcp.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,137 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_SOCKET_TCP_H_INCLUDED_
+#define _NGX_HTTP_LUA_SOCKET_TCP_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+#define NGX_HTTP_LUA_SOCKET_FT_ERROR         0x0001
+#define NGX_HTTP_LUA_SOCKET_FT_TIMEOUT       0x0002
+#define NGX_HTTP_LUA_SOCKET_FT_CLOSED        0x0004
+#define NGX_HTTP_LUA_SOCKET_FT_RESOLVER      0x0008
+#define NGX_HTTP_LUA_SOCKET_FT_BUFTOOSMALL   0x0010
+#define NGX_HTTP_LUA_SOCKET_FT_NOMEM         0x0020
+#define NGX_HTTP_LUA_SOCKET_FT_PARTIALWRITE  0x0040
+#define NGX_HTTP_LUA_SOCKET_FT_CLIENTABORT   0x0080
+
+
+typedef struct ngx_http_lua_socket_tcp_upstream_s
+        ngx_http_lua_socket_tcp_upstream_t;
+
+
+typedef
+    int (*ngx_http_lua_socket_tcp_retval_handler)(ngx_http_request_t *r,
+        ngx_http_lua_socket_tcp_upstream_t *u, lua_State *L);
+
+
+typedef void (*ngx_http_lua_socket_tcp_upstream_handler_pt)(
+          ngx_http_request_t *r, ngx_http_lua_socket_tcp_upstream_t *u);
+
+
+typedef struct {
+    ngx_http_lua_main_conf_t          *conf;
+    ngx_uint_t                         active_connections;
+
+    /* queues of ngx_http_lua_socket_pool_item_t: */
+    ngx_queue_t                        cache;
+    ngx_queue_t                        free;
+
+    u_char                             key[1];
+
+} ngx_http_lua_socket_pool_t;
+
+
+struct ngx_http_lua_socket_tcp_upstream_s {
+    ngx_http_lua_socket_tcp_retval_handler          prepare_retvals;
+    ngx_http_lua_socket_tcp_upstream_handler_pt     read_event_handler;
+    ngx_http_lua_socket_tcp_upstream_handler_pt     write_event_handler;
+
+    ngx_http_lua_socket_pool_t      *socket_pool;
+
+    ngx_http_lua_loc_conf_t         *conf;
+    ngx_http_cleanup_pt             *cleanup;
+    ngx_http_request_t              *request;
+    ngx_peer_connection_t            peer;
+
+    ngx_msec_t                       read_timeout;
+    ngx_msec_t                       send_timeout;
+    ngx_msec_t                       connect_timeout;
+
+    ngx_http_upstream_resolved_t    *resolved;
+
+    ngx_chain_t                     *bufs_in; /* input data buffers */
+    ngx_chain_t                     *buf_in; /* last input data buffer */
+    ngx_buf_t                        buffer; /* receive buffer */
+
+    size_t                           length;
+    size_t                           rest;
+
+    ngx_uint_t                       ft_type;
+    ngx_err_t                        socket_errno;
+
+    ngx_int_t                      (*input_filter)(void *data, ssize_t bytes);
+    void                            *input_filter_ctx;
+
+    size_t                           request_len;
+    ngx_chain_t                     *request_bufs;
+
+    ngx_http_lua_co_ctx_t           *co_ctx;
+
+    ngx_uint_t                       reused;
+
+    unsigned                         no_close:1;
+    unsigned                         waiting:1;
+    unsigned                         eof:1;
+    unsigned                         body_downstream:1;
+    unsigned                         raw_downstream:1;
+};
+
+
+typedef struct ngx_http_lua_dfa_edge_s ngx_http_lua_dfa_edge_t;
+
+
+struct ngx_http_lua_dfa_edge_s {
+    u_char                           chr;
+    int                              new_state;
+    ngx_http_lua_dfa_edge_t         *next;
+};
+
+
+typedef struct {
+    ngx_http_lua_socket_tcp_upstream_t  *upstream;
+
+    ngx_str_t                            pattern;
+    int                                  state;
+    ngx_http_lua_dfa_edge_t            **recovering;
+
+    unsigned                             inclusive:1;
+} ngx_http_lua_socket_compiled_pattern_t;
+
+
+typedef struct {
+    ngx_http_lua_socket_pool_t      *socket_pool;
+
+    ngx_queue_t                      queue;
+    ngx_connection_t                *connection;
+
+    socklen_t                        socklen;
+    struct sockaddr_storage          sockaddr;
+
+    ngx_uint_t                       reused;
+
+} ngx_http_lua_socket_pool_item_t;
+
+
+void ngx_http_lua_inject_socket_tcp_api(ngx_log_t *log, lua_State *L);
+void ngx_http_lua_inject_req_socket_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_SOCKET_TCP_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.c b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,1539 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_socket_udp.h"
+#include "ngx_http_lua_socket_tcp.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_output.h"
+#include "ngx_http_lua_probe.h"
+
+
+#if 1
+#undef ngx_http_lua_probe_info
+#define ngx_http_lua_probe_info(msg)
+#endif
+
+
+#define UDP_MAX_DATAGRAM_SIZE 8192
+
+
+static int ngx_http_lua_socket_udp(lua_State *L);
+static int ngx_http_lua_socket_udp_setpeername(lua_State *L);
+static int ngx_http_lua_socket_udp_send(lua_State *L);
+static int ngx_http_lua_socket_udp_receive(lua_State *L);
+static int ngx_http_lua_socket_udp_settimeout(lua_State *L);
+static void ngx_http_lua_socket_udp_finalize(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u);
+static int ngx_http_lua_socket_udp_upstream_destroy(lua_State *L);
+static int ngx_http_lua_socket_resolve_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, lua_State *L);
+static void ngx_http_lua_socket_resolve_handler(ngx_resolver_ctx_t *ctx);
+static int ngx_http_lua_socket_error_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, lua_State *L);
+static void ngx_http_lua_socket_udp_handle_error(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, ngx_uint_t ft_type);
+static void ngx_http_lua_socket_udp_cleanup(void *data);
+static void ngx_http_lua_socket_udp_handler(ngx_event_t *ev);
+static void ngx_http_lua_socket_dummy_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u);
+static int ngx_http_lua_socket_udp_receive_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, lua_State *L);
+static ngx_int_t ngx_http_lua_socket_udp_read(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u);
+static void ngx_http_lua_socket_udp_read_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u);
+static void ngx_http_lua_socket_udp_handle_success(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u);
+static ngx_int_t ngx_http_lua_udp_connect(ngx_udp_connection_t *uc);
+static int ngx_http_lua_socket_udp_close(lua_State *L);
+static ngx_int_t ngx_http_lua_socket_udp_resume(ngx_http_request_t *r);
+static void ngx_http_lua_udp_resolve_cleanup(void *data);
+static void ngx_http_lua_udp_socket_cleanup(void *data);
+
+
+enum {
+    SOCKET_CTX_INDEX = 1,
+    SOCKET_TIMEOUT_INDEX = 2
+};
+
+
+static char ngx_http_lua_socket_udp_metatable_key;
+static u_char ngx_http_lua_socket_udp_buffer[UDP_MAX_DATAGRAM_SIZE];
+
+
+void
+ngx_http_lua_inject_socket_udp_api(ngx_log_t *log, lua_State *L)
+{
+    lua_getfield(L, -1, "socket"); /* ngx socket */
+
+    lua_pushcfunction(L, ngx_http_lua_socket_udp);
+    lua_setfield(L, -2, "udp"); /* ngx socket */
+
+    /* udp socket object metatable */
+    lua_pushlightuserdata(L, &ngx_http_lua_socket_udp_metatable_key);
+    lua_createtable(L, 0 /* narr */, 4 /* nrec */);
+
+    lua_pushcfunction(L, ngx_http_lua_socket_udp_setpeername);
+    lua_setfield(L, -2, "setpeername"); /* ngx socket mt */
+
+    lua_pushcfunction(L, ngx_http_lua_socket_udp_send);
+    lua_setfield(L, -2, "send");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_udp_receive);
+    lua_setfield(L, -2, "receive");
+
+    lua_pushcfunction(L, ngx_http_lua_socket_udp_settimeout);
+    lua_setfield(L, -2, "settimeout"); /* ngx socket mt */
+
+    lua_pushcfunction(L, ngx_http_lua_socket_udp_close);
+    lua_setfield(L, -2, "close"); /* ngx socket mt */
+
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -2, "__index");
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+
+    lua_pop(L, 1);
+}
+
+
+static int
+ngx_http_lua_socket_udp(lua_State *L)
+{
+    ngx_http_request_t      *r;
+    ngx_http_lua_ctx_t      *ctx;
+
+    if (lua_gettop(L) != 0) {
+        return luaL_error(L, "expecting zero arguments, but got %d",
+                          lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    lua_createtable(L, 3 /* narr */, 1 /* nrec */);
+    lua_pushlightuserdata(L, &ngx_http_lua_socket_udp_metatable_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_setmetatable(L, -2);
+
+    dd("top: %d", lua_gettop(L));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_udp_setpeername(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_str_t                    host;
+    int                          port;
+    ngx_resolver_ctx_t          *rctx, temp;
+    ngx_http_core_loc_conf_t    *clcf;
+    int                          saved_top;
+    int                          n;
+    u_char                      *p;
+    size_t                       len;
+    ngx_url_t                    url;
+    ngx_int_t                    rc;
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_udp_connection_t        *uc;
+    int                          timeout;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    ngx_http_lua_socket_udp_upstream_t      *u;
+
+    /*
+     * TODO: we should probably accept an extra argument to setpeername()
+     * to allow the user bind the datagram unix domain socket himself,
+     * which is necessary for systems without autobind support.
+     */
+
+    n = lua_gettop(L);
+    if (n != 2 && n != 3) {
+        return luaL_error(L, "ngx.socket.udp setpeername: expecting 2 or 3 "
+                          "arguments (including the object), but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    host.data = ngx_palloc(r->pool, len + 1);
+    if (host.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    host.len = len;
+
+    ngx_memcpy(host.data, p, len);
+    host.data[len] = '\0';
+
+    if (n == 3) {
+        port = luaL_checkinteger(L, 3);
+
+        if (port < 0 || port > 65536) {
+            lua_pushnil(L);
+            lua_pushfstring(L, "bad port number: %d", port);
+            return 2;
+        }
+
+    } else { /* n == 2 */
+        port = 0;
+    }
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u) {
+        if (u->waiting) {
+            lua_pushnil(L);
+            lua_pushliteral(L, "socket busy");
+            return 2;
+        }
+
+        if (u->udp_connection.connection) {
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua udp socket reconnect without shutting down");
+
+            ngx_http_lua_socket_udp_finalize(r, u);
+        }
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua reuse socket upstream ctx");
+
+    } else {
+        u = lua_newuserdata(L, sizeof(ngx_http_lua_socket_udp_upstream_t));
+        if (u == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+#if 1
+        lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */
+        lua_pushcfunction(L, ngx_http_lua_socket_udp_upstream_destroy);
+        lua_setfield(L, -2, "__gc");
+        lua_setmetatable(L, -2);
+#endif
+
+        lua_rawseti(L, 1, SOCKET_CTX_INDEX);
+    }
+
+    ngx_memzero(u, sizeof(ngx_http_lua_socket_udp_upstream_t));
+
+    u->request = r; /* set the controlling request */
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    u->conf = llcf;
+
+    uc = &u->udp_connection;
+
+    uc->log = *r->connection->log;
+
+    dd("lua peer connection log: %p", &uc->log);
+
+    lua_rawgeti(L, 1, SOCKET_TIMEOUT_INDEX);
+    timeout = (ngx_int_t) lua_tointeger(L, -1);
+    lua_pop(L, 1);
+
+    if (timeout > 0) {
+        u->read_timeout = (ngx_msec_t) timeout;
+
+    } else {
+        u->read_timeout = u->conf->read_timeout;
+    }
+
+    ngx_memzero(&url, sizeof(ngx_url_t));
+
+    url.url.len = host.len;
+    url.url.data = host.data;
+    url.default_port = (in_port_t) port;
+    url.no_resolve = 1;
+
+    if (ngx_parse_url(r->pool, &url) != NGX_OK) {
+        lua_pushnil(L);
+
+        if (url.err) {
+            lua_pushfstring(L, "failed to parse host name \"%s\": %s",
+                            host.data, url.err);
+
+        } else {
+            lua_pushfstring(L, "failed to parse host name \"%s\"", host.data);
+        }
+
+        return 2;
+    }
+
+    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));
+    if (u->resolved == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    if (url.addrs && url.addrs[0].sockaddr) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua udp socket network address given directly");
+
+        u->resolved->sockaddr = url.addrs[0].sockaddr;
+        u->resolved->socklen = url.addrs[0].socklen;
+        u->resolved->naddrs = 1;
+        u->resolved->host = url.addrs[0].name;
+
+    } else {
+        u->resolved->host = host;
+        u->resolved->port = (in_port_t) port;
+    }
+
+    if (u->resolved->sockaddr) {
+        rc = ngx_http_lua_socket_resolve_retval_handler(r, u, L);
+        if (rc == NGX_AGAIN) {
+            return lua_yield(L, 0);
+        }
+
+        return rc;
+    }
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    temp.name = host;
+    rctx = ngx_resolve_start(clcf->resolver, &temp);
+    if (rctx == NULL) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+        lua_pushnil(L);
+        lua_pushliteral(L, "failed to start the resolver");
+        return 2;
+    }
+
+    if (rctx == NGX_NO_RESOLVER) {
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+        lua_pushnil(L);
+        lua_pushfstring(L, "no resolver defined to resolve \"%s\"", host.data);
+        return 2;
+    }
+
+    rctx->name = host;
+    rctx->type = NGX_RESOLVE_A;
+    rctx->handler = ngx_http_lua_socket_resolve_handler;
+    rctx->data = u;
+    rctx->timeout = clcf->resolver_timeout;
+
+    u->co_ctx = ctx->cur_co_ctx;
+    u->resolved->ctx = rctx;
+
+    saved_top = lua_gettop(L);
+
+    coctx = ctx->cur_co_ctx;
+    coctx->cleanup = ngx_http_lua_udp_resolve_cleanup;
+
+    if (ngx_resolve_name(rctx) != NGX_OK) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua udp socket fail to run resolver immediately");
+
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+
+        u->resolved->ctx = NULL;
+        lua_pushnil(L);
+        lua_pushfstring(L, "%s could not be resolved", host.data);
+
+        return 2;
+    }
+
+    if (u->waiting == 1) {
+        /* resolved and already connecting */
+        return lua_yield(L, 0);
+    }
+
+    n = lua_gettop(L) - saved_top;
+    if (n) {
+        /* errors occurred during resolving or connecting
+         * or already connected */
+        return n;
+    }
+
+    /* still resolving */
+
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_resolve_retval_handler;
+
+    coctx->data = u;
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    return lua_yield(L, 0);
+}
+
+
+static void
+ngx_http_lua_socket_resolve_handler(ngx_resolver_ctx_t *ctx)
+{
+    ngx_http_request_t                  *r;
+    ngx_connection_t                    *c;
+    ngx_http_upstream_resolved_t        *ur;
+    ngx_http_lua_ctx_t                  *lctx;
+    lua_State                           *L;
+    ngx_http_lua_socket_udp_upstream_t  *u;
+    u_char                              *p;
+    size_t                               len;
+    struct sockaddr_in                  *sin;
+    ngx_uint_t                           i;
+    unsigned                             waiting;
+
+    u = ctx->data;
+    r = u->request;
+    c = r->connection;
+    ur = u->resolved;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua udp socket resolve handler");
+
+    lctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (lctx == NULL) {
+        return;
+    }
+
+    lctx->cur_co_ctx = u->co_ctx;
+
+    u->co_ctx->cleanup = NULL;
+
+    L = lctx->cur_co_ctx->co;
+
+    dd("setting socket_ready to 1");
+
+    waiting = u->waiting;
+
+    if (ctx->state) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "lua udp socket resolver error: %s (waiting: %d)",
+                       ngx_resolver_strerror(ctx->state), (int) u->waiting);
+
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *) ctx->name.data, ctx->name.len);
+        lua_pushfstring(L, " could not be resolved (%d: %s)",
+                        (int) ctx->state,
+                        ngx_resolver_strerror(ctx->state));
+        lua_concat(L, 2);
+
+#if 1
+        ur->ctx = NULL;
+        ngx_resolve_name_done(ctx);
+#endif
+
+        u->prepare_retvals = ngx_http_lua_socket_error_retval_handler;
+        ngx_http_lua_socket_udp_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_RESOLVER);
+
+        if (waiting) {
+            ngx_http_run_posted_requests(c);
+        }
+
+        return;
+    }
+
+    ur->naddrs = ctx->naddrs;
+    ur->addrs = ctx->addrs;
+
+#if (NGX_DEBUG)
+    {
+    in_addr_t   addr;
+    ngx_uint_t  i;
+
+    for (i = 0; i < ctx->naddrs; i++) {
+        dd("addr i: %d %p", (int) i,  &ctx->addrs[i]);
+
+        addr = ntohl(ctx->addrs[i]);
+
+        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "name was resolved to %ud.%ud.%ud.%ud",
+                       (addr >> 24) & 0xff, (addr >> 16) & 0xff,
+                       (addr >> 8) & 0xff, addr & 0xff);
+    }
+    }
+#endif
+
+    if (ur->naddrs == 0) {
+        ngx_resolve_name_done(ctx);
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "name cannot be resolved to a address");
+
+        if (waiting) {
+            ngx_http_run_posted_requests(c);
+        }
+
+        return;
+    }
+
+    if (ur->naddrs == 1) {
+        i = 0;
+
+    } else {
+        i = ngx_random() % ur->naddrs;
+    }
+
+    dd("selected addr index: %d", (int) i);
+
+    len = NGX_INET_ADDRSTRLEN + sizeof(":65536") - 1;
+
+    p = ngx_pnalloc(r->pool, len + sizeof(struct sockaddr_in));
+    if (p == NULL) {
+        ngx_resolve_name_done(ctx);
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER;
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "out of memory");
+
+        if (waiting) {
+            ngx_http_run_posted_requests(c);
+        }
+
+        return;
+    }
+
+    sin = (struct sockaddr_in *) &p[len];
+    ngx_memzero(sin, sizeof(struct sockaddr_in));
+
+    len = ngx_inet_ntop(AF_INET, &ur->addrs[i], p, NGX_INET_ADDRSTRLEN);
+    len = ngx_sprintf(&p[len], ":%d", ur->port) - p;
+
+    sin->sin_family = AF_INET;
+    sin->sin_port = htons(ur->port);
+    sin->sin_addr.s_addr = ur->addrs[i];
+
+    ur->sockaddr = (struct sockaddr *) sin;
+    ur->socklen = sizeof(struct sockaddr_in);
+
+    ur->host.data = p;
+    ur->host.len = len;
+    ur->naddrs = 1;
+
+    ur->ctx = NULL;
+
+    ngx_resolve_name_done(ctx);
+
+    u->waiting = 0;
+
+    if (waiting) {
+        lctx->resume_handler = ngx_http_lua_socket_udp_resume;
+        r->write_event_handler(r);
+        ngx_http_run_posted_requests(c);
+
+    } else {
+        (void) ngx_http_lua_socket_resolve_retval_handler(r, u, L);
+    }
+}
+
+
+static int
+ngx_http_lua_socket_resolve_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, lua_State *L)
+{
+    ngx_http_lua_ctx_t              *ctx;
+    ngx_http_lua_co_ctx_t           *coctx;
+    ngx_udp_connection_t            *uc;
+    ngx_connection_t                *c;
+    ngx_http_cleanup_t              *cln;
+    ngx_http_upstream_resolved_t    *ur;
+    ngx_int_t                        rc;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket resolve retval handler");
+
+    if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_RESOLVER) {
+        return 2;
+    }
+
+    uc = &u->udp_connection;
+
+    ur = u->resolved;
+
+    if (ur->sockaddr) {
+        uc->sockaddr = ur->sockaddr;
+        uc->socklen = ur->socklen;
+        uc->server = ur->host;
+
+    } else {
+        lua_pushnil(L);
+        lua_pushliteral(L, "resolver not working");
+        return 2;
+    }
+
+    rc = ngx_http_lua_udp_connect(uc);
+
+    if (rc != NGX_OK) {
+        u->socket_errno = ngx_socket_errno;
+    }
+
+    if (u->cleanup == NULL) {
+        cln = ngx_http_cleanup_add(r, 0);
+        if (cln == NULL) {
+            u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR;
+            lua_pushnil(L);
+            lua_pushliteral(L, "out of memory");
+            return 2;
+        }
+
+        cln->handler = ngx_http_lua_socket_udp_cleanup;
+        cln->data = u;
+        u->cleanup = &cln->handler;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket connect: %i", rc);
+
+    if (rc != NGX_OK) {
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    /* rc == NGX_OK */
+
+    c = uc->connection;
+
+    c->data = u;
+
+    c->write->handler = NULL;
+    c->read->handler = ngx_http_lua_socket_udp_handler;
+    c->read->resolver = 0;
+
+    c->pool = r->pool;
+    c->log = r->connection->log;
+    c->read->log = c->log;
+    c->write->log = c->log;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    coctx = ctx->cur_co_ctx;
+
+    coctx->data = u;
+
+    u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_error_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, lua_State *L)
+{
+    u_char           errstr[NGX_MAX_ERROR_STR];
+    u_char          *p;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket error retval handler");
+
+    if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_RESOLVER) {
+        return 2;
+    }
+
+    lua_pushnil(L);
+
+    if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_PARTIALWRITE) {
+        lua_pushliteral(L, "partial write");
+
+    } else if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_TIMEOUT) {
+        lua_pushliteral(L, "timeout");
+
+    } else if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_CLOSED) {
+        lua_pushliteral(L, "closed");
+
+    } else if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_BUFTOOSMALL) {
+        lua_pushliteral(L, "buffer too small");
+
+    } else if (u->ft_type & NGX_HTTP_LUA_SOCKET_FT_NOMEM) {
+        lua_pushliteral(L, "out of memory");
+
+    } else {
+
+        if (u->socket_errno) {
+#if (nginx_version >= 1000000)
+            p = ngx_strerror(u->socket_errno, errstr, sizeof(errstr));
+#else
+            p = ngx_strerror_r(u->socket_errno, errstr, sizeof(errstr));
+#endif
+            /* for compatibility with LuaSocket */
+            ngx_strlow(errstr, errstr, p - errstr);
+            lua_pushlstring(L, (char *) errstr, p - errstr);
+
+        } else {
+            lua_pushliteral(L, "error");
+        }
+    }
+
+    return 2;
+}
+
+
+static int
+ngx_http_lua_socket_udp_send(lua_State *L)
+{
+    ssize_t                              n;
+    ngx_http_request_t                  *r;
+    u_char                              *p;
+    size_t                               len;
+    ngx_http_lua_socket_udp_upstream_t  *u;
+    int                                  type;
+    const char                          *msg;
+    ngx_str_t                            query;
+    ngx_http_lua_loc_conf_t             *llcf;
+
+    if (lua_gettop(L) != 2) {
+        return luaL_error(L, "expecting 2 arguments (including the object), "
+                          "but got %d", lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "request object not found");
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u == NULL || u->udp_connection.connection == NULL) {
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "attempt to send data on a closed socket: u:%p, c:%p",
+                          u, u ? u->udp_connection.connection : NULL);
+        }
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->ft_type) {
+        u->ft_type = 0;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    type = lua_type(L, 2);
+    switch (type) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            lua_tolstring(L, 2, &len);
+            break;
+
+        case LUA_TTABLE:
+            len = ngx_http_lua_calc_strlen_in_table(L, 2, 2, 1 /* strict */);
+            break;
+
+        default:
+            msg = lua_pushfstring(L, "string, number, boolean, nil, "
+                                  "or array table expected, got %s",
+                                  lua_typename(L, type));
+
+            return luaL_argerror(L, 2, msg);
+    }
+
+    query.data = lua_newuserdata(L, len);
+    query.len = len;
+
+    switch (type) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            p = (u_char *) lua_tolstring(L, 2, &len);
+            ngx_memcpy(query.data, (u_char *) p, len);
+            break;
+
+        case LUA_TTABLE:
+            (void) ngx_http_lua_copy_str_in_table(L, 2, query.data);
+            break;
+
+        default:
+            return luaL_error(L, "impossible to reach here");
+    }
+
+    u->ft_type = 0;
+
+    /* mimic ngx_http_upstream_init_request here */
+
+#if 1
+    u->waiting = 0;
+#endif
+
+    dd("sending query %.*s", (int) query.len, query.data);
+
+    n = ngx_send(u->udp_connection.connection, query.data, query.len);
+
+    dd("ngx_send returns %d (query len %d)", (int) n, (int) query.len);
+
+    if (n == NGX_ERROR || n == NGX_AGAIN) {
+        u->socket_errno = ngx_socket_errno;
+
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    if (n != (ssize_t) query.len) {
+        dd("not the while query was sent");
+
+        u->ft_type |= NGX_HTTP_LUA_SOCKET_FT_PARTIALWRITE;
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    dd("n == len");
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_udp_receive(lua_State *L)
+{
+    ngx_http_request_t                  *r;
+    ngx_http_lua_socket_udp_upstream_t  *u;
+    ngx_int_t                            rc;
+    ngx_http_lua_ctx_t                  *ctx;
+    ngx_http_lua_co_ctx_t               *coctx;
+    size_t                               size;
+    int                                  nargs;
+    ngx_http_lua_loc_conf_t             *llcf;
+
+    nargs = lua_gettop(L);
+    if (nargs != 1 && nargs != 2) {
+        return luaL_error(L, "expecting 1 or 2 arguments "
+                          "(including the object), but got %d", nargs);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket calling receive() method");
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u == NULL || u->udp_connection.connection == NULL) {
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "attempt to receive data on a closed socket: u:%p, "
+                          "c:%p", u, u ? u->udp_connection.connection : NULL);
+        }
+
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->ft_type) {
+        u->ft_type = 0;
+    }
+
+#if 1
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+#endif
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket read timeout: %M", u->read_timeout);
+
+    size = (size_t) luaL_optnumber(L, 2, UDP_MAX_DATAGRAM_SIZE);
+    size = ngx_min(size, UDP_MAX_DATAGRAM_SIZE);
+
+    u->recv_buf_size = size;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket receive buffer size: %uz", u->recv_buf_size);
+
+    rc = ngx_http_lua_socket_udp_read(r, u);
+
+    if (rc == NGX_ERROR) {
+        dd("read failed: %d", (int) u->ft_type);
+        rc = ngx_http_lua_socket_udp_receive_retval_handler(r, u, L);
+        dd("udp receive retval returned: %d", (int) rc);
+        return rc;
+    }
+
+    if (rc == NGX_OK) {
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua udp socket receive done in a single run");
+
+        return ngx_http_lua_socket_udp_receive_retval_handler(r, u, L);
+    }
+
+    /* n == NGX_AGAIN */
+
+    u->read_event_handler = ngx_http_lua_socket_udp_read_handler;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ctx->cur_co_ctx->cleanup = ngx_http_lua_udp_socket_cleanup;
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    u->co_ctx = ctx->cur_co_ctx;
+    u->waiting = 1;
+    u->prepare_retvals = ngx_http_lua_socket_udp_receive_retval_handler;
+
+    coctx = ctx->cur_co_ctx;
+    coctx->data = u;
+
+    return lua_yield(L, 0);
+}
+
+
+static int
+ngx_http_lua_socket_udp_receive_retval_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, lua_State *L)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket receive return value handler");
+
+    if (u->ft_type) {
+        return ngx_http_lua_socket_error_retval_handler(r, u, L);
+    }
+
+    lua_pushlstring(L, (char *) ngx_http_lua_socket_udp_buffer, u->received);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_socket_udp_settimeout(lua_State *L)
+{
+    int                     n;
+    ngx_int_t               timeout;
+
+    ngx_http_lua_socket_udp_upstream_t  *u;
+
+    n = lua_gettop(L);
+
+    if (n != 2) {
+        return luaL_error(L, "ngx.socket settimout: expecting at least 2 "
+                          "arguments (including the object) but seen %d",
+                          lua_gettop(L));
+    }
+
+    timeout = (ngx_int_t) lua_tonumber(L, 2);
+
+    lua_rawseti(L, 1, SOCKET_TIMEOUT_INDEX);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+
+    if (u) {
+        if (timeout > 0) {
+            u->read_timeout = (ngx_msec_t) timeout;
+
+        } else {
+            u->read_timeout = u->conf->read_timeout;
+        }
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_socket_udp_finalize(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua finalize socket");
+
+    if (u->cleanup) {
+        *u->cleanup = NULL;
+        u->cleanup = NULL;
+    }
+
+    if (u->resolved && u->resolved->ctx) {
+        ngx_resolve_name_done(u->resolved->ctx);
+        u->resolved->ctx = NULL;
+    }
+
+    if (u->udp_connection.connection) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua close socket connection");
+
+        ngx_close_connection(u->udp_connection.connection);
+        u->udp_connection.connection = NULL;
+    }
+
+    if (u->waiting) {
+        u->waiting = 0;
+    }
+}
+
+
+static int
+ngx_http_lua_socket_udp_upstream_destroy(lua_State *L)
+{
+    ngx_http_lua_socket_udp_upstream_t      *u;
+
+    dd("upstream destroy triggered by Lua GC");
+
+    u = lua_touserdata(L, 1);
+    if (u == NULL) {
+        return 0;
+    }
+
+    if (u->cleanup) {
+        ngx_http_lua_socket_udp_cleanup(u); /* it will clear u->cleanup */
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_http_lua_socket_dummy_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket dummy handler");
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_udp_read(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u)
+{
+    ngx_connection_t            *c;
+    ngx_event_t                 *rev;
+    ssize_t                      n;
+
+    c = u->udp_connection.connection;
+    rev = c->read;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua udp socket read data: waiting: %d", (int) u->waiting);
+
+    n = ngx_udp_recv(u->udp_connection.connection,
+                     ngx_http_lua_socket_udp_buffer, u->recv_buf_size);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua udp recv returned %z", n);
+
+    if (n >= 0) {
+        u->received = n;
+        ngx_http_lua_socket_udp_handle_success(r, u);
+        return NGX_OK;
+    }
+
+    if (n == NGX_ERROR) {
+        u->socket_errno = ngx_socket_errno;
+        ngx_http_lua_socket_udp_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return NGX_ERROR;
+    }
+
+    /* n == NGX_AGAIN */
+
+#if 1
+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+        ngx_http_lua_socket_udp_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_ERROR);
+        return NGX_ERROR;
+    }
+#endif
+
+    if (rev->active) {
+        ngx_add_timer(rev, u->read_timeout);
+
+    } else if (rev->timer_set) {
+        ngx_del_timer(rev);
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static void
+ngx_http_lua_socket_udp_read_handler(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u)
+{
+    ngx_connection_t            *c;
+    ngx_http_lua_loc_conf_t     *llcf;
+
+    c = u->udp_connection.connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket read handler");
+
+    if (c->read->timedout) {
+        c->read->timedout = 0;
+
+        llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+        if (llcf->log_socket_errors) {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "lua udp socket read timed out");
+        }
+
+        ngx_http_lua_socket_udp_handle_error(r, u,
+                                             NGX_HTTP_LUA_SOCKET_FT_TIMEOUT);
+        return;
+    }
+
+#if 1
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+#endif
+
+    (void) ngx_http_lua_socket_udp_read(r, u);
+}
+
+
+static void
+ngx_http_lua_socket_udp_handle_error(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u, ngx_uint_t ft_type)
+{
+    ngx_http_lua_ctx_t          *ctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket handle error");
+
+    u->ft_type |= ft_type;
+
+#if 0
+    ngx_http_lua_socket_udp_finalize(r, u);
+#endif
+
+    u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    if (u->co_ctx) {
+        u->co_ctx->cleanup = NULL;
+    }
+
+    if (u->waiting) {
+        u->waiting = 0;
+
+        ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+        if (ctx == NULL) {
+            return;
+        }
+
+        ctx->resume_handler = ngx_http_lua_socket_udp_resume;
+        ctx->cur_co_ctx = u->co_ctx;
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua udp socket waking up the current request");
+
+        r->write_event_handler(r);
+    }
+}
+
+
+static void
+ngx_http_lua_socket_udp_cleanup(void *data)
+{
+    ngx_http_lua_socket_udp_upstream_t  *u = data;
+
+    ngx_http_request_t  *r;
+
+    r = u->request;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "cleanup lua udp socket upstream request: \"%V\"", &r->uri);
+
+    ngx_http_lua_socket_udp_finalize(r, u);
+}
+
+
+static void
+ngx_http_lua_socket_udp_handler(ngx_event_t *ev)
+{
+    ngx_connection_t                *c;
+    ngx_http_request_t              *r;
+    ngx_http_log_ctx_t              *ctx;
+
+    ngx_http_lua_socket_udp_upstream_t  *u;
+
+    c = ev->data;
+    u = c->data;
+    r = u->request;
+    c = r->connection;
+
+    ctx = c->log->data;
+    ctx->current_request = r;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket handler for \"%V?%V\", wev %d", &r->uri,
+                   &r->args, (int) ev->write);
+
+    u->read_event_handler(r, u);
+
+    ngx_http_run_posted_requests(c);
+}
+
+
+static void
+ngx_http_lua_socket_udp_handle_success(ngx_http_request_t *r,
+    ngx_http_lua_socket_udp_upstream_t *u)
+{
+    ngx_http_lua_ctx_t          *ctx;
+
+    u->read_event_handler = ngx_http_lua_socket_dummy_handler;
+
+    if (u->co_ctx) {
+        u->co_ctx->cleanup = NULL;
+    }
+
+    if (u->waiting) {
+        u->waiting = 0;
+
+        ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+        if (ctx == NULL) {
+            return;
+        }
+
+        ctx->resume_handler = ngx_http_lua_socket_udp_resume;
+        ctx->cur_co_ctx = u->co_ctx;
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua udp socket waking up the current request");
+
+        r->write_event_handler(r);
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_udp_connect(ngx_udp_connection_t *uc)
+{
+    int                rc;
+    ngx_int_t          event;
+    ngx_event_t       *rev, *wev;
+    ngx_socket_t       s;
+    ngx_connection_t  *c;
+
+    s = ngx_socket(uc->sockaddr->sa_family, SOCK_DGRAM, 0);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, &uc->log, 0, "UDP socket %d", s);
+
+    if (s == -1) {
+        ngx_log_error(NGX_LOG_ALERT, &uc->log, ngx_socket_errno,
+                      ngx_socket_n " failed");
+
+        return NGX_ERROR;
+    }
+
+    c = ngx_get_connection(s, &uc->log);
+
+    if (c == NULL) {
+        if (ngx_close_socket(s) == -1) {
+            ngx_log_error(NGX_LOG_ALERT, &uc->log, ngx_socket_errno,
+                          ngx_close_socket_n "failed");
+        }
+
+        return NGX_ERROR;
+    }
+
+    if (ngx_nonblocking(s) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, &uc->log, ngx_socket_errno,
+                      ngx_nonblocking_n " failed");
+
+        ngx_free_connection(c);
+
+        if (ngx_close_socket(s) == -1) {
+            ngx_log_error(NGX_LOG_ALERT, &uc->log, ngx_socket_errno,
+                          ngx_close_socket_n " failed");
+        }
+
+        return NGX_ERROR;
+    }
+
+    rev = c->read;
+    wev = c->write;
+
+    rev->log = &uc->log;
+    wev->log = &uc->log;
+
+    uc->connection = c;
+
+    c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);
+
+#if (NGX_THREADS)
+
+    /* TODO: lock event when call completion handler */
+
+    rev->lock = &c->lock;
+    wev->lock = &c->lock;
+    rev->own_lock = &c->lock;
+    wev->own_lock = &c->lock;
+
+#endif
+
+#if (NGX_HTTP_LUA_HAVE_SO_PASSCRED)
+    if (uc->sockaddr->sa_family == AF_UNIX) {
+        struct sockaddr         addr;
+
+        addr.sa_family = AF_UNIX;
+
+        /* just to make valgrind happy */
+        ngx_memzero(addr.sa_data, sizeof(addr.sa_data));
+
+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, &uc->log, 0, "datagram unix "
+                       "domain socket autobind");
+
+        if (bind(uc->connection->fd, &addr, sizeof(sa_family_t)) != 0) {
+            ngx_log_error(NGX_LOG_CRIT, &uc->log, ngx_socket_errno,
+                          "bind() failed");
+
+            return NGX_ERROR;
+        }
+    }
+#endif
+
+    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, &uc->log, 0,
+                   "connect to %V, fd:%d #%d", &uc->server, s, c->number);
+
+    rc = connect(s, uc->sockaddr, uc->socklen);
+
+    /* TODO: aio, iocp */
+
+    if (rc == -1) {
+        ngx_log_error(NGX_LOG_CRIT, &uc->log, ngx_socket_errno,
+                      "connect() failed");
+
+        return NGX_ERROR;
+    }
+
+    /* UDP sockets are always ready to write */
+    wev->ready = 1;
+
+    if (ngx_add_event) {
+
+        event = (ngx_event_flags & NGX_USE_CLEAR_EVENT) ?
+                    /* kqueue, epoll */                 NGX_CLEAR_EVENT:
+                    /* select, poll, /dev/poll */       NGX_LEVEL_EVENT;
+                    /* eventport event type has no meaning: oneshot only */
+
+        if (ngx_add_event(rev, NGX_READ_EVENT, event) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+    } else {
+        /* rtsig */
+
+        if (ngx_add_conn(c) == NGX_ERROR) {
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static int
+ngx_http_lua_socket_udp_close(lua_State *L)
+{
+    ngx_http_request_t                  *r;
+    ngx_http_lua_socket_udp_upstream_t  *u;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting 1 argument "
+                          "(including the object) but seen %d", lua_gettop(L));
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    lua_rawgeti(L, 1, SOCKET_CTX_INDEX);
+    u = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    if (u == NULL || u->udp_connection.connection == NULL) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "closed");
+        return 2;
+    }
+
+    if (u->waiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "socket busy");
+        return 2;
+    }
+
+    ngx_http_lua_socket_udp_finalize(r, u);
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static ngx_int_t
+ngx_http_lua_socket_udp_resume(ngx_http_request_t *r)
+{
+    int                          nret;
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ngx_http_lua_socket_udp_upstream_t      *u;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp operation done, resuming lua thread");
+
+    coctx = ctx->cur_co_ctx;
+
+#if 0
+    ngx_http_lua_probe_info("udp resume");
+#endif
+
+    u = coctx->data;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua udp socket calling prepare retvals handler %p, "
+                   "u:%p", u->prepare_retvals, u);
+
+    nret = u->prepare_retvals(r, u, ctx->cur_co_ctx->co);
+    if (nret == NGX_AGAIN) {
+        return NGX_DONE;
+    }
+
+    c = r->connection;
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, nret);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
+static void
+ngx_http_lua_udp_resolve_cleanup(void *data)
+{
+    ngx_resolver_ctx_t                      *rctx;
+    ngx_http_lua_socket_udp_upstream_t      *u;
+    ngx_http_lua_co_ctx_t                   *coctx = data;
+
+    u = coctx->data;
+    if (u == NULL) {
+        return;
+    }
+
+    rctx = u->resolved->ctx;
+    if (rctx == NULL) {
+        return;
+    }
+
+    ngx_resolve_name_done(rctx);
+}
+
+
+static void
+ngx_http_lua_udp_socket_cleanup(void *data)
+{
+    ngx_http_lua_socket_udp_upstream_t      *u;
+    ngx_http_lua_co_ctx_t                   *coctx = data;
+
+    u = coctx->data;
+    if (u == NULL) {
+        return;
+    }
+
+    if (u->request == NULL) {
+        return;
+    }
+
+    ngx_http_lua_socket_udp_finalize(u->request, u);
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.h b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_socket_udp.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,56 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_SOCKET_UDP_H_INCLUDED_
+#define _NGX_HTTP_LUA_SOCKET_UDP_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+typedef struct ngx_http_lua_socket_udp_upstream_s
+    ngx_http_lua_socket_udp_upstream_t;
+
+
+typedef
+    int (*ngx_http_lua_socket_udp_retval_handler)(ngx_http_request_t *r,
+        ngx_http_lua_socket_udp_upstream_t *u, lua_State *L);
+
+
+typedef void (*ngx_http_lua_socket_udp_upstream_handler_pt)(
+          ngx_http_request_t *r, ngx_http_lua_socket_udp_upstream_t *u);
+
+
+struct ngx_http_lua_socket_udp_upstream_s {
+    ngx_http_lua_socket_udp_retval_handler          prepare_retvals;
+    ngx_http_lua_socket_udp_upstream_handler_pt     read_event_handler;
+
+    ngx_http_lua_loc_conf_t         *conf;
+    ngx_http_cleanup_pt             *cleanup;
+    ngx_http_request_t              *request;
+    ngx_udp_connection_t             udp_connection;
+
+    ngx_msec_t                       read_timeout;
+
+    ngx_http_upstream_resolved_t    *resolved;
+
+    ngx_uint_t                       ft_type;
+    ngx_err_t                        socket_errno;
+    size_t                           received; /* for receive */
+    size_t                           recv_buf_size;
+
+    ngx_http_lua_co_ctx_t           *co_ctx;
+
+    unsigned                         waiting; /* :1 */
+};
+
+
+void ngx_http_lua_inject_socket_udp_api(ngx_log_t *log, lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_SOCKET_UDP_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_string.c b/src/lua/lua-nginx-module/src/ngx_http_lua_string.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_string.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_string.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,590 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_string.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_args.h"
+#include "ngx_crc32.h"
+
+#if NGX_HAVE_SHA1
+#include "ngx_sha1.h"
+#endif
+
+#include "ngx_md5.h"
+
+#if (NGX_OPENSSL)
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#endif
+
+
+#ifndef SHA_DIGEST_LENGTH
+#define SHA_DIGEST_LENGTH 20
+#endif
+
+
+static uintptr_t ngx_http_lua_ngx_escape_sql_str(u_char *dst, u_char *src,
+        size_t size);
+static int ngx_http_lua_ngx_escape_uri(lua_State *L);
+static int ngx_http_lua_ngx_unescape_uri(lua_State *L);
+static int ngx_http_lua_ngx_quote_sql_str(lua_State *L);
+static int ngx_http_lua_ngx_md5(lua_State *L);
+static int ngx_http_lua_ngx_md5_bin(lua_State *L);
+
+#if (NGX_HAVE_SHA1)
+static int ngx_http_lua_ngx_sha1_bin(lua_State *L);
+#endif
+
+static int ngx_http_lua_ngx_decode_base64(lua_State *L);
+static int ngx_http_lua_ngx_encode_base64(lua_State *L);
+static int ngx_http_lua_ngx_crc32_short(lua_State *L);
+static int ngx_http_lua_ngx_crc32_long(lua_State *L);
+static int ngx_http_lua_ngx_encode_args(lua_State *L);
+static int ngx_http_lua_ngx_decode_args(lua_State *L);
+#if (NGX_OPENSSL)
+static int ngx_http_lua_ngx_hmac_sha1(lua_State *L);
+#endif
+
+
+void
+ngx_http_lua_inject_string_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_escape_uri);
+    lua_setfield(L, -2, "escape_uri");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_unescape_uri);
+    lua_setfield(L, -2, "unescape_uri");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_encode_args);
+    lua_setfield(L, -2, "encode_args");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_decode_args);
+    lua_setfield(L, -2, "decode_args");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_quote_sql_str);
+    lua_setfield(L, -2, "quote_sql_str");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_decode_base64);
+    lua_setfield(L, -2, "decode_base64");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_encode_base64);
+    lua_setfield(L, -2, "encode_base64");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_md5_bin);
+    lua_setfield(L, -2, "md5_bin");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_md5);
+    lua_setfield(L, -2, "md5");
+
+#if (NGX_HAVE_SHA1)
+    lua_pushcfunction(L, ngx_http_lua_ngx_sha1_bin);
+    lua_setfield(L, -2, "sha1_bin");
+#endif
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_crc32_short);
+    lua_setfield(L, -2, "crc32_short");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_crc32_long);
+    lua_setfield(L, -2, "crc32_long");
+
+#if (NGX_OPENSSL)
+    lua_pushcfunction(L, ngx_http_lua_ngx_hmac_sha1);
+    lua_setfield(L, -2, "hmac_sha1");
+#endif
+}
+
+
+static int
+ngx_http_lua_ngx_escape_uri(lua_State *L)
+{
+    size_t                   len, dlen;
+    uintptr_t                escape;
+    u_char                  *src, *dst;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    src = (u_char *) luaL_checklstring(L, 1, &len);
+
+    if (len == 0) {
+        return 1;
+    }
+
+    escape = 2 * ngx_http_lua_escape_uri(NULL, src, len, NGX_ESCAPE_URI);
+
+    if (escape) {
+        dlen = escape + len;
+        dst = lua_newuserdata(L, dlen);
+        ngx_http_lua_escape_uri(dst, src, len, NGX_ESCAPE_URI);
+        lua_pushlstring(L, (char *) dst, dlen);
+    }
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_unescape_uri(lua_State *L)
+{
+    size_t                   len, dlen;
+    u_char                  *p;
+    u_char                  *src, *dst;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    src = (u_char *) luaL_checklstring(L, 1, &len);
+
+    /* the unescaped string can only be smaller */
+    dlen = len;
+
+    p = lua_newuserdata(L, dlen);
+
+    dst = p;
+
+    ngx_http_lua_unescape_uri(&dst, &src, len, NGX_UNESCAPE_URI_COMPONENT);
+
+    lua_pushlstring(L, (char *) p, dst - p);
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_quote_sql_str(lua_State *L)
+{
+    size_t                   len, dlen, escape;
+    u_char                  *p;
+    u_char                  *src, *dst;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    src = (u_char *) luaL_checklstring(L, 1, &len);
+
+    if (len == 0) {
+        dst = (u_char *) "''";
+        dlen = sizeof("''") - 1;
+        lua_pushlstring(L, (char *) dst, dlen);
+        return 1;
+    }
+
+    escape = ngx_http_lua_ngx_escape_sql_str(NULL, src, len);
+
+    dlen = sizeof("''") - 1 + len + escape;
+
+    p = lua_newuserdata(L, dlen);
+
+    dst = p;
+
+    *p++ = '\'';
+
+    if (escape == 0) {
+        p = ngx_copy(p, src, len);
+
+    } else {
+        p = (u_char *) ngx_http_lua_ngx_escape_sql_str(p, src, len);
+    }
+
+    *p++ = '\'';
+
+    if (p != dst + dlen) {
+        return NGX_ERROR;
+    }
+
+    lua_pushlstring(L, (char *) dst, p - dst);
+
+    return 1;
+}
+
+
+static uintptr_t
+ngx_http_lua_ngx_escape_sql_str(u_char *dst, u_char *src, size_t size)
+{
+    ngx_uint_t               n;
+
+    if (dst == NULL) {
+        /* find the number of chars to be escaped */
+        n = 0;
+        while (size) {
+            /* the highest bit of all the UTF-8 chars
+             * is always 1 */
+            if ((*src & 0x80) == 0) {
+                switch (*src) {
+                    case '\0':
+                    case '\b':
+                    case '\n':
+                    case '\r':
+                    case '\t':
+                    case 26:  /* \z */
+                    case '\\':
+                    case '\'':
+                    case '"':
+                        n++;
+                        break;
+                    default:
+                        break;
+                }
+            }
+            src++;
+            size--;
+        }
+
+        return (uintptr_t) n;
+    }
+
+    while (size) {
+        if ((*src & 0x80) == 0) {
+            switch (*src) {
+                case '\0':
+                    *dst++ = '\\';
+                    *dst++ = '0';
+                    break;
+
+                case '\b':
+                    *dst++ = '\\';
+                    *dst++ = 'b';
+                    break;
+
+                case '\n':
+                    *dst++ = '\\';
+                    *dst++ = 'n';
+                    break;
+
+                case '\r':
+                    *dst++ = '\\';
+                    *dst++ = 'r';
+                    break;
+
+                case '\t':
+                    *dst++ = '\\';
+                    *dst++ = 't';
+                    break;
+
+                case 26:
+                    *dst++ = '\\';
+                    *dst++ = 'z';
+                    break;
+
+                case '\\':
+                    *dst++ = '\\';
+                    *dst++ = '\\';
+                    break;
+
+                case '\'':
+                    *dst++ = '\\';
+                    *dst++ = '\'';
+                    break;
+
+                case '"':
+                    *dst++ = '\\';
+                    *dst++ = '"';
+                    break;
+
+                default:
+                    *dst++ = *src;
+                    break;
+            }
+        } else {
+            *dst++ = *src;
+        }
+        src++;
+        size--;
+    } /* while (size) */
+
+    return (uintptr_t) dst;
+}
+
+
+static int
+ngx_http_lua_ngx_md5(lua_State *L)
+{
+    u_char                  *src;
+    size_t                   slen;
+
+    ngx_md5_t                md5;
+    u_char                   md5_buf[MD5_DIGEST_LENGTH];
+    u_char                   hex_buf[2 * sizeof(md5_buf)];
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    if (lua_isnil(L, 1)) {
+        src = (u_char *) "";
+        slen = 0;
+
+    } else {
+        src = (u_char *) luaL_checklstring(L, 1, &slen);
+    }
+
+    ngx_md5_init(&md5);
+    ngx_md5_update(&md5, src, slen);
+    ngx_md5_final(md5_buf, &md5);
+
+    ngx_hex_dump(hex_buf, md5_buf, sizeof(md5_buf));
+
+    lua_pushlstring(L, (char *) hex_buf, sizeof(hex_buf));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_md5_bin(lua_State *L)
+{
+    u_char                  *src;
+    size_t                   slen;
+
+    ngx_md5_t                md5;
+    u_char                   md5_buf[MD5_DIGEST_LENGTH];
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    if (lua_isnil(L, 1)) {
+        src     = (u_char *) "";
+        slen    = 0;
+
+    } else {
+        src = (u_char *) luaL_checklstring(L, 1, &slen);
+    }
+
+    dd("slen: %d", (int) slen);
+
+    ngx_md5_init(&md5);
+    ngx_md5_update(&md5, src, slen);
+    ngx_md5_final(md5_buf, &md5);
+
+    lua_pushlstring(L, (char *) md5_buf, sizeof(md5_buf));
+
+    return 1;
+}
+
+
+#if (NGX_HAVE_SHA1)
+static int
+ngx_http_lua_ngx_sha1_bin(lua_State *L)
+{
+    u_char                  *src;
+    size_t                   slen;
+
+    ngx_sha1_t               sha;
+    u_char                   sha_buf[SHA_DIGEST_LENGTH];
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    if (lua_isnil(L, 1)) {
+        src     = (u_char *) "";
+        slen    = 0;
+
+    } else {
+        src = (u_char *) luaL_checklstring(L, 1, &slen);
+    }
+
+    dd("slen: %d", (int) slen);
+
+    ngx_sha1_init(&sha);
+    ngx_sha1_update(&sha, src, slen);
+    ngx_sha1_final(sha_buf, &sha);
+
+    lua_pushlstring(L, (char *) sha_buf, sizeof(sha_buf));
+
+    return 1;
+}
+#endif
+
+
+static int
+ngx_http_lua_ngx_decode_base64(lua_State *L)
+{
+    ngx_str_t                p, src;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    if (lua_isnil(L, 1)) {
+        src.data = (u_char *) "";
+        src.len = 0;
+
+    } else {
+        src.data = (u_char *) luaL_checklstring(L, 1, &src.len);
+    }
+
+    p.len = ngx_base64_decoded_length(src.len);
+
+    p.data = lua_newuserdata(L, p.len);
+
+    if (ngx_decode_base64(&p, &src) == NGX_OK) {
+        lua_pushlstring(L, (char *) p.data, p.len);
+
+    } else {
+        lua_pushnil(L);
+    }
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_encode_base64(lua_State *L)
+{
+    ngx_str_t                p, src;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    if (lua_isnil(L, 1)) {
+        src.data = (u_char *) "";
+        src.len = 0;
+
+    } else {
+        src.data = (u_char *) luaL_checklstring(L, 1, &src.len);
+    }
+
+    p.len = ngx_base64_encoded_length(src.len);
+
+    p.data = lua_newuserdata(L, p.len);
+
+    ngx_encode_base64(&p, &src);
+
+    lua_pushlstring(L, (char *) p.data, p.len);
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_crc32_short(lua_State *L)
+{
+    u_char                  *p;
+    size_t                   len;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument, but got %d",
+                lua_gettop(L));
+    }
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    lua_pushnumber(L, (lua_Number) ngx_crc32_short(p, len));
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_crc32_long(lua_State *L)
+{
+    u_char                  *p;
+    size_t                   len;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument, but got %d",
+                          lua_gettop(L));
+    }
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    lua_pushnumber(L, (lua_Number) ngx_crc32_long(p, len));
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_encode_args(lua_State *L)
+{
+    ngx_str_t                    args;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting 1 argument but seen %d",
+                          lua_gettop(L));
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+    ngx_http_lua_process_args_option(NULL, L, 1, &args);
+    lua_pushlstring(L, (char *) args.data, args.len);
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_decode_args(lua_State *L)
+{
+    u_char                      *buf;
+    u_char                      *tmp;
+    size_t                       len = 0;
+    int                          n;
+    int                          max;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting 1 or 2 arguments but seen %d", n);
+    }
+
+    buf = (u_char *) luaL_checklstring(L, 1, &len);
+
+    if (n == 2) {
+        max = luaL_checkint(L, 2);
+        lua_pop(L, 1);
+
+    } else {
+        max = NGX_HTTP_LUA_MAX_ARGS;
+    }
+
+    tmp = lua_newuserdata(L, len);
+    ngx_memcpy(tmp, buf, len);
+
+    lua_createtable(L, 0, 4);
+
+    return ngx_http_lua_parse_args(L, tmp, tmp + len, max);
+}
+
+
+#if (NGX_OPENSSL)
+static int
+ngx_http_lua_ngx_hmac_sha1(lua_State *L)
+{
+    u_char                  *sec, *sts;
+    size_t                   lsec, lsts;
+    unsigned int             md_len;
+    unsigned char            md[EVP_MAX_MD_SIZE];
+    const EVP_MD            *evp_md;
+
+    if (lua_gettop(L) != 2) {
+        return luaL_error(L, "expecting one argument, but got %d",
+                          lua_gettop(L));
+    }
+
+    sec = (u_char *) luaL_checklstring(L, 1, &lsec);
+    sts = (u_char *) luaL_checklstring(L, 2, &lsts);
+
+    evp_md = EVP_sha1();
+
+    HMAC(evp_md, sec, lsec, sts, lsts, md, &md_len);
+
+    lua_pushlstring(L, (char *) md, md_len);
+
+    return 1;
+}
+#endif
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_string.h b/src/lua/lua-nginx-module/src/ngx_http_lua_string.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_string.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_string.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_STRING_H_INCLUDED_
+#define _NGX_HTTP_LUA_STRING_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_string_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_STRING_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.c b/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,1688 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_subrequest.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_ctx.h"
+#include "ngx_http_lua_contentby.h"
+#if defined(NGX_DTRACE) && NGX_DTRACE
+#include "ngx_http_probe.h"
+#endif
+
+
+#define NGX_HTTP_LUA_SHARE_ALL_VARS     0x01
+#define NGX_HTTP_LUA_COPY_ALL_VARS      0x02
+
+
+#define ngx_http_lua_method_name(m) { sizeof(m) - 1, (u_char *) m " " }
+
+ngx_str_t  ngx_http_lua_get_method = ngx_http_lua_method_name("GET");
+ngx_str_t  ngx_http_lua_put_method = ngx_http_lua_method_name("PUT");
+ngx_str_t  ngx_http_lua_post_method = ngx_http_lua_method_name("POST");
+ngx_str_t  ngx_http_lua_head_method = ngx_http_lua_method_name("HEAD");
+ngx_str_t  ngx_http_lua_delete_method =
+        ngx_http_lua_method_name("DELETE");
+ngx_str_t  ngx_http_lua_options_method =
+        ngx_http_lua_method_name("OPTIONS");
+ngx_str_t  ngx_http_lua_copy_method = ngx_http_lua_method_name("COPY");
+ngx_str_t  ngx_http_lua_move_method = ngx_http_lua_method_name("MOVE");
+ngx_str_t  ngx_http_lua_lock_method = ngx_http_lua_method_name("LOCK");
+ngx_str_t  ngx_http_lua_mkcol_method =
+        ngx_http_lua_method_name("MKCOL");
+ngx_str_t  ngx_http_lua_propfind_method =
+        ngx_http_lua_method_name("PROPFIND");
+ngx_str_t  ngx_http_lua_proppatch_method =
+        ngx_http_lua_method_name("PROPPATCH");
+ngx_str_t  ngx_http_lua_unlock_method =
+        ngx_http_lua_method_name("UNLOCK");
+ngx_str_t  ngx_http_lua_patch_method =
+        ngx_http_lua_method_name("PATCH");
+ngx_str_t  ngx_http_lua_trace_method =
+        ngx_http_lua_method_name("TRACE");
+
+
+static ngx_str_t  ngx_http_lua_content_length_header_key =
+    ngx_string("Content-Length");
+
+
+static ngx_int_t ngx_http_lua_set_content_length_header(ngx_http_request_t *r,
+    off_t len);
+static ngx_int_t ngx_http_lua_adjust_subrequest(ngx_http_request_t *sr,
+    ngx_uint_t method, int forward_body,
+    ngx_http_request_body_t *body, unsigned vars_action,
+    ngx_array_t *extra_vars);
+static int ngx_http_lua_ngx_location_capture(lua_State *L);
+static int ngx_http_lua_ngx_location_capture_multi(lua_State *L);
+static void ngx_http_lua_process_vars_option(ngx_http_request_t *r,
+    lua_State *L, int table, ngx_array_t **varsp);
+static ngx_int_t ngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *r,
+    ngx_array_t *extra_vars);
+static ngx_int_t ngx_http_lua_subrequest(ngx_http_request_t *r,
+    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,
+    ngx_http_post_subrequest_t *ps, ngx_uint_t flags);
+static ngx_int_t ngx_http_lua_subrequest_resume(ngx_http_request_t *r);
+static void ngx_http_lua_handle_subreq_responses(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+static void ngx_http_lua_cancel_subreq(ngx_http_request_t *r);
+static ngx_int_t ngx_http_post_request_to_head(ngx_http_request_t *r);
+static ngx_int_t ngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r);
+
+
+/* ngx.location.capture is just a thin wrapper around
+ * ngx.location.capture_multi */
+static int
+ngx_http_lua_ngx_location_capture(lua_State *L)
+{
+    int                 n;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting one or two arguments");
+    }
+
+    lua_createtable(L, n, 0); /* uri opts? table  */
+    lua_insert(L, 1); /* table uri opts? */
+    if (n == 1) { /* table uri */
+        lua_rawseti(L, 1, 1); /* table */
+
+    } else { /* table uri opts */
+        lua_rawseti(L, 1, 2); /* table uri */
+        lua_rawseti(L, 1, 1); /* table */
+    }
+
+    lua_createtable(L, 1, 0); /* table table' */
+    lua_insert(L, 1);   /* table' table */
+    lua_rawseti(L, 1, 1); /* table' */
+
+    return ngx_http_lua_ngx_location_capture_multi(L);
+}
+
+
+static int
+ngx_http_lua_ngx_location_capture_multi(lua_State *L)
+{
+    ngx_http_request_t              *r;
+    ngx_http_request_t              *sr; /* subrequest object */
+    ngx_http_post_subrequest_t      *psr;
+    ngx_http_lua_ctx_t              *sr_ctx;
+    ngx_http_lua_ctx_t              *ctx;
+    ngx_array_t                     *extra_vars;
+    ngx_str_t                        uri;
+    ngx_str_t                        args;
+    ngx_str_t                        extra_args;
+    ngx_uint_t                       flags;
+    u_char                          *p;
+    u_char                          *q;
+    size_t                           len;
+    size_t                           nargs;
+    int                              rc;
+    int                              n;
+    int                              always_forward_body = 0;
+    ngx_uint_t                       method;
+    ngx_http_request_body_t         *body;
+    int                              type;
+    ngx_buf_t                       *b;
+    unsigned                         vars_action;
+    ngx_uint_t                       nsubreqs;
+    ngx_uint_t                       index;
+    size_t                           sr_statuses_len;
+    size_t                           sr_headers_len;
+    size_t                           sr_bodies_len;
+    size_t                           sr_flags_len;
+    unsigned                         custom_ctx;
+    ngx_http_lua_co_ctx_t           *coctx;
+
+    ngx_http_lua_post_subrequest_data_t      *psr_data;
+
+    n = lua_gettop(L);
+    if (n != 1) {
+        return luaL_error(L, "only one argument is expected, but got %d", n);
+    }
+
+    luaL_checktype(L, 1, LUA_TTABLE);
+
+    nsubreqs = lua_objlen(L, 1);
+    if (nsubreqs == 0) {
+        return luaL_error(L, "at least one subrequest should be specified");
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+#if (NGX_HTTP_SPDY)
+    if (r->spdy_stream) {
+        return luaL_error(L, "spdy not supported yet");
+    }
+#endif
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT);
+
+    coctx = ctx->cur_co_ctx;
+    if (coctx == NULL) {
+        return luaL_error(L, "no co ctx found");
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua location capture, uri:\"%V\" c:%ud", &r->uri,
+                   r->main->count);
+
+    sr_statuses_len = nsubreqs * sizeof(ngx_int_t);
+    sr_headers_len  = nsubreqs * sizeof(ngx_http_headers_out_t *);
+    sr_bodies_len   = nsubreqs * sizeof(ngx_str_t);
+    sr_flags_len    = nsubreqs * sizeof(uint8_t);
+
+    p = ngx_pcalloc(r->pool, sr_statuses_len + sr_headers_len +
+                    sr_bodies_len + sr_flags_len);
+
+    if (p == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    coctx->sr_statuses = (void *) p;
+    p += sr_statuses_len;
+
+    coctx->sr_headers = (void *) p;
+    p += sr_headers_len;
+
+    coctx->sr_bodies = (void *) p;
+    p += sr_bodies_len;
+
+    coctx->sr_flags = (void *) p;
+
+    coctx->nsubreqs = nsubreqs;
+
+    coctx->pending_subreqs = 0;
+
+    extra_vars = NULL;
+
+    for (index = 0; index < nsubreqs; index++) {
+        coctx->pending_subreqs++;
+
+        lua_rawgeti(L, 1, index + 1);
+        if (lua_isnil(L, -1)) {
+            return luaL_error(L, "only array-like tables are allowed");
+        }
+
+        dd("queries query: top %d", lua_gettop(L));
+
+        if (lua_type(L, -1) != LUA_TTABLE) {
+            return luaL_error(L, "the query argument %d is not a table, "
+                              "but a %s",
+                              index, lua_typename(L, lua_type(L, -1)));
+        }
+
+        nargs = lua_objlen(L, -1);
+
+        if (nargs != 1 && nargs != 2) {
+            return luaL_error(L, "query argument %d expecting one or "
+                              "two arguments", index);
+        }
+
+        lua_rawgeti(L, 2, 1); /* queries query uri */
+
+        dd("queries query uri: %d", lua_gettop(L));
+
+        dd("first arg in first query: %s", lua_typename(L, lua_type(L, -1)));
+
+        body = NULL;
+
+        extra_args.data = NULL;
+        extra_args.len = 0;
+
+        if (extra_vars != NULL) {
+            /* flush out existing elements in the array */
+            extra_vars->nelts = 0;
+        }
+
+        vars_action = 0;
+
+        custom_ctx = 0;
+
+        if (nargs == 2) {
+            /* check out the options table */
+
+            lua_rawgeti(L, 2, 2); /* queries query uri opts */
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            if (lua_type(L, 4) != LUA_TTABLE) {
+                return luaL_error(L, "expecting table as the 2nd argument for "
+                                  "subrequest %d, but got %s", index,
+                                  luaL_typename(L, 4));
+            }
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            /* check the args option */
+
+            lua_getfield(L, 4, "args");
+
+            type = lua_type(L, -1);
+
+            switch (type) {
+            case LUA_TTABLE:
+                ngx_http_lua_process_args_option(r, L, -1, &extra_args);
+                break;
+
+            case LUA_TNIL:
+                /* do nothing */
+                break;
+
+            case LUA_TNUMBER:
+            case LUA_TSTRING:
+                extra_args.data = (u_char *) lua_tolstring(L, -1, &len);
+                extra_args.len = len;
+
+                break;
+
+            default:
+                return luaL_error(L, "Bad args option value");
+            }
+
+            lua_pop(L, 1);
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            /* check the vars option */
+
+            lua_getfield(L, 4, "vars");
+
+            switch (lua_type(L, -1)) {
+            case LUA_TTABLE:
+                ngx_http_lua_process_vars_option(r, L, -1, &extra_vars);
+
+                dd("post process vars top: %d", lua_gettop(L));
+                break;
+
+            case LUA_TNIL:
+                /* do nothing */
+                break;
+
+            default:
+                return luaL_error(L, "Bad vars option value");
+            }
+
+            lua_pop(L, 1);
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            /* check the share_all_vars option */
+
+            lua_getfield(L, 4, "share_all_vars");
+
+            switch (lua_type(L, -1)) {
+            case LUA_TNIL:
+                /* do nothing */
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, -1)) {
+                    vars_action |= NGX_HTTP_LUA_SHARE_ALL_VARS;
+                }
+                break;
+
+            default:
+                return luaL_error(L, "Bad share_all_vars option value");
+            }
+
+            lua_pop(L, 1);
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            /* check the copy_all_vars option */
+
+            lua_getfield(L, 4, "copy_all_vars");
+
+            switch (lua_type(L, -1)) {
+            case LUA_TNIL:
+                /* do nothing */
+                break;
+
+            case LUA_TBOOLEAN:
+                if (lua_toboolean(L, -1)) {
+                    vars_action |= NGX_HTTP_LUA_COPY_ALL_VARS;
+                }
+                break;
+
+            default:
+                return luaL_error(L, "Bad copy_all_vars option value");
+            }
+
+            lua_pop(L, 1);
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            /* check the "forward_body" option */
+
+            lua_getfield(L, 4, "always_forward_body");
+            always_forward_body = lua_toboolean(L, -1);
+            lua_pop(L, 1);
+
+            dd("always foward body: %d", always_forward_body);
+
+            /* check the "method" option */
+
+            lua_getfield(L, 4, "method");
+
+            type = lua_type(L, -1);
+
+            if (type == LUA_TNIL) {
+                method = NGX_HTTP_GET;
+
+            } else {
+                if (type != LUA_TNUMBER) {
+                    return luaL_error(L, "Bad http request method");
+                }
+
+                method = (ngx_uint_t) lua_tonumber(L, -1);
+            }
+
+            lua_pop(L, 1);
+
+            dd("queries query uri opts: %d", lua_gettop(L));
+
+            /* check the "ctx" option */
+
+            lua_getfield(L, 4, "ctx");
+
+            type = lua_type(L, -1);
+
+            if (type != LUA_TNIL) {
+                if (type != LUA_TTABLE) {
+                    return luaL_error(L, "Bad ctx option value type %s, "
+                                      "expected a Lua table",
+                                      lua_typename(L, type));
+                }
+
+                custom_ctx = 1;
+
+            } else {
+                lua_pop(L, 1);
+            }
+
+            dd("queries query uri opts ctx?: %d", lua_gettop(L));
+
+            /* check the "body" option */
+
+            lua_getfield(L, 4, "body");
+
+            type = lua_type(L, -1);
+
+            if (type != LUA_TNIL) {
+                if (type != LUA_TSTRING && type != LUA_TNUMBER) {
+                    return luaL_error(L, "Bad http request body");
+                }
+
+                body = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
+
+                if (body == NULL) {
+                    return luaL_error(L, "out of memory");
+                }
+
+                q = (u_char *) lua_tolstring(L, -1, &len);
+
+                dd("request body: [%.*s]", (int) len, q);
+
+                if (len) {
+                    b = ngx_create_temp_buf(r->pool, len);
+                    if (b == NULL) {
+                        return luaL_error(L, "out of memory");
+                    }
+
+                    b->last = ngx_copy(b->last, q, len);
+
+                    body->bufs = ngx_alloc_chain_link(r->pool);
+                    if (body->bufs == NULL) {
+                        return luaL_error(L, "out of memory");
+                    }
+
+                    body->bufs->buf = b;
+                    body->bufs->next = NULL;
+
+                    body->buf = b;
+                }
+            }
+
+            lua_pop(L, 1); /* pop the body */
+
+            /* stack: queries query uri opts ctx? */
+
+            lua_remove(L, 4);
+
+            /* stack: queries query uri ctx? */
+
+            dd("queries query uri ctx?: %d", lua_gettop(L));
+
+        } else {
+            method = NGX_HTTP_GET;
+        }
+
+        /* stack: queries query uri ctx? */
+
+        p = (u_char *) luaL_checklstring(L, 3, &len);
+
+        uri.data = ngx_palloc(r->pool, len);
+        if (uri.data == NULL) {
+            return luaL_error(L, "memory allocation error");
+        }
+
+        ngx_memcpy(uri.data, p, len);
+
+        uri.len = len;
+
+        args.data = NULL;
+        args.len = 0;
+
+        flags = 0;
+
+        rc = ngx_http_parse_unsafe_uri(r, &uri, &args, &flags);
+        if (rc != NGX_OK) {
+            dd("rc = %d", (int) rc);
+
+            return luaL_error(L, "unsafe uri in argument #1: %s", p);
+        }
+
+        if (args.len == 0) {
+            if (extra_args.len) {
+                p = ngx_palloc(r->pool, extra_args.len);
+                if (p == NULL) {
+                    return luaL_error(L, "out of memory");
+                }
+
+                ngx_memcpy(p, extra_args.data, extra_args.len);
+
+                args.data = p;
+                args.len = extra_args.len;
+            }
+
+        } else if (extra_args.len) {
+            /* concatenate the two parts of args together */
+            len = args.len + (sizeof("&") - 1) + extra_args.len;
+
+            p = ngx_palloc(r->pool, len);
+            if (p == NULL) {
+                return luaL_error(L, "out of memory");
+            }
+
+            q = ngx_copy(p, args.data, args.len);
+            *q++ = '&';
+            ngx_memcpy(q, extra_args.data, extra_args.len);
+
+            args.data = p;
+            args.len = len;
+        }
+
+        p = ngx_pnalloc(r->pool, sizeof(ngx_http_post_subrequest_t)
+                        + sizeof(ngx_http_lua_ctx_t)
+                        + sizeof(ngx_http_lua_post_subrequest_data_t));
+        if (p == NULL) {
+            return luaL_error(L, "out of memory");
+        }
+
+        psr = (ngx_http_post_subrequest_t *) p;
+
+        p += sizeof(ngx_http_post_subrequest_t);
+
+        sr_ctx = (ngx_http_lua_ctx_t *) p;
+
+        p += sizeof(ngx_http_lua_ctx_t);
+
+        psr_data = (ngx_http_lua_post_subrequest_data_t *) p;
+
+        ngx_memzero(sr_ctx, sizeof(ngx_http_lua_ctx_t));
+
+        /* set by ngx_memzero:
+         *      sr_ctx->run_post_subrequest = 0
+         *      sr_ctx->free = NULL
+         *      sr_ctx->body = NULL
+         */
+
+        psr_data->ctx = sr_ctx;
+        psr_data->pr_co_ctx = coctx;
+
+        psr->handler = ngx_http_lua_post_subrequest;
+        psr->data = psr_data;
+
+        rc = ngx_http_lua_subrequest(r, &uri, &args, &sr, psr, 0);
+
+        if (rc != NGX_OK) {
+            return luaL_error(L, "failed to issue subrequest: %d", (int) rc);
+        }
+
+        ngx_http_lua_init_ctx(sr, sr_ctx);
+
+        sr_ctx->capture = 1;
+        sr_ctx->index = index;
+        sr_ctx->last_body = &sr_ctx->body;
+
+        ngx_http_set_ctx(sr, sr_ctx, ngx_http_lua_module);
+
+        rc = ngx_http_lua_adjust_subrequest(sr, method, always_forward_body,
+                                            body, vars_action, extra_vars);
+
+        if (rc != NGX_OK) {
+            ngx_http_lua_cancel_subreq(sr);
+            return luaL_error(L, "failed to adjust the subrequest: %d",
+                              (int) rc);
+        }
+
+        dd("queries query uri opts ctx? %d", lua_gettop(L));
+
+        /* stack: queries query uri ctx? */
+
+        if (custom_ctx) {
+            ngx_http_lua_ngx_set_ctx_helper(L, sr, sr_ctx, -1);
+            lua_pop(L, 3);
+
+        } else {
+            lua_pop(L, 2);
+        }
+
+        /* stack: queries */
+    }
+
+    if (extra_vars) {
+        ngx_array_destroy(extra_vars);
+    }
+
+    ctx->no_abort = 1;
+
+    return lua_yield(L, 0);
+}
+
+
+static ngx_int_t
+ngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,
+    int always_forward_body, ngx_http_request_body_t *body,
+    unsigned vars_action, ngx_array_t *extra_vars)
+{
+    ngx_http_request_t          *r;
+    ngx_int_t                    rc;
+    ngx_http_core_main_conf_t   *cmcf;
+    size_t                       size;
+
+    r = sr->parent;
+
+    sr->header_in = r->header_in;
+
+    if (body) {
+        sr->request_body = body;
+
+        rc = ngx_http_lua_set_content_length_header(sr,
+                                                    body->buf
+                                                    ? ngx_buf_size(body->buf)
+                                                    : 0);
+
+        if (rc != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+    } else if (!always_forward_body
+               && method != NGX_HTTP_PUT
+               && method != NGX_HTTP_POST
+               && r->headers_in.content_length_n > 0)
+    {
+        rc = ngx_http_lua_set_content_length_header(sr, 0);
+        if (rc != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+#if 1
+        sr->request_body = NULL;
+#endif
+
+    } else if (sr->request_body) {
+
+        /* deep-copy the request body */
+
+        if (sr->request_body->temp_file) {
+            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    sr->method = method;
+
+    switch (method) {
+        case NGX_HTTP_GET:
+            sr->method_name = ngx_http_lua_get_method;
+            break;
+
+        case NGX_HTTP_POST:
+            sr->method_name = ngx_http_lua_post_method;
+            break;
+
+        case NGX_HTTP_PUT:
+            sr->method_name = ngx_http_lua_put_method;
+            break;
+
+        case NGX_HTTP_HEAD:
+            sr->method_name = ngx_http_lua_head_method;
+            break;
+
+        case NGX_HTTP_DELETE:
+            sr->method_name = ngx_http_lua_delete_method;
+            break;
+
+        case NGX_HTTP_OPTIONS:
+            sr->method_name = ngx_http_lua_options_method;
+            break;
+
+        case NGX_HTTP_MKCOL:
+            sr->method_name = ngx_http_lua_mkcol_method;
+            break;
+
+        case NGX_HTTP_COPY:
+            sr->method_name = ngx_http_lua_copy_method;
+            break;
+
+        case NGX_HTTP_MOVE:
+            sr->method_name = ngx_http_lua_move_method;
+            break;
+
+        case NGX_HTTP_PROPFIND:
+            sr->method_name = ngx_http_lua_propfind_method;
+            break;
+
+        case NGX_HTTP_PROPPATCH:
+            sr->method_name = ngx_http_lua_proppatch_method;
+            break;
+
+        case NGX_HTTP_LOCK:
+            sr->method_name = ngx_http_lua_lock_method;
+            break;
+
+        case NGX_HTTP_UNLOCK:
+            sr->method_name = ngx_http_lua_unlock_method;
+            break;
+
+        case NGX_HTTP_PATCH:
+            sr->method_name = ngx_http_lua_patch_method;
+            break;
+
+        case NGX_HTTP_TRACE:
+            sr->method_name = ngx_http_lua_trace_method;
+            break;
+
+        default:
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "unsupported HTTP method: %u", (unsigned) method);
+
+            return NGX_ERROR;
+    }
+
+    /* XXX work-around a bug in ngx_http_subrequest */
+    if (r->headers_in.headers.last == &r->headers_in.headers.part) {
+        sr->headers_in.headers.last = &sr->headers_in.headers.part;
+    }
+
+    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {
+        /* we do not inherit the parent request's variables */
+        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);
+
+        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);
+
+        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {
+
+            sr->variables = ngx_palloc(sr->pool, size);
+            if (sr->variables == NULL) {
+                return NGX_ERROR;
+            }
+
+            ngx_memcpy(sr->variables, r->variables, size);
+
+        } else {
+
+            /* we do not inherit the parent request's variables */
+
+            sr->variables = ngx_pcalloc(sr->pool, size);
+            if (sr->variables == NULL) {
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);
+}
+
+
+static ngx_int_t
+ngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *sr,
+   ngx_array_t *extra_vars)
+{
+    ngx_http_core_main_conf_t   *cmcf;
+    ngx_http_variable_t         *v;
+    ngx_http_variable_value_t   *vv;
+    u_char                      *val;
+    u_char                      *p;
+    ngx_uint_t                   i, hash;
+    ngx_str_t                    name;
+    size_t                       len;
+    ngx_hash_t                  *variables_hash;
+    ngx_keyval_t                *var;
+
+    /* set any extra variables that were passed to the subrequest */
+
+    if (extra_vars == NULL || extra_vars->nelts == 0) {
+        return NGX_OK;
+    }
+
+    cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);
+
+    variables_hash = &cmcf->variables_hash;
+
+    var = extra_vars->elts;
+
+    for (i = 0; i < extra_vars->nelts; i++, var++) {
+        /* copy the variable's name and value because they are allocated
+         * by the lua VM */
+
+        len = var->key.len + var->value.len;
+
+        p = ngx_pnalloc(sr->pool, len);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        name.data = p;
+        name.len = var->key.len;
+
+        p = ngx_copy(p, var->key.data, var->key.len);
+
+        hash = ngx_hash_strlow(name.data, name.data, name.len);
+
+        val = p;
+        len = var->value.len;
+
+        ngx_memcpy(p, var->value.data, len);
+
+        v = ngx_hash_find(variables_hash, hash, name.data, name.len);
+
+        if (v) {
+            if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {
+                ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,
+                              "variable \"%V\" not changeable", &name);
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            if (v->set_handler) {
+                vv = ngx_palloc(sr->pool, sizeof(ngx_http_variable_value_t));
+                if (vv == NULL) {
+                    return NGX_ERROR;
+                }
+
+                vv->valid = 1;
+                vv->not_found = 0;
+                vv->no_cacheable = 0;
+
+                vv->data = val;
+                vv->len = len;
+
+                v->set_handler(sr, vv, v->data);
+
+                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,
+                               "variable \"%V\" set to value \"%v\"", &name,
+                               vv);
+
+                continue;
+            }
+
+            if (v->flags & NGX_HTTP_VAR_INDEXED) {
+                vv = &sr->variables[v->index];
+
+                vv->valid = 1;
+                vv->not_found = 0;
+                vv->no_cacheable = 0;
+
+                vv->data = val;
+                vv->len = len;
+
+                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,
+                               "variable \"%V\" set to value \"%v\"",
+                               &name, vv);
+
+                continue;
+            }
+        }
+
+        ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,
+                      "variable \"%V\" cannot be assigned a value (maybe you "
+                      "forgot to define it first?) ", &name);
+
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_process_vars_option(ngx_http_request_t *r, lua_State *L,
+    int table, ngx_array_t **varsp)
+{
+    ngx_array_t         *vars;
+    ngx_keyval_t        *var;
+
+    if (table < 0) {
+        table = lua_gettop(L) + table + 1;
+    }
+
+    vars = *varsp;
+
+    if (vars == NULL) {
+
+        vars = ngx_array_create(r->pool, 4, sizeof(ngx_keyval_t));
+        if (vars == NULL) {
+            dd("here");
+            luaL_error(L, "out of memory");
+            return;
+        }
+
+        *varsp = vars;
+    }
+
+    lua_pushnil(L);
+    while (lua_next(L, table) != 0) {
+
+        if (lua_type(L, -2) != LUA_TSTRING) {
+            luaL_error(L, "attempt to use a non-string key in the "
+                       "\"vars\" option table");
+            return;
+        }
+
+        if (!lua_isstring(L, -1)) {
+            luaL_error(L, "attempt to use bad variable value type %s",
+                       luaL_typename(L, -1));
+        }
+
+        var = ngx_array_push(vars);
+        if (var == NULL) {
+            dd("here");
+            luaL_error(L, "out of memory");
+            return;
+        }
+
+        var->key.data = (u_char *) lua_tolstring(L, -2, &var->key.len);
+        var->value.data = (u_char *) lua_tolstring(L, -1, &var->value.len);
+
+        lua_pop(L, 1);
+    }
+}
+
+
+ngx_int_t
+ngx_http_lua_post_subrequest(ngx_http_request_t *r, void *data, ngx_int_t rc)
+{
+    ngx_http_request_t            *pr;
+    ngx_http_lua_ctx_t            *pr_ctx;
+    ngx_http_lua_ctx_t            *ctx; /* subrequest ctx */
+    ngx_http_lua_co_ctx_t         *pr_coctx;
+    size_t                         len;
+    ngx_str_t                     *body_str;
+    u_char                        *p;
+    ngx_chain_t                   *cl;
+
+    ngx_http_lua_post_subrequest_data_t    *psr_data = data;
+
+    ctx = psr_data->ctx;
+
+    if (ctx->run_post_subrequest) {
+        if (r != r->connection->data) {
+            r->connection->data = r;
+        }
+
+        return NGX_OK;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run post subrequest handler, rc:%i c:%ud", rc,
+                   r->main->count);
+
+    ctx->run_post_subrequest = 1;
+
+    pr = r->parent;
+
+    pr_ctx = ngx_http_get_module_ctx(pr, ngx_http_lua_module);
+    if (pr_ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    pr_coctx = psr_data->pr_co_ctx;
+    pr_coctx->pending_subreqs--;
+
+    if (pr_coctx->pending_subreqs == 0) {
+        dd("all subrequests are done");
+
+        pr_ctx->no_abort = 0;
+        pr_ctx->resume_handler = ngx_http_lua_subrequest_resume;
+        pr_ctx->cur_co_ctx = pr_coctx;
+    }
+
+    if (pr_ctx->entered_content_phase) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua restoring write event handler");
+
+        pr->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        pr->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    dd("status rc = %d", (int) rc);
+    dd("status headers_out.status = %d", (int) r->headers_out.status);
+    dd("uri: %.*s", (int) r->uri.len, r->uri.data);
+
+    /*  capture subrequest response status */
+
+    pr_coctx->sr_statuses[ctx->index] = r->headers_out.status;
+
+    if (pr_coctx->sr_statuses[ctx->index] == 0) {
+        if (rc == NGX_OK) {
+            rc = NGX_HTTP_OK;
+        }
+
+        if (rc == NGX_ERROR) {
+            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            pr_coctx->sr_statuses[ctx->index] = rc;
+        }
+    }
+
+    if (!ctx->seen_last_for_subreq) {
+        pr_coctx->sr_flags[ctx->index] |= NGX_HTTP_LUA_SUBREQ_TRUNCATED;
+    }
+
+    dd("pr_coctx status: %d", (int) pr_coctx->sr_statuses[ctx->index]);
+
+    /* copy subrequest response headers */
+
+    pr_coctx->sr_headers[ctx->index] = &r->headers_out;
+
+    /* copy subrequest response body */
+
+    body_str = &pr_coctx->sr_bodies[ctx->index];
+
+    len = 0;
+    for (cl = ctx->body; cl; cl = cl->next) {
+        /*  ignore all non-memory buffers */
+        len += cl->buf->last - cl->buf->pos;
+    }
+
+    body_str->len = len;
+
+    if (len == 0) {
+        body_str->data = NULL;
+
+    } else {
+        p = ngx_palloc(r->pool, len);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        body_str->data = p;
+
+        /* copy from and then free the data buffers */
+
+        for (cl = ctx->body; cl; cl = cl->next) {
+            p = ngx_copy(p, cl->buf->pos, cl->buf->last - cl->buf->pos);
+
+            cl->buf->last = cl->buf->pos;
+
+#if 0
+            dd("free body chain link buf ASAP");
+            ngx_pfree(r->pool, cl->buf->start);
+#endif
+        }
+    }
+
+    if (ctx->body) {
+
+#if defined(nginx_version) && nginx_version >= 1001004
+        ngx_chain_update_chains(r->pool,
+#else
+        ngx_chain_update_chains(
+#endif
+                                &pr_ctx->free_bufs, &pr_ctx->busy_bufs,
+                                &ctx->body,
+                                (ngx_buf_tag_t) &ngx_http_lua_module);
+
+        dd("free bufs: %p", pr_ctx->free_bufs);
+    }
+
+    ngx_http_post_request_to_head(pr);
+
+    if (r != r->connection->data) {
+        r->connection->data = r;
+    }
+
+    if (rc == NGX_ERROR
+        || rc == NGX_HTTP_CREATED
+        || rc == NGX_HTTP_NO_CONTENT
+        || (rc >= NGX_HTTP_SPECIAL_RESPONSE
+            && rc != NGX_HTTP_CLOSE
+            && rc != NGX_HTTP_REQUEST_TIME_OUT
+            && rc != NGX_HTTP_CLIENT_CLOSED_REQUEST))
+    {
+        /* emulate ngx_http_special_response_handler */
+
+        if (rc > NGX_OK) {
+            r->err_status = rc;
+
+            r->expect_tested = 1;
+            r->headers_out.content_type.len = 0;
+            r->headers_out.content_length_n = 0;
+
+            ngx_http_clear_accept_ranges(r);
+            ngx_http_clear_last_modified(r);
+
+            rc = ngx_http_send_header(r);
+
+            if (rc == NGX_ERROR) {
+                return NGX_ERROR;
+            }
+        }
+
+        return NGX_OK;
+    }
+
+    return rc;
+}
+
+
+static ngx_int_t
+ngx_http_lua_set_content_length_header(ngx_http_request_t *r, off_t len)
+{
+    ngx_table_elt_t                 *h, *header;
+    u_char                          *p;
+    ngx_list_part_t                 *part;
+    ngx_http_request_t              *pr;
+    ngx_uint_t                       i;
+
+    r->headers_in.content_length_n = len;
+
+    if (ngx_list_init(&r->headers_in.headers, r->pool, 20,
+                      sizeof(ngx_table_elt_t)) != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+    h = ngx_list_push(&r->headers_in.headers);
+    if (h == NULL) {
+        return NGX_ERROR;
+    }
+
+    h->key = ngx_http_lua_content_length_header_key;
+    h->lowcase_key = ngx_pnalloc(r->pool, h->key.len);
+    if (h->lowcase_key == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
+
+    r->headers_in.content_length = h;
+
+    p = ngx_palloc(r->pool, NGX_OFF_T_LEN);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    h->value.data = p;
+
+    h->value.len = ngx_sprintf(h->value.data, "%O", len) - h->value.data;
+
+    h->hash = ngx_http_lua_content_length_hash;
+
+#if 0
+    dd("content length hash: %lu == %lu", (unsigned long) h->hash,
+       ngx_hash_key_lc((u_char *) "Content-Length",
+       sizeof("Content-Length") - 1));
+#endif
+
+    dd("r content length: %.*s",
+       (int)r->headers_in.content_length->value.len,
+       r->headers_in.content_length->value.data);
+
+    pr = r->parent;
+
+    if (pr == NULL) {
+        return NGX_OK;
+    }
+
+    /* forward the parent request's all other request headers */
+
+    part = &pr->headers_in.headers.part;
+    header = part->elts;
+
+    for (i = 0; /* void */; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            header = part->elts;
+            i = 0;
+        }
+
+        if (header[i].key.len == sizeof("Content-Length") - 1
+            && ngx_strncasecmp(header[i].key.data, (u_char *) "Content-Length",
+                               sizeof("Content-Length") - 1) == 0)
+        {
+            continue;
+        }
+
+        h = ngx_list_push(&r->headers_in.headers);
+        if (h == NULL) {
+            return NGX_ERROR;
+        }
+
+        *h = header[i];
+    }
+
+    /* XXX maybe we should set those built-in header slot in
+     * ngx_http_headers_in_t too? */
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_handle_subreq_responses(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_uint_t                   i;
+    ngx_uint_t                   index;
+    lua_State                   *co;
+    ngx_str_t                   *body_str;
+    ngx_table_elt_t             *header;
+    ngx_list_part_t             *part;
+    ngx_http_headers_out_t      *sr_headers;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    u_char                  buf[sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1];
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua handle subrequest responses");
+
+    coctx = ctx->cur_co_ctx;
+    co = coctx->co;
+
+    for (index = 0; index < coctx->nsubreqs; index++) {
+        dd("summary: reqs %d, subquery %d, pending %d, req %.*s",
+           (int) coctx->nsubreqs,
+           (int) index,
+           (int) coctx->pending_subreqs,
+           (int) r->uri.len, r->uri.data);
+
+        /*  {{{ construct ret value */
+        lua_newtable(co);
+
+        /*  copy captured status */
+        lua_pushinteger(co, coctx->sr_statuses[index]);
+        lua_setfield(co, -2, "status");
+
+        dd("captured subrequest flags: %d", (int) coctx->sr_flags[index]);
+
+        /* set truncated flag if truncation happens */
+        if (coctx->sr_flags[index] & NGX_HTTP_LUA_SUBREQ_TRUNCATED) {
+            lua_pushboolean(co, 1);
+            lua_setfield(co, -2, "truncated");
+
+        } else {
+            lua_pushboolean(co, 0);
+            lua_setfield(co, -2, "truncated");
+        }
+
+        /*  copy captured body */
+
+        body_str = &coctx->sr_bodies[index];
+
+        lua_pushlstring(co, (char *) body_str->data, body_str->len);
+        lua_setfield(co, -2, "body");
+
+        if (body_str->data) {
+            dd("free body buffer ASAP");
+            ngx_pfree(r->pool, body_str->data);
+        }
+
+        /* copy captured headers */
+
+        lua_newtable(co); /* res.header */
+
+        sr_headers = coctx->sr_headers[index];
+
+        dd("saving subrequest response headers");
+
+        part = &sr_headers->headers.part;
+        header = part->elts;
+
+        for (i = 0; /* void */; i++) {
+
+            if (i >= part->nelts) {
+                if (part->next == NULL) {
+                    break;
+                }
+
+                part = part->next;
+                header = part->elts;
+                i = 0;
+            }
+
+            dd("checking sr header %.*s", (int) header[i].key.len,
+                    header[i].key.data);
+
+#if 1
+            if (header[i].hash == 0) {
+                continue;
+            }
+#endif
+
+            header[i].hash = 0;
+
+            dd("pushing sr header %.*s", (int) header[i].key.len,
+                    header[i].key.data);
+
+            lua_pushlstring(co, (char *) header[i].key.data,
+                            header[i].key.len); /* header key */
+            lua_pushvalue(co, -1); /* stack: table key key */
+
+            /* check if header already exists */
+            lua_rawget(co, -3); /* stack: table key value */
+
+            if (lua_isnil(co, -1)) {
+                lua_pop(co, 1); /* stack: table key */
+
+                lua_pushlstring(co, (char *) header[i].value.data,
+                                header[i].value.len);
+                    /* stack: table key value */
+
+                lua_rawset(co, -3); /* stack: table */
+
+            } else {
+
+                if (!lua_istable(co, -1)) { /* already inserted one value */
+                    lua_createtable(co, 4, 0);
+                        /* stack: table key value table */
+
+                    lua_insert(co, -2); /* stack: table key table value */
+                    lua_rawseti(co, -2, 1); /* stack: table key table */
+
+                    lua_pushlstring(co, (char *) header[i].value.data,
+                                    header[i].value.len);
+                        /* stack: table key table value */
+
+                    lua_rawseti(co, -2, lua_objlen(co, -2) + 1);
+                        /* stack: table key table */
+
+                    lua_rawset(co, -3); /* stack: table */
+
+                } else {
+                    lua_pushlstring(co, (char *) header[i].value.data,
+                                    header[i].value.len);
+                        /* stack: table key table value */
+
+                    lua_rawseti(co, -2, lua_objlen(co, -2) + 1);
+                        /* stack: table key table */
+
+                    lua_pop(co, 2); /* stack: table */
+                }
+            }
+        }
+
+        if (sr_headers->content_type.len) {
+            lua_pushliteral(co, "Content-Type"); /* header key */
+            lua_pushlstring(co, (char *) sr_headers->content_type.data,
+                            sr_headers->content_type.len); /* head key value */
+            lua_rawset(co, -3); /* head */
+        }
+
+        if (sr_headers->content_length == NULL
+            && sr_headers->content_length_n >= 0)
+        {
+            lua_pushliteral(co, "Content-Length"); /* header key */
+
+            lua_pushnumber(co, (lua_Number) sr_headers->content_length_n);
+                /* head key value */
+
+            lua_rawset(co, -3); /* head */
+        }
+
+        /* to work-around an issue in ngx_http_static_module
+         * (github issue #41) */
+        if (sr_headers->location && sr_headers->location->value.len) {
+            lua_pushliteral(co, "Location"); /* header key */
+            lua_pushlstring(co, (char *) sr_headers->location->value.data,
+                            sr_headers->location->value.len);
+            /* head key value */
+            lua_rawset(co, -3); /* head */
+        }
+
+        if (sr_headers->last_modified_time != -1) {
+            if (sr_headers->status != NGX_HTTP_OK
+                && sr_headers->status != NGX_HTTP_PARTIAL_CONTENT
+                && sr_headers->status != NGX_HTTP_NOT_MODIFIED
+                && sr_headers->status != NGX_HTTP_NO_CONTENT)
+            {
+                sr_headers->last_modified_time = -1;
+                sr_headers->last_modified = NULL;
+            }
+        }
+
+        if (sr_headers->last_modified == NULL
+            && sr_headers->last_modified_time != -1)
+        {
+            (void) ngx_http_time(buf, sr_headers->last_modified_time);
+
+            lua_pushliteral(co, "Last-Modified"); /* header key */
+            lua_pushlstring(co, (char *) buf, sizeof(buf)); /* head key value */
+            lua_rawset(co, -3); /* head */
+        }
+
+        lua_setfield(co, -2, "header");
+
+        /*  }}} */
+    }
+}
+
+
+void
+ngx_http_lua_inject_subrequest_api(lua_State *L)
+{
+    lua_createtable(L, 0 /* narr */, 2 /* nrec */); /* .location */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_location_capture);
+    lua_setfield(L, -2, "capture");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_location_capture_multi);
+    lua_setfield(L, -2, "capture_multi");
+
+    lua_setfield(L, -2, "location");
+}
+
+
+static ngx_int_t
+ngx_http_lua_subrequest(ngx_http_request_t *r,
+    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,
+    ngx_http_post_subrequest_t *ps, ngx_uint_t flags)
+{
+    ngx_time_t                    *tp;
+    ngx_connection_t              *c;
+    ngx_http_request_t            *sr;
+    ngx_http_core_srv_conf_t      *cscf;
+
+    r->main->subrequests--;
+
+    if (r->main->subrequests == 0) {
+#if defined(NGX_DTRACE) && NGX_DTRACE
+        ngx_http_probe_subrequest_cycle(r, uri, args);
+#endif
+
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "subrequests cycle while processing \"%V\"", uri);
+        r->main->subrequests = 1;
+        return NGX_ERROR;
+    }
+
+    sr = ngx_pcalloc(r->pool, sizeof(ngx_http_request_t));
+    if (sr == NULL) {
+        return NGX_ERROR;
+    }
+
+    sr->signature = NGX_HTTP_MODULE;
+
+    c = r->connection;
+    sr->connection = c;
+
+    sr->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);
+    if (sr->ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    if (ngx_list_init(&sr->headers_out.headers, r->pool, 20,
+                      sizeof(ngx_table_elt_t))
+        != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
+    sr->main_conf = cscf->ctx->main_conf;
+    sr->srv_conf = cscf->ctx->srv_conf;
+    sr->loc_conf = cscf->ctx->loc_conf;
+
+    sr->pool = r->pool;
+
+    sr->headers_in = r->headers_in;
+
+    ngx_http_clear_content_length(sr);
+    ngx_http_clear_accept_ranges(sr);
+    ngx_http_clear_last_modified(sr);
+
+    sr->request_body = r->request_body;
+
+#ifdef HAVE_ALLOW_REQUEST_BODY_UPDATING_PATCH
+    sr->content_length_n = -1;
+#endif
+
+    sr->method = NGX_HTTP_GET;
+    sr->http_version = r->http_version;
+
+    sr->request_line = r->request_line;
+    sr->uri = *uri;
+
+    if (args) {
+        sr->args = *args;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "http subrequest \"%V?%V\"", uri, &sr->args);
+
+    sr->subrequest_in_memory = (flags & NGX_HTTP_SUBREQUEST_IN_MEMORY) != 0;
+    sr->waited = (flags & NGX_HTTP_SUBREQUEST_WAITED) != 0;
+
+    sr->unparsed_uri = r->unparsed_uri;
+    sr->method_name = ngx_http_core_get_method;
+    sr->http_protocol = r->http_protocol;
+
+    ngx_http_set_exten(sr);
+
+    sr->main = r->main;
+    sr->parent = r;
+    sr->post_subrequest = ps;
+    sr->read_event_handler = ngx_http_request_empty_handler;
+    sr->write_event_handler = ngx_http_handler;
+
+    sr->variables = r->variables;
+
+    sr->log_handler = r->log_handler;
+
+    sr->internal = 1;
+
+    sr->discard_body = r->discard_body;
+    sr->expect_tested = 1;
+    sr->main_filter_need_in_memory = r->main_filter_need_in_memory;
+
+    sr->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1;
+
+    tp = ngx_timeofday();
+    sr->start_sec = tp->sec;
+    sr->start_msec = tp->msec;
+
+    r->main->count++;
+
+    *psr = sr;
+
+#if defined(NGX_DTRACE) && NGX_DTRACE
+    ngx_http_probe_subrequest_start(sr);
+#endif
+
+    return ngx_http_post_request(sr, NULL);
+}
+
+
+static ngx_int_t
+ngx_http_lua_subrequest_resume(ngx_http_request_t *r)
+{
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run subrequests done, resuming lua thread");
+
+    coctx = ctx->cur_co_ctx;
+
+    dd("nsubreqs: %d", (int) coctx->nsubreqs);
+
+    ngx_http_lua_handle_subreq_responses(r, ctx);
+
+    dd("free sr_statues/headers/bodies memory ASAP");
+
+#if 1
+    ngx_pfree(r->pool, coctx->sr_statuses);
+
+    coctx->sr_statuses = NULL;
+    coctx->sr_headers = NULL;
+    coctx->sr_bodies = NULL;
+    coctx->sr_flags = NULL;
+#endif
+
+    c = r->connection;
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, coctx->nsubreqs);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    /* rc == NGX_ERROR || rc >= NGX_OK */
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
+static void
+ngx_http_lua_cancel_subreq(ngx_http_request_t *r)
+{
+    ngx_http_posted_request_t   *pr;
+    ngx_http_posted_request_t  **p;
+
+#if 1
+    r->main->count--;
+    r->main->subrequests++;
+#endif
+
+    p = &r->main->posted_requests;
+    for (pr = r->main->posted_requests; pr->next; pr = pr->next) {
+        p = &pr->next;
+    }
+
+    *p = NULL;
+
+    r->connection->data = r->parent;
+}
+
+
+static ngx_int_t
+ngx_http_post_request_to_head(ngx_http_request_t *r)
+{
+    ngx_http_posted_request_t  *pr;
+
+    pr = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t));
+    if (pr == NULL) {
+        return NGX_ERROR;
+    }
+
+    pr->request = r;
+    pr->next = r->main->posted_requests;
+    r->main->posted_requests = pr;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r)
+{
+    ngx_temp_file_t     *tf;
+
+    ngx_http_request_body_t   *body;
+
+    tf = r->request_body->temp_file;
+
+    if (!tf->persistent || !tf->clean) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "the request body was not read by ngx_lua");
+
+        return NGX_ERROR;
+    }
+
+    body = ngx_palloc(r->pool, sizeof(ngx_http_request_body_t));
+    if (body == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(body, r->request_body, sizeof(ngx_http_request_body_t));
+
+    body->temp_file = ngx_palloc(r->pool, sizeof(ngx_temp_file_t));
+    if (body->temp_file == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(body->temp_file, tf, sizeof(ngx_temp_file_t));
+    dd("file fd: %d", body->temp_file->file.fd);
+
+    r->request_body = body;
+
+    return NGX_OK;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.h b/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_subrequest.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,46 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_SUBREQUEST_H_INCLUDED_
+#define _NGX_HTTP_LUA_SUBREQUEST_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_subrequest_api(lua_State *L);
+ngx_int_t ngx_http_lua_post_subrequest(ngx_http_request_t *r, void *data,
+    ngx_int_t rc);
+
+
+extern ngx_str_t  ngx_http_lua_get_method;
+extern ngx_str_t  ngx_http_lua_put_method;
+extern ngx_str_t  ngx_http_lua_post_method;
+extern ngx_str_t  ngx_http_lua_head_method;
+extern ngx_str_t  ngx_http_lua_delete_method;
+extern ngx_str_t  ngx_http_lua_options_method;
+extern ngx_str_t  ngx_http_lua_copy_method;
+extern ngx_str_t  ngx_http_lua_move_method;
+extern ngx_str_t  ngx_http_lua_lock_method;
+extern ngx_str_t  ngx_http_lua_mkcol_method;
+extern ngx_str_t  ngx_http_lua_propfind_method;
+extern ngx_str_t  ngx_http_lua_proppatch_method;
+extern ngx_str_t  ngx_http_lua_unlock_method;
+extern ngx_str_t  ngx_http_lua_patch_method;
+extern ngx_str_t  ngx_http_lua_trace_method;
+
+
+typedef struct ngx_http_lua_post_subrequest_data_s {
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *pr_co_ctx;
+
+} ngx_http_lua_post_subrequest_data_t;
+
+
+#endif /* _NGX_HTTP_LUA_SUBREQUEST_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_time.c b/src/lua/lua-nginx-module/src/ngx_http_lua_time.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_time.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_time.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,250 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_time.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_ngx_today(lua_State *L);
+static int ngx_http_lua_ngx_time(lua_State *L);
+static int ngx_http_lua_ngx_now(lua_State *L);
+static int ngx_http_lua_ngx_localtime(lua_State *L);
+static int ngx_http_lua_ngx_utctime(lua_State *L);
+static int ngx_http_lua_ngx_cookie_time(lua_State *L);
+static int ngx_http_lua_ngx_http_time(lua_State *L);
+static int ngx_http_lua_ngx_parse_http_time(lua_State *L);
+static int ngx_http_lua_ngx_update_time(lua_State *L);
+static int ngx_http_lua_ngx_req_start_time(lua_State *L);
+
+
+static int
+ngx_http_lua_ngx_today(lua_State *L)
+{
+    time_t                   now;
+    ngx_tm_t                 tm;
+    u_char                   buf[sizeof("2010-11-19") - 1];
+
+    now = ngx_time();
+    ngx_gmtime(now + ngx_cached_time->gmtoff * 60, &tm);
+
+    ngx_sprintf(buf, "%04d-%02d-%02d", tm.ngx_tm_year, tm.ngx_tm_mon,
+                tm.ngx_tm_mday);
+
+    lua_pushlstring(L, (char *) buf, sizeof(buf));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_localtime(lua_State *L)
+{
+    ngx_tm_t                 tm;
+
+    u_char buf[sizeof("2010-11-19 20:56:31") - 1];
+
+    ngx_gmtime(ngx_time() + ngx_cached_time->gmtoff * 60, &tm);
+
+    ngx_sprintf(buf, "%04d-%02d-%02d %02d:%02d:%02d", tm.ngx_tm_year,
+                tm.ngx_tm_mon, tm.ngx_tm_mday, tm.ngx_tm_hour, tm.ngx_tm_min,
+                tm.ngx_tm_sec);
+
+    lua_pushlstring(L, (char *) buf, sizeof(buf));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_time(lua_State *L)
+{
+    lua_pushnumber(L, (lua_Number) ngx_time());
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_now(lua_State *L)
+{
+    ngx_time_t              *tp;
+
+    tp = ngx_timeofday();
+
+    lua_pushnumber(L, (lua_Number) (tp->sec + tp->msec / 1000.0L));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_update_time(lua_State *L)
+{
+    ngx_time_update();
+    return 0;
+}
+
+
+static int
+ngx_http_lua_ngx_utctime(lua_State *L)
+{
+    ngx_tm_t       tm;
+    u_char         buf[sizeof("2010-11-19 20:56:31") - 1];
+
+    ngx_gmtime(ngx_time(), &tm);
+
+    ngx_sprintf(buf, "%04d-%02d-%02d %02d:%02d:%02d", tm.ngx_tm_year,
+                tm.ngx_tm_mon, tm.ngx_tm_mday, tm.ngx_tm_hour, tm.ngx_tm_min,
+                tm.ngx_tm_sec);
+
+    lua_pushlstring(L, (char *) buf, sizeof(buf));
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_cookie_time(lua_State *L)
+{
+    time_t                               t;
+    u_char                              *p;
+
+    u_char   buf[sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1];
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    t = (time_t) luaL_checknumber(L, 1);
+
+    p = buf;
+    p = ngx_http_cookie_time(p, t);
+
+    lua_pushlstring(L, (char *) buf, p - buf);
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_http_time(lua_State *L)
+{
+    time_t                               t;
+    u_char                              *p;
+
+    u_char   buf[sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1];
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    t = (time_t) luaL_checknumber(L, 1);
+
+    p = buf;
+    p = ngx_http_time(p, t);
+
+    lua_pushlstring(L, (char *) buf, p - buf);
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_parse_http_time(lua_State *L)
+{
+    u_char                              *p;
+    size_t                               len;
+    time_t                               time;
+
+    if (lua_gettop(L) != 1) {
+        return luaL_error(L, "expecting one argument");
+    }
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    time = ngx_http_parse_time(p, len);
+    if (time == NGX_ERROR) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    lua_pushnumber(L, (lua_Number) time);
+
+    return 1;
+}
+
+
+static int
+ngx_http_lua_ngx_req_start_time(lua_State *L)
+{
+    ngx_http_request_t  *r;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    lua_pushnumber(L, (lua_Number) (r->start_sec + r->start_msec / 1000.0L));
+    return 1;
+}
+
+
+void
+ngx_http_lua_inject_time_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_utctime);
+    lua_setfield(L, -2, "utctime");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_time);
+    lua_setfield(L, -2, "get_now_ts"); /* deprecated */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_localtime);
+    lua_setfield(L, -2, "get_now"); /* deprecated */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_localtime);
+    lua_setfield(L, -2, "localtime");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_time);
+    lua_setfield(L, -2, "time");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_now);
+    lua_setfield(L, -2, "now");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_update_time);
+    lua_setfield(L, -2, "update_time");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_today);
+    lua_setfield(L, -2, "get_today"); /* deprecated */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_today);
+    lua_setfield(L, -2, "today");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_cookie_time);
+    lua_setfield(L, -2, "cookie_time");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_http_time);
+    lua_setfield(L, -2, "http_time");
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_parse_http_time);
+    lua_setfield(L, -2, "parse_http_time");
+}
+
+
+void
+ngx_http_lua_inject_req_time_api(lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_start_time);
+    lua_setfield(L, -2, "start_time");
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_time.h b/src/lua/lua-nginx-module/src/ngx_http_lua_time.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_time.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_time.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,21 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_TIME_H_INCLUDED_
+#define _NGX_HTTP_LUA_TIME_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_time_api(lua_State *L);
+void ngx_http_lua_inject_req_time_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_TIME_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_timer.c b/src/lua/lua-nginx-module/src/ngx_http_lua_timer.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_timer.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_timer.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,646 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_timer.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_probe.h"
+
+
+typedef struct {
+    unsigned      premature;  /* :1 */
+
+    int           co_ref;
+    lua_State    *co;
+
+    void        **main_conf;
+    void        **srv_conf;
+    void        **loc_conf;
+
+    ngx_http_lua_main_conf_t    *lmcf;
+} ngx_http_lua_timer_ctx_t;
+
+
+static int ngx_http_lua_ngx_timer_at(lua_State *L);
+static void ngx_http_lua_timer_handler(ngx_event_t *ev);
+static u_char * ngx_http_lua_log_timer_error(ngx_log_t *log, u_char *buf,
+    size_t len);
+static void ngx_http_lua_abort_pending_timers(ngx_event_t *ev);
+
+
+void
+ngx_http_lua_inject_timer_api(lua_State *L)
+{
+    lua_createtable(L, 0 /* narr */, 1 /* nrec */);    /* ngx.timer. */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_timer_at);
+    lua_setfield(L, -2, "at");
+
+    lua_setfield(L, -2, "timer");
+}
+
+
+static int
+ngx_http_lua_ngx_timer_at(lua_State *L)
+{
+    int                      nargs, co_ref;
+    u_char                  *p;
+    lua_State               *mt;  /* the main thread */
+    lua_State               *co;
+    ngx_msec_t               delay;
+    ngx_event_t             *ev;
+    ngx_http_request_t      *r;
+    ngx_connection_t        *saved_c = NULL;
+#if 0
+    ngx_http_connection_t   *hc;
+#endif
+
+    ngx_http_lua_timer_ctx_t      *tctx;
+    ngx_http_lua_main_conf_t      *lmcf;
+#if 0
+    ngx_http_core_main_conf_t     *cmcf;
+#endif
+
+    nargs = lua_gettop(L);
+    if (nargs < 2) {
+        return luaL_error(L, "expecting at least 2 arguments but got %d",
+                          nargs);
+    }
+
+    delay = (ngx_msec_t) (luaL_checknumber(L, 1) * 1000);
+
+    luaL_argcheck(L, lua_isfunction(L, 2) && !lua_iscfunction(L, 2), 2,
+                 "Lua function expected");
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request");
+    }
+
+    if (ngx_exiting) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "process exiting");
+        return 2;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    if (lmcf->pending_timers >= lmcf->max_pending_timers) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "too many pending timers");
+        return 2;
+    }
+
+    if (lmcf->watcher == NULL) {
+        /* create the watcher fake connection */
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
+                       "lua creating fake watcher connection");
+
+        if (ngx_cycle->files) {
+            saved_c = ngx_cycle->files[0];
+        }
+
+        lmcf->watcher = ngx_get_connection(0, ngx_cycle->log);
+
+        if (ngx_cycle->files) {
+            ngx_cycle->files[0] = saved_c;
+        }
+
+        if (lmcf->watcher == NULL) {
+            return luaL_error(L, "no memory");
+        }
+
+        /* to work around the -1 check in ngx_worker_process_cycle: */
+        lmcf->watcher->fd = (ngx_socket_t) -2;
+
+        lmcf->watcher->idle = 1;
+        lmcf->watcher->read->handler = ngx_http_lua_abort_pending_timers;
+        lmcf->watcher->data = lmcf;
+    }
+
+    mt = lmcf->lua;
+
+    co = lua_newthread(mt);
+
+    /* L stack: time func [args] thread */
+
+    ngx_http_lua_probe_user_coroutine_create(r, L, co);
+
+    lua_createtable(co, 0, 0);  /* the new global table */
+
+    /* co stack: global_tb */
+
+    lua_createtable(co, 0, 1);  /* the metatable */
+    lua_pushvalue(co, LUA_GLOBALSINDEX);
+    lua_setfield(co, -2, "__index");
+    lua_setmetatable(co, -2);
+
+    /* co stack: global_tb */
+
+    lua_replace(co, LUA_GLOBALSINDEX);
+
+    /* co stack: <empty> */
+
+    dd("stack top: %d", lua_gettop(L));
+
+    lua_xmove(mt, L, 1);    /* move coroutine from main thread to L */
+
+    /* L stack: time func [args] thread */
+    /* mt stack: empty */
+
+    lua_pushvalue(L, 2);    /* copy entry function to top of L*/
+
+    /* L stack: time func [args] thread func */
+
+    lua_xmove(L, co, 1);    /* move entry function from L to co */
+
+    /* L stack: time func [args] thread */
+    /* co stack: func */
+
+    lua_pushvalue(co, LUA_GLOBALSINDEX);
+    lua_setfenv(co, -2);
+
+    /* co stack: func */
+
+    lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+
+    /* L stack: time func [args] thread corountines */
+
+    lua_pushvalue(L, -2);
+
+    /* L stack: time func [args] thread coroutines thread */
+
+    co_ref = luaL_ref(L, -2);
+    lua_pop(L, 1);
+
+    /* L stack: time func [args] thread */
+
+    if (nargs > 2) {
+        lua_pop(L, 1);  /* L stack: time func [args] */
+        lua_xmove(L, co, nargs - 2);  /* L stack: time func */
+
+        /* co stack: func [args] */
+    }
+
+    p = ngx_alloc(sizeof(ngx_event_t) + sizeof(ngx_http_lua_timer_ctx_t),
+                  r->connection->log);
+    if (p == NULL) {
+        lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+        lua_rawget(L, LUA_REGISTRYINDEX);
+        luaL_unref(L, -1, co_ref);
+        return luaL_error(L, "no memory");
+    }
+
+    ev = (ngx_event_t *) p;
+
+    ngx_memzero(ev, sizeof(ngx_event_t));
+
+    p += sizeof(ngx_event_t);
+
+    tctx = (ngx_http_lua_timer_ctx_t *) p;
+
+    tctx->premature = 0;
+    tctx->co_ref = co_ref;
+    tctx->co = co;
+    tctx->main_conf = r->main_conf;
+    tctx->srv_conf = r->srv_conf;
+    tctx->loc_conf = r->loc_conf;
+    tctx->lmcf = lmcf;
+
+    ev->handler = ngx_http_lua_timer_handler;
+    ev->data = tctx;
+    ev->log = ngx_cycle->log;
+
+    lmcf->pending_timers++;
+
+    ngx_add_timer(ev, delay);
+
+    lua_pushinteger(L, 1);
+    return 1;
+}
+
+
+static void
+ngx_http_lua_timer_handler(ngx_event_t *ev)
+{
+    int                      n;
+    lua_State               *L;
+    ngx_int_t                rc;
+    ngx_log_t               *log;
+    ngx_connection_t        *c = NULL, *saved_c = NULL;
+    ngx_http_request_t      *r = NULL;
+    ngx_http_lua_ctx_t      *ctx;
+    ngx_http_cleanup_t      *cln;
+    ngx_http_log_ctx_t      *logctx;
+
+    ngx_http_lua_timer_ctx_t         tctx;
+    ngx_http_lua_main_conf_t        *lmcf;
+    ngx_http_core_loc_conf_t        *clcf;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
+                   "lua ngx.timer expired");
+
+    ngx_memcpy(&tctx, ev->data, sizeof(ngx_http_lua_timer_ctx_t));
+    ngx_free(ev);
+    ev = NULL;
+
+    lmcf = tctx.lmcf;
+
+    lmcf->pending_timers--;
+
+    if (lmcf->running_timers >= lmcf->max_running_timers) {
+        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
+                      "%i lua_max_running_timers are not enough",
+                      lmcf->max_running_timers);
+        goto abort;
+    }
+
+    /* create the fake connection (we temporarily use a valid fd (0) to make
+       ngx_get_connection happy) */
+
+    if (ngx_cycle->files) {
+        saved_c = ngx_cycle->files[0];
+    }
+
+    c = ngx_get_connection(0, ngx_cycle->log);
+
+    if (ngx_cycle->files) {
+        ngx_cycle->files[0] = saved_c;
+    }
+
+    if (c == NULL) {
+        goto abort;
+    }
+
+    c->fd = (ngx_socket_t) -1;
+
+    c->pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, c->log);
+    if (c->pool == NULL) {
+        goto abort;
+    }
+
+    log = ngx_pcalloc(c->pool, sizeof(ngx_log_t));
+    if (log == NULL) {
+        goto abort;
+    }
+
+    logctx = ngx_palloc(c->pool, sizeof(ngx_http_log_ctx_t));
+    if (logctx == NULL) {
+        goto abort;
+    }
+
+    dd("c pool allocated: %d", (int) (sizeof(ngx_log_t)
+       + sizeof(ngx_http_log_ctx_t) + sizeof(ngx_http_request_t)));
+
+    logctx->connection = c;
+    logctx->request = NULL;
+    logctx->current_request = NULL;
+
+    c->log = log;
+    c->log->connection = c->number;
+    c->log->handler = ngx_http_lua_log_timer_error;
+    c->log->data = logctx;
+    c->log->action = NULL;
+
+    c->log_error = NGX_ERROR_INFO;
+
+#if 0
+    c->buffer = ngx_create_temp_buf(c->pool, 2);
+    if (c->buffer == NULL) {
+        goto abort;
+    }
+
+    c->buffer->start[0] = CR;
+    c->buffer->start[1] = LF;
+#endif
+
+    /* create the fake request */
+
+    r = ngx_pcalloc(c->pool, sizeof(ngx_http_request_t));
+    if (r == NULL) {
+        goto abort;
+    }
+
+    c->requests++;
+    logctx->request = r;
+    logctx->current_request = r;
+
+    r->pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, c->log);
+    if (r->pool == NULL) {
+        goto abort;
+    }
+
+    dd("r pool allocated: %d", (int) (sizeof(ngx_http_lua_ctx_t)
+       + sizeof(void *) * ngx_http_max_module + sizeof(ngx_http_cleanup_t)));
+
+#if 0
+    hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));
+    if (hc == NULL) {
+        goto abort;
+    }
+
+    r->header_in = c->buffer;
+    r->header_end = c->buffer->start;
+
+    if (ngx_list_init(&r->headers_out.headers, r->pool, 0,
+                      sizeof(ngx_table_elt_t))
+        != NGX_OK)
+    {
+        goto abort;
+    }
+
+    if (ngx_list_init(&r->headers_in.headers, r->pool, 0,
+                      sizeof(ngx_table_elt_t))
+        != NGX_OK)
+    {
+        goto abort;
+    }
+#endif
+
+    r->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);
+    if (r->ctx == NULL) {
+        goto abort;
+    }
+
+#if 0
+    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+    r->variables = ngx_pcalloc(r->pool, cmcf->variables.nelts
+                                        * sizeof(ngx_http_variable_value_t));
+    if (r->variables == NULL) {
+        goto abort;
+    }
+#endif
+
+    ctx = ngx_http_lua_create_ctx(r);
+    if (ctx == NULL) {
+        goto abort;
+    }
+
+    r->headers_in.content_length_n = 0;
+    c->data = r;
+#if 0
+    hc->request = r;
+    r->http_connection = hc;
+#endif
+    r->signature = NGX_HTTP_MODULE;
+    r->connection = c;
+    r->main = r;
+    r->count = 1;
+
+    r->method = NGX_HTTP_UNKNOWN;
+
+    r->headers_in.keep_alive_n = -1;
+    r->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1;
+    r->subrequests = NGX_HTTP_MAX_SUBREQUESTS + 1;
+
+    r->http_state = NGX_HTTP_PROCESS_REQUEST_STATE;
+    r->discard_body = 1;
+
+    r->main_conf = tctx.main_conf;
+    r->srv_conf = tctx.srv_conf;
+    r->loc_conf = tctx.loc_conf;
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+    c->log->file = clcf->error_log->file;
+    if (!(c->log->log_level & NGX_LOG_DEBUG_CONNECTION)) {
+        c->log->log_level = clcf->error_log->log_level;
+    }
+
+    c->error = 1;
+
+    ctx->cur_co_ctx = &ctx->entry_co_ctx;
+
+    L = lmcf->lua;
+
+    cln = ngx_http_cleanup_add(r, 0);
+    if (cln == NULL) {
+        goto abort;
+    }
+
+    cln->handler = ngx_http_lua_request_cleanup_handler;
+    cln->data = ctx;
+    ctx->cleanup = &cln->handler;
+
+    ctx->entered_content_phase = 1;
+    ctx->context = NGX_HTTP_LUA_CONTEXT_TIMER;
+
+    r->read_event_handler = ngx_http_block_reading;
+
+    ctx->cur_co_ctx->co_ref = tctx.co_ref;
+    ctx->cur_co_ctx->co = tctx.co;
+    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+
+    dd("r connection: %p, log %p", r->connection, r->connection->log);
+
+    /*  save the request in coroutine globals table */
+    ngx_http_lua_set_req(tctx.co, r);
+
+    lmcf->running_timers++;
+
+    lua_pushboolean(tctx.co, tctx.premature);
+
+    n = lua_gettop(tctx.co);
+    if (n > 2) {
+        lua_insert(tctx.co, 2);
+    }
+
+    rc = ngx_http_lua_run_thread(L, r, ctx, n - 1);
+
+    dd("timer lua run thread: %d", (int) rc);
+
+    if (rc == NGX_ERROR || rc >= NGX_OK) {
+        /* do nothing */
+
+    } else if (rc == NGX_AGAIN) {
+        rc = ngx_http_lua_content_run_posted_threads(L, r, ctx, 0);
+
+    } else if (rc == NGX_DONE) {
+        rc = ngx_http_lua_content_run_posted_threads(L, r, ctx, 1);
+
+    } else {
+        rc = NGX_OK;
+    }
+
+    ngx_http_lua_finalize_request(r, rc);
+    return;
+
+abort:
+    if (tctx.co_ref && tctx.co) {
+        lua_pushlightuserdata(tctx.co, &ngx_http_lua_coroutines_key);
+        lua_rawget(tctx.co, LUA_REGISTRYINDEX);
+        luaL_unref(tctx.co, -1, tctx.co_ref);
+        lua_settop(tctx.co, 0);
+    }
+
+    if (r && r->pool) {
+        ngx_destroy_pool(r->pool);
+    }
+
+    if (c) {
+        ngx_http_lua_close_fake_connection(c);
+    }
+}
+
+
+static u_char *
+ngx_http_lua_log_timer_error(ngx_log_t *log, u_char *buf, size_t len)
+{
+    u_char              *p;
+
+    if (log->action) {
+        p = ngx_snprintf(buf, len, " while %s", log->action);
+        len -= p - buf;
+        buf = p;
+    }
+
+    return ngx_snprintf(buf, len, ", context: ngx.timer");
+}
+
+
+static void
+ngx_http_lua_abort_pending_timers(ngx_event_t *ev)
+{
+    ngx_int_t                    i, n;
+    ngx_event_t                **events;
+    ngx_connection_t            *c, *saved_c = NULL;
+    ngx_rbtree_node_t           *cur, *prev, *next, *sentinel;
+    ngx_http_lua_timer_ctx_t    *tctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
+                   "lua abort pending timers HERE");
+
+    c = ev->data;
+    lmcf = c->data;
+
+    dd("lua connection fd: %d", (int) c->fd);
+
+    if (!c->close) {
+        return;
+    }
+
+    c->read->closed = 1;
+    c->write->closed = 1;
+
+    /* we temporarily use a valid fd (0) to make ngx_free_connection happy */
+
+    c->fd = 0;
+
+    if (ngx_cycle->files) {
+        saved_c = ngx_cycle->files[0];
+    }
+
+    ngx_free_connection(c);
+
+    c->fd = (ngx_socket_t) -1;
+
+    if (ngx_cycle->files) {
+        ngx_cycle->files[0] = saved_c;
+    }
+
+    if (lmcf->pending_timers == 0) {
+        return;
+    }
+
+    /* expire pending timers immediately */
+
+    sentinel = ngx_event_timer_rbtree.sentinel;
+
+    prev = NULL;
+    cur = ngx_event_timer_rbtree.root;
+
+    events = ngx_pcalloc(ngx_cycle->pool,
+                         lmcf->pending_timers * sizeof(ngx_event_t));
+    if (events == NULL) {
+        return;
+    }
+
+    n = 0;
+
+    dd("root: %p, root parent: %p, sentinel: %p", cur, cur->parent, sentinel);
+
+    while (lmcf->pending_timers > n) {
+        if  (cur == sentinel || cur == NULL) {
+            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
+                          "lua pending timer counter got out of sync: %i",
+                          lmcf->pending_timers);
+            break;
+        }
+
+        if (prev == cur->parent) {
+            next = cur->left;
+            if (next == sentinel) {
+                ev = (ngx_event_t *)
+                    ((char *) cur - offsetof(ngx_event_t, timer));
+
+                if (ev->handler == ngx_http_lua_timer_handler) {
+                    dd("found node: %p", cur);
+                    events[n++] = ev;
+                }
+
+                next = (cur->right != sentinel) ? cur->right : cur->parent;
+            }
+
+        } else if (prev == cur->left) {
+            ev = (ngx_event_t *)
+                ((char *) cur - offsetof(ngx_event_t, timer));
+
+            if (ev->handler == ngx_http_lua_timer_handler) {
+                dd("found node 2: %p", cur);
+                events[n++] = ev;
+            }
+
+            next = (cur->right != sentinel) ? cur->right : cur->parent;
+
+        } else if (prev == cur->right) {
+            next = cur->parent;
+
+        } else {
+            next = NULL;
+        }
+
+        prev = cur;
+        cur = next;
+    }
+
+    for (i = 0; i < n; i++) {
+        ev = events[i];
+
+        ngx_rbtree_delete(&ngx_event_timer_rbtree, &ev->timer);
+
+#if (NGX_DEBUG)
+        ev->timer.left = NULL;
+        ev->timer.right = NULL;
+        ev->timer.parent = NULL;
+#endif
+
+        ev->timer_set = 0;
+
+        ev->timedout = 1;
+
+        tctx = ev->data;
+        tctx->premature = 1;
+
+        ev->handler(ev);
+    }
+
+    if (lmcf->pending_timers) {
+        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
+                      "lua pending timer counter got out of sync: %i",
+                      lmcf->pending_timers);
+    }
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_timer.h b/src/lua/lua-nginx-module/src/ngx_http_lua_timer.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_timer.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_timer.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_TIMER_H_INCLUDED_
+#define _NGX_HTTP_LUA_TIMER_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_timer_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_TIMER_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_uri.c b/src/lua/lua-nginx-module/src/ngx_http_lua_uri.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_uri.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_uri.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,110 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_uri.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_ngx_req_set_uri(lua_State *L);
+
+
+void
+ngx_http_lua_inject_req_uri_api(ngx_log_t *log, lua_State *L)
+{
+    lua_pushcfunction(L, ngx_http_lua_ngx_req_set_uri);
+    lua_setfield(L, -2, "set_uri");
+}
+
+
+static int
+ngx_http_lua_ngx_req_set_uri(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    size_t                       len;
+    u_char                      *p;
+    int                          n;
+    int                          jump = 0;
+    ngx_http_lua_ctx_t          *ctx;
+
+    n = lua_gettop(L);
+
+    if (n != 1 && n != 2) {
+        return luaL_error(L, "expecting 1 argument but seen %d", n);
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    p = (u_char *) luaL_checklstring(L, 1, &len);
+
+    if (len == 0) {
+        return luaL_error(L, "attempt to use zero-length uri");
+    }
+
+    if (n == 2) {
+
+        luaL_checktype(L, 2, LUA_TBOOLEAN);
+        jump = lua_toboolean(L, 2);
+
+        if (jump) {
+
+            ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+            if (ctx == NULL) {
+                return luaL_error(L, "no ctx found");
+            }
+
+            dd("rewrite: %d, access: %d, content: %d",
+               (int) ctx->entered_rewrite_phase,
+               (int) ctx->entered_access_phase,
+               (int) ctx->entered_content_phase);
+
+            ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE);
+
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua set uri jump to \"%*s\"", len, p);
+
+            ngx_http_lua_check_if_abortable(L, ctx);
+        }
+    }
+
+    r->uri.data = ngx_palloc(r->pool, len);
+    if (r->uri.data == NULL) {
+        return luaL_error(L, "out of memory");
+    }
+
+    ngx_memcpy(r->uri.data, p, len);
+
+    r->uri.len = len;
+
+    r->internal = 1;
+    r->valid_unparsed_uri = 0;
+
+    ngx_http_set_exten(r);
+
+    if (jump) {
+        r->uri_changed = 1;
+
+        return lua_yield(L, 0);
+    }
+
+    r->valid_location = 0;
+    r->uri_changed = 0;
+
+    return 0;
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_uri.h b/src/lua/lua-nginx-module/src/ngx_http_lua_uri.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_uri.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_uri.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_URI_H_INCLUDED_
+#define _NGX_HTTP_LUA_URI_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_req_uri_api(ngx_log_t *log, lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_URI_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.c b/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,184 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_uthread.h"
+#include "ngx_http_lua_coroutine.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_probe.h"
+
+
+#if 1
+#undef ngx_http_lua_probe_info
+#define ngx_http_lua_probe_info(msg)
+#endif
+
+
+static int ngx_http_lua_uthread_spawn(lua_State *L);
+static int ngx_http_lua_uthread_wait(lua_State *L);
+
+
+void
+ngx_http_lua_inject_uthread_api(ngx_log_t *log, lua_State *L)
+{
+    /* new thread table */
+    lua_newtable(L);
+
+    lua_pushcfunction(L, ngx_http_lua_uthread_spawn);
+    lua_setfield(L, -2, "spawn");
+
+    lua_pushcfunction(L, ngx_http_lua_uthread_wait);
+    lua_setfield(L, -2, "wait");
+
+    lua_setfield(L, -2, "thread");
+}
+
+
+static int
+ngx_http_lua_uthread_spawn(lua_State *L)
+{
+    int                           n;
+    ngx_http_request_t           *r;
+    ngx_http_lua_ctx_t           *ctx;
+    ngx_http_lua_co_ctx_t        *coctx = NULL;
+
+    n = lua_gettop(L);
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_coroutine_create_helper(L, r, ctx, &coctx);
+
+    /* anchor the newly created coroutine into the Lua registry */
+
+    lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_pushvalue(L, -2);
+    coctx->co_ref = luaL_ref(L, -2);
+    lua_pop(L, 1);
+
+    if (n > 1) {
+        lua_replace(L, 1);
+        lua_xmove(L, coctx->co, n - 1);
+    }
+
+    coctx->is_uthread = 1;
+    ctx->uthreads++;
+
+    coctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+    ctx->co_op = NGX_HTTP_LUA_USER_THREAD_RESUME;
+
+    ctx->cur_co_ctx->thread_spawn_yielded = 1;
+
+    if (ngx_http_lua_post_thread(r, ctx, ctx->cur_co_ctx) != NGX_OK) {
+        return luaL_error(L, "out of memory");
+    }
+
+    coctx->parent_co_ctx = ctx->cur_co_ctx;
+    ctx->cur_co_ctx = coctx;
+
+    ngx_http_lua_probe_user_thread_spawn(r, L, coctx->co);
+
+    return lua_yield(L, 1);
+}
+
+
+static int
+ngx_http_lua_uthread_wait(lua_State *L)
+{
+    int                          i, nargs, nrets;
+    lua_State                   *sub_co;
+    ngx_http_request_t          *r;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx, *sub_coctx;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request found");
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "no request ctx found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE
+                               | NGX_HTTP_LUA_CONTEXT_ACCESS
+                               | NGX_HTTP_LUA_CONTEXT_CONTENT
+                               | NGX_HTTP_LUA_CONTEXT_TIMER);
+
+    coctx = ctx->cur_co_ctx;
+
+    nargs = lua_gettop(L);
+
+    for (i = 1; i <= nargs; i++) {
+        sub_co = lua_tothread(L, i);
+
+        luaL_argcheck(L, sub_co, i, "lua thread expected");
+
+        sub_coctx = ngx_http_lua_get_co_ctx(sub_co, ctx);
+        if (sub_coctx == NULL) {
+            return luaL_error(L, "no co ctx found for the ngx.thread "
+                              "instance given");
+        }
+
+        if (!sub_coctx->is_uthread) {
+            return luaL_error(L, "attempt to wait on a coroutine that is "
+                              "not a user thread");
+        }
+
+        if (sub_coctx->parent_co_ctx != coctx) {
+            return luaL_error(L, "only the parent coroutine can wait on the "
+                              "thread");
+        }
+
+        switch (sub_coctx->co_status) {
+        case NGX_HTTP_LUA_CO_ZOMBIE:
+
+            ngx_http_lua_probe_info("found zombie child");
+
+            nrets = lua_gettop(sub_coctx->co);
+
+            dd("child retval count: %d, %s: %s", (int) nrets,
+               luaL_typename(sub_coctx->co, -1),
+               lua_tostring(sub_coctx->co, -1));
+
+            if (nrets) {
+                lua_xmove(sub_coctx->co, L, nrets);
+            }
+
+#if 1
+            ngx_http_lua_del_thread(r, L, ctx, sub_coctx);
+            ctx->uthreads--;
+#endif
+
+            return nrets;
+
+        default:
+            /* still alive */
+            break;
+        }
+
+        ngx_http_lua_probe_user_thread_wait(L, sub_coctx->co);
+        sub_coctx->waited_by_parent = 1;
+    }
+
+    return lua_yield(L, 0);
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.h b/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_uthread.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,36 @@
+
+/*
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_UTHREAD_H_INCLUDED_
+#define _NGX_HTTP_LUA_UTHREAD_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+#define ngx_http_lua_is_thread(ctx)                                          \
+    ((ctx)->cur_co_ctx->is_uthread || (ctx)->cur_co_ctx == &(ctx)->entry_co_ctx)
+
+
+#define ngx_http_lua_is_entry_thread(ctx)                                    \
+    ((ctx)->cur_co_ctx == &(ctx)->entry_co_ctx)
+
+
+#define ngx_http_lua_entry_thread_alive(ctx)                                 \
+    ((ctx)->entry_co_ctx.co_ref != LUA_NOREF)
+
+
+#define ngx_http_lua_coroutine_alive(coctx)                                  \
+    ((coctx)->co_status != NGX_HTTP_LUA_CO_DEAD                              \
+     && (coctx)->co_status != NGX_HTTP_LUA_CO_ZOMBIE)
+
+
+void ngx_http_lua_inject_uthread_api(ngx_log_t *log, lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_UTHREAD_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_util.c b/src/lua/lua-nginx-module/src/ngx_http_lua_util.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_util.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_util.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,3593 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "nginx.h"
+#include "ngx_http_lua_directive.h"
+#include "ngx_http_lua_util.h"
+#include "ngx_http_lua_exception.h"
+#include "ngx_http_lua_pcrefix.h"
+#include "ngx_http_lua_regex.h"
+#include "ngx_http_lua_args.h"
+#include "ngx_http_lua_uri.h"
+#include "ngx_http_lua_req_body.h"
+#include "ngx_http_lua_headers.h"
+#include "ngx_http_lua_output.h"
+#include "ngx_http_lua_time.h"
+#include "ngx_http_lua_control.h"
+#include "ngx_http_lua_ndk.h"
+#include "ngx_http_lua_subrequest.h"
+#include "ngx_http_lua_log.h"
+#include "ngx_http_lua_variable.h"
+#include "ngx_http_lua_string.h"
+#include "ngx_http_lua_misc.h"
+#include "ngx_http_lua_consts.h"
+#include "ngx_http_lua_req_method.h"
+#include "ngx_http_lua_shdict.h"
+#include "ngx_http_lua_coroutine.h"
+#include "ngx_http_lua_socket_tcp.h"
+#include "ngx_http_lua_socket_udp.h"
+#include "ngx_http_lua_sleep.h"
+#include "ngx_http_lua_setby.h"
+#include "ngx_http_lua_headerfilterby.h"
+#include "ngx_http_lua_bodyfilterby.h"
+#include "ngx_http_lua_logby.h"
+#include "ngx_http_lua_phase.h"
+#include "ngx_http_lua_probe.h"
+#include "ngx_http_lua_uthread.h"
+#include "ngx_http_lua_contentby.h"
+#include "ngx_http_lua_timer.h"
+#include "ngx_http_lua_config.h"
+
+
+#if 1
+#undef ngx_http_lua_probe_info
+#define ngx_http_lua_probe_info(msg)
+#endif
+
+
+#ifndef NGX_HTTP_LUA_BT_DEPTH
+#define NGX_HTTP_LUA_BT_DEPTH  22
+#endif
+
+
+#ifndef NGX_HTTP_LUA_BT_MAX_COROS
+#define NGX_HTTP_LUA_BT_MAX_COROS  5
+#endif
+
+
+char ngx_http_lua_code_cache_key;
+char ngx_http_lua_ctx_tables_key;
+char ngx_http_lua_regex_cache_key;
+char ngx_http_lua_socket_pool_key;
+char ngx_http_lua_coroutines_key;
+char ngx_http_lua_req_get_headers_metatable_key;
+
+
+ngx_uint_t  ngx_http_lua_location_hash = 0;
+ngx_uint_t  ngx_http_lua_content_length_hash = 0;
+
+
+static ngx_int_t ngx_http_lua_send_http10_headers(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+static void ngx_http_lua_init_registry(ngx_conf_t *cf, lua_State *L);
+static void ngx_http_lua_init_globals(ngx_conf_t *cf, lua_State *L);
+static void ngx_http_lua_set_path(ngx_conf_t *cf, lua_State *L, int tab_idx,
+    const char *fieldname, const char *path, const char *default_path);
+static ngx_int_t ngx_http_lua_handle_exec(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+static ngx_int_t ngx_http_lua_handle_exit(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+static ngx_int_t ngx_http_lua_handle_rewrite_jump(lua_State *L,
+    ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx);
+static int ngx_http_lua_thread_traceback(lua_State *L, lua_State *co,
+    ngx_http_lua_co_ctx_t *coctx);
+static void ngx_http_lua_inject_ngx_api(ngx_conf_t *cf, lua_State *L);
+static void ngx_http_lua_inject_arg_api(lua_State *L);
+static int ngx_http_lua_param_get(lua_State *L);
+static int ngx_http_lua_param_set(lua_State *L);
+static void ngx_http_lua_del_all_threads(ngx_http_request_t *r, lua_State *L,
+    ngx_http_lua_ctx_t *ctx);
+static ngx_int_t ngx_http_lua_output_filter(ngx_http_request_t *r,
+    ngx_chain_t *in);
+static ngx_int_t ngx_http_lua_send_special(ngx_http_request_t *r,
+    ngx_uint_t flags);
+static void ngx_http_lua_finalize_coroutines(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+static ngx_int_t ngx_http_lua_post_zombie_thread(ngx_http_request_t *r,
+    ngx_http_lua_co_ctx_t *parent, ngx_http_lua_co_ctx_t *thread);
+static void ngx_http_lua_cleanup_zombie_child_uthreads(ngx_http_request_t *r,
+    lua_State *L, ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t *coctx);
+static ngx_int_t ngx_http_lua_on_abort_resume(ngx_http_request_t *r);
+static void ngx_http_lua_close_fake_request(ngx_http_request_t *r);
+static void ngx_http_lua_free_fake_request(ngx_http_request_t *r);
+static ngx_int_t ngx_http_lua_flush_pending_output(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+static ngx_int_t
+    ngx_http_lua_process_flushing_coroutines(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+
+
+#ifndef LUA_PATH_SEP
+#define LUA_PATH_SEP ";"
+#endif
+
+#define AUX_MARK "\1"
+
+
+static void
+ngx_http_lua_set_path(ngx_conf_t *cf, lua_State *L, int tab_idx,
+    const char *fieldname, const char *path, const char *default_path)
+{
+    const char          *tmp_path;
+    const char          *prefix;
+
+    /* XXX here we use some hack to simplify string manipulation */
+    tmp_path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,
+            LUA_PATH_SEP AUX_MARK LUA_PATH_SEP);
+
+    lua_pushlstring(L, (char *) cf->cycle->prefix.data, cf->cycle->prefix.len);
+    prefix = lua_tostring(L, -1);
+    tmp_path = luaL_gsub(L, tmp_path, "$prefix", prefix);
+    tmp_path = luaL_gsub(L, tmp_path, "${prefix}", prefix);
+    lua_pop(L, 3);
+
+    dd("tmp_path path: %s", tmp_path);
+
+#if (NGX_DEBUG)
+    tmp_path =
+#else
+    (void)
+#endif
+        luaL_gsub(L, tmp_path, AUX_MARK, default_path);
+
+#if (NGX_DEBUG)
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, cf->log, 0,
+                   "lua setting lua package.%s to \"%s\"", fieldname, tmp_path);
+#endif
+
+    lua_remove(L, -2);
+
+    /* fix negative index as there's new data on stack */
+    tab_idx = (tab_idx < 0) ? (tab_idx - 1) : tab_idx;
+    lua_setfield(L, tab_idx, fieldname);
+}
+
+
+/**
+ * Create new table and set _G field to itself.
+ *
+ * After:
+ *         | new table | <- top
+ *         |    ...    |
+ * */
+void
+ngx_http_lua_create_new_global_table(lua_State *L, int narr, int nrec)
+{
+    lua_createtable(L, narr, nrec + 1);
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -2, "_G");
+}
+
+
+lua_State *
+ngx_http_lua_new_state(ngx_conf_t *cf, ngx_http_lua_main_conf_t *lmcf)
+{
+    lua_State       *L;
+    const char      *old_path;
+    const char      *new_path;
+    size_t           old_path_len;
+    const char      *old_cpath;
+    const char      *new_cpath;
+    size_t           old_cpath_len;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0, "lua creating new vm state");
+
+    L = luaL_newstate();
+    if (L == NULL) {
+        return NULL;
+    }
+
+    luaL_openlibs(L);
+
+    lua_getglobal(L, "package");
+
+    if (!lua_istable(L, -1)) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "the \"package\" table does not exist");
+        return NULL;
+    }
+
+#ifdef LUA_DEFAULT_PATH
+#   define LUA_DEFAULT_PATH_LEN (sizeof(LUA_DEFAULT_PATH) - 1)
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, cf->log, 0,
+                   "lua prepending default package.path with %s",
+                   LUA_DEFAULT_PATH);
+
+    lua_pushliteral(L, LUA_DEFAULT_PATH ";"); /* package default */
+    lua_getfield(L, -2, "path"); /* package default old */
+    old_path = lua_tolstring(L, -1, &old_path_len);
+    lua_concat(L, 2); /* package new */
+    lua_setfield(L, -2, "path"); /* package */
+#endif
+
+#ifdef LUA_DEFAULT_CPATH
+#   define LUA_DEFAULT_CPATH_LEN (sizeof(LUA_DEFAULT_CPATH) - 1)
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, cf->log, 0,
+                   "lua prepending default package.cpath with %s",
+                   LUA_DEFAULT_CPATH);
+
+    lua_pushliteral(L, LUA_DEFAULT_CPATH ";"); /* package default */
+    lua_getfield(L, -2, "cpath"); /* package default old */
+    old_cpath = lua_tolstring(L, -1, &old_cpath_len);
+    lua_concat(L, 2); /* package new */
+    lua_setfield(L, -2, "cpath"); /* package */
+#endif
+
+    if (lmcf->lua_path.len != 0) {
+        lua_getfield(L, -1, "path"); /* get original package.path */
+        old_path = lua_tolstring(L, -1, &old_path_len);
+
+        dd("old path: %s", old_path);
+
+        lua_pushlstring(L, (char *) lmcf->lua_path.data, lmcf->lua_path.len);
+        new_path = lua_tostring(L, -1);
+
+        ngx_http_lua_set_path(cf, L, -3, "path", new_path, old_path);
+
+        lua_pop(L, 2);
+    }
+
+    if (lmcf->lua_cpath.len != 0) {
+        lua_getfield(L, -1, "cpath"); /* get original package.cpath */
+        old_cpath = lua_tolstring(L, -1, &old_cpath_len);
+
+        dd("old cpath: %s", old_cpath);
+
+        lua_pushlstring(L, (char *) lmcf->lua_cpath.data, lmcf->lua_cpath.len);
+        new_cpath = lua_tostring(L, -1);
+
+        ngx_http_lua_set_path(cf, L, -3, "cpath", new_cpath, old_cpath);
+
+
+        lua_pop(L, 2);
+    }
+
+    lua_remove(L, -1); /* remove the "package" table */
+
+    ngx_http_lua_init_registry(cf, L);
+    ngx_http_lua_init_globals(cf, L);
+
+    return L;
+}
+
+
+lua_State *
+ngx_http_lua_new_thread(ngx_http_request_t *r, lua_State *L, int *ref)
+{
+    int              base;
+    lua_State       *co;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua creating new thread");
+
+    base = lua_gettop(L);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+
+    co = lua_newthread(L);
+
+    /*  {{{ inherit coroutine's globals to main thread's globals table
+     *  for print() function will try to find tostring() in current
+     *  globals table.
+     */
+    /*  new globals table for coroutine */
+    ngx_http_lua_create_new_global_table(co, 0, 0);
+
+    lua_createtable(co, 0, 1);
+    lua_pushvalue(co, LUA_GLOBALSINDEX);
+    lua_setfield(co, -2, "__index");
+    lua_setmetatable(co, -2);
+
+    lua_replace(co, LUA_GLOBALSINDEX);
+    /*  }}} */
+
+    *ref = luaL_ref(L, -2);
+
+    if (*ref == LUA_NOREF) {
+        lua_settop(L, base);  /* restore main thread stack */
+        return NULL;
+    }
+
+    lua_settop(L, base);
+    return co;
+}
+
+
+void
+ngx_http_lua_del_thread(ngx_http_request_t *r, lua_State *L,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t *coctx)
+{
+    if (coctx->co_ref == LUA_NOREF) {
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua deleting light thread");
+
+    lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+
+    ngx_http_lua_probe_thread_delete(r, coctx->co, ctx);
+
+    luaL_unref(L, -1, coctx->co_ref);
+    coctx->co_ref = LUA_NOREF;
+    coctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+    lua_pop(L, 1);
+}
+
+
+static void
+ngx_http_lua_del_all_threads(ngx_http_request_t *r, lua_State *L,
+    ngx_http_lua_ctx_t *ctx)
+{
+    int                              inited = 0;
+    int                              ref;
+    ngx_uint_t                       i;
+    ngx_list_part_t                 *part;
+    ngx_http_lua_co_ctx_t           *entry_coctx;
+    ngx_http_lua_co_ctx_t           *cc;
+
+    cc = ctx->on_abort_co_ctx;
+    if (cc) {
+        lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+        lua_rawget(L, LUA_REGISTRYINDEX);
+        inited = 1;
+
+        if (cc->co_ref != LUA_NOREF) {
+            ngx_http_lua_probe_thread_delete(r, cc->co, ctx);
+
+            luaL_unref(L, -1, cc->co_ref);
+            cc->co_ref = LUA_NOREF;
+
+            if (cc->co_status != NGX_HTTP_LUA_CO_SUSPENDED) {
+                ctx->uthreads--;
+            }
+
+            cc->co_status = NGX_HTTP_LUA_CO_DEAD;
+        }
+
+        ctx->on_abort_co_ctx = NULL;
+    }
+
+    if (ctx->uthreads && ctx->user_co_ctx) {
+        /* release all pending user threads */
+
+        if (!inited) {
+            lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+            lua_rawget(L, LUA_REGISTRYINDEX);
+            inited = 1;
+        }
+
+        part = &ctx->user_co_ctx->part;
+        cc = part->elts;
+
+        for (i = 0; /* void */; i++) {
+
+            if (i >= part->nelts) {
+                if (part->next == NULL) {
+                    break;
+                }
+
+                part = part->next;
+                cc = part->elts;
+                i = 0;
+            }
+
+            ref = cc[i].co_ref;
+
+            if (ref != LUA_NOREF) {
+                ngx_http_lua_probe_thread_delete(r, cc[i].co, ctx);
+
+                luaL_unref(L, -1, ref);
+                cc[i].co_ref = LUA_NOREF;
+                cc[i].co_status = NGX_HTTP_LUA_CO_DEAD;
+                ctx->uthreads--;
+
+                if (ctx->uthreads == 0) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /* release the reference to the entry thread */
+
+    entry_coctx = &ctx->entry_co_ctx;
+
+    if (entry_coctx->co_ref != LUA_NOREF) {
+        if (!inited) {
+            lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+            lua_rawget(L, LUA_REGISTRYINDEX);
+            inited = 1;
+        }
+
+        ngx_http_lua_probe_thread_delete(r, entry_coctx->co, ctx);
+
+        luaL_unref(L, -1, entry_coctx->co_ref);
+        entry_coctx->co_ref = LUA_NOREF;
+        entry_coctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+    }
+
+    if (inited) {
+        lua_pop(L, 1);
+    }
+}
+
+
+u_char *
+ngx_http_lua_rebase_path(ngx_pool_t *pool, u_char *src, size_t len)
+{
+    u_char            *p, *dst;
+
+    if (len == 0) {
+        return NULL;
+    }
+
+    if (src[0] == '/') {
+        /* being an absolute path already */
+        dst = ngx_palloc(pool, len + 1);
+        if (dst == NULL) {
+            return NULL;
+        }
+
+        p = ngx_copy(dst, src, len);
+
+        *p = '\0';
+
+        return dst;
+    }
+
+    dst = ngx_palloc(pool, ngx_cycle->prefix.len + len + 1);
+    if (dst == NULL) {
+        return NULL;
+    }
+
+    p = ngx_copy(dst, ngx_cycle->prefix.data, ngx_cycle->prefix.len);
+    p = ngx_copy(p, src, len);
+
+    *p = '\0';
+
+    return dst;
+}
+
+
+ngx_int_t
+ngx_http_lua_send_header_if_needed(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t            rc;
+
+    if (!r->header_sent) {
+        if (r->headers_out.status == 0) {
+            r->headers_out.status = NGX_HTTP_OK;
+        }
+
+        if (!ctx->headers_set && ngx_http_set_content_type(r) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (!ctx->headers_set) {
+            ngx_http_clear_content_length(r);
+            ngx_http_clear_accept_ranges(r);
+        }
+
+        if (!ctx->buffering) {
+            dd("sending headers");
+            rc = ngx_http_send_header(r);
+            return rc;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_send_chain_link(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx,
+    ngx_chain_t *in)
+{
+    ngx_int_t                     rc;
+    ngx_chain_t                  *cl;
+    ngx_chain_t                 **ll;
+    ngx_http_lua_loc_conf_t      *llcf;
+
+#if 1
+    if (ctx->acquired_raw_req_socket || ctx->eof) {
+        dd("ctx->eof already set or raw req socket already acquired");
+        return NGX_OK;
+    }
+#endif
+
+    if ((r->method & NGX_HTTP_HEAD) && !r->header_only) {
+        r->header_only = 1;
+    }
+
+    llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+
+    if (llcf->http10_buffering
+        && !ctx->buffering
+        && !r->header_sent
+        && r->http_version < NGX_HTTP_VERSION_11
+        && r->headers_out.content_length_n < 0)
+    {
+        ctx->buffering = 1;
+    }
+
+    rc = ngx_http_lua_send_header_if_needed(r, ctx);
+
+    if (rc == NGX_ERROR || rc > NGX_OK) {
+        return rc;
+    }
+
+    if (r->header_only) {
+        ctx->eof = 1;
+
+        if (ctx->buffering) {
+            return ngx_http_lua_send_http10_headers(r, ctx);
+        }
+
+        return rc;
+    }
+
+    if (in == NULL) {
+        if (ctx->buffering) {
+            rc = ngx_http_lua_send_http10_headers(r, ctx);
+            if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+                return rc;
+            }
+
+            if (ctx->out) {
+
+                rc = ngx_http_lua_output_filter(r, ctx->out);
+
+                if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+                    return rc;
+                }
+
+                ctx->out = NULL;
+            }
+        }
+
+#if defined(nginx_version) && nginx_version <= 8004
+
+        /* earlier versions of nginx does not allow subrequests
+           to send last_buf themselves */
+        if (r != r->main) {
+            return NGX_OK;
+        }
+
+#endif
+
+        ctx->eof = 1;
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua sending last buf of the response body");
+
+        rc = ngx_http_lua_send_special(r, NGX_HTTP_LAST);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+
+        return NGX_OK;
+    }
+
+    /* in != NULL */
+
+    if (ctx->buffering) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "lua buffering output bufs for the HTTP 1.0 request");
+
+        for (cl = ctx->out, ll = &ctx->out; cl; cl = cl->next) {
+            ll = &cl->next;
+        }
+
+        *ll = in;
+
+        return NGX_OK;
+    }
+
+    return ngx_http_lua_output_filter(r, in);
+}
+
+
+static ngx_int_t
+ngx_http_lua_send_special(ngx_http_request_t *r, ngx_uint_t flags)
+{
+    ngx_int_t            rc;
+    ngx_http_request_t  *ar; /* active request */
+
+    ar = r->connection->data;
+
+    if (ar != r) {
+
+        /* bypass ngx_http_postpone_filter_module */
+
+        r->connection->data = r;
+        rc = ngx_http_send_special(r, flags);
+        r->connection->data = ar;
+        return rc;
+    }
+
+    return ngx_http_send_special(r, flags);
+}
+
+
+static ngx_int_t
+ngx_http_lua_output_filter(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    ngx_int_t            rc;
+    ngx_http_request_t  *ar; /* active request */
+
+    ar = r->connection->data;
+
+    if (ar != r) {
+
+        /* bypass ngx_http_postpone_filter_module */
+
+        r->connection->data = r;
+        rc = ngx_http_output_filter(r, in);
+        r->connection->data = ar;
+        return rc;
+    }
+
+    return ngx_http_output_filter(r, in);
+}
+
+
+static ngx_int_t
+ngx_http_lua_send_http10_headers(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    off_t                size;
+    ngx_chain_t         *cl;
+    ngx_int_t            rc;
+
+    if (r->header_sent) {
+        return NGX_OK;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua sending HTTP 1.0 response headers");
+
+    if (r->header_only) {
+        goto send;
+    }
+
+    if (r->headers_out.content_length == NULL) {
+        for (size = 0, cl = ctx->out; cl; cl = cl->next) {
+            size += ngx_buf_size(cl->buf);
+        }
+
+        r->headers_out.content_length_n = size;
+
+        if (r->headers_out.content_length) {
+            r->headers_out.content_length->hash = 0;
+        }
+    }
+
+send:
+    rc = ngx_http_send_header(r);
+    return rc;
+}
+
+
+static void
+ngx_http_lua_init_registry(ngx_conf_t *cf, lua_State *L)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,
+                   "lua initializing lua registry");
+
+    /* {{{ register a table to anchor lua coroutines reliably:
+     * {([int]ref) = [cort]} */
+    lua_pushlightuserdata(L, &ngx_http_lua_coroutines_key);
+    lua_newtable(L);
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+
+    /* create the registry entry for the Lua request ctx data table */
+    lua_pushlightuserdata(L, &ngx_http_lua_ctx_tables_key);
+    lua_newtable(L);
+    lua_rawset(L, LUA_REGISTRYINDEX);
+
+    /* create the registry entry for the Lua socket connection pool table */
+    lua_pushlightuserdata(L, &ngx_http_lua_socket_pool_key);
+    lua_newtable(L);
+    lua_rawset(L, LUA_REGISTRYINDEX);
+
+#if (NGX_PCRE)
+    /* create the registry entry for the Lua precompiled regex object cache */
+    lua_pushlightuserdata(L, &ngx_http_lua_regex_cache_key);
+    lua_newtable(L);
+    lua_rawset(L, LUA_REGISTRYINDEX);
+#endif
+
+    /* {{{ register table to cache user code:
+     * { [(string)cache_key] = <code closure> } */
+    lua_pushlightuserdata(L, &ngx_http_lua_code_cache_key);
+    lua_newtable(L);
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+}
+
+
+static void
+ngx_http_lua_init_globals(ngx_conf_t *cf, lua_State *L)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,
+                   "lua initializing lua globals");
+
+#if defined(NDK) && NDK
+    ngx_http_lua_inject_ndk_api(L);
+#endif /* defined(NDK) && NDK */
+
+    ngx_http_lua_inject_ngx_api(cf, L);
+}
+
+
+static void
+ngx_http_lua_inject_ngx_api(ngx_conf_t *cf, lua_State *L)
+{
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);
+
+    lua_createtable(L, 0 /* narr */, 96 /* nrec */);    /* ngx.* */
+
+    ngx_http_lua_inject_arg_api(L);
+
+    ngx_http_lua_inject_http_consts(L);
+    ngx_http_lua_inject_core_consts(L);
+
+    ngx_http_lua_inject_log_api(L);
+    ngx_http_lua_inject_output_api(L);
+    ngx_http_lua_inject_time_api(L);
+    ngx_http_lua_inject_string_api(L);
+    ngx_http_lua_inject_control_api(cf->log, L);
+    ngx_http_lua_inject_subrequest_api(L);
+    ngx_http_lua_inject_sleep_api(L);
+    ngx_http_lua_inject_phase_api(L);
+
+#if (NGX_PCRE)
+    ngx_http_lua_inject_regex_api(L);
+#endif
+
+    ngx_http_lua_inject_req_api(cf->log, L);
+    ngx_http_lua_inject_resp_header_api(L);
+    ngx_http_lua_inject_variable_api(L);
+    ngx_http_lua_inject_shdict_api(lmcf, L);
+    ngx_http_lua_inject_socket_tcp_api(cf->log, L);
+    ngx_http_lua_inject_socket_udp_api(cf->log, L);
+    ngx_http_lua_inject_uthread_api(cf->log, L);
+    ngx_http_lua_inject_timer_api(L);
+    ngx_http_lua_inject_config_api(L);
+
+    ngx_http_lua_inject_misc_api(L);
+
+    lua_getglobal(L, "package"); /* ngx package */
+    lua_getfield(L, -1, "loaded"); /* ngx package loaded */
+    lua_pushvalue(L, -3); /* ngx package loaded ngx */
+    lua_setfield(L, -2, "ngx"); /* ngx package loaded */
+    lua_pop(L, 2);
+
+    lua_setglobal(L, "ngx");
+
+    ngx_http_lua_inject_coroutine_api(cf->log, L);
+}
+
+
+void
+ngx_http_lua_discard_bufs(ngx_pool_t *pool, ngx_chain_t *in)
+{
+    ngx_chain_t         *cl;
+
+    for (cl = in; cl; cl = cl->next) {
+        cl->buf->pos = cl->buf->last;
+        cl->buf->file_pos = cl->buf->file_last;
+    }
+}
+
+
+ngx_int_t
+ngx_http_lua_add_copy_chain(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx,
+    ngx_chain_t ***plast, ngx_chain_t *in, ngx_int_t *eof)
+{
+    ngx_chain_t     *cl;
+    size_t           len;
+    ngx_buf_t       *b;
+
+    len = 0;
+    *eof = 0;
+
+    for (cl = in; cl; cl = cl->next) {
+        if (ngx_buf_in_memory(cl->buf)) {
+            len += cl->buf->last - cl->buf->pos;
+        }
+
+        if (cl->buf->last_in_chain || cl->buf->last_buf) {
+            *eof = 1;
+        }
+    }
+
+    if (len == 0) {
+        return NGX_OK;
+    }
+
+    cl = ngx_http_lua_chains_get_free_buf(r->connection->log, r->pool,
+                                          &ctx->free_bufs, len,
+                                          (ngx_buf_tag_t) &ngx_http_lua_module);
+
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    dd("chains get free buf: %d == %d", (int) (cl->buf->end - cl->buf->start),
+       (int) len);
+
+    b = cl->buf;
+
+    while (in) {
+        if (ngx_buf_in_memory(in->buf)) {
+            b->last = ngx_copy(b->last, in->buf->pos,
+                               in->buf->last - in->buf->pos);
+        }
+
+        in = in->next;
+    }
+
+    **plast = cl;
+    *plast = &cl->next;
+
+    return NGX_OK;
+}
+
+
+void
+ngx_http_lua_reset_ctx(ngx_http_request_t *r, lua_State *L,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua reset ctx");
+
+    ngx_http_lua_del_all_threads(r, L, ctx);
+
+    if (ctx->user_co_ctx) {
+        /* no way to destroy a list but clean up the whole pool */
+        ctx->user_co_ctx = NULL;
+    }
+
+    ngx_memzero(&ctx->entry_co_ctx, sizeof(ngx_http_lua_co_ctx_t));
+
+    ctx->entry_co_ctx.co_ref = LUA_NOREF;
+
+    ctx->entered_rewrite_phase = 0;
+    ctx->entered_access_phase = 0;
+    ctx->entered_content_phase = 0;
+
+    ctx->exit_code = 0;
+    ctx->exited = 0;
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    ngx_str_null(&ctx->exec_uri);
+    ngx_str_null(&ctx->exec_args);
+
+    ctx->co_op = 0;
+}
+
+
+/* post read callback for rewrite and access phases */
+void
+ngx_http_lua_generic_phase_post_read(ngx_http_request_t *r)
+{
+    ngx_http_lua_ctx_t  *ctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua post read for rewrite/access phases");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+    ctx->read_body_done = 1;
+
+#if defined(nginx_version) && nginx_version >= 8011
+    r->main->count--;
+#endif
+
+    if (ctx->waiting_more_body) {
+        ctx->waiting_more_body = 0;
+        ngx_http_core_run_phases(r);
+    }
+}
+
+
+void
+ngx_http_lua_request_cleanup_handler(void *data)
+{
+    ngx_http_lua_ctx_t          *ctx = data;
+
+    ngx_http_lua_request_cleanup(ctx, 0 /* forcible */);
+}
+
+
+void
+ngx_http_lua_request_cleanup(ngx_http_lua_ctx_t *ctx, int forcible)
+{
+    lua_State                   *L;
+    ngx_http_request_t          *r;
+    ngx_http_lua_main_conf_t    *lmcf;
+    ngx_http_lua_loc_conf_t     *llcf;
+    ngx_http_lua_ctx_t          *cur_ctx;
+
+    r = ctx->request;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua request cleanup: forcible=%d", forcible);
+
+    /*  force coroutine handling the request quit */
+    if (ctx == NULL) {
+        dd("ctx is NULL");
+        return;
+    }
+
+    if (ctx->cleanup) {
+        *ctx->cleanup = NULL;
+        ctx->cleanup = NULL;
+    }
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+#if 1
+    if (r->connection->fd == -1) {
+        /* being a fake request */
+        lmcf->running_timers--;
+    }
+#endif
+
+    L = lmcf->lua;
+
+    /* we cannot release the ngx.ctx table if we have log_by_lua* hooks
+     * because request cleanup runs before log phase handlers */
+
+    if (ctx->ctx_ref != LUA_NOREF) {
+
+        if (forcible || r->connection->fd == -1 /* being a fake request */) {
+            ngx_http_lua_release_ngx_ctx_table(r->connection->log, L, ctx);
+
+        } else {
+
+            cur_ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+
+            if (cur_ctx != ctx) {
+                /* internal redirects happened */
+                ngx_http_lua_release_ngx_ctx_table(r->connection->log, L, ctx);
+
+            } else {
+
+                llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module);
+                if (llcf->log_handler == NULL) {
+                    /* no log_by_lua* configured */
+                    ngx_http_lua_release_ngx_ctx_table(r->connection->log, L,
+                                                       ctx);
+                }
+            }
+        }
+    }
+
+    ngx_http_lua_finalize_coroutines(r, ctx);
+    ngx_http_lua_del_all_threads(r, L, ctx);
+}
+
+
+void
+ngx_http_lua_release_ngx_ctx_table(ngx_log_t *log, lua_State *L,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+                   "lua release ngx.ctx at ref %d", ctx->ctx_ref);
+
+    lua_pushlightuserdata(L, &ngx_http_lua_ctx_tables_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    luaL_unref(L, -1, ctx->ctx_ref);
+    ctx->ctx_ref = LUA_NOREF;
+    lua_pop(L, 1);
+}
+
+
+/*
+ * description:
+ *  run a Lua coroutine specified by ctx->cur_co_ctx->co
+ * return value:
+ *  NGX_AGAIN:      I/O interruption: r->main->count intact
+ *  NGX_DONE:       I/O interruption: r->main->count already incremented by 1
+ *  NGX_ERROR:      error
+ *  >= 200          HTTP status code
+ */
+ngx_int_t
+ngx_http_lua_run_thread(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, volatile int nrets)
+{
+    ngx_http_lua_co_ctx_t   *next_coctx, *parent_coctx, *orig_coctx;
+    int                      rv, success = 1;
+    lua_State               *next_co;
+    lua_State               *old_co;
+    const char              *err, *msg, *trace;
+    ngx_int_t                rc;
+#if (NGX_PCRE)
+    ngx_pool_t              *old_pool = NULL;
+#endif
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread, top:%d c:%ud", lua_gettop(L),
+                   r->main->count);
+
+    /* set Lua VM panic handler */
+    lua_atpanic(L, ngx_http_lua_atpanic);
+
+    dd("ctx = %p", ctx);
+
+    NGX_LUA_EXCEPTION_TRY {
+
+        if (ctx->cur_co_ctx->thread_spawn_yielded) {
+            ngx_http_lua_probe_info("thread spawn yielded");
+
+            ctx->cur_co_ctx->thread_spawn_yielded = 0;
+            nrets = 1;
+        }
+
+        for ( ;; ) {
+
+            dd("calling lua_resume: vm %p, nret %d", ctx->cur_co_ctx->co,
+               (int) nrets);
+
+#if (NGX_PCRE)
+            /* XXX: work-around to nginx regex subsystem */
+            old_pool = ngx_http_lua_pcre_malloc_init(r->pool);
+#endif
+
+            /*  run code */
+            dd("ctx: %p", ctx);
+            dd("cur co: %p", ctx->cur_co_ctx->co);
+
+            orig_coctx = ctx->cur_co_ctx;
+            rv = lua_resume(orig_coctx->co, nrets);
+
+#if (NGX_PCRE)
+            /* XXX: work-around to nginx regex subsystem */
+            ngx_http_lua_pcre_malloc_done(old_pool);
+#endif
+
+#if 0
+            /* test the longjmp thing */
+            if (rand() % 2 == 0) {
+                NGX_LUA_EXCEPTION_THROW(1);
+            }
+#endif
+
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "lua resume returned %d", rv);
+
+            switch (rv) {
+            case LUA_YIELD:
+                /*  yielded, let event handler do the rest job */
+                /*  FIXME: add io cmd dispatcher here */
+
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "lua thread yielded");
+
+                if (r->uri_changed) {
+                    return ngx_http_lua_handle_rewrite_jump(L, r, ctx);
+                }
+
+                if (ctx->exited) {
+                    return ngx_http_lua_handle_exit(L, r, ctx);
+                }
+
+                if (ctx->exec_uri.len) {
+                    return ngx_http_lua_handle_exec(L, r, ctx);
+                }
+
+                /*
+                 * check if coroutine.resume or coroutine.yield called
+                 * lua_yield()
+                 */
+                switch(ctx->co_op) {
+                case NGX_HTTP_LUA_USER_CORO_NOP:
+                    dd("hit! it is the API yield");
+
+                    lua_settop(ctx->cur_co_ctx->co, 0);
+                    ctx->cur_co_ctx = NULL;
+
+                    return NGX_AGAIN;
+
+                case NGX_HTTP_LUA_USER_THREAD_RESUME:
+
+                    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                                   "lua user thread resume");
+
+                    ctx->co_op = NGX_HTTP_LUA_USER_CORO_NOP;
+                    nrets = lua_gettop(ctx->cur_co_ctx->co) - 1;
+                    dd("nrets = %d", nrets);
+
+                    break;
+
+                case NGX_HTTP_LUA_USER_CORO_RESUME:
+                    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                                   "lua coroutine: resume");
+
+                    /*
+                     * the target coroutine lies at the base of the
+                     * parent's stack
+                     */
+                    ctx->co_op = NGX_HTTP_LUA_USER_CORO_NOP;
+
+                    old_co = ctx->cur_co_ctx->parent_co_ctx->co;
+
+                    nrets = lua_gettop(old_co);
+                    if (nrets) {
+                        lua_xmove(old_co, ctx->cur_co_ctx->co, nrets);
+                    }
+
+                    break;
+
+                default:
+                    /* ctx->co_op == NGX_HTTP_LUA_USER_CORO_YIELD */
+
+                    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                                   "lua coroutine: yield");
+
+                    ctx->co_op = NGX_HTTP_LUA_USER_CORO_NOP;
+
+                    if (ngx_http_lua_is_thread(ctx)) {
+                        ngx_http_lua_probe_thread_yield(r, ctx->cur_co_ctx->co);
+
+                        lua_settop(ctx->cur_co_ctx->co, 0);
+
+                        ngx_http_lua_probe_info("set co running");
+                        ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+
+                        if (ctx->posted_threads) {
+                            ngx_http_lua_post_thread(r, ctx, ctx->cur_co_ctx);
+                            ctx->cur_co_ctx = NULL;
+                            return NGX_AGAIN;
+                        }
+
+                        /* no pending threads, so resume the thread
+                         * immediately */
+
+                        nrets = 0;
+                        continue;
+                    }
+
+                    /* being a user coroutine that has a parent */
+
+                    nrets = lua_gettop(ctx->cur_co_ctx->co);
+
+                    next_coctx = ctx->cur_co_ctx->parent_co_ctx;
+                    next_co = next_coctx->co;
+
+                    /*
+                     * prepare return values for coroutine.resume
+                     * (true plus any retvals)
+                     */
+                    lua_pushboolean(next_co, 1);
+
+                    if (nrets) {
+                        lua_xmove(ctx->cur_co_ctx->co, next_co, nrets);
+                    }
+
+                    nrets++;
+
+                    ctx->cur_co_ctx = next_coctx;
+
+                    break;
+                }
+
+                /* try resuming on the new coroutine again */
+                continue;
+
+            case 0:
+
+                ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 1);
+
+                ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+                if (ctx->cur_co_ctx->zombie_child_threads) {
+                    ngx_http_lua_cleanup_zombie_child_uthreads(r, L, ctx,
+                                                               ctx->cur_co_ctx);
+                }
+
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "lua light thread ended normally");
+
+                if (ngx_http_lua_is_entry_thread(ctx)) {
+
+                    lua_settop(L, 0);
+
+                    ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);
+
+                    dd("uthreads: %d", (int) ctx->uthreads);
+
+                    if (ctx->uthreads) {
+
+                        ctx->cur_co_ctx = NULL;
+                        return NGX_AGAIN;
+                    }
+
+                    /* all user threads terminated already */
+                    goto done;
+                }
+
+                if (ctx->cur_co_ctx->is_uthread) {
+                    /* being a user thread */
+
+                    lua_settop(L, 0);
+
+                    parent_coctx = ctx->cur_co_ctx->parent_co_ctx;
+
+                    if (ngx_http_lua_coroutine_alive(parent_coctx)) {
+                        if (ctx->cur_co_ctx->waited_by_parent) {
+                            ngx_http_lua_probe_info("parent already waiting");
+                            ctx->cur_co_ctx->waited_by_parent = 0;
+                            success = 1;
+                            goto user_co_done;
+                        }
+
+                        ngx_http_lua_probe_info("parent still alive");
+
+                        if (ngx_http_lua_post_zombie_thread(r, parent_coctx,
+                                                            ctx->cur_co_ctx)
+                            != NGX_OK)
+                        {
+                            return NGX_ERROR;
+                        }
+
+                        lua_pushboolean(ctx->cur_co_ctx->co, 1);
+                        lua_insert(ctx->cur_co_ctx->co, 1);
+
+                        ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_ZOMBIE;
+                        ctx->cur_co_ctx = NULL;
+                        return NGX_AGAIN;
+                    }
+
+                    ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);
+                    ctx->uthreads--;
+
+                    if (ctx->uthreads == 0) {
+                        if (ngx_http_lua_entry_thread_alive(ctx)) {
+                            ctx->cur_co_ctx = NULL;
+                            return NGX_AGAIN;
+                        }
+
+                        /* all threads terminated already */
+                        goto done;
+                    }
+
+                    /* some other user threads still running */
+                    ctx->cur_co_ctx = NULL;
+                    return NGX_AGAIN;
+                }
+
+                /* being a user coroutine that has a parent */
+
+                success = 1;
+
+user_co_done:
+                nrets = lua_gettop(ctx->cur_co_ctx->co);
+
+                next_coctx = ctx->cur_co_ctx->parent_co_ctx;
+
+                if (next_coctx == NULL) {
+                    /* being a light thread */
+                    goto no_parent;
+                }
+
+                next_co = next_coctx->co;
+
+                /*
+                 * ended successful, coroutine.resume returns true plus
+                 * any return values
+                 */
+                lua_pushboolean(next_co, success);
+
+                if (nrets) {
+                    lua_xmove(ctx->cur_co_ctx->co, next_co, nrets);
+                }
+
+                if (ctx->cur_co_ctx->is_uthread) {
+                    ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);
+                    ctx->uthreads--;
+                }
+
+                nrets++;
+                ctx->cur_co_ctx = next_coctx;
+
+                ngx_http_lua_probe_info("set parent running");
+
+                next_coctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                               "lua coroutine: lua user thread ended normally");
+
+                continue;
+
+            case LUA_ERRRUN:
+                err = "runtime error";
+                break;
+
+            case LUA_ERRSYNTAX:
+                err = "syntax error";
+                break;
+
+            case LUA_ERRMEM:
+                err = "memory allocation error";
+                ngx_quit = 1;
+                break;
+
+            case LUA_ERRERR:
+                err = "error handler error";
+                break;
+
+            default:
+                err = "unknown error";
+                break;
+            }
+
+            if (ctx->cur_co_ctx != orig_coctx) {
+                ctx->cur_co_ctx = orig_coctx;
+            }
+
+            if (lua_isstring(ctx->cur_co_ctx->co, -1)) {
+                dd("user custom error msg");
+                msg = lua_tostring(ctx->cur_co_ctx->co, -1);
+
+            } else {
+                msg = "unknown reason";
+            }
+
+            ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 0);
+
+            ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+            ngx_http_lua_thread_traceback(L, ctx->cur_co_ctx->co,
+                                          ctx->cur_co_ctx);
+            trace = lua_tostring(L, -1);
+
+            if (ctx->cur_co_ctx->is_uthread) {
+
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                              "lua user thread aborted: %s: %s\n%s",
+                              err, msg, trace);
+
+                lua_settop(L, 0);
+
+                parent_coctx = ctx->cur_co_ctx->parent_co_ctx;
+
+                if (ngx_http_lua_coroutine_alive(parent_coctx)) {
+                    if (ctx->cur_co_ctx->waited_by_parent) {
+                        ctx->cur_co_ctx->waited_by_parent = 0;
+                        success = 0;
+                        goto user_co_done;
+                    }
+
+                    if (ngx_http_lua_post_zombie_thread(r, parent_coctx,
+                                                        ctx->cur_co_ctx)
+                        != NGX_OK)
+                    {
+                        return NGX_ERROR;
+                    }
+
+                    lua_pushboolean(ctx->cur_co_ctx->co, 0);
+                    lua_insert(ctx->cur_co_ctx->co, 1);
+
+                    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_ZOMBIE;
+                    ctx->cur_co_ctx = NULL;
+                    return NGX_AGAIN;
+                }
+
+                ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);
+                ctx->uthreads--;
+
+                if (ctx->uthreads == 0) {
+                    if (ngx_http_lua_entry_thread_alive(ctx)) {
+                        ctx->cur_co_ctx = NULL;
+                        return NGX_AGAIN;
+                    }
+
+                    /* all threads terminated already */
+                    goto done;
+                }
+
+                /* some other user threads still running */
+                ctx->cur_co_ctx = NULL;
+                return NGX_AGAIN;
+            }
+
+            if (ngx_http_lua_is_entry_thread(ctx)) {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                              "lua entry thread aborted: %s: %s\n%s",
+                              err, msg, trace);
+
+                lua_settop(L, 0);
+
+                /* being the entry thread aborted */
+
+                if (r->filter_finalize) {
+                    ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+                }
+
+                ngx_http_lua_request_cleanup(ctx, 0);
+
+                dd("headers sent? %d", r->header_sent ? 1 : 0);
+
+                if (ctx->no_abort) {
+                    ctx->no_abort = 0;
+                    return NGX_ERROR;
+                }
+
+                return r->header_sent ? NGX_ERROR :
+                       NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            /* being a user coroutine that has a parent */
+
+            next_coctx = ctx->cur_co_ctx->parent_co_ctx;
+            if (next_coctx == NULL) {
+                goto no_parent;
+            }
+
+            next_co = next_coctx->co;
+
+            ngx_http_lua_probe_info("set parent running");
+
+            next_coctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+
+            /*
+             * ended with error, coroutine.resume returns false plus
+             * err msg
+             */
+            lua_pushboolean(next_co, 0);
+            lua_xmove(ctx->cur_co_ctx->co, next_co, 1);
+            nrets = 2;
+
+            ctx->cur_co_ctx = next_coctx;
+
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                          "lua coroutine: %s: %s\n%s", err, msg, trace);
+
+            /* try resuming on the new coroutine again */
+            continue;
+        }
+
+    } NGX_LUA_EXCEPTION_CATCH {
+        dd("nginx execution restored");
+    }
+
+    return NGX_ERROR;
+
+no_parent:
+    lua_settop(L, 0);
+
+    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+    if (r->filter_finalize) {
+        ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+    }
+
+    ngx_http_lua_request_cleanup(ctx, 0);
+
+    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "lua handler aborted: "
+                  "user coroutine has no parent");
+
+    return r->header_sent ? NGX_ERROR : NGX_HTTP_INTERNAL_SERVER_ERROR;
+
+done:
+    if (ctx->entered_content_phase && r->connection->fd != -1) {
+        rc = ngx_http_lua_send_chain_link(r, ctx,
+                                          NULL /* last_buf */);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_lua_wev_handler(ngx_http_request_t *r)
+{
+    ngx_int_t                    rc;
+    ngx_event_t                 *wev;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_co_ctx_t       *coctx;
+    ngx_http_core_loc_conf_t    *clcf;
+
+    ngx_http_lua_socket_tcp_upstream_t *u;
+
+    c = r->connection;
+    wev = c->write;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua run write event handler: timedout:%ud, ready:%ud, "
+                   "writing_raw_req_socket:%ud",
+                   wev->timedout, wev->ready, ctx->writing_raw_req_socket);
+
+    clcf = ngx_http_get_module_loc_conf(r->main, ngx_http_core_module);
+
+    if (wev->timedout && !ctx->writing_raw_req_socket) {
+        if (!wev->delayed) {
+            ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
+                          "client timed out");
+            c->timedout = 1;
+
+            if (ctx->entered_content_phase) {
+                ngx_http_lua_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);
+            }
+
+            return NGX_HTTP_REQUEST_TIME_OUT;
+        }
+
+        wev->timedout = 0;
+        wev->delayed = 0;
+
+        if (!wev->ready) {
+            ngx_add_timer(wev, clcf->send_timeout);
+
+            if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {
+                if (ctx->entered_content_phase) {
+                    ngx_http_lua_finalize_request(r, NGX_ERROR);
+                }
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    if (!wev->ready && !wev->timedout) {
+        goto useless;
+    }
+
+    if (ctx->writing_raw_req_socket) {
+        ctx->writing_raw_req_socket = 0;
+
+        coctx = ctx->downstream_co_ctx;
+        if (coctx == NULL) {
+            return NGX_ERROR;
+        }
+
+        u = coctx->data;
+        if (u == NULL) {
+            return NGX_ERROR;
+        }
+
+        u->write_event_handler(r, u);
+        return NGX_DONE;
+    }
+
+    if (c->buffered) {
+        rc = ngx_http_lua_flush_pending_output(r, ctx);
+        if (rc != NGX_OK) {
+            return rc;
+        }
+    }
+
+    if (ctx->flushing_coros) {
+        return ngx_http_lua_process_flushing_coroutines(r, ctx);
+    }
+
+    /* ctx->flushing_coros == 0 */
+
+useless:
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "useless lua write event handler");
+
+    if (ctx->entered_content_phase) {
+        return NGX_OK;
+    }
+
+    return NGX_DONE;
+}
+
+
+static ngx_int_t
+ngx_http_lua_process_flushing_coroutines(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t                    rc, n;
+    ngx_uint_t                   i;
+    ngx_list_part_t             *part;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    dd("processing flushing coroutines");
+
+    coctx = &ctx->entry_co_ctx;
+    n = ctx->flushing_coros;
+
+    if (coctx->flushing) {
+        coctx->flushing = 0;
+
+        ctx->flushing_coros--;
+        n--;
+        ctx->cur_co_ctx = coctx;
+
+        rc = ngx_http_lua_flush_resume_helper(r, ctx);
+        if (rc == NGX_ERROR || rc >= NGX_OK) {
+            return rc;
+        }
+
+        /* rc == NGX_DONE */
+    }
+
+    if (n) {
+
+        if (ctx->user_co_ctx == NULL) {
+            return NGX_ERROR;
+        }
+
+        part = &ctx->user_co_ctx->part;
+        coctx = part->elts;
+
+        for (i = 0; /* void */; i++) {
+
+            if (i >= part->nelts) {
+                if (part->next == NULL) {
+                    break;
+                }
+
+                part = part->next;
+                coctx = part->elts;
+                i = 0;
+            }
+
+            if (coctx[i].flushing) {
+                coctx[i].flushing = 0;
+                ctx->cur_co_ctx = &coctx[i];
+
+                rc = ngx_http_lua_flush_resume_helper(r, ctx);
+                if (rc == NGX_ERROR || rc >= NGX_OK) {
+                    return rc;
+                }
+
+                /* rc == NGX_DONE */
+
+                ctx->flushing_coros--;
+                n--;
+                if (n == 0) {
+                    return NGX_DONE;
+                }
+            }
+        }
+    }
+
+    if (n) {
+        return NGX_ERROR;
+    }
+
+    return NGX_DONE;
+}
+
+
+static ngx_int_t
+ngx_http_lua_flush_pending_output(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t           rc;
+    ngx_chain_t        *cl;
+    ngx_event_t        *wev;
+    ngx_connection_t   *c;
+
+    ngx_http_core_loc_conf_t    *clcf;
+
+    c = r->connection;
+    wev = c->write;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "lua flushing output: buffered 0x%uxd",
+                   c->buffered);
+
+    rc = ngx_http_lua_output_filter(r, NULL);
+
+    if (rc == NGX_ERROR || rc > NGX_OK) {
+        if (ctx->entered_content_phase) {
+            ngx_http_lua_finalize_request(r, rc);
+        }
+
+        return rc;
+    }
+
+    if (ctx->busy_bufs) {
+        cl = NULL;
+
+        dd("updating chains...");
+
+#if nginx_version >= 1001004
+        ngx_chain_update_chains(r->pool,
+#else
+        ngx_chain_update_chains(
+#endif
+                                &ctx->free_bufs, &ctx->busy_bufs, &cl,
+                                (ngx_buf_tag_t) &ngx_http_lua_module);
+
+        dd("update lua buf tag: %p, buffered: %x, busy bufs: %p",
+            &ngx_http_lua_module, (int) c->buffered, ctx->busy_bufs);
+    }
+
+    if (c->buffered) {
+
+        clcf = ngx_http_get_module_loc_conf(r->main, ngx_http_core_module);
+
+        if (!wev->delayed) {
+            ngx_add_timer(wev, clcf->send_timeout);
+        }
+
+        if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {
+            if (ctx->entered_content_phase) {
+                ngx_http_lua_finalize_request(r, NGX_ERROR);
+            }
+
+            return NGX_ERROR;
+        }
+
+        if (ctx->flushing_coros) {
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                           "lua flush still waiting: buffered 0x%uxd",
+                           c->buffered);
+
+            return NGX_DONE;
+        }
+
+    } else {
+#if 1
+        if (wev->timer_set) {
+            ngx_del_timer(wev);
+        }
+#endif
+    }
+
+    return NGX_OK;
+}
+
+
+u_char *
+ngx_http_lua_digest_hex(u_char *dest, const u_char *buf, int buf_len)
+{
+    ngx_md5_t                     md5;
+    u_char                        md5_buf[MD5_DIGEST_LENGTH];
+
+    ngx_md5_init(&md5);
+    ngx_md5_update(&md5, buf, buf_len);
+    ngx_md5_final(md5_buf, &md5);
+
+    return ngx_hex_dump(dest, md5_buf, sizeof(md5_buf));
+}
+
+
+void
+ngx_http_lua_set_multi_value_table(lua_State *L, int index)
+{
+    if (index < 0) {
+        index = lua_gettop(L) + index + 1;
+    }
+
+    lua_pushvalue(L, -2); /* stack: table key value key */
+    lua_rawget(L, index);
+    if (lua_isnil(L, -1)) {
+        lua_pop(L, 1); /* stack: table key value */
+        lua_rawset(L, index); /* stack: table */
+
+    } else {
+        if (!lua_istable(L, -1)) {
+            /* just inserted one value */
+            lua_createtable(L, 4, 0);
+                /* stack: table key value value table */
+            lua_insert(L, -2);
+                /* stack: table key value table value */
+            lua_rawseti(L, -2, 1);
+                /* stack: table key value table */
+            lua_insert(L, -2);
+                /* stack: table key table value */
+
+            lua_rawseti(L, -2, 2); /* stack: table key table */
+
+            lua_rawset(L, index); /* stack: table */
+
+        } else {
+            /* stack: table key value table */
+            lua_insert(L, -2); /* stack: table key table value */
+
+            lua_rawseti(L, -2, lua_objlen(L, -2) + 1);
+                /* stack: table key table  */
+            lua_pop(L, 2); /* stack: table */
+        }
+    }
+}
+
+
+uintptr_t
+ngx_http_lua_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)
+{
+    ngx_uint_t      n;
+    uint32_t       *escape;
+    static u_char   hex[] = "0123456789abcdef";
+
+                    /* " ", "#", "%", "?", %00-%1F, %7F-%FF */
+
+    static uint32_t   uri[] = {
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+
+                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #"!  */
+        0xfc00886d, /* 1111 1100 0000 0000  1000 1000 0110 1101 */
+
+                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
+        0x78000000, /* 0111 1000 0000 0000  0000 0000 0000 0000 */
+
+                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
+        0xa8000000, /* 1010 1000 0000 0000  0000 0000 0000 0000 */
+
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+    };
+
+                    /* " ", "#", "%", "+", "?", %00-%1F, %7F-%FF */
+
+    static uint32_t   args[] = {
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+
+                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #"!  */
+        0x80000829, /* 1000 0000 0000 0000  0000 1000 0010 1001 */
+
+                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+
+                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
+        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */
+
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+    };
+
+                    /* " ", "#", """, "%", "'", %00-%1F, %7F-%FF */
+
+    static uint32_t   html[] = {
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+
+                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #"!  */
+        0x000000ad, /* 0000 0000 0000 0000  0000 0000 1010 1101 */
+
+                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+
+                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
+        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */
+
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+    };
+
+                    /* " ", """, "%", "'", %00-%1F, %7F-%FF */
+
+    static uint32_t   refresh[] = {
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+
+                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #"!  */
+        0x00000085, /* 0000 0000 0000 0000  0000 0000 1000 0101 */
+
+                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+
+                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
+        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */
+
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+    };
+
+                    /* " ", "%", %00-%1F */
+
+    static uint32_t   memcached[] = {
+        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
+
+                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #"!  */
+        0x00000021, /* 0000 0000 0000 0000  0000 0000 0010 0001 */
+
+                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+
+                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */
+    };
+
+                    /* mail_auth is the same as memcached */
+
+    static uint32_t  *map[] =
+        { uri, args, html, refresh, memcached, memcached };
+
+
+    escape = map[type];
+
+    if (dst == NULL) {
+
+        /* find the number of the characters to be escaped */
+
+        n = 0;
+
+        while (size) {
+            if (escape[*src >> 5] & (1 << (*src & 0x1f))) {
+                n++;
+            }
+            src++;
+            size--;
+        }
+
+        return (uintptr_t) n;
+    }
+
+    while (size) {
+        if (escape[*src >> 5] & (1 << (*src & 0x1f))) {
+            *dst++ = '%';
+            *dst++ = hex[*src >> 4];
+            *dst++ = hex[*src & 0xf];
+            src++;
+
+        } else {
+            *dst++ = *src++;
+        }
+        size--;
+    }
+
+    return (uintptr_t) dst;
+}
+
+
+/* XXX we also decode '+' to ' ' */
+void
+ngx_http_lua_unescape_uri(u_char **dst, u_char **src, size_t size,
+    ngx_uint_t type)
+{
+    u_char  *d, *s, ch, c, decoded;
+    enum {
+        sw_usual = 0,
+        sw_quoted,
+        sw_quoted_second
+    } state;
+
+    d = *dst;
+    s = *src;
+
+    state = 0;
+    decoded = 0;
+
+    while (size--) {
+
+        ch = *s++;
+
+        switch (state) {
+        case sw_usual:
+            if (ch == '?'
+                && (type & (NGX_UNESCAPE_URI|NGX_UNESCAPE_REDIRECT)))
+            {
+                *d++ = ch;
+                goto done;
+            }
+
+            if (ch == '%') {
+                state = sw_quoted;
+                break;
+            }
+
+            if (ch == '+') {
+                *d++ = ' ';
+                break;
+            }
+
+            *d++ = ch;
+            break;
+
+        case sw_quoted:
+
+            if (ch >= '0' && ch <= '9') {
+                decoded = (u_char) (ch - '0');
+                state = sw_quoted_second;
+                break;
+            }
+
+            c = (u_char) (ch | 0x20);
+            if (c >= 'a' && c <= 'f') {
+                decoded = (u_char) (c - 'a' + 10);
+                state = sw_quoted_second;
+                break;
+            }
+
+            /* the invalid quoted character */
+
+            state = sw_usual;
+
+            *d++ = ch;
+
+            break;
+
+        case sw_quoted_second:
+
+            state = sw_usual;
+
+            if (ch >= '0' && ch <= '9') {
+                ch = (u_char) ((decoded << 4) + ch - '0');
+
+                if (type & NGX_UNESCAPE_REDIRECT) {
+                    if (ch > '%' && ch < 0x7f) {
+                        *d++ = ch;
+                        break;
+                    }
+
+                    *d++ = '%'; *d++ = *(s - 2); *d++ = *(s - 1);
+                    break;
+                }
+
+                *d++ = ch;
+
+                break;
+            }
+
+            c = (u_char) (ch | 0x20);
+            if (c >= 'a' && c <= 'f') {
+                ch = (u_char) ((decoded << 4) + c - 'a' + 10);
+
+                if (type & NGX_UNESCAPE_URI) {
+                    if (ch == '?') {
+                        *d++ = ch;
+                        goto done;
+                    }
+
+                    *d++ = ch;
+                    break;
+                }
+
+                if (type & NGX_UNESCAPE_REDIRECT) {
+                    if (ch == '?') {
+                        *d++ = ch;
+                        goto done;
+                    }
+
+                    if (ch > '%' && ch < 0x7f) {
+                        *d++ = ch;
+                        break;
+                    }
+
+                    *d++ = '%'; *d++ = *(s - 2); *d++ = *(s - 1);
+                    break;
+                }
+
+                *d++ = ch;
+
+                break;
+            }
+
+            /* the invalid quoted character */
+
+            break;
+        }
+    }
+
+done:
+
+    *dst = d;
+    *src = s;
+}
+
+
+void
+ngx_http_lua_inject_req_api(ngx_log_t *log, lua_State *L)
+{
+    /* ngx.req table */
+
+    lua_createtable(L, 0 /* narr */, 23 /* nrec */);    /* .req */
+
+    ngx_http_lua_inject_req_header_api(log, L);
+    ngx_http_lua_inject_req_uri_api(log, L);
+    ngx_http_lua_inject_req_args_api(L);
+    ngx_http_lua_inject_req_body_api(L);
+    ngx_http_lua_inject_req_socket_api(L);
+    ngx_http_lua_inject_req_method_api(L);
+    ngx_http_lua_inject_req_time_api(L);
+
+    lua_setfield(L, -2, "req");
+}
+
+
+static ngx_int_t
+ngx_http_lua_handle_exec(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t               rc;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua thread initiated internal redirect to %V",
+                   &ctx->exec_uri);
+
+    ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 1);
+
+    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+    if (r->filter_finalize) {
+        ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+    }
+
+    ngx_http_lua_request_cleanup(ctx, 1 /* forcible */);
+
+    if (ctx->exec_uri.data[0] == '@') {
+        if (ctx->exec_args.len > 0) {
+            ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                          "query strings %V ignored when exec'ing "
+                          "named location %V",
+                          &ctx->exec_args, &ctx->exec_uri);
+        }
+
+        r->write_event_handler = ngx_http_request_empty_handler;
+
+#if 1
+        if (r->read_event_handler == ngx_http_lua_rd_check_broken_connection) {
+            /* resume the read event handler */
+
+            r->read_event_handler = ngx_http_block_reading;
+        }
+#endif
+
+#if 1
+        /* clear the modules contexts */
+        ngx_memzero(r->ctx, sizeof(void *) * ngx_http_max_module);
+#endif
+
+        rc = ngx_http_named_location(r, &ctx->exec_uri);
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE)
+        {
+            return rc;
+        }
+
+#if 0
+        if (!ctx->entered_content_phase) {
+            /* XXX ensure the main request ref count
+             * is decreased because the current
+             * request will be quit */
+            r->main->count--;
+            dd("XXX decrement main count: c:%d", (int) r->main->count);
+        }
+#endif
+
+        return NGX_DONE;
+    }
+
+    dd("internal redirect to %.*s", (int) ctx->exec_uri.len,
+            ctx->exec_uri.data);
+
+    r->write_event_handler = ngx_http_request_empty_handler;
+
+    if (r->read_event_handler == ngx_http_lua_rd_check_broken_connection) {
+        /* resume the read event handler */
+
+        r->read_event_handler = ngx_http_block_reading;
+    }
+
+    rc = ngx_http_internal_redirect(r, &ctx->exec_uri, &ctx->exec_args);
+
+    dd("internal redirect returned %d when in content phase? "
+            "%d", (int) rc, ctx->entered_content_phase);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+#if 0
+    if (!ctx->entered_content_phase) {
+        /* XXX ensure the main request ref count
+         * is decreased because the current
+         * request will be quit */
+        dd("XXX decrement main count");
+        r->main->count--;
+    }
+#endif
+
+    return NGX_DONE;
+}
+
+
+static ngx_int_t
+ngx_http_lua_handle_exit(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t           rc;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua thread aborting request with status %d",
+                   ctx->exit_code);
+
+#if 1
+    if (!r->header_sent
+        && r->headers_out.status == 0
+        && ctx->exit_code >= NGX_HTTP_OK)
+    {
+        r->headers_out.status = ctx->exit_code;
+    }
+#endif
+
+    ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 1);
+
+    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+    if (r->filter_finalize) {
+        ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+    }
+
+    ngx_http_lua_request_cleanup(ctx, 0);
+
+    if (ctx->buffering && r->headers_out.status) {
+        rc = ngx_http_lua_send_chain_link(r, ctx, NULL /* indicate last_buf */);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+
+        if (ctx->exit_code >= NGX_HTTP_OK) {
+            return NGX_HTTP_OK;
+        }
+
+        return ctx->exit_code;
+    }
+
+    if ((ctx->exit_code == NGX_OK
+         && ctx->entered_content_phase)
+        || (ctx->exit_code >= NGX_HTTP_OK
+            && ctx->exit_code < NGX_HTTP_SPECIAL_RESPONSE
+            && ctx->exit_code != NGX_HTTP_NO_CONTENT))
+    {
+        rc = ngx_http_lua_send_chain_link(r, ctx, NULL /* indicate last_buf */);
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+    }
+
+    return ctx->exit_code;
+}
+
+
+void
+ngx_http_lua_process_args_option(ngx_http_request_t *r, lua_State *L,
+    int table, ngx_str_t *args)
+{
+    u_char              *key;
+    size_t               key_len;
+    u_char              *value;
+    size_t               value_len;
+    size_t               len = 0;
+    size_t               key_escape = 0;
+    uintptr_t            total_escape = 0;
+    int                  n;
+    int                  i;
+    u_char              *p;
+
+    if (table < 0) {
+        table = lua_gettop(L) + table + 1;
+    }
+
+    n = 0;
+    lua_pushnil(L);
+    while (lua_next(L, table) != 0) {
+        if (lua_type(L, -2) != LUA_TSTRING) {
+            luaL_error(L, "attempt to use a non-string key in the "
+                       "\"args\" option table");
+            return;
+        }
+
+        key = (u_char *) lua_tolstring(L, -2, &key_len);
+
+        key_escape = 2 * ngx_http_lua_escape_uri(NULL, key, key_len,
+                                                 NGX_ESCAPE_URI);
+        total_escape += key_escape;
+
+        switch (lua_type(L, -1)) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+            value = (u_char *) lua_tolstring(L, -1, &value_len);
+
+            total_escape += 2 * ngx_http_lua_escape_uri(NULL, value, value_len,
+                    NGX_ESCAPE_URI);
+
+            len += key_len + value_len + (sizeof("=") - 1);
+            n++;
+
+            break;
+
+        case LUA_TBOOLEAN:
+            if (lua_toboolean(L, -1)) {
+                len += key_len;
+                n++;
+            }
+
+            break;
+
+        case LUA_TTABLE:
+
+            i = 0;
+            lua_pushnil(L);
+            while (lua_next(L, -2) != 0) {
+                if (lua_isboolean(L, -1)) {
+                    if (lua_toboolean(L, -1)) {
+                        len += key_len;
+
+                    } else {
+                        lua_pop(L, 1);
+                        continue;
+                    }
+
+                } else {
+                    value = (u_char *) lua_tolstring(L, -1, &value_len);
+
+                    if (value == NULL) {
+                        luaL_error(L, "attempt to use %s as query arg value",
+                                   luaL_typename(L, -1));
+                        return;
+                    }
+
+                    total_escape +=
+                        2 * ngx_http_lua_escape_uri(NULL, value,
+                                                    value_len,
+                                                    NGX_ESCAPE_URI);
+
+                    len += key_len + value_len + (sizeof("=") - 1);
+                }
+
+                if (i++ > 0) {
+                    total_escape += key_escape;
+                }
+
+                n++;
+                lua_pop(L, 1);
+            }
+
+            break;
+
+        default:
+            luaL_error(L, "attempt to use %s as query arg value",
+                       luaL_typename(L, -1));
+            return;
+        }
+
+        lua_pop(L, 1);
+    }
+
+    len += (size_t) total_escape;
+
+    if (n > 1) {
+        len += (n - 1) * (sizeof("&") - 1);
+    }
+
+    dd("len 1: %d", (int) len);
+
+    if (r) {
+        p = ngx_palloc(r->pool, len);
+        if (p == NULL) {
+            luaL_error(L, "out of memory");
+            return;
+        }
+
+    } else {
+        p = lua_newuserdata(L, len);
+    }
+
+    args->data = p;
+    args->len = len;
+
+    i = 0;
+    lua_pushnil(L);
+    while (lua_next(L, table) != 0) {
+        key = (u_char *) lua_tolstring(L, -2, &key_len);
+
+        switch (lua_type(L, -1)) {
+        case LUA_TNUMBER:
+        case LUA_TSTRING:
+
+            if (total_escape) {
+                p = (u_char *) ngx_http_lua_escape_uri(p, key, key_len,
+                                                       NGX_ESCAPE_URI);
+
+            } else {
+                dd("shortcut: no escape required");
+
+                p = ngx_copy(p, key, key_len);
+            }
+
+            *p++ = '=';
+
+            value = (u_char *) lua_tolstring(L, -1, &value_len);
+
+            if (total_escape) {
+                p = (u_char *) ngx_http_lua_escape_uri(p, value, value_len,
+                                                       NGX_ESCAPE_URI);
+
+            } else {
+                p = ngx_copy(p, value, value_len);
+            }
+
+            if (i != n - 1) {
+                /* not the last pair */
+                *p++ = '&';
+            }
+
+            i++;
+
+            break;
+
+        case LUA_TBOOLEAN:
+            if (lua_toboolean(L, -1)) {
+                if (total_escape) {
+                    p = (u_char *) ngx_http_lua_escape_uri(p, key, key_len,
+                                                           NGX_ESCAPE_URI);
+
+                } else {
+                    dd("shortcut: no escape required");
+
+                    p = ngx_copy(p, key, key_len);
+                }
+
+                if (i != n - 1) {
+                    /* not the last pair */
+                    *p++ = '&';
+                }
+
+                i++;
+            }
+
+            break;
+
+        case LUA_TTABLE:
+
+            lua_pushnil(L);
+            while (lua_next(L, -2) != 0) {
+
+                if (lua_isboolean(L, -1)) {
+                    if (lua_toboolean(L, -1)) {
+                        if (total_escape) {
+                            p = (u_char *) ngx_http_lua_escape_uri(p, key,
+    key_len,
+    NGX_ESCAPE_URI);
+
+                        } else {
+                            dd("shortcut: no escape required");
+
+                            p = ngx_copy(p, key, key_len);
+                        }
+
+                    } else {
+                        lua_pop(L, 1);
+                        continue;
+                    }
+
+                } else {
+
+                    if (total_escape) {
+                        p = (u_char *)
+                                ngx_http_lua_escape_uri(p, key,
+                                                        key_len,
+                                                        NGX_ESCAPE_URI);
+
+                    } else {
+                        dd("shortcut: no escape required");
+
+                        p = ngx_copy(p, key, key_len);
+                    }
+
+                    *p++ = '=';
+
+                    value = (u_char *) lua_tolstring(L, -1, &value_len);
+
+                    if (total_escape) {
+                        p = (u_char *)
+                                ngx_http_lua_escape_uri(p, value,
+                                                        value_len,
+                                                        NGX_ESCAPE_URI);
+
+                    } else {
+                        p = ngx_copy(p, value, value_len);
+                    }
+                }
+
+                if (i != n - 1) {
+                    /* not the last pair */
+                    *p++ = '&';
+                }
+
+                i++;
+                lua_pop(L, 1);
+            }
+
+            break;
+
+        default:
+            luaL_error(L, "should not reach here");
+            return;
+        }
+
+        lua_pop(L, 1);
+    }
+
+    if (p - args->data != (ssize_t) len) {
+        luaL_error(L, "buffer error: %d != %d",
+                (int) (p - args->data), (int) len);
+        return;
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_handle_rewrite_jump(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx)
+{
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua thread aborting request with URI rewrite jump: "
+                   "\"%V?%V\"", &r->uri, &r->args);
+
+    ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 1);
+
+    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+
+    if (r->filter_finalize) {
+        ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+    }
+
+    ngx_http_lua_request_cleanup(ctx, 1 /* forcible */);
+    ngx_http_lua_init_ctx(r, ctx);
+
+    return NGX_OK;
+}
+
+
+/* XXX ngx_open_and_stat_file is static in the core. sigh. */
+ngx_int_t
+ngx_http_lua_open_and_stat_file(u_char *name, ngx_open_file_info_t *of,
+    ngx_log_t *log)
+{
+    ngx_fd_t         fd;
+    ngx_file_info_t  fi;
+
+    if (of->fd != NGX_INVALID_FILE) {
+
+        if (ngx_file_info(name, &fi) == NGX_FILE_ERROR) {
+            of->failed = ngx_file_info_n;
+            goto failed;
+        }
+
+        if (of->uniq == ngx_file_uniq(&fi)) {
+            goto done;
+        }
+
+    } else if (of->test_dir) {
+
+        if (ngx_file_info(name, &fi) == NGX_FILE_ERROR) {
+            of->failed = ngx_file_info_n;
+            goto failed;
+        }
+
+        if (ngx_is_dir(&fi)) {
+            goto done;
+        }
+    }
+
+    if (!of->log) {
+
+        /*
+         * Use non-blocking open() not to hang on FIFO files, etc.
+         * This flag has no effect on a regular files.
+         */
+
+        fd = ngx_open_file(name, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,
+                           NGX_FILE_OPEN, 0);
+
+    } else {
+        fd = ngx_open_file(name, NGX_FILE_APPEND, NGX_FILE_CREATE_OR_OPEN,
+                           NGX_FILE_DEFAULT_ACCESS);
+    }
+
+    if (fd == NGX_INVALID_FILE) {
+        of->failed = ngx_open_file_n;
+        goto failed;
+    }
+
+    if (ngx_fd_info(fd, &fi) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,
+                      ngx_fd_info_n " \"%s\" failed", name);
+
+        if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                          ngx_close_file_n " \"%s\" failed", name);
+        }
+
+        of->fd = NGX_INVALID_FILE;
+
+        return NGX_ERROR;
+    }
+
+    if (ngx_is_dir(&fi)) {
+        if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                          ngx_close_file_n " \"%s\" failed", name);
+        }
+
+        of->fd = NGX_INVALID_FILE;
+
+    } else {
+        of->fd = fd;
+
+        if (of->directio <= ngx_file_size(&fi)) {
+            if (ngx_directio_on(fd) == NGX_FILE_ERROR) {
+                ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                              ngx_directio_on_n " \"%s\" failed", name);
+
+            } else {
+                of->is_directio = 1;
+            }
+        }
+    }
+
+done:
+
+    of->uniq = ngx_file_uniq(&fi);
+    of->mtime = ngx_file_mtime(&fi);
+    of->size = ngx_file_size(&fi);
+#if defined(nginx_version) && nginx_version >= 1000001
+    of->fs_size = ngx_file_fs_size(&fi);
+#endif
+    of->is_dir = ngx_is_dir(&fi);
+    of->is_file = ngx_is_file(&fi);
+    of->is_link = ngx_is_link(&fi);
+    of->is_exec = ngx_is_exec(&fi);
+
+    return NGX_OK;
+
+failed:
+
+    of->fd = NGX_INVALID_FILE;
+    of->err = ngx_errno;
+
+    return NGX_ERROR;
+}
+
+
+ngx_chain_t *
+ngx_http_lua_chains_get_free_buf(ngx_log_t *log, ngx_pool_t *p,
+    ngx_chain_t **free, size_t len, ngx_buf_tag_t tag)
+{
+    ngx_chain_t  *cl;
+    ngx_buf_t    *b;
+
+    if (*free) {
+        cl = *free;
+        *free = cl->next;
+        cl->next = NULL;
+
+        b = cl->buf;
+        if ((size_t) (b->end - b->start) >= len) {
+            ngx_log_debug4(NGX_LOG_DEBUG_HTTP, log, 0,
+                           "lua reuse free buf memory %O >= %uz, cl:%p, p:%p",
+                           (off_t) (b->end - b->start), len, cl, b->start);
+
+            b->pos = b->start;
+            b->last = b->start;
+            b->tag = tag;
+            return cl;
+        }
+
+        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, log, 0,
+                       "lua reuse free buf chain, but reallocate memory "
+                       "because %uz >= %O, cl:%p, p:%p", len,
+                       (off_t) (b->end - b->start), cl, b->start);
+
+        if (ngx_buf_in_memory(b) && b->start) {
+            ngx_pfree(p, b->start);
+        }
+
+        if (len) {
+            b->start = ngx_palloc(p, len);
+            if (b->start == NULL) {
+                return NULL;
+            }
+
+            b->end = b->start + len;
+
+        } else {
+            b->last = NULL;
+            b->end = NULL;
+        }
+
+        dd("buf start: %p", cl->buf->start);
+
+        b->pos = b->start;
+        b->last = b->start;
+        b->tag = tag;
+
+        return cl;
+    }
+
+    cl = ngx_alloc_chain_link(p);
+    if (cl == NULL) {
+        return NULL;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
+                   "lua allocate new chainlink and new buf of size %uz, cl:%p",
+                   len, cl);
+
+    cl->buf = ngx_create_temp_buf(p, len);
+    if (cl->buf == NULL) {
+        return NULL;
+    }
+
+    dd("buf start: %p", cl->buf->start);
+
+    cl->buf->tag = tag;
+    cl->next = NULL;
+
+    return cl;
+}
+
+
+static int
+ngx_http_lua_thread_traceback(lua_State *L, lua_State *co,
+    ngx_http_lua_co_ctx_t *coctx)
+{
+    int         base;
+    int         level, coid;
+    lua_Debug   ar;
+
+    base = lua_gettop(L);
+    lua_pushliteral(L, "stack traceback:");
+    coid = 0;
+
+    while (co) {
+
+        if (coid >= NGX_HTTP_LUA_BT_MAX_COROS) {
+            break;
+        }
+
+        lua_pushfstring(L, "\ncoroutine %d:", coid++);
+
+        level = 0;
+
+        while (lua_getstack(co, level++, &ar)) {
+
+            if (level > NGX_HTTP_LUA_BT_DEPTH) {
+                lua_pushliteral(L, "\n\t...");
+                break;
+            }
+
+            lua_pushliteral(L, "\n\t");
+            lua_getinfo(co, "Snl", &ar);
+            lua_pushfstring(L, "%s:", ar.short_src);
+
+            if (ar.currentline > 0) {
+                lua_pushfstring(L, "%d:", ar.currentline);
+            }
+
+            if (*ar.namewhat != '\0') {  /* is there a name? */
+                lua_pushfstring(L, " in function " LUA_QS, ar.name);
+
+            } else {
+                if (*ar.what == 'm') {  /* main? */
+                    lua_pushfstring(L, " in main chunk");
+
+                } else if (*ar.what == 'C' || *ar.what == 't') {
+                    lua_pushliteral(L, " ?");  /* C function or tail call */
+
+                } else {
+                    lua_pushfstring(L, " in function <%s:%d>",
+                                    ar.short_src, ar.linedefined);
+                }
+            }
+        }
+
+        if (lua_gettop(L) - base >= 15) {
+            lua_concat(L, lua_gettop(L) - base);
+        }
+
+        /* check if the coroutine has a parent coroutine*/
+        coctx = coctx->parent_co_ctx;
+        if (!coctx || coctx->co_status == NGX_HTTP_LUA_CO_DEAD) {
+            break;
+        }
+
+        co = coctx->co;
+    }
+
+    lua_concat(L, lua_gettop(L) - base);
+    return 1;
+}
+
+
+int
+ngx_http_lua_traceback(lua_State *L)
+{
+    if (!lua_isstring(L, 1)) { /* 'message' not a string? */
+        return 1;  /* keep it intact */
+    }
+
+    lua_getfield(L, LUA_GLOBALSINDEX, "debug");
+    if (!lua_istable(L, -1)) {
+        lua_pop(L, 1);
+        return 1;
+    }
+
+    lua_getfield(L, -1, "traceback");
+    if (!lua_isfunction(L, -1)) {
+        lua_pop(L, 2);
+        return 1;
+    }
+
+    lua_pushvalue(L, 1);  /* pass error message */
+    lua_pushinteger(L, 2);  /* skip this function and traceback */
+    lua_call(L, 2, 1);  /* call debug.traceback */
+    return 1;
+}
+
+
+static void
+ngx_http_lua_inject_arg_api(lua_State *L)
+{
+    lua_pushliteral(L, "arg");
+    lua_newtable(L);    /*  .arg table aka {} */
+
+    lua_createtable(L, 0 /* narr */, 2 /* nrec */);    /*  the metatable */
+
+    lua_pushcfunction(L, ngx_http_lua_param_get);
+    lua_setfield(L, -2, "__index");
+
+    lua_pushcfunction(L, ngx_http_lua_param_set);
+    lua_setfield(L, -2, "__newindex");
+
+    lua_setmetatable(L, -2);    /*  tie the metatable to param table */
+
+    dd("top: %d, type -1: %s", lua_gettop(L), luaL_typename(L, -1));
+
+    lua_rawset(L, -3);    /*  set ngx.arg table */
+}
+
+
+static int
+ngx_http_lua_param_get(lua_State *L)
+{
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_request_t          *r;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return 0;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "ctx not found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_SET
+                               | NGX_HTTP_LUA_CONTEXT_BODY_FILTER);
+
+    if (ctx->context & (NGX_HTTP_LUA_CONTEXT_SET)) {
+        return ngx_http_lua_setby_param_get(L);
+    }
+
+    /* ctx->context & (NGX_HTTP_LUA_CONTEXT_BODY_FILTER) */
+
+    return ngx_http_lua_body_filter_param_get(L);
+}
+
+
+static int
+ngx_http_lua_param_set(lua_State *L)
+{
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_request_t          *r;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return 0;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return luaL_error(L, "ctx not found");
+    }
+
+    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_BODY_FILTER);
+
+    return ngx_http_lua_body_filter_param_set(L, r, ctx);
+}
+
+
+ngx_http_lua_co_ctx_t *
+ngx_http_lua_get_co_ctx(lua_State *L, ngx_http_lua_ctx_t *ctx)
+{
+    ngx_uint_t                   i;
+    ngx_list_part_t             *part;
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    if (L == ctx->entry_co_ctx.co) {
+        return &ctx->entry_co_ctx;
+    }
+
+    if (ctx->user_co_ctx == NULL) {
+        return NULL;
+    }
+
+    part = &ctx->user_co_ctx->part;
+    coctx = part->elts;
+
+    /* FIXME: we should use rbtree here to prevent O(n) lookup overhead */
+
+    for (i = 0; /* void */; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            coctx = part->elts;
+            i = 0;
+        }
+
+        if (coctx[i].co == L) {
+            return &coctx[i];
+        }
+    }
+
+    return NULL;
+}
+
+
+ngx_http_lua_co_ctx_t *
+ngx_http_lua_create_co_ctx(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)
+{
+    ngx_http_lua_co_ctx_t       *coctx;
+
+    if (ctx->user_co_ctx == NULL) {
+        ctx->user_co_ctx = ngx_list_create(r->pool, 4,
+                                           sizeof(ngx_http_lua_co_ctx_t));
+        if (ctx->user_co_ctx == NULL) {
+            return NULL;
+        }
+    }
+
+    coctx = ngx_list_push(ctx->user_co_ctx);
+    if (coctx == NULL) {
+        return NULL;
+    }
+
+    ngx_memzero(coctx, sizeof(ngx_http_lua_co_ctx_t));
+
+    coctx->co_ref = LUA_NOREF;
+
+    return coctx;
+}
+
+
+/* this is for callers other than the content handler */
+ngx_int_t
+ngx_http_lua_run_posted_threads(ngx_connection_t *c, lua_State *L,
+    ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)
+{
+    ngx_int_t                        rc;
+    ngx_http_lua_posted_thread_t    *pt;
+
+    for ( ;; ) {
+        if (c->destroyed) {
+            return NGX_DONE;
+        }
+
+        pt = ctx->posted_threads;
+        if (pt == NULL) {
+            return NGX_DONE;
+        }
+
+        ctx->posted_threads = pt->next;
+
+        ngx_http_lua_probe_run_posted_thread(r, pt->co_ctx->co,
+                                             (int) pt->co_ctx->co_status);
+
+        if (pt->co_ctx->co_status != NGX_HTTP_LUA_CO_RUNNING) {
+            continue;
+        }
+
+        ctx->cur_co_ctx = pt->co_ctx;
+
+        rc = ngx_http_lua_run_thread(L, r, ctx, 0);
+
+        if (rc == NGX_AGAIN) {
+            continue;
+        }
+
+        if (rc == NGX_DONE) {
+            ngx_http_lua_finalize_request(r, NGX_DONE);
+            continue;
+        }
+
+        /* rc == NGX_ERROR || rc >= NGX_OK */
+
+        if (ctx->entered_content_phase) {
+            ngx_http_lua_finalize_request(r, rc);
+        }
+
+        return rc;
+    }
+
+    /* impossible to reach here */
+}
+
+
+ngx_int_t
+ngx_http_lua_post_thread(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx,
+    ngx_http_lua_co_ctx_t *coctx)
+{
+    ngx_http_lua_posted_thread_t  **p;
+    ngx_http_lua_posted_thread_t   *pt;
+
+    pt = ngx_palloc(r->pool, sizeof(ngx_http_lua_posted_thread_t));
+    if (pt == NULL) {
+        return NGX_ERROR;
+    }
+
+    pt->co_ctx = coctx;
+    pt->next = NULL;
+
+    for (p = &ctx->posted_threads; *p; p = &(*p)->next) { /* void */ }
+
+    *p = pt;
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_finalize_coroutines(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)
+{
+    ngx_http_lua_co_ctx_t           *cc, *coctx;
+    ngx_list_part_t                 *part;
+    ngx_uint_t                       i;
+
+    if (ctx->uthreads == 0) {
+        if (ngx_http_lua_is_entry_thread(ctx)) {
+            return;
+        }
+
+        /* the current thread is not the entry thread */
+
+        if (ctx->entry_co_ctx.co_status == NGX_HTTP_LUA_CO_DEAD) {
+            return;
+        }
+    }
+
+    if (ctx->user_co_ctx) {
+        part = &ctx->user_co_ctx->part;
+        cc = part->elts;
+
+        for (i = 0; /* void */; i++) {
+
+            if (i >= part->nelts) {
+                if (part->next == NULL) {
+                    break;
+                }
+
+                part = part->next;
+                cc = part->elts;
+                i = 0;
+            }
+
+            coctx = &cc[i];
+            if (coctx->cleanup) {
+                coctx->cleanup(coctx);
+                coctx->cleanup = NULL;
+                coctx->co_status = NGX_HTTP_LUA_CO_DEAD;
+                /* TODO we could also free the user thread here */
+            }
+        }
+    }
+
+    coctx = &ctx->entry_co_ctx;
+    if (coctx->cleanup) {
+        coctx->cleanup(coctx);
+    }
+}
+
+
+static ngx_int_t
+ngx_http_lua_post_zombie_thread(ngx_http_request_t *r,
+    ngx_http_lua_co_ctx_t *parent, ngx_http_lua_co_ctx_t *thread)
+{
+    ngx_http_lua_posted_thread_t  **p;
+    ngx_http_lua_posted_thread_t   *pt;
+
+    pt = ngx_palloc(r->pool, sizeof(ngx_http_lua_posted_thread_t));
+    if (pt == NULL) {
+        return NGX_ERROR;
+    }
+
+    pt->co_ctx = thread;
+    pt->next = NULL;
+
+    for (p = &parent->zombie_child_threads; *p; p = &(*p)->next) { /* void */ }
+
+    *p = pt;
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_lua_cleanup_zombie_child_uthreads(ngx_http_request_t *r,
+    lua_State *L, ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t *coctx)
+{
+    ngx_http_lua_posted_thread_t   *pt;
+
+    for (pt = coctx->zombie_child_threads; pt; pt = pt->next) {
+        if (pt->co_ctx->co_ref != LUA_NOREF) {
+            ngx_http_lua_del_thread(r, L, ctx, pt->co_ctx);
+            ctx->uthreads--;
+        }
+    }
+
+    coctx->zombie_child_threads = NULL;
+}
+
+
+ngx_int_t
+ngx_http_lua_check_broken_connection(ngx_http_request_t *r, ngx_event_t *ev)
+{
+    int                  n;
+    char                 buf[1];
+    ngx_err_t            err;
+    ngx_int_t            event;
+    ngx_connection_t     *c;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ev->log, 0,
+                   "http lua check client, write event:%d, \"%V\"",
+                   ev->write, &r->uri);
+
+    c = r->connection;
+
+    if (c->error) {
+        if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {
+
+            event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
+
+            if (ngx_del_event(ev, event, 0) != NGX_OK) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+        }
+
+        return NGX_HTTP_CLIENT_CLOSED_REQUEST;
+    }
+
+#if (NGX_HAVE_KQUEUE)
+
+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
+
+        if (!ev->pending_eof) {
+            return NGX_OK;
+        }
+
+        ev->eof = 1;
+
+        if (ev->kq_errno) {
+            ev->error = 1;
+        }
+
+        ngx_log_error(NGX_LOG_INFO, ev->log, ev->kq_errno,
+                      "kevent() reported that client prematurely closed "
+                      "connection");
+
+        return NGX_HTTP_CLIENT_CLOSED_REQUEST;
+    }
+
+#endif
+
+    n = recv(c->fd, buf, 1, MSG_PEEK);
+
+    err = ngx_socket_errno;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ev->log, err,
+                   "http lua recv(): %d", n);
+
+    if (ev->write && (n >= 0 || err == NGX_EAGAIN)) {
+        return NGX_OK;
+    }
+
+    if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {
+        dd("event is active");
+
+        event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
+
+#if 1
+        if (ngx_del_event(ev, event, 0) != NGX_OK) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+#endif
+    }
+
+    dd("HERE %d", (int) n);
+
+    if (n > 0) {
+        return NGX_OK;
+    }
+
+    if (n == -1) {
+        if (err == NGX_EAGAIN) {
+            dd("HERE");
+            return NGX_OK;
+        }
+
+        ev->error = 1;
+
+    } else { /* n == 0 */
+        err = 0;
+    }
+
+    ev->eof = 1;
+
+    ngx_log_error(NGX_LOG_INFO, ev->log, err,
+                  "client prematurely closed connection");
+
+    return NGX_HTTP_CLIENT_CLOSED_REQUEST;
+}
+
+
+void
+ngx_http_lua_rd_check_broken_connection(ngx_http_request_t *r)
+{
+    ngx_int_t                   rc;
+    ngx_event_t                *rev;
+    ngx_http_lua_ctx_t         *ctx;
+
+    if (r->done) {
+        return;
+    }
+
+    rc = ngx_http_lua_check_broken_connection(r, r->connection->read);
+
+    if (rc == NGX_OK) {
+        return;
+    }
+
+    /* rc == NGX_ERROR || rc > NGX_OK */
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return;
+    }
+
+    if (ctx->on_abort_co_ctx == NULL) {
+        r->connection->error = 1;
+        ngx_http_lua_request_cleanup(ctx, 0);
+        ngx_http_lua_finalize_request(r, rc);
+        return;
+    }
+
+    if (ctx->on_abort_co_ctx->co_status != NGX_HTTP_LUA_CO_SUSPENDED) {
+
+        /* on_abort already run for the current request handler */
+
+        rev = r->connection->read;
+
+        if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && rev->active) {
+            if (ngx_del_event(rev, NGX_READ_EVENT, 0) != NGX_OK) {
+                ngx_http_lua_request_cleanup(ctx, 0);
+                ngx_http_lua_finalize_request(r,
+                                              NGX_HTTP_INTERNAL_SERVER_ERROR);
+                return;
+            }
+        }
+
+        return;
+    }
+
+    ctx->uthreads++;
+    ctx->resume_handler = ngx_http_lua_on_abort_resume;
+    ctx->on_abort_co_ctx->co_status = NGX_HTTP_LUA_CO_RUNNING;
+    ctx->cur_co_ctx = ctx->on_abort_co_ctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua waking up the on_abort callback thread");
+
+    if (ctx->entered_content_phase) {
+        r->write_event_handler = ngx_http_lua_content_wev_handler;
+
+    } else {
+        r->write_event_handler = ngx_http_core_run_phases;
+    }
+
+    r->write_event_handler(r);
+}
+
+
+static ngx_int_t
+ngx_http_lua_on_abort_resume(ngx_http_request_t *r)
+{
+    ngx_int_t                    rc;
+    ngx_connection_t            *c;
+    ngx_http_lua_ctx_t          *ctx;
+    ngx_http_lua_main_conf_t    *lmcf;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua resuming the on_abort callback thread");
+
+#if 0
+    ngx_http_lua_probe_info("tcp resume");
+#endif
+
+    c = r->connection;
+
+    rc = ngx_http_lua_run_thread(lmcf->lua, r, ctx, 0);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, lmcf->lua, r, ctx);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c,lmcf->lua, r, ctx);
+    }
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
+ngx_int_t
+ngx_http_lua_test_expect(ngx_http_request_t *r)
+{
+    ngx_int_t   n;
+    ngx_str_t  *expect;
+
+    if (r->expect_tested
+        || r->headers_in.expect == NULL
+        || r->http_version < NGX_HTTP_VERSION_11)
+    {
+        return NGX_OK;
+    }
+
+    r->expect_tested = 1;
+
+    expect = &r->headers_in.expect->value;
+
+    if (expect->len != sizeof("100-continue") - 1
+        || ngx_strncasecmp(expect->data, (u_char *) "100-continue",
+                           sizeof("100-continue") - 1)
+           != 0)
+    {
+        return NGX_OK;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "send 100 Continue");
+
+    n = r->connection->send(r->connection,
+                            (u_char *) "HTTP/1.1 100 Continue" CRLF CRLF,
+                            sizeof("HTTP/1.1 100 Continue" CRLF CRLF) - 1);
+
+    if (n == sizeof("HTTP/1.1 100 Continue" CRLF CRLF) - 1) {
+        return NGX_OK;
+    }
+
+    /* we assume that such small packet should be send successfully */
+
+    return NGX_ERROR;
+}
+
+
+void
+ngx_http_lua_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
+{
+    if (r->connection->fd != -1) {
+        ngx_http_finalize_request(r, rc);
+        return;
+    }
+
+    ngx_http_lua_finalize_fake_request(r, rc);
+}
+
+
+void
+ngx_http_lua_finalize_fake_request(ngx_http_request_t *r, ngx_int_t rc)
+{
+    ngx_connection_t          *c;
+
+    c = r->connection;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "http lua finalize fake request: %d, a:%d, c:%d",
+                   rc, r == c->data, r->main->count);
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_close_fake_request(r);
+        return;
+    }
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        ngx_http_lua_close_fake_request(r);
+        return;
+    }
+
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    if (c->write->timer_set) {
+        c->write->delayed = 0;
+        ngx_del_timer(c->write);
+    }
+
+    ngx_http_lua_close_fake_request(r);
+}
+
+
+static void
+ngx_http_lua_close_fake_request(ngx_http_request_t *r)
+{
+    ngx_connection_t  *c;
+
+    r = r->main;
+    c = r->connection;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "http lua fake request count:%d", r->count);
+
+    if (r->count == 0) {
+        ngx_log_error(NGX_LOG_ALERT, c->log, 0, "http lua fake request "
+                      "count is zero");
+    }
+
+    r->count--;
+
+    if (r->count) {
+        return;
+    }
+
+    ngx_http_lua_free_fake_request(r);
+    ngx_http_lua_close_fake_connection(c);
+}
+
+
+static void
+ngx_http_lua_free_fake_request(ngx_http_request_t *r)
+{
+    ngx_log_t                 *log;
+    ngx_http_cleanup_t        *cln;
+    ngx_http_log_ctx_t        *ctx;
+
+    log = r->connection->log;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, "http lua close fake "
+                   "request");
+
+    if (r->pool == NULL) {
+        ngx_log_error(NGX_LOG_ALERT, log, 0, "http lua fake request "
+                      "already closed");
+        return;
+    }
+
+    for (cln = r->cleanup; cln; cln = cln->next) {
+        if (cln->handler) {
+            cln->handler(cln->data);
+        }
+    }
+
+    /* the various request strings were allocated from r->pool */
+    ctx = log->data;
+    ctx->request = NULL;
+
+    r->request_line.len = 0;
+
+    r->connection->destroyed = 1;
+
+    ngx_destroy_pool(r->pool);
+}
+
+
+void
+ngx_http_lua_close_fake_connection(ngx_connection_t *c)
+{
+    ngx_pool_t          *pool;
+    ngx_connection_t    *saved_c = NULL;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "http lua close fake http connection");
+
+    c->destroyed = 1;
+
+    pool = c->pool;
+
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    if (c->write->timer_set) {
+        ngx_del_timer(c->write);
+    }
+
+    c->read->closed = 1;
+    c->write->closed = 1;
+
+    /* we temporarily use a valid fd (0) to make ngx_free_connection happy */
+
+    c->fd = 0;
+
+    if (ngx_cycle->files) {
+        saved_c = ngx_cycle->files[0];
+    }
+
+    ngx_free_connection(c);
+
+    c->fd = (ngx_socket_t) -1;
+
+    if (ngx_cycle->files) {
+        ngx_cycle->files[0] = saved_c;
+    }
+
+    if (pool) {
+        ngx_destroy_pool(pool);
+    }
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_util.h b/src/lua/lua-nginx-module/src/ngx_http_lua_util.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_util.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_util.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,258 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_UTIL_H_INCLUDED_
+#define _NGX_HTTP_LUA_UTIL_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+#ifndef NGX_UNESCAPE_URI_COMPONENT
+#define NGX_UNESCAPE_URI_COMPONENT  0
+#endif
+
+/* char whose address we use as the key in Lua vm registry for
+ * user code cache table */
+extern char ngx_http_lua_code_cache_key;
+
+/* char whose address we use as the key in Lua vm registry for
+ * all the "ngx.ctx" tables */
+extern char ngx_http_lua_ctx_tables_key;
+
+/* char whose address we use as the key in Lua vm registry for
+ * regex cache table  */
+extern char ngx_http_lua_regex_cache_key;
+
+/* char whose address we use as the key in Lua vm registry for
+ * socket connection pool table */
+extern char ngx_http_lua_socket_pool_key;
+
+/* char whose address we use as the key for the coroutine parent relationship */
+extern char ngx_http_lua_coroutine_parents_key;
+
+/* coroutine anchoring table key in Lua VM registry */
+extern char ngx_http_lua_coroutines_key;
+
+/* key to the metatable for ngx.req.get_headers() */
+extern char ngx_http_lua_req_get_headers_metatable_key;
+
+
+#ifndef ngx_str_set
+#define ngx_str_set(str, text)                                               \
+    (str)->len = sizeof(text) - 1; (str)->data = (u_char *) text
+#endif
+
+
+#define ngx_http_lua_context_name(c)                                         \
+    ((c) == NGX_HTTP_LUA_CONTEXT_SET ? "set_by_lua*"                         \
+     : (c) == NGX_HTTP_LUA_CONTEXT_REWRITE ? "rewrite_by_lua*"               \
+     : (c) == NGX_HTTP_LUA_CONTEXT_ACCESS ? "access_by_lua*"                 \
+     : (c) == NGX_HTTP_LUA_CONTEXT_CONTENT ? "content_by_lua*"               \
+     : (c) == NGX_HTTP_LUA_CONTEXT_LOG ? "log_by_lua*"                       \
+     : (c) == NGX_HTTP_LUA_CONTEXT_HEADER_FILTER ? "header_filter_by_lua*"   \
+     : (c) == NGX_HTTP_LUA_CONTEXT_TIMER ? "ngx.timer"   \
+     : "(unknown)")
+
+
+#define ngx_http_lua_check_context(L, ctx, flags)                            \
+    if (!((ctx)->context & (flags))) {                                       \
+        return luaL_error(L, "API disabled in the context of %s",            \
+                          ngx_http_lua_context_name((ctx)->context));        \
+    }
+
+
+#define ngx_http_lua_check_fake_request(L, r)                                \
+    if ((r)->connection->fd == -1) {                                         \
+        return luaL_error(L, "API disabled in the current context");         \
+    }
+
+
+#define ngx_http_lua_check_fake_request2(L, r, ctx)                          \
+    if ((r)->connection->fd == -1) {                                         \
+        return luaL_error(L, "API disabled in the context of %s",            \
+                          ngx_http_lua_context_name((ctx)->context));        \
+    }
+
+
+lua_State * ngx_http_lua_new_state(ngx_conf_t *cf,
+    ngx_http_lua_main_conf_t *lmcf);
+
+lua_State * ngx_http_lua_new_thread(ngx_http_request_t *r, lua_State *l,
+    int *ref);
+
+u_char * ngx_http_lua_rebase_path(ngx_pool_t *pool, u_char *src, size_t len);
+
+ngx_int_t ngx_http_lua_send_header_if_needed(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+
+ngx_int_t ngx_http_lua_send_chain_link(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_chain_t *cl);
+
+void ngx_http_lua_discard_bufs(ngx_pool_t *pool, ngx_chain_t *in);
+
+ngx_int_t ngx_http_lua_add_copy_chain(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_chain_t ***plast, ngx_chain_t *in,
+    ngx_int_t *eof);
+
+void ngx_http_lua_reset_ctx(ngx_http_request_t *r, lua_State *L,
+    ngx_http_lua_ctx_t *ctx);
+
+void ngx_http_lua_generic_phase_post_read(ngx_http_request_t *r);
+
+void ngx_http_lua_request_cleanup(ngx_http_lua_ctx_t *ctx, int foricible);
+
+void ngx_http_lua_request_cleanup_handler(void *data);
+
+ngx_int_t ngx_http_lua_run_thread(lua_State *L, ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, volatile int nret);
+
+ngx_int_t ngx_http_lua_wev_handler(ngx_http_request_t *r);
+
+u_char * ngx_http_lua_digest_hex(u_char *dest, const u_char *buf,
+    int buf_len);
+
+void ngx_http_lua_set_multi_value_table(lua_State *L, int index);
+
+void ngx_http_lua_unescape_uri(u_char **dst, u_char **src, size_t size,
+    ngx_uint_t type);
+
+uintptr_t ngx_http_lua_escape_uri(u_char *dst, u_char *src,
+    size_t size, ngx_uint_t type);
+
+void ngx_http_lua_inject_req_api(ngx_log_t *log, lua_State *L);
+
+void ngx_http_lua_process_args_option(ngx_http_request_t *r,
+    lua_State *L, int table, ngx_str_t *args);
+
+ngx_int_t ngx_http_lua_open_and_stat_file(u_char *name,
+    ngx_open_file_info_t *of, ngx_log_t *log);
+
+ngx_chain_t * ngx_http_lua_chains_get_free_buf(ngx_log_t *log, ngx_pool_t *p,
+    ngx_chain_t **free, size_t len, ngx_buf_tag_t tag);
+
+void ngx_http_lua_create_new_global_table(lua_State *L, int narr, int nrec);
+
+int ngx_http_lua_traceback(lua_State *L);
+
+ngx_http_lua_co_ctx_t * ngx_http_lua_get_co_ctx(lua_State *L,
+    ngx_http_lua_ctx_t *ctx);
+
+ngx_http_lua_co_ctx_t * ngx_http_lua_create_co_ctx(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx);
+
+ngx_int_t ngx_http_lua_run_posted_threads(ngx_connection_t *c, lua_State *L,
+    ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx);
+
+ngx_int_t ngx_http_lua_post_thread(ngx_http_request_t *r,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t *coctx);
+
+void ngx_http_lua_del_thread(ngx_http_request_t *r, lua_State *L,
+    ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t *coctx);
+
+void ngx_http_lua_rd_check_broken_connection(ngx_http_request_t *r);
+
+ngx_int_t ngx_http_lua_test_expect(ngx_http_request_t *r);
+
+ngx_int_t ngx_http_lua_check_broken_connection(ngx_http_request_t *r,
+    ngx_event_t *ev);
+
+void ngx_http_lua_finalize_request(ngx_http_request_t *r, ngx_int_t rc);
+
+void ngx_http_lua_finalize_fake_request(ngx_http_request_t *r,
+    ngx_int_t rc);
+
+void ngx_http_lua_close_fake_connection(ngx_connection_t *c);
+
+void ngx_http_lua_release_ngx_ctx_table(ngx_log_t *log, lua_State *L,
+    ngx_http_lua_ctx_t *ctx);
+
+
+#define ngx_http_lua_check_if_abortable(L, ctx)                             \
+    if ((ctx)->no_abort) {                                                  \
+        return luaL_error(L, "attempt to abort with pending subrequests");  \
+    }
+
+
+static ngx_inline void
+ngx_http_lua_init_ctx(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)
+{
+    ngx_memzero(ctx, sizeof(ngx_http_lua_ctx_t));
+    ctx->ctx_ref = LUA_NOREF;
+    ctx->entry_co_ctx.co_ref = LUA_NOREF;
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+    ctx->request = r;
+}
+
+
+static ngx_inline ngx_http_lua_ctx_t *
+ngx_http_lua_create_ctx(ngx_http_request_t *r)
+{
+    ngx_http_lua_ctx_t      *ctx;
+
+    ctx = ngx_palloc(r->pool, sizeof(ngx_http_lua_ctx_t));
+    if (ctx == NULL) {
+        return NULL;
+    }
+
+    ngx_http_lua_init_ctx(r, ctx);
+
+    ngx_http_set_ctx(r, ctx, ngx_http_lua_module);
+    return ctx;
+}
+
+
+static ngx_inline ngx_http_request_t *
+ngx_http_lua_get_req(lua_State *L)
+{
+    ngx_http_request_t    *r;
+
+    lua_pushliteral(L, "__ngx_req");
+    lua_rawget(L, LUA_GLOBALSINDEX);
+    r = lua_touserdata(L, -1);
+    lua_pop(L, 1);
+
+    return r;
+}
+
+
+static ngx_inline void
+ngx_http_lua_set_req(lua_State *L, ngx_http_request_t *r)
+{
+    lua_pushliteral(L, "__ngx_req");
+    lua_pushlightuserdata(L, r);
+    lua_rawset(L, LUA_GLOBALSINDEX);
+}
+
+
+#define ngx_http_lua_hash_literal(s)                                        \
+    ngx_http_lua_hash_str((u_char *) s, sizeof(s) - 1)
+
+
+static ngx_inline ngx_uint_t
+ngx_http_lua_hash_str(u_char *src, size_t n)
+{
+    ngx_uint_t  key;
+
+    key = 0;
+
+    while (n--) {
+        key = ngx_hash(key, *src);
+        src++;
+    }
+
+    return key;
+}
+
+
+extern ngx_uint_t  ngx_http_lua_location_hash;
+extern ngx_uint_t  ngx_http_lua_content_length_hash;
+
+
+#endif /* _NGX_HTTP_LUA_UTIL_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_variable.c b/src/lua/lua-nginx-module/src/ngx_http_lua_variable.c
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_variable.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_variable.c	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,280 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef DDEBUG
+#define DDEBUG 0
+#endif
+#include "ddebug.h"
+
+
+#include "ngx_http_lua_variable.h"
+#include "ngx_http_lua_util.h"
+
+
+static int ngx_http_lua_var_get(lua_State *L);
+static int ngx_http_lua_var_set(lua_State *L);
+
+
+void
+ngx_http_lua_inject_variable_api(lua_State *L)
+{
+    /* {{{ register reference maps */
+    lua_newtable(L);    /* ngx.var */
+
+    lua_createtable(L, 0, 2 /* nrec */); /* metatable for .var */
+    lua_pushcfunction(L, ngx_http_lua_var_get);
+    lua_setfield(L, -2, "__index");
+    lua_pushcfunction(L, ngx_http_lua_var_set);
+    lua_setfield(L, -2, "__newindex");
+    lua_setmetatable(L, -2);
+
+    lua_setfield(L, -2, "var");
+}
+
+
+/**
+ * Get nginx internal variables content
+ *
+ * @retval Always return a string or nil on Lua stack. Return nil when failed
+ * to get content, and actual content string when found the specified variable.
+ * @seealso ngx_http_lua_var_set
+ * */
+static int
+ngx_http_lua_var_get(lua_State *L)
+{
+    ngx_http_request_t          *r;
+    u_char                      *p, *lowcase;
+    size_t                       len;
+    ngx_uint_t                   hash;
+    ngx_str_t                    name;
+    ngx_http_variable_value_t   *vv;
+
+#if (NGX_PCRE)
+    u_char                      *val;
+    ngx_uint_t                   n;
+    LUA_NUMBER                   index;
+    int                         *cap;
+#endif
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+#if (NGX_PCRE)
+    if (lua_type(L, -1) == LUA_TNUMBER) {
+        /* it is a regex capturing variable */
+
+        index = lua_tonumber(L, -1);
+
+        if (index <= 0) {
+            lua_pushnil(L);
+            return 1;
+        }
+
+        n = (ngx_uint_t) index * 2;
+
+        dd("n = %d, ncaptures = %d", (int) n, (int) r->ncaptures);
+
+        if (r->captures == NULL
+            || r->captures_data == NULL
+            || n >= r->ncaptures)
+        {
+            lua_pushnil(L);
+            return 1;
+        }
+
+        /* n >= 0 && n < r->ncaptures */
+
+        cap = r->captures;
+
+        p = r->captures_data;
+
+        val = &p[cap[n]];
+
+        lua_pushlstring(L, (const char *) val, (size_t) (cap[n + 1] - cap[n]));
+
+        return 1;
+    }
+#endif
+
+    p = (u_char *) luaL_checklstring(L, -1, &len);
+
+    lowcase = lua_newuserdata(L, len);
+
+    hash = ngx_hash_strlow(lowcase, p, len);
+
+    name.len = len;
+    name.data = lowcase;
+
+    vv = ngx_http_get_variable(r, &name, hash);
+
+    if (vv == NULL || vv->not_found) {
+        lua_pushnil(L);
+        return 1;
+    }
+
+    lua_pushlstring(L, (const char *) vv->data, (size_t) vv->len);
+    return 1;
+}
+
+
+/**
+ * Set nginx internal variable content
+ *
+ * @retval Always return a boolean on Lua stack. Return true when variable
+ * content was modified successfully, false otherwise.
+ * @seealso ngx_http_lua_var_get
+ * */
+static int
+ngx_http_lua_var_set(lua_State *L)
+{
+    ngx_http_variable_t         *v;
+    ngx_http_variable_value_t   *vv;
+    ngx_http_core_main_conf_t   *cmcf;
+    u_char                      *p, *lowcase, *val;
+    size_t                       len;
+    ngx_str_t                    name;
+    ngx_uint_t                   hash;
+    ngx_http_request_t          *r;
+    int                          value_type;
+    const char                  *msg;
+
+    r = ngx_http_lua_get_req(L);
+    if (r == NULL) {
+        return luaL_error(L, "no request object found");
+    }
+
+    ngx_http_lua_check_fake_request(L, r);
+
+    /* we skip the first argument that is the table */
+
+    /* we read the variable name */
+
+    p = (u_char *) luaL_checklstring(L, 2, &len);
+
+    lowcase = lua_newuserdata(L, len + 1);
+
+    hash = ngx_hash_strlow(lowcase, p, len);
+    lowcase[len] = '\0';
+
+    name.len = len;
+    name.data = lowcase;
+
+    /* we read the variable new value */
+
+    value_type = lua_type(L, 3);
+    switch (value_type) {
+    case LUA_TNUMBER:
+    case LUA_TSTRING:
+        p = (u_char *) luaL_checklstring(L, 3, &len);
+
+        val = ngx_palloc(r->pool, len);
+        if (val == NULL) {
+            return luaL_error(L, "memory allocation erorr");
+        }
+
+        ngx_memcpy(val, p, len);
+
+        break;
+
+    case LUA_TNIL:
+        /* undef the variable */
+
+        val = NULL;
+        len = 0;
+
+        break;
+
+    default:
+        msg = lua_pushfstring(L, "string, number, or nil expected, "
+                              "but got %s", lua_typename(L, value_type));
+        return luaL_argerror(L, 1, msg);
+    }
+
+    /* we fetch the variable itself */
+
+    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+    v = ngx_hash_find(&cmcf->variables_hash, hash, name.data, name.len);
+
+    if (v) {
+        if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {
+            return luaL_error(L, "variable \"%s\" not changeable", lowcase);
+        }
+
+        if (v->set_handler) {
+
+            dd("set variables with set_handler");
+
+            vv = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t));
+            if (vv == NULL) {
+                return luaL_error(L, "out of memory");
+            }
+
+            if (value_type == LUA_TNIL) {
+                vv->valid = 0;
+                vv->not_found = 1;
+                vv->no_cacheable = 0;
+                vv->data = NULL;
+                vv->len = 0;
+
+            } else {
+                vv->valid = 1;
+                vv->not_found = 0;
+                vv->no_cacheable = 0;
+
+                vv->data = val;
+                vv->len = len;
+            }
+
+            v->set_handler(r, vv, v->data);
+
+            return 0;
+        }
+
+        if (v->flags & NGX_HTTP_VAR_INDEXED) {
+            vv = &r->variables[v->index];
+
+            dd("set indexed variable");
+
+            if (value_type == LUA_TNIL) {
+                vv->valid = 0;
+                vv->not_found = 1;
+                vv->no_cacheable = 0;
+
+                vv->data = NULL;
+                vv->len = 0;
+
+            } else {
+                vv->valid = 1;
+                vv->not_found = 0;
+                vv->no_cacheable = 0;
+
+                vv->data = val;
+                vv->len = len;
+            }
+
+            return 0;
+        }
+
+        return luaL_error(L, "variable \"%s\" cannot be assigned a value",
+                          lowcase);
+    }
+
+    /* variable not found */
+
+    return luaL_error(L, "variable \"%s\" not found for writing; "
+                      "maybe it is a built-in variable that is not changeable "
+                      "or you forgot to use \"set $%s '';\" "
+                      "in the config file to define it first",
+                      lowcase, lowcase);
+}
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/src/ngx_http_lua_variable.h b/src/lua/lua-nginx-module/src/ngx_http_lua_variable.h
--- a/src/lua/lua-nginx-module/src/ngx_http_lua_variable.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/src/ngx_http_lua_variable.h	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,20 @@
+
+/*
+ * Copyright (C) Xiaozhe Wang (chaoslawful)
+ * Copyright (C) Yichun Zhang (agentzh)
+ */
+
+
+#ifndef _NGX_HTTP_LUA_VARIABLE_H_INCLUDED_
+#define _NGX_HTTP_LUA_VARIABLE_H_INCLUDED_
+
+
+#include "ngx_http_lua_common.h"
+
+
+void ngx_http_lua_inject_variable_api(lua_State *L);
+
+
+#endif /* _NGX_HTTP_LUA_VARIABLE_H_INCLUDED_ */
+
+/* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff -rNu a/src/lua/lua-nginx-module/t/000--init.t b/src/lua/lua-nginx-module/t/000--init.t
--- a/src/lua/lua-nginx-module/t/000--init.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/000--init.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,88 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2 + 1);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+
+our $http_config = <<'_EOC_';
+    upstream database {
+        drizzle_server 127.0.0.1:$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+    }
+_EOC_
+
+no_shuffle();
+run_tests();
+
+__DATA__
+
+=== TEST 1: conv_uid - drop table
+--- http_config eval: $::http_config
+--- config
+    location = /init {
+        drizzle_pass   database;
+        drizzle_query  "DROP TABLE IF EXISTS conv_uid";
+    }
+--- request
+GET /init
+--- error_code: 200
+--- timeout: 10
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: conv_uid - create table
+--- http_config eval: $::http_config
+--- config
+    location = /init {
+        drizzle_pass   database;
+        drizzle_query  "CREATE TABLE conv_uid(id serial primary key, new_uid integer, old_uid integer)";
+    }
+--- request
+GET /init
+--- error_code: 200
+--- timeout: 10
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: conv_uid - insert value
+--- http_config eval: $::http_config
+--- config
+    location = /init {
+        drizzle_pass   database;
+        drizzle_query  "INSERT INTO conv_uid(old_uid,new_uid) VALUES(32,56),(35,78)";
+    }
+--- request
+GET /init
+--- error_code: 200
+--- timeout: 10
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: flush data from memcached
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+GET /flush
+--- error_code: 200
+--- response_body eval
+"OK\r
+"
+--- timeout: 10
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/000-sanity.t b/src/lua/lua-nginx-module/t/000-sanity.t
--- a/src/lua/lua-nginx-module/t/000-sanity.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/000-sanity.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,35 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => blocks() * repeat_each() * 2;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity (integer)
+--- config
+    location /lua {
+        echo 2;
+    }
+--- request
+GET /lua
+--- response_body
+2
+
+
+
+=== TEST 2: sanity (string)
+--- config
+    location /lua {
+        echo "helloworld";
+    }
+--- request
+GET /lua
+--- response_body
+helloworld
+
diff -rNu a/src/lua/lua-nginx-module/t/001-set.t b/src/lua/lua-nginx-module/t/001-set.t
--- a/src/lua/lua-nginx-module/t/001-set.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/001-set.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,799 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 4);
+
+#log_level("warn");
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple set (integer)
+--- config
+    location /lua {
+        set_by_lua $res "return 1+1";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body
+2
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: simple set (string)
+--- config
+    location /lua {
+        set_by_lua $res "return 'hello' .. 'world'";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body
+helloworld
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: internal only
+--- config
+    location /lua {
+        set_by_lua $res "function fib(n) if n > 2 then return fib(n-1)+fib(n-2) else return 1 end end return fib(10)";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body
+55
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: inlined script with arguments
+--- config
+    location /lua {
+        set_by_lua $res "return ngx.arg[1] + ngx.arg[2]" $arg_a $arg_b;
+        echo $res;
+    }
+--- request
+GET /lua?a=1&b=2
+--- response_body
+3
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: fib by arg
+--- config
+    location /fib {
+        set_by_lua $res "function fib(n) if n > 2 then return fib(n-1)+fib(n-2) else return 1 end end return fib(tonumber(ngx.arg[1]))" $arg_n;
+        echo $res;
+    }
+--- request
+GET /fib?n=10
+--- response_body
+55
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: adder
+--- config
+    location = /adder {
+        set_by_lua $res
+            "local a = tonumber(ngx.arg[1])
+             local b = tonumber(ngx.arg[2])
+             return a + b" $arg_a $arg_b;
+
+        echo $res;
+    }
+--- request
+GET /adder?a=25&b=75
+--- response_body
+100
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: read nginx variables directly from within Lua
+--- config
+    location = /set-both {
+        set $b 32;
+        set_by_lua $a "return tonumber(ngx.var.b) + 1";
+
+        echo "a = $a";
+    }
+--- request
+GET /set-both
+--- response_body
+a = 33
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: set nginx variables directly from within Lua
+--- config
+    location = /set-both {
+        set $b "";
+        set_by_lua $a "ngx.var.b = 32; return 7";
+
+        echo "a = $a";
+        echo "b = $b";
+    }
+--- request
+GET /set-both
+--- response_body
+a = 7
+b = 32
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: set non-existent nginx variables
+--- config
+    location = /set-both {
+        #set $b "";
+        set_by_lua $a "ngx.var.b = 32; return 7";
+
+        echo "a = $a";
+    }
+--- request
+GET /set-both
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+variable "b" not found for writing; maybe it is a built-in variable that is not changeable or you forgot to use "set $b '';" in the config file to define it first
+
+
+
+=== TEST 10: set quote sql str
+--- config
+    location = /set {
+        set $a "";
+        set_by_lua $a "return ngx.quote_sql_str(ngx.var.a)";
+        echo $a;
+    }
+--- request
+GET /set
+--- response_body
+''
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: set md5
+--- config
+    location = /md5 {
+        set_by_lua $a 'return ngx.md5("hello")';
+        echo $a;
+    }
+--- request
+GET /md5
+--- response_body
+5d41402abc4b2a76b9719d911017c592
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: no ngx.print
+--- config
+    location /lua {
+        set_by_lua $res "ngx.print(32) return 1";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 13: no ngx.say
+--- config
+    location /lua {
+        set_by_lua $res "ngx.say(32) return 1";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 14: no ngx.flush
+--- config
+    location /lua {
+        set_by_lua $res "ngx.flush()";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 15: no ngx.eof
+--- config
+    location /lua {
+        set_by_lua $res "ngx.eof()";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 16: no ngx.send_headers
+--- config
+    location /lua {
+        set_by_lua $res "ngx.send_headers()";
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 17: no ngx.location.capture
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.location.capture("/sub")';
+        echo $res;
+    }
+
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 18: no ngx.location.capture_multi
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.location.capture_multi{{"/sub"}}';
+        echo $res;
+    }
+
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 19: no ngx.exit
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.exit(0)';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 20: no ngx.redirect
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.redirect("/blah")';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 21: no ngx.exec
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.exec("/blah")';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 22: no ngx.req.set_uri(uri, true)
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.req.set_uri("/blah", true)';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 23: ngx.req.set_uri(uri) exists
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.req.set_uri("/blah") return 1';
+        echo $uri;
+    }
+--- request
+GET /lua
+--- response_body
+/blah
+--- no_error_log
+[error]
+
+
+
+=== TEST 24: no ngx.req.read_body()
+--- config
+    location /lua {
+        set_by_lua $res 'ngx.req.read_body()';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 25: no ngx.req.socket()
+--- config
+    location /lua {
+        set_by_lua $res 'return ngx.req.socket()';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 26: no ngx.socket.tcp()
+--- config
+    location /lua {
+        set_by_lua $res 'return ngx.socket.tcp()';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 27: no ngx.socket.connect()
+--- config
+    location /lua {
+        set_by_lua $res 'return ngx.socket.connect("127.0.0.1", 80)';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+API disabled in the context of set_by_lua*
+
+
+
+=== TEST 28: set $limit_rate (variables with set_handler)
+--- config
+    location /lua {
+        set $limit_rate 1000;
+        rewrite_by_lua '
+            ngx.var.limit_rate = 180;
+        ';
+        echo "limit rate = $limit_rate";
+    }
+--- request
+    GET /lua
+--- response_body
+limit rate = 180
+--- no_error_log
+[error]
+
+
+
+=== TEST 29: set $args and read $query_string
+--- config
+    location /lua {
+        set $args 'hello';
+        rewrite_by_lua '
+            ngx.var.args = "world";
+        ';
+        echo $query_string;
+    }
+--- request
+    GET /lua
+--- response_body
+world
+--- no_error_log
+[error]
+
+
+
+=== TEST 30: set $arg_xxx
+--- config
+    location /lua {
+        rewrite_by_lua '
+            ngx.var.arg_foo = "world";
+        ';
+        echo $arg_foo;
+    }
+--- request
+    GET /lua?foo=3
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+variable "arg_foo" not found for writing; maybe it is a built-in variable that is not changeable or you forgot to use "set $arg_foo '';" in the config file to define it first
+
+
+
+=== TEST 31: symbol $ in lua code of set_by_lua
+--- config
+    location /lua {
+        set_by_lua $res 'return "$unknown"';
+        echo $res;
+    }
+--- request
+    GET /lua
+--- response_body
+$unknown
+--- no_error_log
+[error]
+
+
+
+=== TEST 32: symbol $ in lua code of set_by_lua_file
+--- config
+    location /lua {
+        set_by_lua_file $res html/a.lua;
+        echo $res;
+    }
+--- user_files
+>>> a.lua
+return "$unknown"
+--- request
+    GET /lua
+--- response_body
+$unknown
+--- no_error_log
+[error]
+
+
+
+=== TEST 33: external script files with arguments
+--- config
+    location /lua {
+        set_by_lua_file $res html/a.lua $arg_a $arg_b;
+        echo $res;
+    }
+--- user_files
+>>> a.lua
+return ngx.arg[1] + ngx.arg[2]
+--- request
+GET /lua?a=5&b=2
+--- response_body
+7
+--- no_error_log
+[error]
+
+
+
+=== TEST 34: variables in set_by_lua_file's file path
+--- config
+    location /lua {
+        set $path "html/a.lua";
+        set_by_lua_file $res $path $arg_a $arg_b;
+        echo $res;
+    }
+--- user_files
+>>> a.lua
+return ngx.arg[1] + ngx.arg[2]
+--- request
+GET /lua?a=5&b=2
+--- response_body
+7
+--- no_error_log
+[error]
+
+
+
+=== TEST 35: lua error (string)
+--- config
+    location /lua {
+        set_by_lua $res 'error("Bad")';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+failed to run set_by_lua*: [string "set_by_lua"]:1: Bad
+
+
+
+=== TEST 36: lua error (nil)
+--- config
+    location /lua {
+        set_by_lua $res 'error(nil)';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+failed to run set_by_lua*: unknown reason
+
+
+
+=== TEST 37: globals get cleared for every single request
+--- config
+    location /lua {
+        set_by_lua $res '
+            if not foo then
+                foo = 1
+            else
+                foo = foo + 1
+            end
+            return foo
+        ';
+        echo $res;
+    }
+--- request
+GET /lua
+--- response_body
+1
+--- no_error_log
+[error]
+
+
+
+=== TEST 38: user modules using ngx.arg
+--- http_config
+    lua_package_path "$prefix/html/?.lua;;";
+--- config
+    location /lua {
+        set_by_lua $res 'local foo = require "foo" return foo.go()' $arg_a $arg_b;
+        echo $res;
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+function go()
+    return ngx.arg[1] + ngx.arg[2]
+end
+--- request
+GET /lua?a=1&b=2
+--- response_body
+3
+--- no_error_log
+[error]
+
+
+
+=== TEST 39: server scope (inline)
+--- config
+    location /lua {
+        set $a "[$res]";
+        echo $a;
+    }
+    set_by_lua $res "return 1+1";
+--- request
+GET /lua
+--- response_body
+[2]
+--- no_error_log
+[error]
+
+
+
+=== TEST 40: server if scope (inline)
+--- config
+    location /lua {
+        set $a "[$res]";
+        echo $a;
+    }
+    if ($arg_name = "jim") {
+        set_by_lua $res "return 1+1";
+    }
+--- request
+GET /lua?name=jim
+--- response_body
+[2]
+--- no_error_log
+[error]
+
+
+
+=== TEST 41: location if scope (inline)
+--- config
+    location /lua {
+        if ($arg_name = "jim") {
+            set_by_lua $res "return 1+1";
+            set $a "[$res]";
+            echo $a;
+        }
+    }
+--- request
+GET /lua?name=jim
+--- response_body
+[2]
+--- no_error_log
+[error]
+
+
+
+=== TEST 42: server scope (file)
+--- config
+    location /lua {
+        set $a "[$res]";
+        echo $a;
+    }
+    set_by_lua_file $res html/a.lua;
+--- user_files
+>>> a.lua
+return 1+1
+--- request
+GET /lua
+--- response_body
+[2]
+--- no_error_log
+[error]
+
+
+
+=== TEST 43: server if scope (file)
+--- config
+    location /lua {
+        set $a "[$res]";
+        echo $a;
+    }
+    if ($arg_name = "jim") {
+        set_by_lua_file $res html/a.lua;
+    }
+--- request
+GET /lua?name=jim
+--- user_files
+>>> a.lua
+return 1+1
+--- response_body
+[2]
+--- no_error_log
+[error]
+
+
+
+=== TEST 44: location if scope (file)
+--- config
+    location /lua {
+        if ($arg_name = "jim") {
+            set_by_lua_file $res html/a.lua;
+            set $a "[$res]";
+            echo $a;
+        }
+    }
+--- user_files
+>>> a.lua
+return 1+1
+--- request
+GET /lua?name=jim
+--- response_body
+[2]
+--- no_error_log
+[error]
+
+
+
+=== TEST 45: backtrace
+--- config
+    location /t {
+        set_by_lua $a '
+            function foo()
+                bar()
+            end
+
+            function bar()
+                error("something bad happened")
+            end
+
+            foo()
+        ';
+        echo ok;
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+something bad happened
+stack traceback:
+in function 'error'
+in function 'bar'
+in function 'foo'
+
+
+
+=== TEST 46: Lua file does not exist
+--- config
+    location /lua {
+        set_by_lua_file $a html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
diff -rNu a/src/lua/lua-nginx-module/t/002-content.t b/src/lua/lua-nginx-module/t/002-content.t
--- a/src/lua/lua-nginx-module/t/002-content.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/002-content.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,837 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2 + 18);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: basic print
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        content_by_lua '
+            local ok, err = ngx.print("Hello, Lua!\\n")
+            if not ok then
+                ngx.log(ngx.ERR, "print failed: ", err)
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Hello, Lua!
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: basic say
+--- config
+    location /say {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        content_by_lua '
+            local ok, err = ngx.say("Hello, Lua!")
+            if not ok then
+                ngx.log(ngx.ERR, "say failed: ", err)
+                return
+            end
+            local ok, err = ngx.say("Yay! ", 123)
+            if not ok then
+                ngx.log(ngx.ERR, "say failed: ", err)
+                return
+            end
+        ';
+    }
+--- request
+GET /say
+--- response_body
+Hello, Lua!
+Yay! 123
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: no ngx.echo
+--- config
+    location /lua {
+        content_by_lua 'ngx.echo("Hello, Lua!\\n")';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: variable
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        content_by_lua 'v = ngx.var["request_uri"] ngx.print("request_uri: ", v, "\\n")';
+    }
+--- request
+GET /lua?a=1&b=2
+--- response_body
+request_uri: /lua?a=1&b=2
+
+
+
+=== TEST 5: variable (file)
+--- config
+    location /lua {
+        content_by_lua_file html/test.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body
+request_uri: /lua?a=1&b=2
+
+
+
+=== TEST 6: calc expression
+--- config
+    location /lua {
+        content_by_lua_file html/calc.lua;
+    }
+--- user_files
+>>> calc.lua
+local function uri_unescape(uri)
+    local function convert(hex)
+        return string.char(tonumber("0x"..hex))
+    end
+    local s = string.gsub(uri, "%%([0-9a-fA-F][0-9a-fA-F])", convert)
+    return s
+end
+
+local function eval_exp(str)
+    return loadstring("return "..str)()
+end
+
+local exp_str = ngx.var["arg_exp"]
+-- print("exp: '", exp_str, "'\n")
+local status, res
+status, res = pcall(uri_unescape, exp_str)
+if not status then
+    ngx.print("error: ", res, "\n")
+    return
+end
+status, res = pcall(eval_exp, res)
+if status then
+    ngx.print("result: ", res, "\n")
+else
+    ngx.print("error: ", res, "\n")
+end
+--- request
+GET /lua?exp=1%2B2*math.sin(3)%2Fmath.exp(4)-math.sqrt(2)
+--- response_body
+result: -0.4090441561579
+
+
+
+=== TEST 7: read $arg_xxx
+--- config
+    location = /lua {
+        content_by_lua 'who = ngx.var.arg_who
+            ngx.print("Hello, ", who, "!")';
+    }
+--- request
+GET /lua?who=agentzh
+--- response_body chomp
+Hello, agentzh!
+
+
+
+=== TEST 8: capture location
+--- config
+    location /other {
+        echo "hello, world";
+    }
+
+    location /lua {
+        content_by_lua 'res = ngx.location.capture("/other"); ngx.print("status=", res.status, " "); ngx.print("body=", res.body)';
+    }
+--- request
+GET /lua
+--- response_body
+status=200 body=hello, world
+
+
+
+ei= TEST 9: capture non-existed location
+--- config
+    location /lua {
+        content_by_lua 'res = ngx.location.capture("/other"); ngx.print("status=", res.status)';
+    }
+--- request
+GET /lua
+--- response_body: status=404
+
+
+
+=== TEST 9: invalid capture location (not as expected...)
+--- config
+    location /lua {
+        content_by_lua 'res = ngx.location.capture("*(#*"); ngx.say("res=", res.status)';
+    }
+--- request
+GET /lua
+--- response_body
+res=404
+
+
+
+=== TEST 10: nil is "nil"
+--- config
+    location /lua {
+        content_by_lua 'ngx.say(nil)';
+    }
+--- request
+GET /lua
+--- response_body
+nil
+
+
+
+=== TEST 11: write boolean
+--- config
+    location /lua {
+        content_by_lua 'ngx.say(true, " ", false)';
+    }
+--- request
+GET /lua
+--- response_body
+true false
+
+
+
+=== TEST 12: bad argument type to ngx.location.capture
+--- config
+    location /lua {
+        content_by_lua 'ngx.location.capture(nil)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 13: capture location (default 0);
+--- config
+ location /recur {
+       content_by_lua '
+           local num = tonumber(ngx.var.arg_num) or 0;
+           ngx.print("num is: ", num, "\\n");
+
+           if (num > 0) then
+               res = ngx.location.capture("/recur?num="..tostring(num - 1));
+               ngx.print("status=", res.status, " ");
+               ngx.print("body=", res.body, "\\n");
+           else
+               ngx.print("end\\n");
+           end
+           ';
+   }
+--- request
+GET /recur
+--- response_body
+num is: 0
+end
+
+
+
+=== TEST 14: capture location
+--- config
+ location /recur {
+       content_by_lua '
+           local num = tonumber(ngx.var.arg_num) or 0;
+           ngx.print("num is: ", num, "\\n");
+
+           if (num > 0) then
+               res = ngx.location.capture("/recur?num="..tostring(num - 1));
+               ngx.print("status=", res.status, " ");
+               ngx.print("body=", res.body);
+           else
+               ngx.print("end\\n");
+           end
+           ';
+   }
+--- request
+GET /recur?num=3
+--- response_body
+num is: 3
+status=200 body=num is: 2
+status=200 body=num is: 1
+status=200 body=num is: 0
+end
+
+
+
+=== TEST 15: setting nginx variables from within Lua
+--- config
+ location /set {
+       set $a "";
+       content_by_lua 'ngx.var.a = 32; ngx.say(ngx.var.a)';
+       add_header Foo $a;
+   }
+--- request
+GET /set
+--- response_headers
+Foo: 32
+--- response_body
+32
+
+
+
+=== TEST 16: nginx quote sql string 1
+--- config
+ location /set {
+       set $a 'hello\n\r\'"\\';
+       content_by_lua 'ngx.say(ngx.quote_sql_str(ngx.var.a))';
+   }
+--- request
+GET /set
+--- response_body
+'hello\n\r\'\"\\'
+
+
+
+=== TEST 17: nginx quote sql string 2
+--- config
+location /set {
+    set $a "hello\n\r'\"\\";
+    content_by_lua 'ngx.say(ngx.quote_sql_str(ngx.var.a))';
+}
+--- request
+GET /set
+--- response_body
+'hello\n\r\'\"\\'
+
+
+
+=== TEST 18: use dollar
+--- config
+location /set {
+    content_by_lua '
+        local s = "hello 112";
+        ngx.say(string.find(s, "%d+$"))';
+}
+--- request
+GET /set
+--- response_body
+79
+
+
+
+=== TEST 19: subrequests do not share variables of main requests by default
+--- config
+location /sub {
+    echo $a;
+}
+location /parent {
+    set $a 12;
+    content_by_lua 'res = ngx.location.capture("/sub"); ngx.print(res.body)';
+}
+--- request
+GET /parent
+--- response_body eval: "\n"
+
+
+
+=== TEST 20: subrequests can share variables of main requests
+--- config
+location /sub {
+    echo $a;
+}
+location /parent {
+    set $a 12;
+    content_by_lua '
+        res = ngx.location.capture(
+            "/sub",
+            { share_all_vars = true }
+        );
+        ngx.print(res.body)
+    ';
+}
+--- request
+GET /parent
+--- response_body
+12
+
+
+
+=== TEST 21: main requests use subrequests' variables
+--- config
+location /sub {
+    set $a 12;
+}
+location /parent {
+    content_by_lua '
+        res = ngx.location.capture("/sub", { share_all_vars = true });
+        ngx.say(ngx.var.a)
+    ';
+}
+--- request
+GET /parent
+--- response_body
+12
+
+
+
+=== TEST 22: main requests do NOT use subrequests' variables
+--- config
+location /sub {
+    set $a 12;
+}
+location /parent {
+    content_by_lua '
+        res = ngx.location.capture("/sub", { share_all_vars = false });
+        ngx.say(ngx.var.a)
+    ';
+}
+--- request
+GET /parent
+--- response_body_like eval: "\n"
+
+
+
+=== TEST 23: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo "hello, world";
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+
+
+
+=== TEST 24: capture location multi-value headers
+--- config
+    location /other {
+        #echo "hello, world";
+        content_by_lua '
+            ngx.header["Set-Cookie"] = {"a", "hello, world", "foo"}
+            local ok, err = ngx.eof()
+            if not ok then
+                ngx.log(ngx.ERR, "eof failed: ", err)
+                return
+            end
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", type(res.header["Set-Cookie"]));
+            ngx.say("len: ", #res.header["Set-Cookie"]);
+            ngx.say("value: ", table.concat(res.header["Set-Cookie"], "|"))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+type: table
+len: 3
+value: a|hello, world|foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 25: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.header.Bar = "Bah";
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+            ngx.say("Bar: ", res.header["Bar"]);
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+Bar: Bah
+
+
+
+=== TEST 26: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.header.Bar = "Bah";
+            ngx.header.Bar = nil;
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+            ngx.say("Bar: ", res.header["Bar"] or "nil");
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+Bar: nil
+
+
+
+=== TEST 27: HTTP 1.0 response
+--- config
+    location /lua {
+        content_by_lua '
+            data = "hello, world"
+            -- ngx.header["Content-Length"] = #data
+            -- ngx.header.content_length = #data
+            ngx.print(data)
+        ';
+    }
+    location /main {
+        proxy_pass http://127.0.0.1:$server_port/lua;
+    }
+--- request
+GET /main
+--- response_headers
+Content-Length: 12
+--- response_body chop
+hello, world
+
+
+
+=== TEST 28: multiple eof
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("Hi")
+
+            local ok, err = ngx.eof()
+            if not ok then
+                ngx.log(ngx.WARN, "eof failed: ", err)
+                return
+            end
+
+            ok, err = ngx.eof()
+            if not ok then
+                ngx.log(ngx.WARN, "eof failed: ", err)
+                return
+            end
+
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Hi
+--- no_error_log
+[error]
+--- error_log
+eof failed: seen eof
+
+
+
+=== TEST 29: nginx vars in script path
+--- config
+    location ~ ^/lua/(.+)$ {
+        content_by_lua_file html/$1.lua;
+    }
+--- user_files
+>>> calc.lua
+local a,b = ngx.var.arg_a, ngx.var.arg_b
+ngx.say(a+b)
+--- request
+GET /lua/calc?a=19&b=81
+--- response_body
+100
+
+
+
+=== TEST 30: nginx vars in script path
+--- config
+    location ~ ^/lua/(.+)$ {
+        content_by_lua_file html/$1.lua;
+    }
+    location /main {
+        echo_location /lua/sum a=3&b=2;
+        echo_location /lua/diff a=3&b=2;
+    }
+--- user_files
+>>> sum.lua
+local a,b = ngx.var.arg_a, ngx.var.arg_b
+ngx.say(a+b)
+>>> diff.lua
+local a,b = ngx.var.arg_a, ngx.var.arg_b
+ngx.say(a-b)
+--- request
+GET /main
+--- response_body
+5
+1
+
+
+
+=== TEST 31: basic print (HEAD + HTTP 1.1)
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        content_by_lua 'ngx.print("Hello, Lua!\\n")';
+    }
+--- request
+HEAD /lua
+--- response_body
+
+
+
+=== TEST 32: basic print (HEAD + HTTP 1.0)
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        content_by_lua '
+            ngx.print("Hello, Lua!\\n")
+        ';
+    }
+--- request
+HEAD /lua HTTP/1.0
+--- response_headers
+!Content-Length
+--- response_body
+
+
+
+=== TEST 33: headers_sent & HEAD
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.headers_sent)
+            local ok, err = ngx.flush()
+            if not ok then
+                ngx.log(ngx.WARN, "failed to flush: ", err)
+                return
+            end
+            ngx.say(ngx.headers_sent)
+        ';
+    }
+--- request
+HEAD /lua
+--- response_body
+--- no_error_log
+[error]
+--- error_log
+failed to flush: header only
+
+
+
+=== TEST 34: HEAD & ngx.say
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.send_headers()
+            local ok, err = ngx.say(ngx.headers_sent)
+            if not ok then
+                ngx.log(ngx.WARN, "failed to say: ", err)
+                return
+            end
+        ';
+    }
+--- request
+HEAD /lua
+--- response_body
+--- no_error_log
+[error]
+--- error_log
+failed to say: header only
+
+
+
+=== TEST 35: ngx.eof before ngx.say
+--- config
+    location /lua {
+        content_by_lua '
+            local ok, err = ngx.eof()
+            if not ok then
+                ngx.log(ngx.ERR, "eof failed: ", err)
+                return
+            end
+
+            ok, err = ngx.say(ngx.headers_sent)
+            if not ok then
+                ngx.log(ngx.WARN, "failed to say: ", err)
+                return
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+--- no_error_log
+[error]
+--- error_log
+failed to say: seen eof
+
+
+
+=== TEST 36: headers_sent + GET
+--- config
+    location /lua {
+        content_by_lua '
+            -- print("headers sent: ", ngx.headers_sent)
+            ngx.say(ngx.headers_sent)
+            ngx.say(ngx.headers_sent)
+            -- ngx.flush()
+            ngx.say(ngx.headers_sent)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+false
+true
+true
+
+
+
+=== TEST 37: HTTP 1.0 response with Content-Length
+--- config
+    location /lua {
+        content_by_lua '
+            data = "hello,\\nworld\\n"
+            ngx.header["Content-Length"] = #data
+            ngx.say("hello,")
+            ngx.flush()
+            -- ngx.location.capture("/sleep")
+            ngx.say("world")
+        ';
+    }
+    location /sleep {
+        echo_sleep 2;
+    }
+    location /main {
+        proxy_pass http://127.0.0.1:$server_port/lua;
+    }
+--- request
+GET /main
+--- response_headers
+Content-Length: 13
+--- response_body
+hello,
+world
+--- timeout: 5
+
+
+
+=== TEST 38: ngx.print table arguments (github issue #54)
+--- config
+    location /t {
+        content_by_lua 'ngx.print({10, {0, 5}, 15}, 32)';
+    }
+--- request
+    GET /t
+--- response_body chop
+10051532
+
+
+
+=== TEST 39: ngx.say table arguments (github issue #54)
+--- config
+    location /t {
+        content_by_lua 'ngx.say({10, {0, "5"}, 15}, 32)';
+    }
+--- request
+    GET /t
+--- response_body
+10051532
+
+
+
+=== TEST 40: Lua file does not exist
+--- config
+    location /lua {
+        content_by_lua_file html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
+
+
+=== TEST 41: .lua file with shebang
+--- config
+    location /lua {
+        content_by_lua_file html/test.lua;
+    }
+--- user_files
+>>> test.lua
+#!/bin/lua
+
+ngx.say("line ", debug.getinfo(1).currentline)
+--- request
+GET /lua?a=1&b=2
+--- response_body
+line 3
+--- no_error_log
+[error]
+
+
+
+=== TEST 42: syntax error in inlined Lua code
+--- config
+    location /lua {
+        content_by_lua 'for end';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+qr/failed to load inlined Lua code: /
+
diff -rNu a/src/lua/lua-nginx-module/t/003-errors.t b/src/lua/lua-nginx-module/t/003-errors.t
--- a/src/lua/lua-nginx-module/t/003-errors.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/003-errors.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,130 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(1);
+
+plan tests => blocks() * repeat_each() * 2;
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: syntax error in lua code chunk
+--- config
+    location /lua {
+        set_by_lua $res "local a
+            a = a+;
+            return a";
+        echo $res;
+    }
+--- request
+GET /lua
+--- error_code: 500
+--- response_body_like: 500 Internal Server Error
+
+
+
+=== TEST 2: syntax error in lua file
+--- config
+    location /lua {
+        set_by_lua_file $res 'html/test.lua';
+        echo $res;
+    }
+--- user_files
+>>> test.lua
+local a
+a = 3 +;
+return a
+--- request
+GET /lua
+--- error_code: 500
+--- response_body_like: 500 Internal Server Error
+
+
+
+=== TEST 3: syntax error in lua file (from Guang Feng)
+--- config
+    location /lua {
+        set $res '[{"a":32},{"b":64}]';
+        #set $res '[{"friend_userid":1750146},{"friend_userid":1750150},{"friend_userid":1750153},{"friend_userid":1750166},{"friend_userid":1750181},{"friend_userid":1750186},{"friend_userid":1750195},{"friend_userid":1750232}]';
+        set_by_lua_file $list 'html/test.lua' $res;
+        #set_by_lua_file $list 'html/feed.lua' $res;
+        echo $list;
+    }
+--- user_files
+>>> test.lua
+-- local j = require('json')
+local p = ngx.arg[1]
+return p
+>>> feed.lua
+local s = require("json")
+local function explode(d,p)
+   local t, ll
+   t={}
+   ll=0
+   if(#p == 1) then return p end
+       while true do
+       l=string.find(p,d,ll+1,true) 
+           if l~=nil then 
+         table.insert(t, string.sub(p,ll,l-1)) 
+         ll=l+1 
+           else
+         table.insert(t, string.sub(p,ll)) 
+         break 
+         end
+     end
+return t
+ end
+
+local a = explode(',', string.sub(ngx.arg[1], 2, -1))
+local x = {}
+for i,v in ipairs(a) do table.insert(x,s.decode(v).friend_userid) end
+return table.concat(x,',')
+--- request
+GET /lua
+--- response_body
+[{"a":32},{"b":64}]
+
+
+
+=== TEST 4: 500 in subrequest
+--- config
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/err")
+            ngx.say(res.status);
+        ';
+    }
+    location /err {
+        return 500;
+    }
+--- request
+GET /main
+--- response_body
+500
+
+
+
+=== TEST 5: drizzle_pass 500 in subrequest
+--- config
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/err")
+            ngx.say(res.status);
+        ';
+    }
+    location /err {
+        set $back 'blah-blah';
+        drizzle_pass $back;
+    }
+--- request
+GET /main
+--- response_body
+500
+
diff -rNu a/src/lua/lua-nginx-module/t/004-require.t b/src/lua/lua-nginx-module/t/004-require.t
--- a/src/lua/lua-nginx-module/t/004-require.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/004-require.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,211 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#log_level('warn');
+
+#master_on();
+#repeat_each(120);
+repeat_each(2);
+
+plan tests => blocks() * repeat_each() * 2;
+
+our $HtmlDir = html_dir;
+#warn $html_dir;
+
+#$ENV{LUA_PATH} = "$html_dir/?.lua";
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /main {
+        echo_location /load;
+        echo_location /check;
+        echo_location /check;
+    }
+
+    location /load {
+        content_by_lua '
+            package.loaded.foo = nil;
+            local foo = require "foo";
+            foo.hi()
+        ';
+    }
+
+    location /check {
+        content_by_lua '
+            local foo = package.loaded.foo
+            if foo then
+                ngx.say("found")
+            else
+                ngx.say("not found")
+            end
+            foo.hi()
+        ';
+    }
+--- request
+GET /main
+--- user_files
+>>> foo.lua
+module(..., package.seeall);
+
+ngx.say("loading");
+
+function hi ()
+    ngx.say("hello, foo")
+end;
+--- response_body
+loading
+hello, foo
+found
+hello, foo
+found
+hello, foo
+
+
+
+=== TEST 2: sanity
+--- http_config eval
+    "lua_package_cpath '$::HtmlDir/?.so';"
+--- config
+    location /main {
+        content_by_lua '
+            ngx.print(package.cpath);
+        ';
+    }
+--- request
+GET /main
+--- user_files
+--- response_body_like: ^[^;]+/servroot/html/\?.so$
+
+
+
+=== TEST 3: expand default path (after)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;;';"
+--- config
+    location /main {
+        content_by_lua '
+            ngx.print(package.path);
+        ';
+    }
+--- request
+GET /main
+--- response_body_like: ^[^;]+/servroot/html/\?.lua;.+\.lua;$
+
+
+
+=== TEST 4: expand default cpath (after)
+--- http_config eval
+    "lua_package_cpath '$::HtmlDir/?.so;;';"
+--- config
+    location /main {
+        content_by_lua '
+            ngx.print(package.cpath);
+        ';
+    }
+--- request
+GET /main
+--- response_body_like: ^[^;]+/servroot/html/\?.so;.+\.so;$
+
+
+
+=== TEST 5: expand default path (before)
+--- http_config eval
+    "lua_package_path ';;$::HtmlDir/?.lua';"
+--- config
+    location /main {
+        content_by_lua '
+            ngx.print(package.path);
+        ';
+    }
+--- request
+GET /main
+--- response_body_like: ^.+\.lua;[^;]+/servroot/html/\?.lua$
+
+
+
+=== TEST 6: expand default cpath (before)
+--- http_config eval
+    "lua_package_cpath ';;$::HtmlDir/?.so';"
+--- config
+    location /main {
+        content_by_lua '
+            ngx.print(package.cpath);
+        ';
+    }
+--- request
+GET /main
+--- response_body_like: ^.+\.so;[^;]+/servroot/html/\?.so$
+
+
+
+=== TEST 7: require "ngx" (content_by_lua)
+--- config
+    location /ngx {
+        content_by_lua '
+            local ngx = require "ngx"
+            ngx.say("hello, world")
+        ';
+    }
+--- request
+GET /ngx
+--- response_body
+hello, world
+
+
+
+=== TEST 8: require "ngx" (set_by_lua)
+--- config
+    location /ngx {
+        set_by_lua $res '
+            local ngx = require "ngx"
+            return ngx.escape_uri(" ")
+        ';
+        echo $res;
+    }
+--- request
+GET /ngx
+--- response_body
+%20
+
+
+
+=== TEST 9: require "ndk" (content_by_lua)
+--- config
+    location /ndk {
+        content_by_lua '
+            local ndk = require "ndk"
+            local res = ndk.set_var.set_escape_uri(" ")
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /ndk
+--- response_body
+%20
+
+
+
+=== TEST 10: require "ndk" (set_by_lua)
+--- config
+    location /ndk {
+        set_by_lua $res '
+            local ndk = require "ndk"
+            return ndk.set_var.set_escape_uri(" ")
+        ';
+        echo $res;
+    }
+--- request
+GET /ndk
+--- response_body
+%20
+
diff -rNu a/src/lua/lua-nginx-module/t/005-exit.t b/src/lua/lua-nginx-module/t/005-exit.t
--- a/src/lua/lua-nginx-module/t/005-exit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/005-exit.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,565 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#repeat_each(20000);
+repeat_each(2);
+#master_on();
+#workers(1);
+#log_level('debug');
+#log_level('warn');
+#worker_connections(1024);
+
+plan tests => repeat_each() * (blocks() * 3 + 4);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+
+our $LuaCpath = $ENV{LUA_CPATH} ||
+    '/usr/local/openresty-debug/lualib/?.so;/usr/local/openresty/lualib/?.so;;';
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: throw 403
+--- config
+    location /lua {
+        content_by_lua "ngx.exit(403);ngx.say('hi')";
+    }
+--- request
+GET /lua
+--- error_code: 403
+--- response_body_like: 403 Forbidden
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: throw 404
+--- config
+    location /lua {
+        content_by_lua "ngx.exit(404);ngx.say('hi');";
+    }
+--- request
+GET /lua
+--- error_code: 404
+--- response_body_like: 404 Not Found
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: throw 404 after sending the header and partial body
+--- config
+    location /lua {
+        content_by_lua "ngx.say('hi');ngx.exit(404);ngx.say(', you')";
+    }
+--- request
+GET /lua
+--- error_log
+attempt to set status 404 via ngx.exit after sending out the response status 200
+--- no_error_log
+alert
+--- response_body
+hi
+
+
+
+=== TEST 4: working with ngx_auth_request (succeeded)
+--- config
+    location /auth {
+        content_by_lua "
+            if ngx.var.user == 'agentzh' then
+                ngx.eof();
+            else
+                ngx.exit(403)
+            end";
+    }
+    location /api {
+        set $user $arg_user;
+        auth_request /auth;
+
+        echo "Logged in";
+    }
+--- request
+GET /api?user=agentzh
+--- error_code: 200
+--- response_body
+Logged in
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: working with ngx_auth_request (failed)
+--- config
+    location /auth {
+        content_by_lua "
+            if ngx.var.user == 'agentzh' then
+                ngx.eof();
+            else
+                ngx.exit(403)
+            end";
+    }
+    location /api {
+        set $user $arg_user;
+        auth_request /auth;
+
+        echo "Logged in";
+    }
+--- request
+GET /api?user=agentz
+--- error_code: 403
+--- response_body_like: 403 Forbidden
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: working with ngx_auth_request (simplest form, w/o ngx_memc)
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        content_by_lua_file 'html/foo.lua';
+    }
+    location /api {
+        set $uid $arg_uid;
+        auth_request /conv-uid;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+-- print('just have run sr: ' .. res.body)
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: working with ngx_auth_request (simplest form)
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        content_by_lua_file 'html/foo.lua';
+    }
+    location /api {
+        set $uid $arg_uid;
+        auth_request /conv-uid;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+-- print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: working with ngx_auth_request
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+
+    upstream memc_a {
+        server 127.0.0.1:\$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    upstream memc_b {
+        server 127.0.0.1:\$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    upstream_list memc_cluster memc_a memc_b;
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        set_hashed_upstream $backend memc_cluster $arg_key;
+        memc_pass $backend;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        content_by_lua_file 'html/foo.lua';
+    }
+    location /api {
+        set $uid $arg_uid;
+        auth_request /conv-uid;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+-- print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 9: working with ngx_auth_request
+--- http_config
+    upstream backend {
+        drizzle_server 127.0.0.1:$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+
+    upstream memc_a {
+        server 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+        keepalive 300;
+    }
+
+    #upstream_list memc_cluster memc_a memc_b;
+
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        #set_hashed_upstream $backend memc_cluster $arg_key;
+        memc_pass memc_a;
+    }
+
+    location /conv-mysql {
+        internal;
+
+        set $key "conv-uri-$query_string";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        set_quote_sql_str $seo_uri $query_string;
+        drizzle_query "select url from my_url_map where seo_url=$seo_uri";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        content_by_lua_file 'html/foo.lua';
+    }
+
+    location /baz {
+        set $my_uri $uri;
+        auth_request /conv-uid;
+
+        echo_exec /jump $my_uri;
+    }
+
+    location /jump {
+        internal;
+        rewrite ^ $query_string? redirect;
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local seo_uri = ngx.var.my_uri
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-mysql?' .. seo_uri)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].url) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.my_uri = res[1].url;
+-- print('done')
+--- request
+GET /baz
+--- response_body_like: 302
+--- error_code: 302
+--- response_headers
+Location: http://localhost:$ServerPort/foo/bar
+--- SKIP
+
+
+
+=== TEST 10: throw 0
+--- config
+    location /lua {
+        content_by_lua "ngx.say('Hi'); ngx.eof(); ngx.exit(0);ngx.say('world')";
+    }
+--- request
+GET /lua
+--- error_code: 200
+--- response_body
+Hi
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: pcall safe
+--- config
+    location /lua {
+        content_by_lua '
+            function f ()
+                ngx.say("hello")
+                ngx.exit(200)
+            end
+
+            pcall(f)
+            ngx.say("world")
+        ';
+    }
+--- request
+GET /lua
+--- error_code: 200
+--- response_body
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: 501 Method Not Implemented
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.exit(501)
+        ';
+    }
+--- request
+GET /lua
+--- error_code: 501
+--- response_body_like: 501 (?:Method )?Not Implemented
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: 501 Method Not Implemented
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.exit(ngx.HTTP_METHOD_NOT_IMPLEMENTED)
+        ';
+    }
+--- request
+GET /lua
+--- error_code: 501
+--- response_body_like: 501 (?:Method )?Not Implemented
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: throw 403 after sending out headers with 200
+--- config
+    location /lua {
+        rewrite_by_lua '
+            ngx.send_headers()
+            ngx.say("Hello World")
+            ngx.exit(403)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Hello World
+--- error_log
+attempt to set status 403 via ngx.exit after sending out the response status 200
+--- no_error_log
+[alert]
+
+
+
+=== TEST 15: throw 403 after sending out headers with 403
+--- config
+    location /lua {
+        rewrite_by_lua '
+            ngx.status = 403
+            ngx.send_headers()
+            ngx.say("Hello World")
+            ngx.exit(403)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Hello World
+--- error_code: 403
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 16: throw 403 after sending out headers with 403 (HTTP 1.0 buffering)
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.status = 403
+            ngx.say("Hello World")
+            ngx.exit(403)
+        ';
+    }
+--- request
+GET /t HTTP/1.0
+--- response_body
+Hello World
+--- error_code: 403
+--- no_error_log
+[error]
+[alert]
+
diff -rNu a/src/lua/lua-nginx-module/t/006-escape.t b/src/lua/lua-nginx-module/t/006-escape.t
--- a/src/lua/lua-nginx-module/t/006-escape.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/006-escape.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,132 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2 + 1);
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: escape uri in set_by_lua
+--- config
+    location /escape {
+        set_by_lua $res "return ngx.escape_uri('a 你')";
+        echo $res;
+    }
+--- request
+GET /escape
+--- response_body
+a%20%e4%bd%a0
+
+
+
+=== TEST 2: unescape uri in set_by_lua
+--- config
+    location /unescape {
+        set_by_lua $res "return ngx.unescape_uri('a%20%e4%bd%a0')";
+        echo $res;
+    }
+--- request
+GET /unescape
+--- response_body
+a 你
+
+
+
+=== TEST 3: escape uri in content_by_lua
+--- config
+    location /escape {
+        content_by_lua "ngx.say(ngx.escape_uri('a 你'))";
+    }
+--- request
+GET /escape
+--- response_body
+a%20%e4%bd%a0
+
+
+
+=== TEST 4: unescape uri in content_by_lua
+--- config
+    location /unescape {
+        content_by_lua "ngx.say(ngx.unescape_uri('a%20%e4%bd%a0'))";
+    }
+--- request
+GET /unescape
+--- response_body
+a 你
+
+
+
+=== TEST 5: escape uri in set_by_lua
+--- config
+    location /escape {
+        set_by_lua $res "return ngx.escape_uri('a+b')";
+        echo $res;
+    }
+--- request
+GET /escape
+--- response_body
+a%2bb
+
+
+
+=== TEST 6: escape uri in set_by_lua
+--- config
+    location /escape {
+        set_by_lua $res "return ngx.escape_uri('\"a/b={}:<>;&[]\\\\^')";
+        echo $res;
+    }
+--- request
+GET /escape
+--- response_body
+%22a%2fb%3d%7b%7d%3a%3c%3e%3b%26%5b%5d%5c%5e
+
+
+
+=== TEST 7: escape uri in set_by_lua
+--- config
+    location /escape {
+        echo hello;
+        header_filter_by_lua '
+            ngx.header.baz = ngx.escape_uri(" ")
+        ';
+    }
+--- request
+GET /escape
+--- response_headers
+baz: %20
+--- response_body
+hello
+
+
+
+=== TEST 8: escape a string that cannot be escaped
+--- config
+    location /escape {
+        set_by_lua $res "return ngx.escape_uri('abc')";
+        echo $res;
+    }
+--- request
+GET /escape
+--- response_body
+abc
+
+
+
+=== TEST 9: escape an empty string that cannot be escaped
+--- config
+    location /escape {
+        set_by_lua $res "return ngx.escape_uri('')";
+        echo $res;
+    }
+--- request
+GET /escape
+--- response_body eval: "\n"
+
diff -rNu a/src/lua/lua-nginx-module/t/007-md5.t b/src/lua/lua-nginx-module/t/007-md5.t
--- a/src/lua/lua-nginx-module/t/007-md5.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/007-md5.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,91 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: set md5 hello
+--- config
+    location = /md5 {
+        content_by_lua 'ngx.say(ngx.md5("hello"))';
+    }
+--- request
+GET /md5
+--- response_body
+5d41402abc4b2a76b9719d911017c592
+
+
+
+=== TEST 2: nil string to ngx.md5
+--- config
+    location = /md5 {
+        content_by_lua 'ngx.say(ngx.md5(nil))';
+    }
+--- request
+GET /md5
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
+
+
+=== TEST 3: null string to ngx.md5
+--- config
+    location /md5 {
+        content_by_lua 'ngx.say(ngx.md5(""))';
+    }
+--- request
+GET /md5
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
+
+
+=== TEST 4: use ngx.md5 in set_by_lua
+--- config
+    location = /md5 {
+        set_by_lua $a 'return ngx.md5("hello")';
+        echo $a;
+    }
+--- request
+GET /md5
+--- response_body
+5d41402abc4b2a76b9719d911017c592
+
+
+
+=== TEST 5: use ngx.md5 in set_by_lua (nil)
+--- config
+    location = /md5 {
+        set_by_lua $a 'return ngx.md5(nil)';
+        echo $a;
+    }
+--- request
+GET /md5
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
+
+
+=== TEST 6: use ngx.md5 in set_by_lua (null string)
+--- config
+    location /md5 {
+        set_by_lua $a 'return ngx.md5("")';
+        echo $a;
+    }
+--- request
+GET /md5
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
diff -rNu a/src/lua/lua-nginx-module/t/008-today.t b/src/lua/lua-nginx-module/t/008-today.t
--- a/src/lua/lua-nginx-module/t/008-today.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/008-today.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,39 @@
+# vim:set ft=perl ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: use ngx.today in content_by_lua
+--- config
+    location = /today {
+        content_by_lua 'ngx.say(ngx.today())';
+    }
+--- request
+GET /today
+--- response_body_like: ^\d{4}-\d{2}-\d{2}$
+
+
+
+=== TEST 2: use ngx.today in set_by_lua
+--- config
+    location = /today {
+        set_by_lua $a 'return ngx.today()';
+        echo $a;
+    }
+--- request
+GET /today
+--- response_body_like: ^\d{4}-\d{2}-\d{2}$
+
diff -rNu a/src/lua/lua-nginx-module/t/009-log.t b/src/lua/lua-nginx-module/t/009-log.t
--- a/src/lua/lua-nginx-module/t/009-log.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/009-log.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,456 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('debug'); # to ensure any log-level can be outputed
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 4);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: test log-level STDERR
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.STDERR, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 2: test log-level EMERG
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.EMERG, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[emerg\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 3: test log-level ALERT
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.ALERT, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[alert\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 4: test log-level CRIT
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.CRIT, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[crit\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 5: test log-level ERR
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.ERR, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[error\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 6: test log-level WARN
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.WARN, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[warn\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 7: test log-level NOTICE
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.NOTICE, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[notice\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 8: test log-level INFO
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.INFO, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[info\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 9: test log-level DEBUG
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            ngx.log(ngx.DEBUG, "hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[debug\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 10: regression test print()
+--- config
+    location /log {
+        content_by_lua '
+            ngx.say("before log")
+            print("hello, log", 1234, 3.14159)
+            ngx.say("after log")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+before log
+after log
+--- error_log eval
+qr/\[notice\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:3: hello, log12343.14159/
+
+
+
+=== TEST 11: print(nil)
+--- config
+    location /log {
+        content_by_lua '
+            print()
+            print(nil)
+            print("nil: ", nil)
+            ngx.say("hi");
+        ';
+    }
+--- request
+GET /log
+--- response_body
+hi
+--- error_log eval
+[
+'[lua] [string "content_by_lua"]:2: ,',
+'[lua] [string "content_by_lua"]:3: nil,',
+'[lua] [string "content_by_lua"]:4: nil: nil,',
+]
+
+
+
+=== TEST 12: ngx.log in set_by_lua
+--- config
+    location /log {
+        set_by_lua $a '
+            ngx.log(ngx.ERR, "HELLO")
+            return 32;
+        ';
+        echo $a;
+    }
+--- request
+GET /log
+--- response_body
+32
+--- error_log eval
+qr/\[error\] \S+: \S+ \[lua\] \[string "set_by_lua"\]:2: HELLO,/
+
+
+
+=== TEST 13: test booleans and nil
+--- config
+    location /log {
+        set_by_lua $a '
+            ngx.log(ngx.ERR, true, false, nil)
+            return 32;
+        ';
+        echo $a;
+    }
+--- request
+GET /log
+--- response_body
+32
+--- error_log eval
+qr/\[error\] \S+: \S+ \[lua\] \[string "set_by_lua"\]:2: truefalsenil,/
+
+
+
+=== TEST 14: print() in header filter
+--- config
+    location /log {
+        header_filter_by_lua '
+            print("hello world")
+            ngx.header.foo = 32
+        ';
+        echo hi;
+    }
+--- request
+GET /log
+--- response_headers
+foo: 32
+--- error_log eval
+qr/\[notice\] .*? \[lua\] \[string "header_filter_by_lua"\]:2: hello world/
+--- response_body
+hi
+
+
+
+=== TEST 15: ngx.log() in header filter
+--- config
+    location /log {
+        header_filter_by_lua '
+            ngx.log(ngx.ERR, "howdy, lua!")
+            ngx.header.foo = 32
+        ';
+        echo hi;
+    }
+--- request
+GET /log
+--- response_headers
+foo: 32
+--- response_body
+hi
+--- error_log eval
+qr/\[error\] .*? \[lua\] \[string "header_filter_by_lua"\]:2: howdy, lua!/
+
+
+
+=== TEST 16: ngx.log() big data
+--- config
+    location /log {
+        content_by_lua '
+            ngx.log(ngx.ERR, "a" .. string.rep("h", 1970) .. "b")
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /log
+--- response_headers
+--- error_log eval
+[qr/ah{1970}b/]
+
+
+
+=== TEST 17: ngx.log in Lua function calls & inlined lua
+--- config
+    location /log {
+        content_by_lua '
+            function foo()
+                bar()
+            end
+
+            function bar()
+                ngx.log(ngx.ERR, "hello, log", 1234, 3.14159)
+            end
+
+            foo()
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+done
+--- error_log eval
+qr/\[error\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:7: bar\(\): hello, log12343.14159/
+
+
+
+=== TEST 18: ngx.log in Lua function tail-calls & inlined lua
+--- config
+    location /log {
+        content_by_lua '
+            function foo()
+                return bar(5)
+            end
+
+            function bar(n)
+                if n < 1 then
+                    ngx.log(ngx.ERR, "hello, log", 1234, 3.14159)
+                    return n
+                end
+
+                return bar(n - 1)
+            end
+
+            foo()
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /log
+--- response_body
+done
+--- error_log eval
+qr/\[error\] \S+: \S+ \[lua\] \[string "content_by_lua"\]:8:(?: foo\(\):)? hello, log12343.14159/
+
+
+
+=== TEST 19: ngx.log in Lua files
+--- config
+    location /log {
+        content_by_lua_file 'html/test.lua';
+    }
+--- user_files
+>>> test.lua
+function foo()
+    bar()
+end
+
+function bar()
+    ngx.log(ngx.ERR, "hello, log", 1234, 3.14159)
+end
+
+foo()
+ngx.say("done")
+
+--- request
+GET /log
+--- response_body
+done
+--- error_log eval
+qr/\[error\] \S+: \S+ \[lua\] test.lua:6: bar\(\): hello, log12343.14159/
+
+
+
+=== TEST 20: ngx.log with bad levels (ngx.ERROR, -1)
+--- config
+    location /log {
+        content_by_lua '
+            ngx.log(ngx.ERROR, "hello lua")
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /log
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad log level: -1
+
+
+
+=== TEST 21: ngx.log with bad levels (9)
+--- config
+    location /log {
+        content_by_lua '
+            ngx.log(9, "hello lua")
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /log
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad log level: 9
+
+
+
+=== TEST 22: \0 in the log message
+--- config
+    location = /t {
+        content_by_lua '
+            ngx.log(ngx.WARN, "hello\\0world")
+            ngx.say("ok")
+        ';
+    }
+--- request
+GET /t
+--- response_body
+ok
+--- no_error_log
+[error]
+--- error_log eval
+"2: hello\0world, client: "
+
diff -rNu a/src/lua/lua-nginx-module/t/010-request_body.t b/src/lua/lua-nginx-module/t/010-request_body.t
--- a/src/lua/lua-nginx-module/t/010-request_body.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/010-request_body.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,273 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('debug'); # to ensure any log-level can be outputed
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: test reading request body
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 2: test not reading request body
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 3: test default setting (not reading request body)
+--- config
+    location /echo_body {
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 4: test main conf
+--- http_config
+    lua_need_request_body on;
+--- config
+    location /echo_body {
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 5: test server conf
+--- config
+    lua_need_request_body on;
+
+    location /echo_body {
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 6: test override main conf
+--- http_config
+    lua_need_request_body on;
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 7: test override server conf
+--- config
+    lua_need_request_body on;
+
+    location /echo_body {
+        lua_need_request_body off;
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 8: test override server conf
+--- config
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /hi {
+        echo_request_body;
+    }
+    location /echo_body {
+        lua_need_request_body off;
+        content_by_lua '
+            ngx.say(ngx.var.request_body or "nil")
+            local res = ngx.location.capture(
+                "/proxy",
+                { method = ngx.HTTP_POST,
+                  body = ngx.var.request_body })
+
+            ngx.say(res.status)
+        ';
+    }
+--- request eval
+"POST /echo_body
+"
+--- response_body
+nil
+200
+
+
+
+=== TEST 9: empty POST body
+--- config
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /hi {
+        echo_request_body;
+    }
+    location /echo_body {
+        lua_need_request_body on;
+        content_by_lua '
+            ngx.say(ngx.var.request_body or "nil")
+            local res = ngx.location.capture(
+                "/proxy",
+                { method = ngx.HTTP_POST,
+                  body = ngx.var.request_body })
+
+            ngx.say(res.status)
+        ';
+    }
+--- request eval
+"POST /echo_body
+"
+--- response_body
+nil
+200
+
+
+
+=== TEST 10: on disk request body
+--- config
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /hi {
+        echo_request_body;
+    }
+    location /echo_body {
+        lua_need_request_body on;
+
+        client_max_body_size 100k;
+        client_body_buffer_size 1;
+        sendfile on;
+
+        content_by_lua '
+            local res = ngx.location.capture(
+                "/proxy",
+                { method = ngx.HTTP_POST,
+                  body = ngx.var.request_body })
+            ngx.print(res.body)
+        ';
+    }
+--- request eval
+"POST /echo_body
+" . ('a' x 1024)
+--- response_body chomp
+
+
+
+=== TEST 11: no modify main request content-length
+--- config
+    location /foo {
+        content_by_lua '
+            ngx.location.capture("/other", {body = "hello"})
+            ngx.say(ngx.req.get_headers()["Content-Length"] or "nil")
+        ';
+    }
+    location /other {
+        echo hi;
+    }
+--- request
+POST /foo
+hi
+--- response_body
+2
+
+
+
+=== TEST 12: Expect: 100-Continue
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        content_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+    }
+--- request
+POST /echo_body
+hello world
+--- more_headers
+Expect: 100-Continue
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+http finalize request: 500, "/echo_body?" a:1, c:2
+http finalize request: 500, "/echo_body?" a:1, c:0
+--- log_level: debug
+
diff -rNu a/src/lua/lua-nginx-module/t/011-md5_bin.t b/src/lua/lua-nginx-module/t/011-md5_bin.t
--- a/src/lua/lua-nginx-module/t/011-md5_bin.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/011-md5_bin.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,152 @@
+# vim:set ft=perl ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+
+#md5_bin_bin is hard to test, so convert it to hex mode
+
+__DATA__
+
+=== TEST 1: set md5_bin hello ????xxoo
+--- config
+    location = /md5_bin {
+        content_by_lua 'local a = string.gsub(ngx.md5_bin("hello"), ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end); ngx.say(a)';
+    }
+--- request
+GET /md5_bin
+--- response_body
+5d41402abc4b2a76b9719d911017c592
+
+
+
+=== TEST 2: set md5_bin hello ????xxoo
+--- config
+    location = /md5_bin {
+        content_by_lua 'ngx.say(string.len(ngx.md5_bin("hello")))';
+    }
+--- request
+GET /md5_bin
+--- response_body
+16
+
+
+
+=== TEST 3: set md5_bin hello
+--- config
+    location = /md5_bin {
+        content_by_lua '
+            local s = ngx.md5_bin("hello")
+            s = string.gsub(s, ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end)
+            ngx.say(s)
+        ';
+    }
+--- request
+GET /md5_bin
+--- response_body
+5d41402abc4b2a76b9719d911017c592
+
+
+
+=== TEST 4: nil string to ngx.md5_bin
+--- config
+    location = /md5_bin {
+        content_by_lua '
+            local s = ngx.md5_bin(nil)
+            s = string.gsub(s, ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end)
+            ngx.say(s)
+        ';
+    }
+--- request
+GET /md5_bin
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
+
+
+=== TEST 5: null string to ngx.md5_bin
+--- config
+    location /md5_bin {
+        content_by_lua '
+            local s = ngx.md5_bin("")
+            s = string.gsub(s, ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end)
+            ngx.say(s)
+        ';
+    }
+--- request
+GET /md5_bin
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
+
+
+=== TEST 6: use ngx.md5_bin in set_by_lua
+--- config
+    location = /md5_bin {
+        set_by_lua $a 'return string.gsub(ngx.md5_bin("hello"), ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end)';
+        echo $a;
+    }
+--- request
+GET /md5_bin
+--- response_body
+5d41402abc4b2a76b9719d911017c592
+
+
+
+=== TEST 7: use ngx.md5_bin in set_by_lua (nil)
+--- config
+    location = /md5_bin {
+        set_by_lua $a '
+            local s = ngx.md5_bin(nil)
+            s = string.gsub(s, ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end)
+            return s
+        ';
+        echo $a;
+    }
+--- request
+GET /md5_bin
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
+
+
+=== TEST 8: use ngx.md5_bin in set_by_lua (null string)
+--- config
+    location /md5_bin {
+        set_by_lua $a '
+            local s = ngx.md5_bin("")
+            s = string.gsub(s, ".", function (c)
+                    return string.format("%02x", string.byte(c))
+                end)
+            return s
+        ';
+        echo $a;
+    }
+--- request
+GET /md5_bin
+--- response_body
+d41d8cd98f00b204e9800998ecf8427e
+
diff -rNu a/src/lua/lua-nginx-module/t/012-now.t b/src/lua/lua-nginx-module/t/012-now.t
--- a/src/lua/lua-nginx-module/t/012-now.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/012-now.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,119 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: use ngx.localtime in content_by_lua
+--- config
+    location = /now {
+        content_by_lua 'ngx.say(ngx.localtime())';
+    }
+--- request
+GET /now
+--- response_body_like: ^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$
+
+
+
+=== TEST 2: use ngx.localtime in set_by_lua
+--- config
+    location = /now {
+        set_by_lua $a 'return ngx.localtime()';
+        echo $a;
+    }
+--- request
+GET /now
+--- response_body_like: ^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$
+
+
+
+=== TEST 3: use ngx.time in set_by_lua
+--- config
+    location = /time {
+        set_by_lua $a 'return ngx.time()';
+        echo $a;
+    }
+--- request
+GET /time
+--- response_body_like: ^\d{10,}$
+
+
+
+=== TEST 4: use ngx.time in content_by_lua
+--- config
+    location = /time {
+        content_by_lua 'ngx.say(ngx.time())';
+    }
+--- request
+GET /time
+--- response_body_like: ^\d{10,}$
+
+
+
+=== TEST 5: use ngx.time in content_by_lua
+--- config
+    location = /time {
+        content_by_lua '
+            ngx.say(ngx.time())
+            ngx.say(ngx.localtime())
+            ngx.say(ngx.utctime())
+            ngx.say(ngx.cookie_time(ngx.time()))
+        ';
+    }
+--- request
+GET /time
+--- response_body_like chomp
+^\d{10,}
+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}
+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}
+\w+, .*? GMT$
+
+
+
+=== TEST 6: use ngx.now in set_by_lua
+--- config
+    location = /time {
+        set_by_lua $a 'return ngx.now()';
+        echo $a;
+    }
+--- request
+GET /time
+--- response_body_like: ^\d{10,}(\.\d{1,3})?$
+
+
+
+=== TEST 7: use ngx.now in content_by_lua
+--- config
+    location = /time {
+        content_by_lua 'ngx.say(ngx.now())';
+    }
+--- request
+GET /time
+--- response_body_like: ^\d{10,}(\.\d{1,3})?$
+
+
+
+=== TEST 8: use ngx.update_time & ngx.now in content_by_lua
+--- config
+    location = /time {
+        content_by_lua '
+            ngx.update_time()
+            ngx.say(ngx.now())
+        ';
+    }
+--- request
+GET /time
+--- response_body_like: ^\d{10,}(\.\d{1,3})?$
+
diff -rNu a/src/lua/lua-nginx-module/t/013-base64.t b/src/lua/lua-nginx-module/t/013-base64.t
--- a/src/lua/lua-nginx-module/t/013-base64.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/013-base64.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,167 @@
+# vim:set ft=perl ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+
+__DATA__
+
+=== TEST 1: base64 encode hello
+--- config
+    location = /encode_base64 {
+        content_by_lua 'ngx.say(ngx.encode_base64("hello"))';
+    }
+--- request
+GET /encode_base64
+--- response_body
+aGVsbG8=
+
+
+
+=== TEST 2: nil string to ngx.encode_base64
+--- config
+    location = /encode_base64 {
+        content_by_lua 'ngx.say("left" .. ngx.encode_base64(nil) .. "right")';
+    }
+--- request
+GET /encode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 3: null string to ngx.encode_base64
+--- config
+    location = /encode_base64 {
+        content_by_lua 'ngx.say("left" .. ngx.encode_base64("") .. "right")';
+    }
+--- request
+GET /encode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 4: use ngx.encode_base64 in set_by_lua
+--- config
+    location = /encode_base64 {
+        set_by_lua $a 'return ngx.encode_base64("hello")';
+        echo $a;
+    }
+--- request
+GET /encode_base64
+--- response_body
+aGVsbG8=
+
+
+
+=== TEST 5: use ngx.encode_base64 in set_by_lua (nil)
+--- config
+    location = /encode_base64 {
+        set_by_lua $a 'return "left" .. ngx.encode_base64(nil) .. "right"';
+        echo $a;
+    }
+--- request
+GET /encode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 6: use ngx.encode_base64 in set_by_lua (null string)
+--- config
+    location /encode_base64 {
+        set_by_lua $a 'return "left" .. ngx.encode_base64("") .. "right"';
+        echo $a;
+    }
+--- request
+GET /encode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 7: base64 encode hello
+--- config
+    location = /decode_base64 {
+        content_by_lua 'ngx.say(ngx.decode_base64("aGVsbG8="))';
+    }
+--- request
+GET /decode_base64
+--- response_body
+hello
+
+
+
+=== TEST 8: nil string to ngx.decode_base64
+--- config
+    location = /decode_base64 {
+        content_by_lua 'ngx.say("left" .. ngx.decode_base64(nil) .. "right")';
+    }
+--- request
+GET /decode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 9: null string to ngx.decode_base64
+--- config
+    location = /decode_base64 {
+        content_by_lua 'ngx.say("left" .. ngx.decode_base64("") .. "right")';
+    }
+--- request
+GET /decode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 10: use ngx.decode_base64 in set_by_lua
+--- config
+    location = /decode_base64 {
+        set_by_lua $a 'return ngx.decode_base64("aGVsbG8=")';
+        echo $a;
+    }
+--- request
+GET /decode_base64
+--- response_body
+hello
+
+
+
+=== TEST 11: use ngx.decode_base64 in set_by_lua (nil)
+--- config
+    location = /decode_base64 {
+        set_by_lua $a 'return "left" .. ngx.decode_base64(nil) .. "right"';
+        echo $a;
+    }
+--- request
+GET /decode_base64
+--- response_body
+leftright
+
+
+
+=== TEST 12: use ngx.decode_base64 in set_by_lua (null string)
+--- config
+    location /decode_base64 {
+        set_by_lua $a 'return "left" .. ngx.decode_base64("") .. "right"';
+        echo $a;
+    }
+--- request
+GET /decode_base64
+--- response_body
+leftright
+
diff -rNu a/src/lua/lua-nginx-module/t/014-bugs.t b/src/lua/lua-nginx-module/t/014-bugs.t
--- a/src/lua/lua-nginx-module/t/014-bugs.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/014-bugs.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,830 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+log_level('debug');
+
+repeat_each(3);
+
+plan tests => repeat_each() * (blocks() * 2 + 24);
+
+our $HtmlDir = html_dir;
+#warn $html_dir;
+
+#no_diff();
+#no_long_string();
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_shuffle();
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /load {
+        content_by_lua '
+            package.loaded.foo = nil;
+            local foo = require "foo";
+            foo.hi()
+        ';
+    }
+--- request
+GET /load
+--- user_files
+>>> foo.lua
+module(..., package.seeall);
+
+function foo () 
+    return 1
+    return 2
+end
+--- error_code: 500
+--- response_body_like: 500 Internal Server Error
+
+
+
+=== TEST 2: sanity
+--- http_config
+lua_package_path '/home/agentz/rpm/BUILD/lua-yajl-1.1/build/?.so;/home/lz/luax/?.so;./?.so';
+--- config
+    location = '/report/listBidwordPrices4lzExtra.htm' {
+        content_by_lua '
+            local yajl = require "yajl"
+            local w = ngx.var.arg_words
+            w = ngx.unescape_uri(w)
+            local r = {}
+            print("start for")
+            for id in string.gmatch(w, "%d+") do
+                 r[id] = -1
+            end
+            print("end for, start yajl")
+            ngx.print(yajl.to_string(r))
+            print("end yajl")
+        ';
+    }
+--- request
+GET /report/listBidwordPrices4lzExtra.htm?words=123,156,2532
+--- response_body
+--- SKIP
+
+
+
+=== TEST 3: sanity
+--- config
+    location = /memc {
+        #set $memc_value 'hello';
+        set $memc_value $arg_v;
+        set $memc_cmd $arg_c;
+        set $memc_key $arg_k;
+        #set $memc_value hello;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+        #echo $memc_value;
+    }
+    location = /echo {
+        echo_location '/memc?c=get&k=foo';
+        echo_location '/memc?c=set&k=foo&v=hello';
+        echo_location '/memc?c=get&k=foo';
+    }
+    location = /main {
+        content_by_lua '
+            res = ngx.location.capture("/memc?c=get&k=foo&v=")
+            ngx.say("1: ", res.body)
+
+            res = ngx.location.capture("/memc?c=set&k=foo&v=bar");
+            ngx.say("2: ", res.body);
+
+            res = ngx.location.capture("/memc?c=get&k=foo")
+            ngx.say("3: ", res.body);
+        ';
+    }
+--- request
+GET /main
+--- response_body_like: 3: bar$
+
+
+
+=== TEST 4: capture works for subrequests with internal redirects
+--- config
+    location /lua {
+        content_by_lua '
+            local res = ngx.location.capture("/")
+            ngx.say(res.status)
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /lua
+--- response_body_like chop
+200
+.*It works
+--- SKIP
+
+
+
+=== TEST 5: disk file bufs not working
+--- config
+    location /lua {
+        content_by_lua '
+            local res = ngx.location.capture("/test.lua")
+            ngx.say(res.status)
+            ngx.print(res.body)
+        ';
+    }
+--- user_files
+>>> test.lua
+print("Hello, world")
+--- request
+    GET /lua
+--- response_body
+200
+print("Hello, world")
+
+
+
+=== TEST 6: print lua empty strings
+--- config
+    location /lua {
+        content_by_lua 'ngx.print("") ngx.flush() ngx.print("Hi")';
+    }
+--- request
+GET /lua
+--- response_body chop
+Hi
+
+
+
+=== TEST 7: say lua empty strings
+--- config
+    location /lua {
+        content_by_lua 'ngx.say("") ngx.flush() ngx.print("Hi")';
+    }
+--- request
+GET /lua
+--- response_body eval
+"
+Hi"
+
+
+
+=== TEST 8: github issue 37: header bug
+https://github.com/chaoslawful/lua-nginx-module/issues/37
+--- config
+    location /sub {
+        content_by_lua '
+            ngx.header["Set-Cookie"] = {"TestCookie1=foo", "TestCookie2=bar"};
+            ngx.say("Hello")
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            -- local yajl = require "yajl"
+            ngx.header["Set-Cookie"] = {}
+            res = ngx.location.capture("/sub")
+
+            for i,j in pairs(res.header) do
+                ngx.header[i] = j
+            end
+
+            -- ngx.say("set-cookie: ", yajl.to_string(res.header["Set-Cookie"]))
+
+            ngx.send_headers()
+            ngx.print("body: ", res.body)
+        ';
+    }
+--- request
+GET /lua
+--- raw_response_headers_like eval
+".*Set-Cookie: TestCookie1=foo\r
+Set-Cookie: TestCookie2=bar.*"
+
+
+
+=== TEST 9: memory leak
+--- config
+    location /foo {
+        content_by_lua_file 'html/foo.lua';
+    }
+--- user_files
+>>> foo.lua
+res = {}
+res = {'good 1', 'good 2', 'good 3'}
+return ngx.redirect("/somedir/" .. ngx.escape_uri(res[math.random(1,#res)]))
+--- request
+    GET /foo
+--- response_body
+--- SKIP
+
+
+
+=== TEST 10: capturing locations with internal redirects (no lua redirect)
+--- config
+    location /bar {
+        echo Bar;
+    }
+    location /foo {
+        #content_by_lua '
+        #ngx.exec("/bar")
+        #';
+        echo_exec /bar;
+    }
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/foo")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+Bar
+
+
+
+=== TEST 11: capturing locations with internal redirects (lua redirect)
+--- config
+    location /bar {
+        content_by_lua 'ngx.say("Bar")';
+    }
+    location /foo {
+        content_by_lua '
+            ngx.exec("/bar")
+        ';
+    }
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/foo")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+Bar
+
+
+
+=== TEST 12: capturing locations with internal redirects (simple index)
+--- config
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body chop
+<html><head><title>It works!</title></head><body>It works!</body></html>
+
+
+
+=== TEST 13: capturing locations with internal redirects (more lua statements)
+--- config
+    location /bar {
+        content_by_lua '
+            ngx.say("hello")
+            ngx.say("world")
+        ';
+    }
+    location /foo {
+        #content_by_lua '
+        #ngx.exec("/bar")
+        #';
+        echo_exec /bar;
+    }
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/foo")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+hello
+world
+
+
+
+=== TEST 14: capturing locations with internal redirects (post subrequest with internal redirect)
+--- config
+    location /bar {
+        lua_need_request_body on;
+        client_body_in_single_buffer on;
+
+        content_by_lua '
+            ngx.say(ngx.var.request_body)
+        ';
+    }
+    location /foo {
+        #content_by_lua '
+        #ngx.exec("/bar")
+        #';
+        echo_exec /bar;
+    }
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/foo", { method = ngx.HTTP_POST, body = "hello" })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+hello
+
+
+
+=== TEST 15: nginx rewrite works in subrequests
+--- config
+    rewrite /foo /foo/ permanent;
+    location = /foo/ {
+        echo hello;
+    }
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/foo")
+            ngx.say("status = ", res.status)
+            ngx.say("Location: ", res.header["Location"] or "nil")
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+status = 301
+Location: /foo/
+
+
+
+=== TEST 16: nginx rewrite works in subrequests
+--- config
+    access_by_lua '
+        local res = ngx.location.capture(ngx.var.uri)
+        ngx.say("status = ", res.status)
+        ngx.say("Location: ", res.header["Location"] or "nil")
+        ngx.exit(200)
+    ';
+--- request
+    GET /foo
+--- user_files
+>>> foo/index.html
+It works!
+--- response_body
+status = 301
+Location: /foo/
+
+
+
+=== TEST 17: set content-type header with charset
+--- config
+    location /lua {
+        charset GBK;
+        content_by_lua '
+            ngx.header.content_type = "text/xml; charset=UTF-8"
+            ngx.say("hi")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hi
+--- response_headers
+Content-Type: text/xml; charset=UTF-8
+
+
+
+=== TEST 18: set response header content-type with charset
+--- config
+    location /lua {
+        charset GBK;
+        content_by_lua '
+            ngx.header.content_type = "text/xml"
+            ngx.say("hi")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hi
+--- response_headers
+Content-Type: text/xml; charset=GBK
+
+
+
+=== TEST 19: get by-position capturing variables
+--- config
+    location ~ '^/lua/(.*)' {
+        content_by_lua '
+            ngx.say(ngx.var[1] or "nil")
+        ';
+    }
+--- request
+    GET /lua/hello
+--- response_body
+hello
+
+
+
+=== TEST 20: get by-position capturing variables ($0)
+--- config
+    location ~ '^/lua/(.*)' {
+        content_by_lua '
+            ngx.say(ngx.var[0] or "nil")
+        ';
+    }
+--- request
+    GET /lua/hello
+--- response_body
+nil
+
+
+
+=== TEST 21: get by-position capturing variables (exceeding captures)
+--- config
+    location ~ '^/lua/(.*)' {
+        content_by_lua '
+            ngx.say(ngx.var[2] or "nil")
+        ';
+    }
+--- request
+    GET /lua/hello
+--- response_body
+nil
+
+
+
+=== TEST 22: get by-position capturing variables ($1, $2)
+--- config
+    location ~ '^/lua/(.*)/(.*)' {
+        content_by_lua '
+            ngx.say(ngx.var[-1] or "nil")
+            ngx.say(ngx.var[0] or "nil")
+            ngx.say(ngx.var[1] or "nil")
+            ngx.say(ngx.var[2] or "nil")
+            ngx.say(ngx.var[3] or "nil")
+            ngx.say(ngx.var[4] or "nil")
+        ';
+    }
+--- request
+    GET /lua/hello/world
+--- response_body
+nil
+nil
+hello
+world
+nil
+nil
+
+
+
+=== TEST 23: set special variables
+--- config
+    location /main {
+        #set_unescape_uri $cookie_a "hello";
+        set $http_a "hello";
+        content_by_lua '
+            ngx.say(ngx.var.http_a)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+hello
+--- SKIP
+
+
+
+=== TEST 24: set special variables
+--- config
+    location /main {
+        content_by_lua '
+            dofile(ngx.var.realpath_root .. "/a.lua")
+        ';
+    }
+    location /echo {
+        echo hi;
+    }
+--- request
+    GET /main
+--- user_files
+>>> a.lua
+ngx.location.capture("/echo")
+--- response_body
+--- SKIP
+
+
+
+=== TEST 25: set 20+ headers
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.req.clear_header("Authorization")
+        ';
+        echo $http_a1;
+        echo $http_authorization;
+        echo $http_a2;
+        echo $http_a3;
+        echo $http_a23;
+        echo $http_a24;
+        echo $http_a25;
+    }
+--- request
+    GET /test
+--- more_headers eval
+my $i = 1;
+my $s;
+while ($i <= 25) {
+    $s .= "A$i: $i\n";
+    if ($i == 22) {
+        $s .= "Authorization: blah\n";
+    }
+    $i++;
+}
+#warn $s;
+$s
+--- response_body
+1
+
+2
+3
+23
+24
+25
+
+
+
+=== TEST 26: unexpected globals sharing by using _G
+--- config
+    location /test {
+        content_by_lua '
+            if _G.t then
+                _G.t = _G.t + 1
+            else
+                _G.t = 0
+            end
+            ngx.print(t)
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test", "GET /test"]
+--- response_body eval
+["0", "0", "0"]
+
+
+
+=== TEST 27: unexpected globals sharing by using _G (set_by_lua*)
+--- config
+    location /test {
+        set_by_lua $a '
+            if _G.t then
+                _G.t = _G.t + 1
+            else
+                _G.t = 0
+            end
+            return t
+        ';
+        echo -n $a;
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test", "GET /test"]
+--- response_body eval
+["0", "0", "0"]
+
+
+
+=== TEST 28: unexpected globals sharing by using _G (log_by_lua*)
+--- http_config
+    lua_shared_dict log_dict 100k;
+--- config
+    location /test {
+        content_by_lua '
+            local log_dict = ngx.shared.log_dict
+            ngx.print(log_dict:get("cnt") or 0)
+        ';
+
+        log_by_lua '
+            local log_dict = ngx.shared.log_dict
+            if _G.t then
+                _G.t = _G.t + 1
+            else
+                _G.t = 0
+            end
+            log_dict:set("cnt", t)
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test", "GET /test"]
+--- response_body eval
+["0", "0", "0"]
+
+
+
+=== TEST 29: unexpected globals sharing by using _G (header_filter_by_lua*)
+--- config
+    location /test {
+        header_filter_by_lua '
+            if _G.t then
+                _G.t = _G.t + 1
+            else
+                _G.t = 0
+            end
+            ngx.ctx.cnt = tostring(t)
+        ';
+        content_by_lua '
+            ngx.send_headers()
+            ngx.print(ngx.ctx.cnt or 0)
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test", "GET /test"]
+--- response_body eval
+["0", "0", "0"]
+
+
+
+=== TEST 30: unexpected globals sharing by using _G (body_filter_by_lua*)
+--- config
+    location /test {
+        body_filter_by_lua '
+            if _G.t then
+                _G.t = _G.t + 1
+            else
+                _G.t = 0
+            end
+            ngx.ctx.cnt = _G.t
+        ';
+        content_by_lua '
+            ngx.print("a")
+            ngx.say(ngx.ctx.cnt or 0)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+a0
+--- no_error_log
+[error]
+
+
+
+=== TEST 31: set content-type header with charset and default_type
+--- http_config
+--- config
+    location /lua {
+        default_type application/json;
+        charset utf-8;
+        charset_types application/json;
+        content_by_lua 'ngx.say("hi")';
+    }
+--- request
+    GET /lua
+--- response_body
+hi
+--- response_headers
+Content-Type: application/json; charset=utf-8
+
+
+
+=== TEST 32: hang on upstream_next (from kindy)
+--- http_config
+    upstream xx {
+        server 127.0.0.1:$TEST_NGINX_SERVER_PORT;
+        server 127.0.0.1:$TEST_NGINX_SERVER_PORT;
+    }
+
+    server {
+        server_name "xx";
+        listen $TEST_NGINX_SERVER_PORT;
+
+        return 444;
+    }
+--- config
+    location = /t {
+        proxy_pass http://xx;
+    }
+
+    location = /bad {
+        return 444;
+    }
+--- request
+    GET /t
+--- timeout: 1
+--- response_body_like: 502 Bad Gateway
+--- error_code: 502
+--- error_log
+upstream prematurely closed connection while reading response header from upstream
+
+
+
+=== TEST 33: last_in_chain is set properly in subrequests
+--- config
+    location = /sub {
+        echo hello;
+        body_filter_by_lua '
+            local eof = ngx.arg[2]
+            if eof then
+                print("eof found in body stream")
+            end
+        ';
+    }
+
+    location = /main {
+        echo_location /sub;
+    }
+
+--- request
+    GET /main
+--- response_body
+hello
+--- log_level: notice
+--- error_log
+eof found in body stream
+
+
+
+=== TEST 34: testing a segfault when using ngx_poll_module + ngx_resolver
+See more details here: http://mailman.nginx.org/pipermail/nginx-devel/2013-January/003275.html
+--- config
+    location /t {
+        set $myserver nginx.org;
+        proxy_pass http://$myserver/;
+        resolver 127.0.0.1;
+    }
+--- request
+    GET /t
+--- ignore_response
+--- abort
+--- timeout: 0.3
+--- log_level: notice
+--- no_error_log
+[alert]
+--- error_log eval
+qr/recv\(\) failed \(\d+: Connection refused\) while resolving/
+
+
+
+=== TEST 35: github issue #218: ngx.location.capture hangs when querying a remote host that does not exist or is really slow to respond
+--- config
+    set $myurl "https://not-exist.agentzh.org";
+    location /toto {
+        content_by_lua '
+                local proxyUrl = "/myproxy/entity"
+                local res = ngx.location.capture( proxyUrl,  { method = ngx.HTTP_GET })
+                ngx.say("Hello, ", res.status)
+            ';
+    }
+    location ~ /myproxy {
+
+        rewrite    ^/myproxy/(.*)  /$1  break;
+        resolver_timeout 1s;
+        #resolver 172.16.0.23; #  AWS DNS resolver address is the same in all regions - 172.16.0.23
+        resolver 8.8.8.8;
+        proxy_read_timeout 1s;
+        proxy_send_timeout 1s;
+        proxy_connect_timeout 1s;
+        proxy_pass $myurl:443;
+        proxy_pass_request_body off;
+        proxy_set_header Content-Length 0;
+        proxy_set_header  Accept-Encoding  "";
+    }
+
+--- request
+GET /toto
+
+--- stap2
+F(ngx_http_lua_post_subrequest) {
+    println("lua post subrequest")
+    print_ubacktrace()
+}
+
+--- response_body
+Hello, 502
+
+--- error_log
+not-exist.agentzh.org could not be resolved
+--- timeout: 3
+
+
+
+=== TEST 36: line comments in the last line of the inlined Lua code
+--- config
+    location /lua {
+        content_by_lua 'ngx.say("ok") -- blah';
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/015-status.t b/src/lua/lua-nginx-module/t/015-status.t
--- a/src/lua/lua-nginx-module/t/015-status.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/015-status.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,237 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+#repeat_each(120);
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 5);
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: no key found
+--- config
+    location /nil {
+        content_by_lua '
+            ngx.say(ngx.blah_blah == nil and "nil" or "not nil")
+        ';
+    }
+--- request
+GET /nil
+--- response_body
+nil
+
+
+
+=== TEST 2: .status found
+--- config
+    location /nil {
+        content_by_lua '
+            ngx.say(ngx.status == nil and "nil" or "not nil")
+        ';
+    }
+--- request
+GET /nil
+--- response_body
+not nil
+
+
+
+=== TEST 3: default to 0
+--- config
+    location /nil {
+        content_by_lua '
+            ngx.say(ngx.status);
+        ';
+    }
+--- request
+GET /nil
+--- response_body
+0
+
+
+
+=== TEST 4: default to 0
+--- config
+    location /nil {
+        content_by_lua '
+            ngx.say("blah");
+            ngx.say(ngx.status);
+        ';
+    }
+--- request
+GET /nil
+--- response_body
+blah
+200
+
+
+
+=== TEST 5: set 201
+--- config
+    location /201 {
+        content_by_lua '
+            ngx.status = 201;
+            ngx.say("created");
+        ';
+    }
+--- request
+GET /201
+--- response_body
+created
+--- error_code: 201
+
+
+
+=== TEST 6: set "201"
+--- config
+    location /201 {
+        content_by_lua '
+            ngx.status = "201";
+            ngx.say("created");
+        ';
+    }
+--- request
+GET /201
+--- response_body
+created
+--- error_code: 201
+
+
+
+=== TEST 7: set "201.7"
+--- config
+    location /201 {
+        content_by_lua '
+            ngx.status = "201.7";
+            ngx.say("created");
+        ';
+    }
+--- request
+GET /201
+--- response_body
+created
+--- error_code: 201
+
+
+
+=== TEST 8: set "abc"
+--- config
+    location /201 {
+        content_by_lua '
+            ngx.status = "abc";
+            ngx.say("created");
+        ';
+    }
+--- request
+GET /201
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 9: set blah
+--- config
+    location /201 {
+        content_by_lua '
+            ngx.blah = 201;
+            ngx.say("created");
+        ';
+    }
+--- request
+GET /201
+--- response_body
+created
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: set ngx.status before headers are sent
+--- config
+    location /t {
+        content_by_lua '
+            ngx.say("ok")
+            ngx.status = 201
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+ok
+--- error_code: 200
+--- error_log eval
+qr/\[error\] .*? attempt to set ngx\.status after sending out response headers/
+
+
+
+=== TEST 11: http 1.0 and ngx.status
+--- config
+    location /nil {
+        content_by_lua '
+            ngx.status = ngx.HTTP_UNAUTHORIZED
+            ngx.say("invalid request")
+            ngx.exit(ngx.HTTP_OK)
+        ';
+    }
+--- request
+GET /nil HTTP/1.0
+--- response_body
+invalid request
+--- error_code: 401
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: github issue #221: cannot modify ngx.status for responses from ngx_proxy
+--- config
+    location = /t {
+        proxy_pass http://127.0.0.1:$server_port/;
+        header_filter_by_lua '
+            if ngx.status == 206 then
+                ngx.status = ngx.HTTP_OK
+            end
+        ';
+    }
+
+--- request
+GET /t
+
+--- more_headers
+Range: bytes=0-4
+
+--- response_body chop
+<html
+
+--- error_code: 200
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: 101 response has a complete status line
+--- config
+    location /t {
+        content_by_lua '
+            ngx.status = 101
+            ngx.send_headers()
+        ';
+    }
+--- request
+GET /t
+--- raw_response_headers_like: ^HTTP/1.1 101 Switching Protocols\r\n
+--- error_code: 101
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/016-resp-header.t b/src/lua/lua-nginx-module/t/016-resp-header.t
--- a/src/lua/lua-nginx-module/t/016-resp-header.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/016-resp-header.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1049 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 8);
+
+#no_diff();
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: set response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.content_type = "text/my-plain";
+            ngx.say("Hi");
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 2: set response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.content_length = "text/my-plain";
+            ngx.say("Hi");
+        ';
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- response_headers
+Content-Type: text/html
+--- error_code: 500
+
+
+
+=== TEST 3: set response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.content_length = 3
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Content-Length: 3
+--- response_body chop
+Hel
+
+
+
+=== TEST 4: set response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.status = 302;
+            ngx.header["Location"] = "http://agentzh.org/foo";
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://agentzh.org/foo
+--- response_body
+--- error_code: 302
+
+
+
+=== TEST 5: set response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.content_length = 3
+            ngx.header.content_length = nil
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+!Content-Length
+--- response_body
+Hello
+
+
+
+=== TEST 6: set multi response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header["X-Foo"] = {"a", "bc"}
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- raw_response_headers_like chomp
+X-Foo: a\r\n.*?X-Foo: bc\r\n
+--- response_body
+Hello
+
+
+
+=== TEST 7: set response content-type header
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.content_type = {"a", "bc"}
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: bc
+--- response_body
+Hello
+
+
+
+=== TEST 8: set multi response content-type header and clears it
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header["X-Foo"] = {"a", "bc"}
+            ngx.header["X-Foo"] = {}
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+!X-Foo
+--- response_body
+Hello
+
+
+
+=== TEST 9: set multi response content-type header and clears it
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header["X-Foo"] = {"a", "bc"}
+            ngx.header["X-Foo"] = nil
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+!X-Foo
+--- response_body
+Hello
+
+
+
+=== TEST 10: set multi response content-type header (multiple times)
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header["X-Foo"] = {"a", "bc"}
+            ngx.header["X-Foo"] = {"a", "abc"}
+            ngx.say("Hello")
+        ';
+    }
+--- request
+GET /read
+--- raw_response_headers_like chomp
+X-Foo: a\r\n.*?X-Foo: abc\r\n
+--- response_body
+Hello
+
+
+
+=== TEST 11: clear first, then add
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header["Foo"] = {}
+            ngx.header["Foo"] = {"a", "b"}
+            ngx.send_headers()
+        ';
+    }
+--- request
+    GET /lua
+--- raw_response_headers_like eval
+".*Foo: a\r
+Foo: b.*"
+--- response_body
+
+
+
+=== TEST 12: first add, then clear, then add again
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header["Foo"] = {"c", "d"}
+            ngx.header["Foo"] = {}
+            ngx.header["Foo"] = {"a", "b"}
+            ngx.send_headers()
+        ';
+    }
+--- request
+    GET /lua
+--- raw_response_headers_like eval
+".*Foo: a\r
+Foo: b.*"
+--- response_body
+
+
+
+=== TEST 13: names are the same in the beginning (one value per key)
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header["Foox"] = "barx"
+            ngx.header["Fooy"] = "bary"
+            ngx.send_headers()
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Foox: barx
+Fooy: bary
+
+
+
+=== TEST 14: names are the same in the beginning (multiple values per key)
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header["Foox"] = {"conx1", "conx2" }
+            ngx.header["Fooy"] = {"cony1", "cony2" }
+            ngx.send_headers()
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Foox: conx1, conx2
+Fooy: cony1, cony2
+
+
+
+=== TEST 15: set header after ngx.print
+--- config
+    location /lua {
+        default_type "text/plain";
+        content_by_lua '
+            ngx.print("hello")
+            ngx.header.content_type = "text/foo"
+        ';
+    }
+--- request
+    GET /lua
+--- response_body chop
+hello
+--- error_log
+attempt to set ngx.header.HEADER after sending out response headers
+--- no_error_log eval
+["alert", "warn"]
+
+
+
+=== TEST 16: get content-type header after ngx.print
+--- config
+    location /lua {
+        default_type "text/my-plain";
+        content_by_lua '
+            ngx.print("hello, ")
+            ngx.say(ngx.header.content_type)
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+hello, text/my-plain
+
+
+
+=== TEST 17: get content-length header
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.content_length = 2;
+            ngx.say(ngx.header.content_length);
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Content-Length: 2
+--- response_body
+2
+
+
+
+=== TEST 18: get content-length header
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.foo = "bar";
+            ngx.say(ngx.header.foo);
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+foo: bar
+--- response_body
+bar
+
+
+
+=== TEST 19: get content-length header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.var.footer = ngx.header.content_length
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        content_by_lua 'ngx.print("Hello")';
+    }
+--- request
+    GET /main
+--- response_headers
+!Content-Length
+--- response_body
+Hello5
+
+
+
+=== TEST 20: set and get content-length header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.header.content_length = 27
+            ngx.var.footer = ngx.header.content_length
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        content_by_lua 'ngx.print("Hello")';
+    }
+--- request
+    GET /main
+--- response_headers
+!Content-Length
+--- response_body
+Hello27
+
+
+
+=== TEST 21: get content-type header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.var.footer = ngx.header.content_type
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        default_type 'abc/foo';
+        content_by_lua 'ngx.print("Hello")';
+    }
+--- request
+    GET /main
+--- response_headers
+Content-Type: abc/foo
+--- response_body
+Helloabc/foo
+
+
+
+=== TEST 22: set and get content-type header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.header.content_type = "text/blah"
+            ngx.var.footer = ngx.header.content_type
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        default_type 'abc/foo';
+        content_by_lua 'ngx.print("Hello")';
+    }
+--- request
+    GET /main
+--- response_headers
+Content-Type: text/blah
+--- response_body
+Hellotext/blah
+
+
+
+=== TEST 23: get user header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.var.footer = ngx.header.baz
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        content_by_lua '
+            ngx.header.baz = "bah"
+            ngx.print("Hello")
+        ';
+    }
+--- request
+    GET /main
+--- response_headers
+baz: bah
+--- response_body
+Hellobah
+
+
+
+=== TEST 24: set and get user header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.header.baz = "foo"
+            ngx.var.footer = ngx.header.baz
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        content_by_lua '
+            ngx.header.baz = "bah"
+            ngx.print("Hello")
+        ';
+    }
+--- request
+    GET /main
+--- response_headers
+baz: foo
+--- response_body
+Hellofoo
+
+
+
+=== TEST 25: get multiple user header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.var.footer = table.concat(ngx.header.baz, ", ")
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        content_by_lua '
+            ngx.header.baz = {"bah", "blah"}
+            ngx.print("Hello")
+        ';
+    }
+--- request
+    GET /main
+--- raw_response_headers_like eval
+"baz: bah\r
+.*?baz: blah"
+--- response_body
+Hellobah, blah
+
+
+
+=== TEST 26: set and get multiple user header (proxy)
+--- config
+    location /main {
+        set $footer '';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        header_filter_by_lua '
+            ngx.header.baz = {"foo", "baz"}
+            ngx.var.footer = table.concat(ngx.header.baz, ", ")
+        ';
+        echo_after_body $footer;
+    }
+    location /echo {
+        content_by_lua '
+            ngx.header.baz = {"bah", "hah"}
+            ngx.print("Hello")
+        ';
+    }
+--- request
+    GET /main
+--- raw_response_headers_like eval
+"baz: foo\r
+.*?baz: baz"
+--- response_body
+Hellofoo, baz
+
+
+
+=== TEST 27: get non-existant header
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.header.foo);
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+!foo
+--- response_body
+nil
+
+
+
+=== TEST 28: get non-existant header
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.foo = {"bah", "baz", "blah"}
+            ngx.header.foo = nil
+            ngx.say(ngx.header.foo);
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+!foo
+--- response_body
+nil
+
+
+
+=== TEST 29: override domains in the cookie
+--- config
+    location /foo {
+        echo hello;
+        add_header Set-Cookie 'foo=bar; Domain=backend.int';
+        add_header Set-Cookie 'baz=bah; Domain=backend.int';
+    }
+
+    location /main {
+        proxy_pass http://127.0.0.1:$server_port/foo;
+        header_filter_by_lua '
+            local cookies = ngx.header.set_cookie
+            if not cookies then return end
+            if type(cookies) ~= "table" then cookies = {cookies} end
+            local newcookies = {}
+            for i, val in ipairs(cookies) do
+                local newval = string.gsub(val, "([dD]omain)=[%w_-\\\\.]+",
+                          "%1=external.domain.com")
+                table.insert(newcookies, newval)
+            end
+            ngx.header.set_cookie = newcookies
+        ';
+    }
+--- request
+    GET /main
+--- response_headers
+Set-Cookie: foo=bar; Domain=external.domain.com, baz=bah; Domain=external.domain.com
+--- response_body
+hello
+
+
+
+=== TEST 30: set single value to cache-control
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.cache_control = "private"
+            ngx.say("Cache-Control: ", ngx.var.sent_http_cache_control)
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Cache-Control: private
+--- response_body
+Cache-Control: private
+
+
+
+=== TEST 31: set multi values to cache-control
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.cache_control = { "private", "no-store" }
+            ngx.say("Cache-Control: ", ngx.var.sent_http_cache_control)
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Cache-Control: private, no-store
+--- response_body_like chop
+^Cache-Control: private[;,] no-store$
+
+
+
+=== TEST 32: set multi values to cache-control and override it with a single value
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.cache_control = { "private", "no-store" }
+            ngx.header.cache_control = { "no-cache" }
+            ngx.say("Cache-Control: ", ngx.var.sent_http_cache_control)
+            ngx.say("Cache-Control: ", ngx.header.cache_control)
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Cache-Control: no-cache
+--- response_body
+Cache-Control: no-cache
+Cache-Control: no-cache
+
+
+
+=== TEST 33: set multi values to cache-control and override it with multiple values
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.cache_control = { "private", "no-store" }
+            ngx.header.cache_control = { "no-cache", "blah", "foo" }
+            ngx.say("Cache-Control: ", ngx.var.sent_http_cache_control)
+            ngx.say("Cache-Control: ", table.concat(ngx.header.cache_control, ", "))
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+Cache-Control: no-cache, blah, foo
+--- response_body_like chop
+^Cache-Control: no-cache[;,] blah[;,] foo
+Cache-Control: no-cache[;,] blah[;,] foo$
+
+
+
+=== TEST 34: set the www-authenticate response header
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.www_authenticate = "blah"
+            ngx.say("WWW-Authenticate: ", ngx.var.sent_http_www_authenticate)
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+WWW-Authenticate: blah
+--- response_body
+WWW-Authenticate: blah
+
+
+
+=== TEST 35: set and clear the www-authenticate response header
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.foo = "blah"
+            ngx.header.foo = nil
+            ngx.say("Foo: ", ngx.var.sent_http_foo)
+        ';
+    }
+--- request
+    GET /lua
+--- response_headers
+!Foo
+--- response_body
+Foo: nil
+
+
+
+=== TEST 36: set multi values to cache-control and override it with multiple values (to reproduce a bug)
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.cache_control = { "private", "no-store", "foo", "bar", "baz" }
+            ngx.header.cache_control = {}
+            ngx.send_headers()
+            ngx.say("Cache-Control: ", ngx.var.sent_http_cache_control)
+        ';
+        add_header Cache-Control "blah";
+    }
+--- request
+    GET /lua
+--- response_headers
+Cache-Control: blah
+--- response_body
+Cache-Control: blah
+
+
+
+=== TEST 37: set last-modified and return 304
+--- config
+  location /lua {
+        content_by_lua '
+            ngx.header["Last-Modified"] = ngx.http_time(1290079655)
+            ngx.say(ngx.header["Last-Modified"])
+        ';
+    }
+--- request
+    GET /lua
+--- more_headers
+If-Modified-Since: Thu, 18 Nov 2010 11:27:35 GMT
+--- response_headers
+Last-Modified: Thu, 18 Nov 2010 11:27:35 GMT
+--- error_code: 304
+
+
+
+=== TEST 38: set last-modified and return 200
+--- config
+  location /lua {
+        content_by_lua '
+            ngx.header["Last-Modified"] = ngx.http_time(1290079655)
+            ngx.say(ngx.header["Last-Modified"])
+        ';
+    }
+--- request
+    GET /lua
+--- more_headers
+If-Modified-Since: Thu, 18 Nov 2010 11:27:34 GMTT
+--- response_headers
+Last-Modified: Thu, 18 Nov 2010 11:27:35 GMT
+--- response_body
+Thu, 18 Nov 2010 11:27:35 GMT
+
+
+
+=== TEST 39: set response content-encoding header should bypass ngx_http_gzip_filter_module
+--- config
+    default_type text/plain;
+    gzip             on;
+    gzip_min_length  1;
+    gzip_types       text/plain;
+    location /read {
+        content_by_lua '
+            ngx.header.content_encoding = "gzip";
+            ngx.say("Hello, world, my dear friend!");
+        ';
+    }
+--- request
+GET /read
+--- more_headers
+Accept-Encoding: gzip
+--- response_headers
+Content-Type: text/plain
+--- response_body
+Hello, world, my dear friend!
+
+
+
+=== TEST 40: no transform underscores (write)
+--- config
+    lua_transform_underscores_in_response_headers off;
+    location = /t {
+        content_by_lua '
+            ngx.header.foo_bar = "Hello"
+            ngx.say(ngx.header.foo_bar)
+            ngx.say(ngx.header["foo-bar"])
+        ';
+    }
+--- request
+    GET /t
+--- raw_response_headers_like eval
+"\r\nfoo_bar: Hello\r\n"
+--- response_body
+Hello
+nil
+
+
+
+=== TEST 41: with transform underscores (write)
+--- config
+    lua_transform_underscores_in_response_headers on;
+    location = /t {
+        content_by_lua '
+            ngx.header.foo_bar = "Hello"
+            ngx.say(ngx.header.foo_bar)
+            ngx.say(ngx.header["foo-bar"])
+        ';
+    }
+--- request
+    GET /t
+--- raw_response_headers_like eval
+"\r\nfoo-bar: Hello\r\n"
+--- response_body
+Hello
+Hello
+
+
+
+=== TEST 42: github issue #199: underscores in lua variables
+--- config
+    location /read {
+        content_by_lua '
+          ngx.header.content_type = "text/my-plain"
+
+          local results = {}
+          results.something = "hello"
+          results.content_type = "anything"
+          results.somehing_else = "hi"
+
+          for k, v in pairs(results) do
+            ngx.say(k .. ": " .. v)
+          end
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain
+
+--- response_body
+somehing_else: hi
+something: hello
+content_type: anything
+--- no_error_log
+[error]
+
+
+
+=== TEST 43: set multiple response header
+--- config
+    location /read {
+        content_by_lua '
+            for i = 1, 50 do
+                ngx.header["X-Direct-" .. i] = "text/my-plain-" .. i;
+            end
+
+            ngx.say(ngx.header["X-Direct-50"]);
+        ';
+    }
+--- request
+GET /read
+--- response_body
+text/my-plain-50
+--- no_error_log
+[error]
+
+
+
+=== TEST 44: set multiple response header and then reset and then clear
+--- config
+    location /read {
+        content_by_lua '
+            for i = 1, 50 do
+                ngx.header["X-Direct-" .. i] = "text/my-plain-" .. i;
+            end
+
+            for i = 1, 50 do
+                ngx.header["X-Direct-" .. i] = "text/my-plain"
+            end
+
+            for i = 1, 50 do
+                ngx.header["X-Direct-" .. i] = nil
+            end
+
+            ngx.say("ok");
+        ';
+    }
+--- request
+GET /read
+--- response_body
+ok
+--- no_error_log
+[error]
+
+
+
+=== TEST 45: set response content-type header for multiple times
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.content_type = "text/my-plain";
+            ngx.header.content_type = "text/my-plain-2";
+            ngx.say("Hi");
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain-2
+--- response_body
+Hi
+
+
+
+=== TEST 46: set Last-Modified response header for multiple times
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.last_modified = ngx.http_time(1290079655)
+            ngx.header.last_modified = ngx.http_time(1290079654)
+            ngx.say("ok");
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Last-Modified: Thu, 18 Nov 2010 11:27:34 GMT
+--- response_body
+ok
+
+
+
+=== TEST 47: set Last-Modified response header and then clear
+--- config
+    location /read {
+        content_by_lua '
+            ngx.header.last_modified = ngx.http_time(1290079655)
+            ngx.header.last_modified = nil
+            ngx.say("ok");
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+!Last-Modified
+--- response_body
+ok
+
+
+
+=== TEST 48: github #20: segfault caused by the nasty optimization in the nginx core (write)
+--- config
+    location = /t/ {
+        header_filter_by_lua '
+            ngx.header.foo = 1
+        ';
+        proxy_pass http://127.0.0.1:$server_port;
+    }
+--- request
+GET /t
+--- more_headers
+Foo: bar
+Bah: baz
+--- response_headers
+Location: http://localhost:$ServerPort/t/
+--- response_body_like: 301 Moved Permanently
+--- error_code: 301
+--- no_error_log
+[error]
+
+
+
+=== TEST 49: github #20: segfault caused by the nasty optimization in the nginx core (read)
+--- config
+    location = /t/ {
+        header_filter_by_lua '
+            local v = ngx.header.foo
+        ';
+        proxy_pass http://127.0.0.1:$server_port;
+    }
+--- request
+GET /t
+--- more_headers
+Foo: bar
+Bah: baz
+--- response_body_like: 301 Moved Permanently
+--- response_headers
+Location: http://localhost:$ServerPort/t/
+--- error_code: 301
+--- no_error_log
+[error]
+
+
+
+=== TEST 50: github #20: segfault caused by the nasty optimization in the nginx core (read Location)
+--- config
+    location = /t/ {
+        header_filter_by_lua '
+            ngx.header.Foo = ngx.header.location
+        ';
+        proxy_pass http://127.0.0.1:$server_port;
+    }
+--- request
+GET /t
+--- more_headers
+Foo: bar
+Bah: baz
+--- response_headers
+Location: http://localhost:$ServerPort/t/
+Foo: /t/
+--- response_body_like: 301 Moved Permanently
+--- error_code: 301
+--- no_error_log
+[error]
+
+
+
+=== TEST 51: github #20: segfault caused by the nasty optimization in the nginx core (set Foo and read Location)
+--- config
+    location = /t/ {
+        header_filter_by_lua '
+            ngx.header.Foo = 3
+            ngx.header.Foo = ngx.header.location
+        ';
+        proxy_pass http://127.0.0.1:$server_port;
+    }
+--- request
+GET /t
+--- more_headers
+Foo: bar
+Bah: baz
+--- response_headers
+Location: http://localhost:$ServerPort/t/
+Foo: /t/
+--- response_body_like: 301 Moved Permanently
+--- error_code: 301
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/017-exec.t b/src/lua/lua-nginx-module/t/017-exec.t
--- a/src/lua/lua-nginx-module/t/017-exec.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/017-exec.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,576 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 4);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+#no_shuffle();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec("/hi");
+            ngx.say("Hi");
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body
+Hello
+
+
+
+=== TEST 2: empty uri arg
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec("");
+            ngx.say("Hi");
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 3: no arg
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec();
+            ngx.say("Hi");
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: too many args
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec(1, 2, 3, 4);
+            ngx.say("Hi");
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 5: null uri
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec(nil)
+            ngx.say("Hi")
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 6: user args
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec("/hi", "Yichun Zhang")
+            ngx.say("Hi")
+        ';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello Yichun Zhang
+
+
+
+=== TEST 7: args in uri
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec("/hi?agentzh")
+            ngx.say("Hi")
+        ';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello agentzh
+
+
+
+=== TEST 8: args in uri and user args
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec("/hi?a=Yichun", "b=Zhang")
+            ngx.say("Hi")
+        ';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello a=Yichun&b=Zhang
+
+
+
+=== TEST 9: args in uri and user args
+--- config
+    location /read {
+        content_by_lua '
+            ngx.exec("@hi?a=Yichun", "b=Zhang")
+            ngx.say("Hi")
+        ';
+    }
+    location @hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello 
+
+
+
+=== TEST 10: exec after location capture (simple echo)
+--- config
+    location /test {
+        content_by_lua_file 'html/test.lua';
+    }
+
+    location /a {
+        echo "hello";
+    }
+
+    location /b {
+        echo "hello";
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('/b')
+--- request
+    GET /test
+--- response_body
+hello
+
+
+
+=== TEST 11: exec after location capture (memc)
+--- config
+    location /test {
+        content_by_lua_file 'html/test.lua';
+    }
+
+    location /a {
+        set $memc_key 'hello world';
+        set $memc_value 'hello hello hello world world world';
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /b {
+        set $memc_key 'hello world';
+        set $memc_cmd get;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('/b')
+--- request
+    GET /test
+--- response_body: hello hello hello world world world
+
+
+
+=== TEST 12: exec after named location capture (simple echo)
+--- config
+    location /test {
+        content_by_lua_file 'html/test.lua';
+    }
+
+    location /a {
+        echo "hello";
+    }
+
+    location @b {
+        echo "hello";
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('@b')
+--- request
+    GET /test
+--- response_body
+hello
+
+
+
+=== TEST 13: exec after named location capture (memc)
+--- config
+    location /test {
+        content_by_lua_file 'html/test.lua';
+    }
+
+    location /a {
+        set $memc_key 'hello world';
+        set $memc_value 'hello hello hello world world world';
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location @b {
+        set $memc_key 'hello world';
+        set $memc_cmd get;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('@b')
+--- request
+    GET /test
+--- response_body: hello hello hello world world world
+
+
+
+=== TEST 14: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (content)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+        #echo hello;
+    }
+    location /p{
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /lua {
+        content_by_lua '
+            ngx.exec("/p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 15: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (content + named location)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+        #echo hello;
+    }
+    location @p {
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /lua {
+        content_by_lua '
+            ngx.exec("@p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 16: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (content + post subrequest)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+        #echo hello;
+    }
+    location /p{
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location blah {
+        echo blah;
+    }
+    location /lua {
+        content_by_lua '
+            ngx.location.capture("/blah")
+            ngx.exec("/p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 17: pcall safe
+--- config
+    location /lua {
+        content_by_lua '
+            function f ()
+                ngx.exec("/hi")
+            end
+
+            pcall(f)
+            ngx.say("hello")
+        ';
+    }
+    location /hi {
+        echo hi;
+    }
+--- request
+GET /lua
+--- error_code: 200
+--- response_body
+hi
+
+
+
+=== TEST 18: lua table as "args" parameter
+--- config
+    location /lua {
+        content_by_lua '
+            local args = { foo = 3, bar = 4 }
+            ngx.exec("/hi", args)
+        ';
+    }
+    location /hi {
+        echo "foo = $arg_foo";
+        echo "bar = $arg_bar";
+    }
+--- request
+GET /lua
+--- error_code: 200
+--- response_body
+foo = 3
+bar = 4
+
+
+
+=== TEST 19: jump to internal locations requires ctx cleared
+--- config
+    location @proxy {
+        rewrite_by_lua return;
+        echo hello;
+    }
+    location /main {
+        content_by_lua '
+            ngx.exec("@proxy")
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+hello
+
+
+
+=== TEST 20: exec + rewrite + named locations
+--- config
+    location @proxy {
+        rewrite_by_lua return;
+        echo hello;
+    }
+    location /main {
+        rewrite_by_lua '
+            ngx.exec("@proxy")
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+hello
+
+
+
+=== TEST 21: exec(named location) in subrequests
+--- config
+    location /entry {
+        echo_location /foo;
+        echo_location /foo2;
+    }
+  location /foo {
+      content_by_lua '
+          ngx.exec("@bar")
+      ';
+  }
+  location /foo2 {
+      content_by_lua '
+          ngx.exec("@bar")
+      ';
+  }
+
+  location @bar {
+      proxy_pass http://127.0.0.1:$server_port/bar;
+  }
+  location /bar {
+      echo hello;
+  }
+--- request
+    GET /entry
+--- response_body
+hello
+hello
+
+
+
+=== TEST 22: exec(normal location) in subrequests
+--- config
+    location /entry {
+        echo_location /foo;
+        echo_location /foo2;
+    }
+  location /foo {
+      content_by_lua '
+          ngx.exec("/baz")
+      ';
+  }
+  location /foo2 {
+      content_by_lua '
+          ngx.exec("/baz")
+      ';
+  }
+
+  location /baz {
+      proxy_pass http://127.0.0.1:$server_port/bar;
+  }
+  location /bar {
+      echo hello;
+  }
+--- request
+    GET /entry
+--- response_body
+hello
+hello
+
+
+
+=== TEST 23: content_by_lua + ngx.exec + subrequest capture
+--- config
+    location /main {
+        rewrite_by_lua '
+            res = ngx.location.capture("/test_loc");
+            ngx.print("hello, ", res.body)
+        ';
+        content_by_lua return;
+    }
+    location /test_loc {
+        content_by_lua '
+            ngx.exec("@proxy")
+        ';
+    }
+    location @proxy {
+        #echo proxy;
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+    location /foo {
+        #echo_status 201;
+        echo bah;
+    }
+--- request
+    GET /main
+--- response_body
+hello, bah
+
+
+
+=== TEST 24: jump to an internal location
+--- config
+    location /t {
+        content_by_lua '
+            return ngx.exec("/proxy", ngx.var.args)
+        ';
+    }
+
+    location /proxy {
+        internal;
+
+        proxy_pass http://127.0.0.1:$server_port/dummy;
+    }
+
+    location = /dummy {
+        echo -n dummy;
+    }
+--- pipelined_requests eval
+["GET /t", "GET /t?foo"]
+--- response_body eval
+["dummy", "dummy"]
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/018-ndk.t b/src/lua/lua-nginx-module/t/018-ndk.t
--- a/src/lua/lua-nginx-module/t/018-ndk.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/018-ndk.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,175 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 4);
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /read {
+        content_by_lua '
+            local s = ndk.set_var.set_escape_uri(" :")
+            local r = ndk.set_var.set_unescape_uri("a%20b")
+            ngx.say(s)
+            ngx.say(r)
+        ';
+    }
+--- request
+GET /read
+--- response_body
+%20%3a
+a b
+
+
+
+=== TEST 2: directive not found
+--- config
+    location /read {
+        content_by_lua '
+            local s = ndk.set_var.set_escape_uri_blah_blah(" :")
+            ngx.say(s)
+        ';
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 3: directive not found
+--- config
+    location /read {
+        content_by_lua '
+            local s = ndk.set_var.content_by_lua(" :")
+            ngx.say(s)
+        ';
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: directive not found
+--- config
+    location /read {
+        header_filter_by_lua '
+            ngx.header.Foo = ndk.set_var.set_escape_uri(" %")
+        ';
+        echo hi;
+    }
+--- request
+GET /read
+--- response_headers
+Foo: %20%25
+--- response_body
+hi
+
+
+
+=== TEST 5: bug: ndk.set_var not initialize ngx_http_variable_value_t variable properly
+--- config
+   location /luaset {
+     content_by_lua "
+
+       local version = '2011.10.13+0000'
+       local e_version = ndk.set_var.set_encode_base32(version)
+       local s_version= ndk.set_var.set_quote_sql_str(version)
+       ngx.say(e_version)
+       ngx.say(s_version)
+     ";
+   }
+--- request
+GET /luaset
+--- response_body
+68o32c9e64o2sc9j5co30c1g
+'2011.10.13+0000'
+
+
+
+=== TEST 6: set_by_lua
+--- config
+    location /read {
+        set_by_lua $r '
+            return ndk.set_var.set_unescape_uri("a%20b")
+        ';
+        echo $r;
+    }
+--- request
+GET /read
+--- response_body
+a b
+
+
+
+=== TEST 7: header_filter_by_lua
+--- config
+    location /read {
+        set $foo '';
+        content_by_lua '
+            ngx.send_headers()
+            ngx.say(ngx.var.foo)
+        ';
+        header_filter_by_lua '
+            ngx.var.foo = ndk.set_var.set_unescape_uri("a%20b")
+        ';
+    }
+--- request
+GET /read
+--- response_body
+a b
+
+
+
+=== TEST 8: log_by_lua
+--- config
+    location /read {
+        echo ok;
+        log_by_lua '
+            local foo = ndk.set_var.set_unescape_uri("a%20b")
+            ngx.log(ngx.WARN, "foo = ", foo)
+        ';
+    }
+--- request
+GET /read
+--- response_body
+ok
+--- wait: 0.1
+--- error_log
+foo = a b
+
+
+
+=== TEST 9: ngx.timer.*
+--- config
+    location /read {
+        echo ok;
+        log_by_lua '
+            ngx.timer.at(0, function ()
+                local foo = ndk.set_var.set_unescape_uri("a%20b")
+                ngx.log(ngx.WARN, "foo = ", foo)
+            end)
+        ';
+    }
+--- request
+GET /read
+--- response_body
+ok
+--- wait: 0.1
+--- error_log
+foo = a b
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/019-const.t b/src/lua/lua-nginx-module/t/019-const.t
--- a/src/lua/lua-nginx-module/t/019-const.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/019-const.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,48 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => blocks() * repeat_each() * 2;
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /read {
+        content_by_lua '
+            ngx.say(ngx.OK)
+            ngx.say(ngx.AGAIN)
+            ngx.say(ngx.DONE)
+            ngx.say(ngx.ERROR)
+        ';
+    }
+--- request
+GET /read
+--- response_body
+0
+-2
+-4
+-1
+
+
+
+=== TEST 2: http constants
+--- config
+    location /read {
+        content_by_lua '
+            ngx.say(ngx.HTTP_GATEWAY_TIMEOUT)
+        ';
+    }
+--- request
+GET /read
+--- response_body
+504
+
diff -rNu a/src/lua/lua-nginx-module/t/020-subrequest.t b/src/lua/lua-nginx-module/t/020-subrequest.t
--- a/src/lua/lua-nginx-module/t/020-subrequest.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/020-subrequest.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,2392 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#master_on();
+#workers(1);
+#worker_connections(1014);
+#log_level('warn');
+#master_process_enabled(1);
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 18);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+no_long_string();
+#no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: DELETE
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+DELETE
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: DELETE (proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+DELETE
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: POST (nobody, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /t {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+POST
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: HEAD
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_HEAD });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+HEAD
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: explicit GET
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_GET });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: implicit GET
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo")
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: implicit GET (empty option table)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo", {})
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: PUT (nobody, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body chomp
+PUT
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: PUT (nobody, no proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        #echo_read_request_body;
+
+        echo $echo_request_method;
+        #echo $echo_request_body;
+        echo_request_body;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body chomp
+PUT
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: PUT (nobody, no proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        #echo_read_request_body;
+
+        echo $echo_request_method;
+        #echo $echo_request_body;
+        echo_request_body;
+        #echo "[$http_content_length]";
+        echo;
+    }
+
+    location /foo {
+        echo $echo_request_method;
+        echo -n "[$http_content_length]";
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+
+            res = ngx.location.capture("/foo")
+            ngx.say(res.body)
+
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+PUT
+hello
+GET
+[]
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: POST (with body, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body chomp
+POST
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: POST (with body, memc method)
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("cached: " .. res.body);
+
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+GET: 404
+PUT: 201
+cached: hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: POST (with body, memc method)
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_cmd "";
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.location.capture("/flush",
+                { share_all_vars = true });
+
+            res = ngx.location.capture("/memc",
+                { share_all_vars = true });
+            ngx.say("GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello", share_all_vars = true });
+            ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc", { share_all_vars = true });
+            ngx.say("cached: " .. res.body);
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+GET: 404
+PUT: 201
+cached: hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: emtpy args option table
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = {} })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body eval: "\n"
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: non-empty args option table (1 pair)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { ["fo="] = "=>" } })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+fo%3d=%3d%3e
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: non-empty args option table (2 pairs)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { ["fo="] = "=>",
+                    ["="] = ":" } })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like chop
+^(?:fo%3d=%3d%3e\&%3d=%3a|%3d=%3a\&fo%3d=%3d%3e)$
+--- no_error_log
+[error]
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: non-empty args option table (2 pairs, no special chars)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { foo = 3,
+                    bar = "hello" } })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like chop
+^(?:bar=hello\&foo=3|foo=3\&bar=hello)$
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: non-empty args option table (number key)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { [57] = "hi" } })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+attempt to use a non-string key in the "args" option table
+
+
+
+=== TEST 19: non-empty args option table (plain arrays)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { "hi" } })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+attempt to use a non-string key in the "args" option table
+
+
+
+=== TEST 20: more args
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo?a=3",
+                { args = { b = 4 } })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a=3&b=4
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: more args
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo?a=3",
+                { args = "b=4" })
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a=3&b=4
+--- no_error_log
+[error]
+
+
+
+=== TEST 22: is_subrequest in main request
+--- config
+    location /lua {
+        content_by_lua '
+            if ngx.is_subrequest then
+                ngx.say("sub req")
+            else
+                ngx.say("main req")
+            end
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+main req
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: is_subrequest in sub request
+--- config
+    location /main {
+        echo_location /lua;
+    }
+
+    location /lua {
+        content_by_lua '
+            if ngx.is_subrequest then
+                ngx.say("sub req")
+            else
+                ngx.say("main req")
+            end
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+sub req
+--- no_error_log
+[error]
+
+
+
+=== TEST 24: is_subrequest in sub request in set_by_lua
+--- config
+    location /main {
+        echo_location /lua;
+    }
+
+    location /lua {
+        set_by_lua $a '
+            if ngx.is_subrequest then
+                return "sub req"
+            else
+                return "main req"
+            end
+        ';
+        echo $a;
+    }
+--- request
+    GET /main
+--- response_body
+sub req
+--- no_error_log
+[error]
+
+
+
+=== TEST 25: header inheritance bug (without body) (github issue 38)
+https://github.com/chaoslawful/lua-nginx-module/issues/38
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo -n $http_foo;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_GET });
+            ngx.say("header foo: [", res.body, "]")
+        ';
+    }
+--- request
+GET /lua
+--- more_headers
+Foo: bar
+--- response_body
+header foo: [bar]
+--- no_error_log
+[error]
+
+
+
+=== TEST 26: header inheritance bug (with body) (github issue 38)
+https://github.com/chaoslawful/lua-nginx-module/issues/38
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo -n $http_foo;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { body = "abc" });
+            ngx.say("header foo: [", res.body, "]")
+        ';
+    }
+--- request
+GET /lua
+--- more_headers
+Foo: bar
+--- response_body
+header foo: [bar]
+--- no_error_log
+[error]
+
+
+
+=== TEST 27: lua calls lua via subrequests
+--- config
+    location /a {
+        content_by_lua '
+            ngx.say("hello, a");
+        ';
+    }
+    location /b {
+        content_by_lua '
+            ngx.say("hello, b");
+        ';
+    }
+    location /c {
+        content_by_lua '
+            ngx.say("hello, c");
+        ';
+    }
+    location /main {
+        content_by_lua '
+            res1, res2 = ngx.location.capture_multi({{"/a"}, {"/b"}})
+            res3 = ngx.location.capture("/c")
+            ngx.print(res1.body, res2.body, res3.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+hello, a
+hello, b
+hello, c
+--- error_log
+lua reuse free buf memory
+--- no_error_log
+[error]
+
+
+
+=== TEST 28: POST (with body, proxy method, main request is a POST too)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+POST /lua
+hi
+--- response_body chomp
+POST
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 29: Last-Modified response header for static file subrequest
+--- config
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo.html")
+
+            ngx.say(res.status)
+            ngx.say(res.header["Last-Modified"])
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- user_files
+>>> foo.html
+hello, static file
+--- response_body_like chomp
+^200
+[A-Za-z]+, \d{1,2} [A-Za-z]+ \d{4} \d{2}:\d{2}:\d{2} GMT
+hello, static file$
+--- no_error_log
+[error]
+
+
+
+=== TEST 30: custom ctx table for subrequest
+--- config
+    location /sub {
+        content_by_lua '
+            ngx.ctx.foo = "bar";
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            local ctx = {}
+            res = ngx.location.capture("/sub", { ctx = ctx })
+
+            ngx.say(ctx.foo);
+            ngx.say(ngx.ctx.foo);
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+bar
+nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 31: share the ctx with the parent
+--- config
+    location /sub {
+        content_by_lua '
+            ngx.ctx.foo = "bar";
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/sub", { ctx = ngx.ctx })
+            ngx.say(ngx.ctx.foo);
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+bar
+--- no_error_log
+[error]
+
+
+
+=== TEST 32: test memcached with subrequests
+--- http_config
+    upstream memc {
+        server 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+        keepalive 100;
+    }
+--- config
+    location /memc {
+        set $memc_key some_key;
+        set $memc_exptime 600;
+        memc_pass memc;
+    }
+
+    location /t {
+        content_by_lua '
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello 1234" });
+            -- ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("some_key: " .. res.body);
+        ';
+    }
+--- request
+GET /t
+--- response_body
+some_key: hello 1234
+--- error_log
+lua reuse free buf chain, but reallocate memory because
+--- no_error_log
+[error]
+
+
+
+=== TEST 33: main POST, sub GET (main does not read the body)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_method)
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+        #proxy_pass http://127.0.0.1:8892/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_GET });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+POST /lua
+hello, world
+--- response_body
+GET
+nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 34: main POST, sub GET (main has read the body)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_method)
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+        #proxy_pass http://127.0.0.1:8892/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_GET });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+POST /lua
+hello, world
+--- response_body
+GET
+nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 35: main POST, sub POST (inherit bodies directly)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_method)
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+        #proxy_pass http://127.0.0.1:8892/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+POST /lua
+hello, world
+--- response_body
+POST
+hello, world
+--- no_error_log
+[error]
+
+
+
+=== TEST 36: main POST, sub PUT (inherit bodies directly)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_method)
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+        #proxy_pass http://127.0.0.1:8892/other;
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_PUT });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+POST /lua
+hello, world
+--- response_body
+PUT
+hello, world
+--- no_error_log
+[error]
+
+
+
+=== TEST 37: recursive calls
+--- config
+    location /t {
+        content_by_lua '
+            ngx.location.capture("/t")
+        ';
+    }
+--- request
+    GET /t
+--- ignore_response
+--- error_log
+subrequests cycle while processing "/t"
+
+
+
+=== TEST 38: OPTIONS
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_OPTIONS });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+OPTIONS
+--- no_error_log
+[error]
+
+
+
+=== TEST 39: OPTIONS with a body
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_OPTIONS, body = "hello world" });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body chop
+OPTIONS
+hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 40: encode args table with a multi-value arg.
+--- config
+    location /t {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local res = ngx.location.capture("/sub", { args = args })
+            ngx.print(res.body)
+        ';
+    }
+
+    location /sub {
+        echo $query_string;
+    }
+--- request
+GET /t?r[]=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fjquery%2F1.7.2%2Fjquery.min.js&r[]=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fdojo%2F1.7.2%2Fdojo%2Fdojo.js.uncompressed.js
+--- response_body
+r%5b%5d=http%3a%2f%2fajax.googleapis.com%3a80%2fajax%2flibs%2fjquery%2f1.7.2%2fjquery.min.js&r%5b%5d=http%3a%2f%2fajax.googleapis.com%3a80%2fajax%2flibs%2fdojo%2f1.7.2%2fdojo%2fdojo.js.uncompressed.js
+--- no_error_log
+[error]
+
+
+
+=== TEST 41: subrequests finalized with NGX_ERROR
+--- config
+    location /sub {
+        content_by_lua '
+            ngx.exit(ngx.ERROR)
+        ';
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/sub")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+        ';
+    }
+--- request
+GET /main
+--- response_body
+status: 500
+body: 
+
+
+
+=== TEST 42: subrequests finalized with 500
+--- config
+    location /sub {
+        return 500;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/sub")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+        ';
+    }
+--- request
+GET /main
+--- response_body
+status: 500
+body: 
+
+
+
+=== TEST 43: subrequests with an output body filter returning NGX_ERROR
+--- config
+    location /sub {
+        echo hello world;
+        body_filter_by_lua '
+            return ngx.ERROR
+        ';
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/sub")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+        ';
+    }
+--- request
+GET /main
+--- stap2
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+--- response_body
+--- error_code
+--- no_error_log
+[error]
+
+
+
+=== TEST 44: subrequests truncated in its response body due to premature connection close (nonbuffered)
+--- config
+    server_tokens off;
+    location /memc {
+        internal;
+
+        set $memc_key 'foo';
+        #set $memc_exptime 300;
+        memc_pass 127.0.0.1:19112; #$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/memc")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19112
+--- tcp_query_len: 9
+--- tcp_reply eval
+"VALUE foo 0 1024\r\nhello world"
+
+--- stap2
+F(ngx_http_lua_capture_body_filter) {
+    if (pid() == target() && $r != $r->main) {
+        printf("lua capture body output: %s\n", ngx_chain_dump($in))
+        if ($in->buf->last_in_chain) {
+            print_ubacktrace()
+        }
+    }
+}
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: true
+--- no_error_log
+[error]
+
+
+
+=== TEST 45: subrequests truncated in its response body due to upstream read timeout (nonbuffered)
+--- config
+    memc_read_timeout 100ms;
+    location /memc {
+        internal;
+
+        set $memc_key 'foo';
+        #set $memc_exptime 300;
+        memc_pass 127.0.0.1:19112; #$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/memc")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19112
+--- tcp_no_close
+--- tcp_reply eval
+"VALUE foo 0 1024\r\nhello world"
+
+--- stap2
+F(ngx_http_lua_capture_body_filter) {
+    if (pid() == target() && $r != $r->main) {
+        printf("lua capture body output: %s\n", ngx_chain_dump($in))
+        //if ($in->buf->last_in_chain) {
+            print_ubacktrace()
+        //}
+    }
+}
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+conn err: 110: upstream timed out
+upstream fin req: error=0 eof=0 rc=504
+post subreq: rc=-1, status=200
+
+--- response_body_like chop
+^status: 200
+body: [^\n]*
+truncated: true
+
+--- error_log
+upstream timed out
+
+
+
+=== TEST 46: subrequests truncated in its response body due to premature connection close (buffered)
+--- config
+    server_tokens off;
+
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_buffering on;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_query_len: 65
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\nContent-Length: 1024\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: true
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 47: subrequests truncated in its response body due to read timeout (buffered)
+--- config
+    location /proxy {
+        internal;
+
+        proxy_read_timeout 100ms;
+        proxy_buffering on;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_no_close
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\nContent-Length: 1024\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+conn err: 110: upstream timed out
+upstream fin req: error=0 eof=0 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: 
+truncated: true
+
+--- error_log
+upstream timed out
+
+
+
+=== TEST 48: subrequests truncated in its response body due to premature connection close (buffered, no content-length)
+--- config
+    server_tokens off;
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_buffering on;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_query_len: 65
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=0
+post subreq: rc=0, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: false
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 49: subrequests truncated in its response body due to read timeout (buffered, no content-length)
+--- config
+    location /proxy {
+        internal;
+
+        proxy_read_timeout 100ms;
+        proxy_buffering on;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_no_close
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+conn err: 110: upstream timed out
+upstream fin req: error=0 eof=0 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: 
+truncated: true
+
+--- error_log
+upstream timed out
+
+
+
+=== TEST 50: subrequests truncated in its response body due to premature connection close (nonbuffered, no content-length)
+--- config
+    server_tokens off;
+
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_buffering off;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_query_len: 65
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=0
+post subreq: rc=0, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: false
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 51: subrequests truncated in its response body due to read timeout (nonbuffered, no content-length)
+--- config
+    location /proxy {
+        internal;
+
+        proxy_read_timeout 500ms;
+        proxy_buffering off;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_no_close
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+conn err: 110: upstream timed out
+upstream fin req: error=0 eof=0 rc=504
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: true
+
+--- error_log
+upstream timed out
+
+
+
+=== TEST 52: forwarding in-memory request bodies to multiple subrequests
+--- config
+    location /other {
+        default_type 'foo/bar';
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+
+    location /back {
+        echo_read_request_body;
+        echo_request_body;
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+
+            for i = 1, 2 do
+                res = ngx.location.capture("/other",
+                    { method = ngx.HTTP_POST });
+
+                ngx.say(res.body)
+            end
+        ';
+    }
+
+--- request eval
+"POST /lua
+" . "hello world"
+
+--- response_body
+hello world
+hello world
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 53: forwarding in-file request bodies to multiple subrequests (client_body_in_file_only)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+
+    location /back {
+        echo_read_request_body;
+        echo_request_body;
+    }
+
+    client_body_in_file_only on;
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+
+            for i = 1, 2 do
+                res = ngx.location.capture("/other",
+                    { method = ngx.HTTP_POST });
+
+                ngx.say(res.body)
+            end
+        ';
+    }
+
+--- request eval
+"POST /lua
+" . "hello world"
+
+--- response_body
+hello world
+hello world
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 54: forwarding in-file request bodies to multiple subrequests (exceeding client_body_buffer_size)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+
+    location /back {
+        echo_read_request_body;
+        echo_request_body;
+    }
+
+    location /lua {
+        #client_body_in_file_only on;
+        client_body_buffer_size 1;
+        content_by_lua '
+            ngx.req.read_body()
+
+            for i = 1, 2 do
+                res = ngx.location.capture("/other",
+                    { method = ngx.HTTP_POST });
+
+                ngx.say(res.body)
+            end
+        ';
+    }
+--- request eval
+"POST /lua
+" . ("hello world" x 100)
+
+--- stap2
+global valid = 0
+global fds
+
+F(ngx_http_handler) { valid = 1  }
+
+probe syscall.open {
+    if (valid && pid() == target()) {
+        print(name, "(", argstr, ")")
+    }
+}
+
+probe syscall.close {
+    if (valid && pid() == target() && fds[sprintf("%d", $fd)]) {
+        println(name, "(", argstr, ")")
+    }
+}
+
+probe syscall.unlink {
+    if (valid && pid() == target()) {
+        println(name, "(", argstr, ")")
+    }
+}
+
+probe syscall.open.return {
+    if (valid && pid() == target()) {
+        println(" = ", retstr)
+        fds[retstr] = 1
+    }
+}
+
+F(ngx_http_lua_subrequest) {
+    println("lua subrequest")
+}
+
+F(ngx_output_chain) {
+    printf("output chain: %s\n", ngx_chain_dump($in))
+}
+
+F(ngx_pool_run_cleanup_file) {
+    println("clean up file: ", $fd)
+}
+
+--- response_body eval
+("hello world" x 100) . "\n"
+. ("hello world" x 100) . "\n"
+
+--- no_error_log
+[error]
+--- error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 55: subrequests truncated in its response body due to premature connection close (buffered + chunked)
+--- config
+    server_tokens off;
+
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_http_version 1.1;
+        proxy_buffering on;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_query_len: 65
+--- tcp_reply eval
+"HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\nb\r\nhello world\r"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: true
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 56: subrequests truncated in its response body due to premature connection close (nonbuffered + chunked)
+--- config
+    server_tokens off;
+
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_http_version 1.1;
+        proxy_buffering off;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_query_len: 65
+--- tcp_reply eval
+"HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\nb\r\nhello world\r"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: true
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 57: subrequests truncated in its response body due to read timeout (buffered + chunked)
+--- config
+    location /proxy {
+        internal;
+
+        proxy_read_timeout 100ms;
+        proxy_buffering on;
+        proxy_http_version 1.1;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_no_close
+--- tcp_reply eval
+"HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\nb\r\nhello world\r"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+conn err: 110: upstream timed out
+upstream fin req: error=0 eof=0 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: 
+truncated: true
+
+--- error_log
+upstream timed out
+
+
+
+=== TEST 58: good chunked response (buffered)
+--- config
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_buffering on;
+        proxy_http_version 1.1;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_no_close
+--- tcp_reply eval
+"HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nhello\r\n0\r\n\r\n"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=0 rc=0
+post subreq: rc=0, status=200
+
+--- response_body
+status: 200
+body: hello
+truncated: false
+
+
+
+=== TEST 59: good chunked response (nonbuffered)
+--- config
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_buffering off;
+        proxy_http_version 1.1;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_no_close
+--- tcp_reply eval
+"HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nhello\r\n0\r\n\r\n"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=0 rc=0
+post subreq: rc=0, status=200
+
+--- response_body
+status: 200
+body: hello
+truncated: false
+
+
+
+=== TEST 60: subrequests truncated in its response body due to premature connection close (nonbuffered + proxy)
+--- config
+    server_tokens off;
+
+    location /proxy {
+        internal;
+
+        #proxy_read_timeout 100ms;
+        proxy_buffering off;
+        proxy_pass http://127.0.0.1:19113;
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/proxy")
+            ngx.say("status: ", res.status)
+            ngx.say("body: ", res.body)
+            ngx.say("truncated: ", res.truncated)
+        ';
+    }
+--- request
+GET /main
+--- tcp_listen: 19113
+--- tcp_query_len: 65
+--- tcp_reply eval
+"HTTP/1.0 200 OK\r\nContent-Length: 1024\r\n\r\nhello world"
+
+--- stap
+F(ngx_http_upstream_finalize_request) {
+    printf("upstream fin req: error=%d eof=%d rc=%d\n",
+        $r->upstream->peer->connection->read->error,
+        $r->upstream->peer->connection->read->eof,
+        $rc)
+    #print_ubacktrace()
+}
+F(ngx_connection_error) {
+    printf("conn err: %d: %s\n", $err, user_string($text))
+    #print_ubacktrace()
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: rc=%d, status=%d\n", $rc, $r->headers_out->status)
+    #print_ubacktrace()
+}
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize: %d\n", $rc)
+}
+*/
+--- stap_out
+upstream fin req: error=0 eof=1 rc=502
+post subreq: rc=-1, status=200
+
+--- response_body
+status: 200
+body: hello world
+truncated: true
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 61: WebDAV methods
+--- config
+    location /other {
+        echo "method: $echo_request_method";
+    }
+
+    location /lua {
+        content_by_lua '
+            local methods = {
+                ngx.HTTP_MKCOL,
+                ngx.HTTP_COPY,
+                ngx.HTTP_MOVE,
+                ngx.HTTP_PROPFIND,
+                ngx.HTTP_PROPPATCH,
+                ngx.HTTP_LOCK,
+                ngx.HTTP_UNLOCK,
+                ngx.HTTP_PATCH,
+                ngx.HTTP_TRACE,
+            }
+
+            for i, method in ipairs(methods) do
+                res = ngx.location.capture("/other",
+                    { method = method })
+                ngx.print(res.body)
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+method: MKCOL
+method: COPY
+method: MOVE
+method: PROPFIND
+method: PROPPATCH
+method: LOCK
+method: UNLOCK
+method: PATCH
+method: TRACE
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 62: by default DELETE subrequests don't forward request bodies
+--- config
+    location /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+DELETE /lua
+hello world
+--- response_body
+nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 63: DELETE subrequests do forward request bodies when always_forward_body == true
+--- config
+    location = /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_DELETE, always_forward_body = true });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+DELETE /lua
+hello world
+--- response_body
+hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 64: DELETE subrequests do forward request bodies when always_forward_body == true (on disk)
+--- config
+    location = /other {
+        default_type 'foo/bar';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_DELETE, always_forward_body = true });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+DELETE /lua
+hello world
+--- response_body
+hello world
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/021-cookie-time.t b/src/lua/lua-nginx-module/t/021-cookie-time.t
--- a/src/lua/lua-nginx-module/t/021-cookie-time.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/021-cookie-time.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,46 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: cookie_time
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.cookie_time(1290079655))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Thu, 18-Nov-10 11:27:35 GMT
+
+
+
+=== TEST 2: cookie_time in set_by_lua
+--- config
+    location /lua {
+        set_by_lua $a '
+            return ngx.cookie_time(1290079655)
+        ';
+        echo $a;
+    }
+--- request
+GET /lua
+--- response_body
+Thu, 18-Nov-10 11:27:35 GMT
+
diff -rNu a/src/lua/lua-nginx-module/t/022-redirect.t b/src/lua/lua-nginx-module/t/022-redirect.t
--- a/src/lua/lua-nginx-module/t/022-redirect.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/022-redirect.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,169 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3 + 1);
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: default 302
+--- config
+    location /read {
+        content_by_lua '
+            ngx.redirect("http://agentzh.org/foo");
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://agentzh.org/foo
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 2: explicit 302
+--- config
+    location /read {
+        content_by_lua '
+            ngx.redirect("http://agentzh.org/foo", ngx.HTTP_MOVED_TEMPORARILY);
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://agentzh.org/foo
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 3: explicit 301
+--- config
+    location /read {
+        content_by_lua '
+            ngx.redirect("http://agentzh.org/foo", ngx.HTTP_MOVED_PERMANENTLY);
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://agentzh.org/foo
+--- response_body_like: 301 Moved Permanently
+--- error_code: 301
+
+
+
+=== TEST 4: bad rc
+--- config
+    location /read {
+        content_by_lua '
+            ngx.redirect("http://agentzh.org/foo", 404);
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+!Location
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 5: no args
+--- config
+    location /read {
+        content_by_lua '
+            ngx.redirect()
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+!Location
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 6: relative uri
+--- config
+    location /echo {
+        echo hello, world;
+    }
+    location /proxy {
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT/echo;
+    }
+    location /read {
+        content_by_lua '
+            ngx.location.capture("/proxy")
+            ngx.redirect("/echo")
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- raw_response_headers_like: Location: http://localhost(?::\d+)?/echo\r\n
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 7: default 302 (with uri args)
+--- config
+    location /read {
+        content_by_lua '
+            ngx.redirect("http://agentzh.org/foo?bar=3");
+            ngx.say("hi")
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://agentzh.org/foo?bar=3
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 8: location.capture + ngx.redirect
+--- config
+    location /echo {
+        echo hello, world;
+    }
+    location /proxy {
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT/echo;
+    }
+    location /read {
+        content_by_lua '
+            ngx.location.capture("/proxy")
+            ngx.location.capture("/proxy")
+            ngx.redirect("/echo")
+            ngx.exit(403)
+        ';
+    }
+--- pipelined_requests eval
+["GET /read/1", "GET /read/2"]
+--- error_code eval
+[302, 302]
+--- response_body eval
+[qr/302 Found/, qr/302 Found/]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/client-abort.t b/src/lua/lua-nginx-module/t/023-rewrite/client-abort.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/client-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/client-abort.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,851 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = <<_EOC_;
+$t::StapThread::GCScript
+
+F(ngx_http_lua_check_broken_connection) {
+    println("lua check broken conn")
+}
+
+F(ngx_http_lua_request_cleanup) {
+    println("lua req cleanup")
+}
+_EOC_
+
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 - 1);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 2: sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 3: sleep + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        rewrite_by_lua '
+            ngx.sleep(1)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: subrequest + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location /sub {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 5: subrequest + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        rewrite_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location /sub {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: fail
+lua req cleanup
+delete thread 1
+
+--- wait: 1.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- error_log
+bad things happen
+
+
+
+=== TEST 6: subrequest + stop (proxy, ignore client abort)
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location = /sub {
+        proxy_ignore_client_abort on;
+        proxy_pass http://agentzh.org:12345/;
+    }
+
+    location = /sleep {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 7: subrequest + stop (proxy, check client abort)
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location = /sub {
+        proxy_ignore_client_abort off;
+        proxy_pass http://agentzh.org:12345/;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 8: need body on + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        lua_need_request_body on;
+        rewrite_by_lua '
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 9: ngx.req.read_body + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 10: ngx.req.socket + receive() + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive()
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 11: ngx.req.socket + receive(N) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(5)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 12: ngx.req.socket + receive(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(2)
+            ngx.sleep(1)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:lua check broken conn
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup|lua check broken conn
+lua req cleanup
+delete thread 1)$
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: ngx.req.socket + m * receive(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(2)
+            sock:receive(2)
+            sock:receive(1)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 14: ngx.req.socket + receiveuntil + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            local it = sock:receiveuntil("\\n")
+            it()
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 15: ngx.req.socket + receiveuntil + it(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            local it = sock:receiveuntil("\\n")
+            it(2)
+            it(3)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 16: cosocket + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.req.discard_body()
+
+            local sock, err = ngx.socket.tcp()
+            if not sock then
+                ngx.log(ngx.ERR, "failed to get socket: ", err)
+                return
+            end
+
+            ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("blpop nonexist 2\\r\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "failed to send query: ", err)
+                return
+            end
+
+            -- ngx.log(ngx.ERR, "about to receive")
+
+            local res, err = sock:receive()
+            if not res then
+                ngx.log(ngx.ERR, "failed to receive query: ", err)
+                return
+            end
+
+            ngx.log(ngx.ERR, "res: ", res)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 17: ngx.req.socket + receive n < content-length + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            error("bad")
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 100\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+failed to receive: client aborted
+
+
+
+=== TEST 18: ngx.req.socket + receive n == content-length + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            ngx.sleep(1)
+            error("bad")
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 5\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 19: ngx.req.socket + receive n == content-length + ignore
+--- config
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            ngx.say("done")
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 5\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- shutdown: 1
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 20: ngx.req.read_body + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.req.read_body()
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- shutdown: 1
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: exec to lua + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.exec("/t2")
+        ';
+    }
+
+    location = /t2 {
+        lua_check_client_abort off;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 22: exec to proxy + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.exec("/t2")
+        ';
+    }
+
+    location = /t2 {
+        proxy_ignore_client_abort on;
+        proxy_pass http://127.0.0.1:$server_port/sleep;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 23: exec (named location) to proxy + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            ngx.exec("@t2")
+        ';
+    }
+
+    location @t2 {
+        proxy_ignore_client_abort on;
+        proxy_pass http://127.0.0.1:$server_port/sleep;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/exec.t b/src/lua/lua-nginx-module/t/023-rewrite/exec.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/exec.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/exec.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,380 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => blocks() * repeat_each() * 2;
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec("/hi");
+            ngx.say("Hi");
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body
+Hello
+
+
+
+=== TEST 2: empty uri arg
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec("");
+            ngx.say("Hi");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 3: no arg
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec();
+            ngx.say("Hi");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: too many args
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec(1, 2, 3, 4);
+            ngx.say("Hi");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 5: null uri
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec(nil)
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 6: user args
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec("/hi", "Yichun Zhang")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello Yichun Zhang
+
+
+
+=== TEST 7: args in uri
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec("/hi?agentzh")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello agentzh
+
+
+
+=== TEST 8: args in uri and user args
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec("/hi?a=Yichun", "b=Zhang")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello a=Yichun&b=Zhang
+
+
+
+=== TEST 9: args in uri and user args
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.exec("@hi?a=Yichun", "b=Zhang")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location @hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello 
+
+
+
+=== TEST 10: exec after location capture
+--- config
+    location /test {
+        rewrite_by_lua_file 'html/test.lua';
+        echo world;
+    }
+
+    location /a {
+        echo "hello";
+    }
+
+    location /b {
+        echo "hello";
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('/b')
+--- request
+    GET /test
+--- response_body
+hello
+
+
+
+=== TEST 11: exec after (named) location capture
+--- config
+    location /test {
+        rewrite_by_lua_file 'html/test.lua';
+    }
+
+    location /a {
+        echo "hello";
+    }
+
+    location @b {
+        echo "hello";
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('@b')
+--- request
+    GET /test
+--- response_body
+hello
+
+
+
+=== TEST 12: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (rewrite)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /p{
+        #content_by_lua '
+        #local res = ngx.location.capture("/sub")
+        #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /lua {
+        rewrite_by_lua '
+            ngx.exec("/p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 13: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (rewrite + named location)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location @p{
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /lua {
+        rewrite_by_lua '
+            ngx.exec("@p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 14: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (rewrite + post subrequest)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /p{
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /blah {
+        echo blah;
+    }
+    location /lua {
+        rewrite_by_lua '
+            ngx.location.capture("/blah")
+            ngx.exec("/p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 15: rewrite_by_lua + ngx.exec + subrequest capture
+--- config
+    location /main {
+        rewrite_by_lua '
+            res = ngx.location.capture("/test_loc");
+            ngx.print("hello, ", res.body)
+        ';
+        content_by_lua return;
+    }
+    location /test_loc {
+        rewrite_by_lua '
+            ngx.exec("@proxy")
+        ';
+    }
+    location @proxy {
+        #echo proxy;
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+    location /foo {
+        echo bah;
+    }
+--- request
+    GET /main
+--- response_body
+hello, bah
+
+
+
+=== TEST 16: rewrite_by_lua_file + ngx.exec + subrequest capture
+--- config
+    location /main {
+        rewrite_by_lua '
+            res = ngx.location.capture("/test_loc");
+            ngx.print("hello, ", res.body)
+        ';
+        content_by_lua return;
+    }
+    location /test_loc {
+        rewrite_by_lua_file html/jump.lua;
+    }
+    location @proxy {
+        #echo proxy;
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+    location /foo {
+        echo bah;
+    }
+--- user_files
+>>> jump.lua
+ngx.exec("@proxy")
+--- request
+    GET /main
+--- response_body
+hello, bah
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/exit.t b/src/lua/lua-nginx-module/t/023-rewrite/exit.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/exit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/exit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,599 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#repeat_each(20000);
+
+repeat_each(2);
+
+#master_on();
+#workers(1);
+#log_level('debug');
+#log_level('warn');
+#worker_connections(1024);
+
+plan tests => repeat_each() * (blocks() * 2 + 4);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+
+our $LuaCpath = $ENV{LUA_CPATH} ||
+    '/usr/local/openresty-debug/lualib/?.so;/usr/local/openresty/lualib/?.so;;';
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+
+no_long_string();
+#no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: throw 403
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.exit(403);ngx.say('hi')";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_code: 403
+--- response_body_like: 403 Forbidden
+
+
+
+=== TEST 2: throw 404
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.exit(404);ngx.say('hi');";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_code: 404
+--- response_body_like: 404 Not Found
+
+
+
+=== TEST 3: throw 404 after sending the header and partial body
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.say('hi');ngx.exit(404);ngx.say(', you')";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_log
+attempt to set status 404 via ngx.exit after sending out the response status 200
+--- response_body
+hi
+
+
+
+=== TEST 4: working with ngx_auth_request (succeeded)
+--- config
+    location /auth {
+        rewrite_by_lua "
+            if ngx.var.user == 'agentzh' then
+                ngx.eof();
+            else
+                ngx.exit(403)
+            end";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /api {
+        set $user $arg_user;
+        auth_request /auth;
+
+        echo "Logged in";
+    }
+--- request
+GET /api?user=agentzh
+--- error_code: 200
+--- response_body
+Logged in
+
+
+
+=== TEST 5: working with ngx_auth_request (failed)
+--- config
+    location /auth {
+        rewrite_by_lua "
+            if ngx.var.user == 'agentzh' then
+                ngx.eof();
+            else
+                ngx.exit(403)
+            end";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /api {
+        set $user $arg_user;
+        auth_request /auth;
+
+        echo "Logged in";
+    }
+--- request
+GET /api?user=agentz
+--- error_code: 403
+--- response_body_like: 403 Forbidden
+
+
+
+=== TEST 6: working with ngx_auth_request (simplest form, w/o ngx_memc)
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        rewrite_by_lua_file 'html/foo.lua';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /api {
+        set $uid $arg_uid;
+        auth_request /conv-uid;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    -- ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+
+
+
+=== TEST 7: working with ngx_auth_request (simplest form)
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        rewrite_by_lua_file 'html/foo.lua';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /api {
+        set $uid $arg_uid;
+        auth_request /conv-uid;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+-- print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+
+
+
+=== TEST 8: working with ngx_auth_request
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+
+    upstream memc_a {
+        server 127.0.0.1:\$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    upstream memc_b {
+        server 127.0.0.1:\$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    upstream_list memc_cluster memc_a memc_b;
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        set_hashed_upstream $backend memc_cluster $arg_key;
+        memc_pass $backend;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        rewrite_by_lua_file 'html/foo.lua';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /api {
+        set $uid $arg_uid;
+        auth_request /conv-uid;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+-- print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: working with ngx_auth_request
+--- http_config
+    upstream backend {
+        drizzle_server 127.0.0.1:$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+
+    upstream memc_a {
+        server 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+        keepalive 300;
+    }
+
+    #upstream_list memc_cluster memc_a memc_b;
+
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        #set_hashed_upstream $backend memc_cluster $arg_key;
+        memc_pass memc_a;
+    }
+
+    location /conv-mysql {
+        internal;
+
+        set $key "conv-uri-$query_string";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        set_quote_sql_str $seo_uri $query_string;
+        drizzle_query "select url from my_url_map where seo_url=$seo_uri";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        rewrite_by_lua_file 'html/foo.lua';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+
+    location /baz {
+        set $my_uri $uri;
+        auth_request /conv-uid;
+
+        echo_exec /jump $my_uri;
+    }
+
+    location /jump {
+        internal;
+        rewrite ^ $query_string? redirect;
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local seo_uri = ngx.var.my_uri
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-mysql?' .. seo_uri)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].url) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.my_uri = res[1].url;
+-- print('done')
+--- request
+GET /baz
+--- response_body_like: 302
+--- error_code: 302
+--- response_headers
+Location: http://localhost:$ServerPort/foo/bar
+--- SKIP
+
+
+
+=== TEST 10: throw 0
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.say('Hi'); ngx.eof(); ngx.exit(0);ngx.say('world')";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_code: 200
+--- response_body
+Hi
+
+
+
+=== TEST 11: throw ngx.OK does *not* skip other rewrite phase handlers
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.exit(ngx.OK)";
+        set $foo hello;
+        echo $foo;
+    }
+--- request
+GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 12: throw ngx.HTTP_OK *does* skip other rewrite phase handlers (by inlined code)
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.exit(ngx.HTTP_OK)";
+        set $foo hello;
+        echo $foo;
+    }
+--- request
+GET /lua
+--- response_body
+
+
+
+=== TEST 13: throw ngx.HTTP_OK *does* skip other rewrite phase handlers (by inlined code + partial output)
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.say('hiya') ngx.exit(ngx.HTTP_OK)";
+        set $foo hello;
+        echo $foo;
+    }
+--- request
+GET /lua
+--- response_body
+hiya
+
+
+
+=== TEST 14: throw ngx.HTTP_OK *does* skip other rewrite phase handlers (by file)
+--- config
+    location /lua {
+        rewrite_by_lua_file html/foo.lua;
+        set $foo hello;
+        echo $foo;
+    }
+--- user_files
+>>> foo.lua
+ngx.exit(ngx.HTTP_OK)
+--- request
+GET /lua
+--- response_body
+
+
+
+=== TEST 15: throw ngx.HTTP_OK *does* skip other rewrite phase handlers (by file + partial output)
+--- config
+    location /lua {
+        rewrite_by_lua_file html/foo.lua;
+        set $foo hello;
+        echo $foo;
+    }
+--- user_files
+>>> foo.lua
+ngx.say("morning")
+ngx.exit(ngx.HTTP_OK)
+--- request
+GET /lua
+--- response_body
+morning
+
+
+
+=== TEST 16: error page with custom body
+--- config
+    error_page 410 @err;
+    location @err {
+        echo blah blah;
+    }
+    location /foo {
+        rewrite_by_lua '
+            ngx.status = ngx.HTTP_GONE
+            ngx.say("This is our own content")
+            -- to cause quit the whole request rather than the current phase handler
+            ngx.exit(ngx.HTTP_OK)
+        ';
+        echo Hello;
+    }
+--- request
+    GET /foo
+--- response_body
+This is our own content
+--- error_code: 410
+
+
+
+=== TEST 17: exit with 204 (HTTP 1.1)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.exit(204)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/blah;
+    }
+
+    location = /blah {
+        echo blah;
+    }
+--- request
+GET /t
+--- more_headers2
+--- stap2
+F(ngx_http_send_header) {
+    printf("send header\n")
+    print_ubacktrace()
+}
+--- response_body
+--- error_code: 204
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: exit with 204 (HTTP 1.0)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.exit(204)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/blah;
+    }
+
+    location = /blah {
+        echo blah;
+    }
+--- request
+GET /t HTTP/1.0
+--- more_headers2
+--- stap2
+F(ngx_http_send_header) {
+    printf("send header\n")
+    print_ubacktrace()
+}
+--- response_body
+--- error_code: 204
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/mixed.t b/src/lua/lua-nginx-module/t/023-rewrite/mixed.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/mixed.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/mixed.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,166 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: rewrite I/O with content I/O
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("rewrite GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("rewrite PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("rewrite cached: " .. res.body);
+
+        ';
+
+        content_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("content GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("content PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("content cached: " .. res.body);
+
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+rewrite GET: 404
+rewrite PUT: 201
+rewrite cached: hello
+content GET: 404
+content PUT: 201
+content cached: hello
+
+
+
+=== TEST 2: share data via nginx variables
+--- config
+    location /foo {
+        set $foo '';
+        rewrite_by_lua '
+            ngx.var.foo = 32
+        ';
+
+        content_by_lua '
+            ngx.say(tonumber(ngx.var.foo) * 2)
+        ';
+    }
+--- request
+    GET /foo
+--- response_body
+64
+
+
+
+=== TEST 3: share the request body (need request body explicitly off)
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        set $res '';
+        rewrite_by_lua '
+            ngx.var.res = ngx.var.request_body or "nil"
+        ';
+        content_by_lua '
+            ngx.say(ngx.var.res or "nil")
+            ngx.say(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body
+nil
+nil
+
+
+
+=== TEST 4: share the request body (need request body off by default)
+--- config
+    location /echo_body {
+        #lua_need_request_body off;
+        set $res '';
+        rewrite_by_lua '
+            ngx.var.res = ngx.var.request_body or "nil"
+        ';
+        content_by_lua '
+            ngx.say(ngx.var.res or "nil")
+            ngx.say(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body
+nil
+nil
+
+
+
+=== TEST 5: share the request body (need request body on)
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        set $res '';
+        rewrite_by_lua '
+            ngx.var.res = ngx.var.request_body or "nil"
+        ';
+        content_by_lua '
+            ngx.say(ngx.var.res or "nil")
+            ngx.say(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff
+hello\x00\x01\x02
+world\x03\x04\xff
+"
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/multi-capture.t b/src/lua/lua-nginx-module/t/023-rewrite/multi-capture.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/multi-capture.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/multi-capture.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,396 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(10);
+
+plan tests => blocks() * repeat_each() * 2;
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+
+
+
+=== TEST 2: 4 concurrent requests
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2, res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+                { "/c" },
+                { "/d" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/([a-d])$' {
+        echo -n $1;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+res3.status = 200
+res3.body = c
+res4.status = 200
+res4.body = d
+
+
+
+=== TEST 3: capture multi in series
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("2 res1.status = " .. res1.status)
+            ngx.say("2 res1.body = " .. res1.body)
+            ngx.say("2 res2.status = " .. res2.status)
+            ngx.say("2 res2.body = " .. res2.body)
+
+        ';
+        content_by_lua return;
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+2 res1.status = 200
+2 res1.body = a
+2 res2.status = 200
+2 res2.body = b
+
+
+
+=== TEST 4: capture multi in subrequest
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+
+            local n = ngx.var.arg_n
+
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /main {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo?n=1")
+            ngx.say("top res.status = " .. res.status)
+            ngx.say("top res.body = [" .. res.body .. "]")
+        ';
+        content_by_lua return;
+    }
+
+    location /a {
+        echo -n a;
+    }
+
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /main
+--- response_body
+top res.status = 200
+top res.body = [1 res1.status = 200
+1 res1.body = a
+1 res2.status = 200
+1 res2.body = b
+]
+
+
+
+=== TEST 5: capture multi in parallel
+--- config
+    location ~ '^/(foo|bar)$' {
+        set $tag $1;
+        rewrite_by_lua '
+            local res1, res2
+            if ngx.var.tag == "foo" then
+                res1, res2 = ngx.location.capture_multi{
+                    { "/a" },
+                    { "/b" },
+                }
+            else
+                res1, res2 = ngx.location.capture_multi{
+                    { "/c" },
+                    { "/d" },
+                }
+            end
+
+            local n = ngx.var.arg_n
+
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /main {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo?n=1" },
+                { "/bar?n=2" },
+            }
+
+            ngx.say("top res1.status = " .. res1.status)
+            ngx.say("top res1.body = [" .. res1.body .. "]")
+            ngx.say("top res2.status = " .. res2.status)
+            ngx.say("top res2.body = [" .. res2.body .. "]")
+        ';
+        content_by_lua return;
+    }
+
+    location ~ '^/([abcd])$' {
+        echo -n $1;
+    }
+--- request
+    GET /main
+--- response_body
+top res1.status = 200
+top res1.body = [1 res1.status = 200
+1 res1.body = a
+1 res2.status = 200
+1 res2.body = b
+]
+top res2.status = 200
+top res2.body = [2 res1.status = 200
+2 res1.body = c
+2 res2.status = 200
+2 res2.body = d
+]
+
+
+
+=== TEST 6: memc sanity
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/[ab]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /foo
+--- response_body eval
+"res1.status = 201
+res1.body = STORED\r
+
+res2.status = 201
+res2.body = STORED\r
+
+"
+
+
+
+=== TEST 7: memc muti + multi
+--- config
+    location /main {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo?n=1" },
+                { "/bar?n=2" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = [" .. res1.body .. "]")
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = [" .. res2.body .. "]")
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/(foo|bar)$' {
+        set $tag $1;
+        rewrite_by_lua '
+            local res1, res2
+            if ngx.var.tag == "foo" then
+                res1, res2 = ngx.location.capture_multi{
+                    { "/a" },
+                    { "/b" },
+                }
+            else
+                res1, res2 = ngx.location.capture_multi{
+                    { "/c" },
+                    { "/d" },
+                }
+            end
+            print("args: " .. ngx.var.args)
+            local n = ngx.var.arg_n
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/[abcd]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /main
+--- response_body eval
+"res1.status = 200
+res1.body = [1 res1.status = 201
+1 res1.body = STORED\r
+
+1 res2.status = 201
+1 res2.body = STORED\r
+
+]
+res2.status = 200
+res2.body = [2 res1.status = 201
+2 res1.body = STORED\r
+
+2 res2.status = 201
+2 res2.body = STORED\r
+
+]
+"
+
+
+
+=== TEST 8: memc 4 concurrent requests
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2, res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+                { "/c" },
+                { "/d" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/[a-d]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /foo
+--- response_body eval
+"res1.status = 201
+res1.body = STORED\r
+
+res2.status = 201
+res2.body = STORED\r
+
+res3.status = 201
+res3.body = STORED\r
+
+res4.status = 201
+res4.body = STORED\r
+
+"
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/on-abort.t b/src/lua/lua-nginx-module/t/023-rewrite/on-abort.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/on-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/on-abort.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,664 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = <<_EOC_;
+$t::StapThread::GCScript
+
+F(ngx_http_lua_check_broken_connection) {
+    println("lua check broken conn")
+}
+
+F(ngx_http_lua_request_cleanup) {
+    println("lua req cleanup")
+}
+_EOC_
+
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 15);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ignore the client abort event in the user callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.7
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 2: abort in the user callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 3: ngx.exit(499) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 4: ngx.exit(408) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(408)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.1
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 5: ngx.exit(-1) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(-1)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 6: ngx.exit(0) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(0)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+            ngx.log(ngx.ERR, "main handler done")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.7;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: fail
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.6
+--- ignore_response
+--- error_log
+client prematurely closed connection
+on abort called
+lua user thread aborted: runtime error: [string "rewrite_by_lua"]:4: attempt to abort with pending subrequests
+main handler done
+
+
+
+=== TEST 7: accessing cosocket in callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+                if not ok then
+                    ngx.log(ngx.ERR, "failed to connect to redis: ", err)
+                    ngx.exit(499)
+                end
+                local bytes, err = sock:send("flushall\\r\\n")
+                if not bytes then
+                    ngx.log(ngx.ERR, "failed to send query: ", err)
+                    ngx.exit(499)
+                end
+
+                local res, err = sock:receive()
+                if not res then
+                    ngx.log(ngx.ERR, "failed to receive: ", err)
+                    ngx.exit(499)
+                end
+                ngx.log(ngx.NOTICE, "callback done: ", res)
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.3
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+callback done: +OK
+
+
+
+=== TEST 8: ignore the client abort event in the user callback (no check)
+--- config
+    location /t {
+        lua_check_client_abort off;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("cannot set on_abort: ", err)
+                return
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- response_body
+cannot set on_abort: lua_check_client_abort is off
+--- no_error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 9: regsiter on_abort callback but no client abortion
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.say("done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+delete thread 2
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- response_body
+done
+--- no_error_log
+[error]
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 10: ignore the client abort event in the user callback (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.7)
+                ngx.log(ngx.NOTICE, "main handler done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+lua check broken conn
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.7
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 11: abort in the user callback (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.7)
+                ngx.log(ngx.NOTICE, "main handler done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 3
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 12: regsiter on_abort callback but no client abortion (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.1)
+                ngx.say("done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+delete thread 2
+terminate 4: ok
+delete thread 4
+lua req cleanup
+
+--- response_body
+done
+--- no_error_log
+[error]
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 13: regsiter on_abort callback multiple times
+--- config
+    location /t {
+        lua_check_client_abort on;
+        rewrite_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("1: cannot set on_abort: " .. err)
+                return
+            end
+
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("2: cannot set on_abort: " .. err)
+                return
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.1)
+                ngx.say("done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+delete thread 2
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- response_body
+2: cannot set on_abort: duplicate call
+
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/redirect.t b/src/lua/lua-nginx-module/t/023-rewrite/redirect.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/redirect.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/redirect.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,126 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => blocks() * repeat_each() * 3;
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: default 302
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.redirect("http://www.taobao.com/foo");
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://www.taobao.com/foo
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 2: explicit 302
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.redirect("http://www.taobao.com/foo", ngx.HTTP_MOVED_TEMPORARILY);
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://www.taobao.com/foo
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 3: explicit 301
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.redirect("http://www.taobao.com/foo", ngx.HTTP_MOVED_PERMANENTLY);
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://www.taobao.com/foo
+--- response_body_like: 301 Moved Permanently
+--- error_code: 301
+
+
+
+=== TEST 4: bad rc
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.redirect("http://www.taobao.com/foo", 404);
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+!Location
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 5: no args
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.redirect()
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+!Location
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 6: relative uri
+--- config
+    location /read {
+        rewrite_by_lua '
+            ngx.redirect("/foo")
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- raw_response_headers_like: Location: http://localhost(?::\d+)?/foo\r\n
+--- response_body_like: 302 Found
+--- error_code: 302
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/req-body.t b/src/lua/lua-nginx-module/t/023-rewrite/req-body.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/req-body.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/req-body.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,125 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 1);
+
+#no_diff();
+#no_long_string();
+#master_on();
+#workers(2);
+run_tests();
+
+__DATA__
+
+=== TEST 1: read buffered body
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+
+
+
+=== TEST 2: read buffered body (timed out)
+--- config
+    client_body_timeout 1ms;
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /test HTTP/1.1\r
+Host: localhost\r
+Content-Length: 100\r
+Connection: close\r
+\r
+hello, world"
+--- response_body:
+--- error_code_like: ^(?:500)?$
+
+
+
+=== TEST 3: read buffered body and then subrequest
+--- config
+    location /foo {
+        echo -n foo;
+    }
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            local res = ngx.location.capture("/foo");
+            ngx.say(ngx.var.request_body)
+            ngx.say("sub: ", res.body)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+sub: foo
+
+
+
+=== TEST 4: first subrequest and then read buffered body
+--- config
+    location /foo {
+        echo -n foo;
+    }
+    location = /test {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/foo");
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+            ngx.say("sub: ", res.body)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+sub: foo
+
+
+
+=== TEST 5: failed to write 100 continue
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+            ngx.exit(200)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- more_headers
+Expect: 100-Continue
+--- ignore_response
+--- no_error_log
+[alert]
+[error]
+http finalize request: 500, "/test?" a:1, c:0
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/req-socket.t b/src/lua/lua-nginx-module/t/023-rewrite/req-socket.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/req-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/req-socket.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,536 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 3);
+
+our $HtmlDir = html_dir;
+
+#$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /t {
+        rewrite_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            for i = 1, 3 do
+                local data, err, part = sock:receive(5)
+                if data then
+                    ngx.say("received: ", data)
+                else
+                    ngx.say("failed to receive: ", err, " [", part, "]")
+                end
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+POST /t
+hello world
+--- response_body
+got the request socket
+received: hello
+received:  worl
+failed to receive: closed [d]
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: multipart rfc sample (just partial streaming)
+--- config
+    location /t {
+        rewrite_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            local boundary
+            local header = ngx.var.http_content_type
+            local m = ngx.re.match(header, [[; +boundary=(?:"(.*?)"|(\\w+))]], "jo")
+            if m then
+                boundary = m[1] or m[2]
+
+            else
+                ngx.say("invalid content-type header")
+                return
+            end
+
+            local read_to_boundary = sock:receiveuntil("\\r\\n--" .. boundary)
+            local read_line = sock:receiveuntil("\\r\\n")
+
+            local data, err, part = read_to_boundary()
+            if data then
+                ngx.say("preamble: [" .. data .. "]")
+            else
+                ngx.say("failed to read the first boundary: ", err)
+                return
+            end
+
+            local i = 1
+            while true do
+                local line, err = read_line()
+
+                if not line then
+                    ngx.say("failed to read post-boundary line: ", err)
+                    return
+                end
+
+                m = ngx.re.match(line, "--$", "jo")
+                if m then
+                    ngx.say("found the end of the stream")
+                    return
+                end
+
+                while true do
+                    local line, err = read_line()
+                    if not line then
+                        ngx.say("failed to read part ", i, " header: ", err)
+                        return
+                    end
+
+                    if line == "" then
+                        -- the header part completes
+                        break
+                    end
+
+                    ngx.say("part ", i, " header: [", line, "]")
+                end
+
+                local data, err, part = read_to_boundary()
+                if data then
+                    ngx.say("part ", i, " body: [" .. data .. "]")
+                else
+                    ngx.say("failed to read part ", i + 1, " boundary: ", err)
+                    return
+                end
+
+                i = i + 1
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request eval
+"POST /t
+This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.\r
+--simple boundary\r
+\r
+This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.\r
+--simple boundary\r
+Content-type: text/plain; charset=us-ascii\r
+\r
+This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+\r
+--simple boundary--\r
+This is the epilogue.  It is also to be ignored.
+"
+--- more_headers
+Content-Type: multipart/mixed; boundary="simple boundary"
+--- response_body
+got the request socket
+preamble: [This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.]
+part 1 body: [This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.]
+part 2 header: [Content-type: text/plain; charset=us-ascii]
+part 2 body: [This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+]
+found the end of the stream
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: multipart rfc sample (completely streaming)
+--- config
+    location /t {
+        rewrite_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            local boundary
+            local header = ngx.var.http_content_type
+            local m = ngx.re.match(header, [[; +boundary=(?:"(.*?)"|(\\w+))]], "jo")
+            if m then
+                boundary = m[1] or m[2]
+
+            else
+                ngx.say("invalid content-type header")
+                return
+            end
+
+            local read_to_boundary = sock:receiveuntil("\\r\\n--" .. boundary)
+            local read_line = sock:receiveuntil("\\r\\n")
+
+            local preamble = ""
+            while true do
+                local data, err, part = read_to_boundary(1)
+                if data then
+                    preamble = preamble .. data
+
+                elseif not err then
+                    break
+
+                else
+                    ngx.say("failed to read the first boundary: ", err)
+                    return
+                end
+            end
+
+            ngx.say("preamble: [" .. preamble .. "]")
+
+            local i = 1
+            while true do
+                local line, err = read_line(50)
+
+                if not line and err then
+                    ngx.say("1: failed to read post-boundary line: ", err)
+                    return
+                end
+
+                if line then
+                    local dummy
+                    dummy, err = read_line(1)
+                    if err then
+                        ngx.say("2: failed to read post-boundary line: ", err)
+                        return
+                    end
+
+                    if dummy then
+                        ngx.say("bad post-boundary line: ", dummy)
+                        return
+                    end
+
+                    m = ngx.re.match(line, "--$", "jo")
+                    if m then
+                        ngx.say("found the end of the stream")
+                        return
+                    end
+                end
+
+                while true do
+                    local line, err = read_line(50)
+                    if not line and err then
+                        ngx.say("failed to read part ", i, " header: ", err)
+                        return
+                    end
+
+                    if line then
+                        local line, err = read_line(1)
+                        if line or err then
+                            ngx.say("error")
+                            return
+                        end
+                    end
+
+                    if line == "" then
+                        -- the header part completes
+                        break
+                    end
+
+                    ngx.say("part ", i, " header: [", line, "]")
+                end
+
+                local body = ""
+
+                while true do
+                    local data, err, part = read_to_boundary(1)
+                    if data then
+                        body = body .. data
+
+                    elseif err then
+                        ngx.say("failed to read part ", i + 1, " boundary: ", err)
+                        return
+
+                    else
+                        break
+                    end
+                end
+
+                ngx.say("part ", i, " body: [" .. body .. "]")
+
+                i = i + 1
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request eval
+"POST /t
+This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.\r
+--simple boundary\r
+\r
+This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.\r
+--simple boundary\r
+Content-type: text/plain; charset=us-ascii\r
+\r
+This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+\r
+--simple boundary--\r
+This is the epilogue.  It is also to be ignored.
+"
+--- more_headers
+Content-Type: multipart/mixed; boundary="simple boundary"
+--- response_body
+got the request socket
+preamble: [This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.]
+part 1 body: [This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.]
+part 2 header: [Content-type: text/plain; charset=us-ascii]
+part 2 body: [This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+]
+found the end of the stream
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: attempt to use the req socket across request boundary
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        rewrite_by_lua '
+            local test = require "test"
+            test.go()
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock, err
+
+function go()
+    if not sock then
+        sock, err = ngx.req.socket()
+        if sock then
+            ngx.say("got the request socket")
+        else
+            ngx.say("failed to get the request socket: ", err)
+        end
+    else
+        for i = 1, 3 do
+            local data, err, part = sock:receive(5)
+            if data then
+                ngx.say("received: ", data)
+            else
+                ngx.say("failed to receive: ", err, " [", part, "]")
+            end
+        end
+    end
+end
+--- request
+POST /t
+hello world
+--- response_body_like
+(?:got the request socket
+|failed to receive: closed [d]
+)?done
+--- no_error_log
+[alert]
+
+
+
+=== TEST 5: receive until on request_body - receiveuntil(1) on the last byte of the body
+See https://groups.google.com/group/openresty/browse_thread/thread/43cf01da3c681aba for details
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        rewrite_by_lua '
+            local test = require "test"
+            test.go()
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go()
+   local sock, err = ngx.req.socket()
+   if sock then
+      ngx.say("got the request socket")
+   else
+      ngx.say("failed to get the request socket: ", err)
+      return
+   end
+
+   local data, err, part = sock:receive(56)
+   if data then
+      ngx.say("received: ", data)
+   else
+      ngx.say("failed to receive: ", err, " [", part, "]")
+   end
+
+   local discard_line = sock:receiveuntil('\r\n')
+
+   local data, err, part = discard_line(8192)
+   if data then
+      ngx.say("received len: ", #data)
+   else
+      ngx.say("failed to receive: ", err, " [", part, "]")
+   end
+
+   local data, err, part = discard_line(1)
+   if data then
+      ngx.say("received: ", data)
+   else
+      ngx.say("failed to receive: ", err, " [", part, "]")
+   end
+end
+--- request
+POST /t
+-----------------------------820127721219505131303151179################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################$
+--- response_body
+got the request socket
+received: -----------------------------820127721219505131303151179
+received len: 8192
+received: $
+done
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 6: pipelined POST requests
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        rewrite_by_lua '
+            local test = require "test"
+            test.go()
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go()
+   local sock, err = ngx.req.socket()
+   if sock then
+      ngx.say("got the request socket")
+   else
+      ngx.say("failed to get the request socket: ", err)
+      return
+   end
+
+   while true do
+       local data, err, part = sock:receive(4)
+       if data then
+          ngx.say("received: ", data)
+       else
+          ngx.say("failed to receive: ", err, " [", part, "]")
+          return
+       end
+   end
+end
+--- pipelined_requests eval
+["POST /t
+hello, world",
+"POST /t
+hiya, world"]
+--- response_body eval
+["got the request socket
+received: hell
+received: o, w
+received: orld
+failed to receive: closed []
+done
+",
+"got the request socket
+received: hiya
+received: , wo
+failed to receive: closed [rld]
+done
+"]
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: Expect & 100 Continue
+--- config
+    location /t {
+        rewrite_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+                return
+            end
+
+            for i = 1, 3 do
+                local data, err, part = sock:receive(5)
+                if data then
+                    ngx.say("received: ", data)
+                else
+                    ngx.say("failed to receive: ", err, " [", part, "]")
+                end
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+POST /t
+hello world
+--- more_headers
+Expect: 100-Continue
+--- error_code: 100
+--- response_body_like chomp
+\breceived: hello\b.*?\breceived:  worl\b
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/request_body.t b/src/lua/lua-nginx-module/t/023-rewrite/request_body.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/request_body.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/request_body.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,174 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('debug'); # to ensure any log-level can be outputed
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: test reading request body
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 2: test not reading request body
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 3: test default setting (not reading request body)
+--- config
+    location /echo_body {
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 4: test main conf
+--- http_config
+    lua_need_request_body on;
+--- config
+    location /echo_body {
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 5: test server conf
+--- config
+    lua_need_request_body on;
+
+    location /echo_body {
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 6: test override main conf
+--- http_config
+    lua_need_request_body on;
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 7: test override server conf
+--- config
+    lua_need_request_body on;
+
+    location /echo_body {
+        lua_need_request_body off;
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 8: Expect: 100-Continue
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        rewrite_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+            ngx.exit(200)
+        ';
+    }
+--- request
+POST /echo_body
+hello world
+--- more_headers
+Expect: 100-Continue
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+http finalize request: 500, "/echo_body?" a:1, c:2
+http finalize request: 500, "/echo_body?" a:1, c:0
+--- log_level: debug
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/sanity.t b/src/lua/lua-nginx-module/t/023-rewrite/sanity.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/sanity.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/sanity.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,758 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#no_nginx_manager();
+#log_level('warn');
+#master_on();
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 9);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: basic print
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        rewrite_by_lua 'ngx.print("Hello, Lua!\\n")';
+        content_by_lua return;
+        #content_by_lua 'ngx.say("Hi")';
+    }
+--- request
+GET /lua
+--- response_body
+Hello, Lua!
+
+
+
+=== TEST 2: basic say
+--- config
+    location /say {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        rewrite_by_lua '
+            ngx.say("Hello, Lua!")
+            ngx.say("Yay! ", 123)';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /say
+--- response_body
+Hello, Lua!
+Yay! 123
+
+
+
+=== TEST 3: no ngx.echo
+--- config
+    location /lua {
+        rewrite_by_lua 'ngx.echo("Hello, Lua!\\n")';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: variable
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        rewrite_by_lua 'v = ngx.var["request_uri"] ngx.print("request_uri: ", v, "\\n")';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua?a=1&b=2
+--- response_body
+request_uri: /lua?a=1&b=2
+
+
+
+=== TEST 5: variable (file)
+--- config
+    location /lua {
+        rewrite_by_lua_file html/test.lua;
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body
+request_uri: /lua?a=1&b=2
+
+
+
+=== TEST 6: calc expression
+--- config
+    location /lua {
+        rewrite_by_lua_file html/calc.lua;
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- user_files
+>>> calc.lua
+local function uri_unescape(uri)
+    local function convert(hex)
+        return string.char(tonumber("0x"..hex))
+    end
+    local s = string.gsub(uri, "%%([0-9a-fA-F][0-9a-fA-F])", convert)
+    return s
+end
+
+local function eval_exp(str)
+    return loadstring("return "..str)()
+end
+
+local exp_str = ngx.var["arg_exp"]
+-- print("exp: '", exp_str, "'\n")
+local status, res
+status, res = pcall(uri_unescape, exp_str)
+if not status then
+    ngx.print("error: ", res, "\n")
+    return
+end
+status, res = pcall(eval_exp, res)
+if status then
+    ngx.print("result: ", res, "\n")
+else
+    ngx.print("error: ", res, "\n")
+end
+--- request
+GET /lua?exp=1%2B2*math.sin(3)%2Fmath.exp(4)-math.sqrt(2)
+--- response_body
+result: -0.4090441561579
+
+
+
+=== TEST 7: read $arg_xxx
+--- config
+    location = /lua {
+        rewrite_by_lua 'who = ngx.var.arg_who
+            ngx.print("Hello, ", who, "!")';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua?who=agentzh
+--- response_body chomp
+Hello, agentzh!
+
+
+
+=== TEST 8: capture location
+--- config
+    location /other {
+        echo "hello, world";
+    }
+
+    location /lua {
+        rewrite_by_lua '
+res = ngx.location.capture("/other")
+ngx.print("status=", res.status, " ")
+ngx.print("body=", res.body)
+';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+status=200 body=hello, world
+
+
+
+=== TEST 9: capture non-existed location
+--- config
+    location /lua {
+        rewrite_by_lua 'res = ngx.location.capture("/other"); ngx.print("status=", res.status)';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body: status=404
+
+
+
+=== TEST 10: invalid capture location (not as expected...)
+--- config
+    location /lua {
+        rewrite_by_lua 'res = ngx.location.capture("*(#*"); ngx.say("res=", res.status)';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+res=404
+
+
+
+=== TEST 11: nil is "nil"
+--- config
+    location /lua {
+        rewrite_by_lua 'ngx.say(nil)';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body
+nil
+
+
+
+=== TEST 12: write boolean
+--- config
+    location /lua {
+        rewrite_by_lua 'ngx.say(true, " ", false)';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body
+true false
+
+
+
+=== TEST 13: bad argument type to ngx.location.capture
+--- config
+    location /lua {
+        rewrite_by_lua 'ngx.location.capture(nil)';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 14: capture location (default 0);
+--- config
+ location /recur {
+       rewrite_by_lua '
+           local num = tonumber(ngx.var.arg_num) or 0;
+           ngx.print("num is: ", num, "\\n");
+
+           if (num > 0) then
+               res = ngx.location.capture("/recur?num="..tostring(num - 1));
+               ngx.print("status=", res.status, " ");
+               ngx.print("body=", res.body, "\\n");
+           else
+               ngx.print("end\\n");
+           end
+           ';
+
+           content_by_lua 'ngx.exit(ngx.OK)';
+   }
+--- request
+GET /recur
+--- response_body
+num is: 0
+end
+
+
+
+=== TEST 15: capture location
+--- config
+ location /recur {
+       rewrite_by_lua '
+           local num = tonumber(ngx.var.arg_num) or 0;
+           ngx.print("num is: ", num, "\\n");
+
+           if (num > 0) then
+               res = ngx.location.capture("/recur?num="..tostring(num - 1));
+               ngx.print("status=", res.status, " ");
+               ngx.print("body=", res.body);
+           else
+               ngx.print("end\\n");
+           end
+           ';
+
+           content_by_lua 'ngx.exit(ngx.OK)';
+   }
+--- request
+GET /recur?num=3
+--- response_body
+num is: 3
+status=200 body=num is: 2
+status=200 body=num is: 1
+status=200 body=num is: 0
+end
+
+
+
+=== TEST 16: setting nginx variables from within Lua
+--- config
+ location /set {
+       set $a "";
+       rewrite_by_lua 'ngx.var.a = 32; ngx.say(ngx.var.a)';
+       content_by_lua 'ngx.exit(ngx.OK)';
+       add_header Foo $a;
+   }
+--- request
+GET /set
+--- response_headers
+Foo: 32
+--- response_body
+32
+
+
+
+=== TEST 17: nginx quote sql string 1
+--- config
+ location /set {
+       set $a 'hello\n\r\'"\\'; # this runs after rewrite_by_lua
+       rewrite_by_lua 'ngx.say(ngx.quote_sql_str(ngx.var.a))';
+       content_by_lua 'ngx.exit(ngx.OK)';
+   }
+--- request
+GET /set
+--- response_body
+'hello\n\r\'\"\\'
+
+
+
+=== TEST 18: nginx quote sql string 2
+--- config
+location /set {
+    #set $a "hello\n\r'\"\\";
+    rewrite_by_lua 'ngx.say(ngx.quote_sql_str("hello\\n\\r\'\\"\\\\"))';
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /set
+--- response_body
+'hello\n\r\'\"\\'
+
+
+
+=== TEST 19: use dollar
+--- config
+location /set {
+    rewrite_by_lua '
+        local s = "hello 112";
+        ngx.say(string.find(s, "%d+$"))';
+
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /set
+--- response_body
+79
+
+
+
+=== TEST 20: subrequests do not share variables of main requests by default
+--- config
+location /sub {
+    echo $a;
+}
+location /parent {
+    set $a 12;
+    rewrite_by_lua 'res = ngx.location.capture("/sub"); ngx.print(res.body)';
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /parent
+--- response_body eval: "\n"
+
+
+
+=== TEST 21: subrequests can share variables of main requests
+--- config
+location /sub {
+    echo $a;
+}
+location /parent {
+    set $a '';
+    rewrite_by_lua '
+        ngx.var.a = 12;
+        res = ngx.location.capture(
+            "/sub",
+            { share_all_vars = true }
+        );
+        ngx.print(res.body)
+    ';
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /parent
+--- response_body
+12
+
+
+
+=== TEST 22: main requests use subrequests' variables
+--- config
+location /sub {
+    set $a 12;
+}
+location /parent {
+    rewrite_by_lua '
+        res = ngx.location.capture("/sub", { share_all_vars = true });
+        ngx.say(ngx.var.a)
+    ';
+
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /parent
+--- response_body
+12
+
+
+
+=== TEST 23: main requests do NOT use subrequests' variables
+--- config
+location /sub {
+    set $a 12;
+    content_by_lua return;
+}
+
+location /parent {
+    rewrite_by_lua '
+        res = ngx.location.capture("/sub", { share_all_vars = false });
+        ngx.say(ngx.var.a)
+    ';
+    content_by_lua return;
+}
+--- request
+GET /parent
+--- response_body_like eval: "\n"
+
+
+
+=== TEST 24: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo "hello, world";
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+        ';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+
+
+
+=== TEST 25: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        rewrite_by_lua '
+            ngx.header.Bar = "Bah";
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+            ngx.say("Bar: ", res.header["Bar"]);
+        ';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+Bar: Bah
+
+
+
+=== TEST 26: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        rewrite_by_lua '
+            ngx.header.Bar = "Bah";
+            ngx.header.Bar = nil;
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+            ngx.say("Bar: ", res.header["Bar"] or "nil");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+Bar: nil
+
+
+
+=== TEST 27: rewrite_by_lua runs before ngx_access
+--- config
+    location /lua {
+        deny all;
+
+        rewrite_by_lua '
+            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 28: rewrite_by_lua shouldn't send headers automatically (on simple return)
+--- config
+    location /lua {
+        rewrite_by_lua 'return';
+
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location = /foo {
+        default_type 'text/css';
+        add_header Bar Baz;
+        echo foo;
+    }
+--- request
+GET /lua
+--- response_headers
+Bar: Baz
+Content-Type: text/css
+--- response_body
+foo
+
+
+
+=== TEST 29: rewrite_by_lua shouldn't send headers automatically (on simple exit)
+--- config
+    location /lua {
+        rewrite_by_lua 'ngx.exit(ngx.OK)';
+
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location = /foo {
+        default_type 'text/css';
+        add_header Bar Baz;
+        echo foo;
+    }
+--- request
+GET /lua
+--- response_headers
+Bar: Baz
+Content-Type: text/css
+--- response_body
+foo
+
+
+
+=== TEST 30: short circuit
+--- config
+    location /lua {
+        rewrite_by_lua '
+            ngx.say("Hi")
+            ngx.eof()
+            ngx.exit(ngx.HTTP_OK)
+        ';
+
+        content_by_lua '
+            print("HERE")
+            ngx.print("BAD")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Hi
+
+
+
+=== TEST 31: nginx vars in script path
+--- config
+    location ~ /lua/(.+)$ {
+        rewrite_by_lua_file html/$1.lua;
+
+        content_by_lua '
+            print("HERE")
+            ngx.print("BAD")
+        ';
+    }
+--- user_files
+>>> hi.lua
+ngx.say("Hi")
+ngx.eof()
+ngx.exit(ngx.HTTP_OK)
+--- request
+GET /lua/hi
+--- response_body
+Hi
+
+
+
+=== TEST 32: phase postponing works for various locations
+--- config
+    location ~ '^/lua/(.+)' {
+        set $path $1;
+        rewrite_by_lua 'ngx.say(ngx.var.path)';
+        content_by_lua return;
+    }
+    location ~ '^/lua2/(.+)' {
+        set $path $1;
+        rewrite_by_lua 'ngx.say(ngx.var.path)';
+        content_by_lua return;
+    }
+    location /main {
+        echo_location /lua/foo;
+        echo_location /lua/bar;
+        echo_location /lua2/baz;
+        echo_location /lua2/bah;
+    }
+--- request
+GET /main
+--- response_body
+foo
+bar
+baz
+bah
+
+
+
+=== TEST 33: server rewrite_by_lua
+--- config
+    rewrite_by_lua 'ngx.header["X-Foo"] = "bar" -- ngx.send_headers()';
+--- request
+GET /
+--- response_body chop
+<html><head><title>It works!</title></head><body>It works!</body></html>
+--- response_headers
+X-Foo: bar
+--- no_error_log
+[error]
+
+
+
+=== TEST 34: server rewrite_by_lua_file
+--- config
+    rewrite_by_lua_file html/foo.lua;
+--- user_files
+>>> foo.lua
+ngx.header["X-Foo"] = "bar" -- ngx.send_headers()
+--- request
+GET /
+--- response_body chop
+<html><head><title>It works!</title></head><body>It works!</body></html>
+--- response_headers
+X-Foo: bar
+
+
+
+=== TEST 35: rewrite last before rewrite_by_lua
+--- config
+    location /main {
+        rewrite ^/main/xyz\.html$ /abc.html last;
+        rewrite_by_lua 'ngx.exit(503)';
+    }
+    location ~ /abc.html {
+        echo abc;
+    }
+--- request
+    GET /main/xyz.html
+--- response_body
+abc
+
+
+
+=== TEST 36: rewrite last before rewrite_by_lua_file
+--- config
+    location /main {
+        rewrite ^/main/xyz\.html$ /abc.html last;
+        rewrite_by_lua_file html/exit.lua;
+    }
+    location ~ /abc.html {
+        echo abc;
+    }
+--- user_files
+>>> exit.lua
+ngx.exit(503)
+--- request
+    GET /main/xyz.html
+--- response_body
+abc
+
+
+
+=== TEST 37: rewrite before rewrite_by_lua
+--- config
+    location /main {
+        rewrite ^/main/xyz\.html$ /abc.html;
+        rewrite_by_lua 'ngx.exit(503)';
+    }
+    location ~ /abc.html {
+        echo abc;
+    }
+--- request
+    GET /main/xyz.html
+--- response_body
+abc
+
+
+
+=== TEST 38: rewrite break before rewrite_by_lua
+--- config
+    location /main {
+        rewrite ^/main/xyz\.html$ /abc.html break;
+        rewrite_by_lua 'ngx.exit(503)';
+    }
+    location ~ /abc.html {
+        echo abc;
+    }
+--- request
+    GET /main/xyz.html
+--- response_body_like: 503 Service Temporarily Unavailable
+--- error_code: 503
+
+
+
+=== TEST 39: Lua file does not exist
+--- config
+    location /lua {
+        rewrite_by_lua_file html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/sleep.t b/src/lua/lua-nginx-module/t/023-rewrite/sleep.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/sleep.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/sleep.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,223 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * 33;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sleep 0.5
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep(0.5)
+            local now = ngx.now()
+            ngx.say(now - before)
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:4[5-9]\d*|5[0-9]\d*|5)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+
+
+
+=== TEST 2: sleep ag
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep("a")
+            local now = ngx.now()
+            ngx.say(now - before)
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /test
+--- error_code: 500
+--- response_body_like: 500 Internal Server Error
+--- error_log
+bad argument #1 to 'sleep'
+
+
+
+=== TEST 3: sleep 0.5 in subrequest
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.location.capture("/sleep")
+            local now = ngx.now()
+            local delay = now - before
+            ngx.say(delay)
+            ngx.exit(200)
+        ';
+    }
+    location /sleep {
+        rewrite_by_lua 'ngx.sleep(0.5) ngx.exit(200)';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:4[5-9]\d*|5[0-9]\d*|5)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/sleep?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: sleep a in subrequest with bad argument
+--- config
+    location /test {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/sleep");
+            ngx.say(res.status)
+            ngx.exit(200)
+        ';
+    }
+    location /sleep {
+        rewrite_by_lua 'ngx.sleep("a") ngx.exit(200)';
+    }
+--- request
+GET /test
+--- response_body
+500
+--- error_log
+bad argument #1 to 'sleep'
+
+
+
+=== TEST 5: sleep 0.5 - multi-times
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.update_time()
+            local start = ngx.now()
+            ngx.sleep(0.3)
+            ngx.sleep(0.3)
+            ngx.sleep(0.3)
+            ngx.say(ngx.now() - start)
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:8[5-9]\d*|9[0-9]\d*|9)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: sleep 0.5 - interleaved by ngx.say() - ended by ngx.sleep
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.send_headers()
+            -- ngx.location.capture("/sleep")
+            ngx.sleep(1)
+            ngx.say("blah")
+            ngx.sleep(1)
+            -- ngx.location.capture("/sleep")
+            ngx.exit(200)
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.1;
+    }
+--- request
+GET /test
+--- response_body
+blah
+--- error_log
+lua ready to sleep
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: sleep 0.5 - interleaved by ngx.say() - not ended by ngx.sleep
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.send_headers()
+            -- ngx.location.capture("/sleep")
+            ngx.sleep(0.3)
+            ngx.say("blah")
+            ngx.sleep(0.5)
+            -- ngx.location.capture("/sleep")
+            ngx.say("hiya")
+            ngx.exit(200)
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.1;
+    }
+--- request
+GET /test
+--- response_body
+blah
+hiya
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: ngx.location.capture before and after ngx.sleep
+--- config
+    location /test {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+
+            ngx.sleep(0.1)
+
+            res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+            ngx.exit(200)
+        ';
+    }
+    location = /hello {
+        echo hello world;
+    }
+    location = /sub {
+        proxy_pass http://127.0.0.1:$server_port/hello;
+    }
+--- request
+GET /test
+--- response_body
+hello world
+hello world
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/socket-keepalive.t b/src/lua/lua-nginx-module/t/023-rewrite/socket-keepalive.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/socket-keepalive.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/socket-keepalive.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,986 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 5 + 8);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_HTML_DIR} = $HtmlDir;
+#$ENV{TEST_NGINX_REDIS_PORT} ||= 6379;
+
+$ENV{LUA_PATH} ||=
+    '/usr/local/openresty-debug/lualib/?.lua;/usr/local/openresty/lualib/?.lua;;';
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+
+no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        rewrite_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port)
+            test.go(port)
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body_like
+^connected: 1, reused: \d+
+request sent: 11
+received: OK
+connected: 1, reused: [1-9]\d*
+request sent: 11
+received: OK
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for "]
+--- error_log eval
+qq{lua tcp socket get keepalive peer: using connection
+lua tcp socket keepalive create connection pool for key "127.0.0.1:$ENV{TEST_NGINX_MEMCACHED_PORT}"
+}
+
+
+
+=== TEST 2: free up the whole connection pool if no active connections
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        rewrite_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port, true)
+            test.go(port, false)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, keepalive)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    if keepalive then
+        local ok, err = sock:setkeepalive()
+        if not ok then
+            ngx.say("failed to set reusable: ", err)
+        end
+
+    else
+        sock:close()
+    end
+end
+--- response_body_like
+^connected: 1, reused: \d+
+request sent: 11
+received: OK
+connected: 1, reused: [1-9]\d*
+request sent: 11
+received: OK
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket get keepalive peer: using connection",
+"lua tcp socket keepalive: free connection pool for "]
+
+
+
+=== TEST 3: upstream sockets close prematurely
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+   server_tokens off;
+   keepalive_timeout 100ms;
+   location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, err = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for "]
+--- timeout: 3
+
+
+
+=== TEST 4: http keepalive
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+   server_tokens off;
+   location /t {
+        keepalive_timeout 60s;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, err = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive close handler: fd:",
+"lua tcp socket keepalive: free connection pool for "]
+--- timeout: 4
+
+
+
+=== TEST 5: lua_socket_keepalive_timeout
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 100ms;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 100 ms",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 6: lua_socket_pool_size
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 100ms;
+       lua_socket_pool_size 1;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 100 ms",
+qr/lua tcp socket connection pool size: 1\b/]
+--- timeout: 4
+
+
+
+=== TEST 7: "lua_socket_keepalive_timeout 0" means unlimited
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 0;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive timeout: unlimited",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 8: setkeepalive(timeout) overrides lua_socket_keepalive_timeout
+--- config
+   server_tokens off;
+   location /t {
+        keepalive_timeout 60s;
+        lua_socket_keepalive_timeout 60s;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive(123)
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 123 ms",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 9: sock:setkeepalive(timeout, size) overrides lua_socket_pool_size
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 100ms;
+       lua_socket_pool_size 100;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive(101, 25)
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 101 ms",
+qr/lua tcp socket connection pool size: 25\b/]
+--- timeout: 4
+
+
+
+=== TEST 10: sock:keepalive_timeout(0) means unlimited
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 1000ms;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        rewrite_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive(0)
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive timeout: unlimited",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 11: sanity (uds)
+--- http_config eval
+"
+    lua_package_path '$::HtmlDir/?.lua;./?.lua';
+    server {
+        listen unix:$::HtmlDir/nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            echo foo;
+            more_clear_headers Date;
+        }
+    }
+"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        rewrite_by_lua '
+            local test = require "test"
+            local path = "$TEST_NGINX_HTML_DIR/nginx.sock";
+            local port = ngx.var.port
+            test.go(path, port)
+            test.go(path, port)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(path, port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("unix:" .. path)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "GET /foo HTTP/1.1\r\nHost: localhost\r\nConnection: keepalive\r\n\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local reader = sock:receiveuntil("\r\n0\r\n\r\n")
+    local data, err = reader()
+
+    if not data then
+        ngx.say("failed to receive response body: ", err)
+        return
+    end
+
+    ngx.say("received response of ", #data, " bytes")
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- response_body_like
+^connected: 1, reused: \d+
+request sent: 61
+received response of 119 bytes
+connected: 1, reused: [1-9]\d*
+request sent: 61
+received response of 119 bytes
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for "]
+--- error_log eval
+["lua tcp socket get keepalive peer: using connection",
+'lua tcp socket keepalive create connection pool for key "unix:']
+
+
+
+=== TEST 12: github issue #108: ngx.locaiton.capture + redis.set_keepalive
+--- http_config eval
+    qq{
+        lua_package_path "$::HtmlDir/?.lua;;";
+    }
+--- config
+    location /t {
+        default_type text/html;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #lua_code_cache off;
+        lua_need_request_body on;
+        rewrite_by_lua_file html/t.lua;
+        content_by_lua return;
+    }
+
+    location /anyurl {
+        internal;
+        proxy_pass http://127.0.0.1:$server_port/dummy;
+    }
+
+    location = /dummy {
+        echo dummy;
+    }
+--- user_files
+>>> t.lua
+local sock, err = ngx.socket.connect("127.0.0.1", ngx.var.port)
+if not sock then ngx.say(err) return end
+sock:send("flush_all\r\n")
+sock:receive()
+sock:setkeepalive()
+
+sock, err = ngx.socket.connect("127.0.0.1", ngx.var.port)
+if not sock then ngx.say(err) return end
+local res = ngx.location.capture("/anyurl") --3
+
+ngx.say("ok")
+--- request
+    GET /t
+--- response_body
+ok
+--- error_log
+lua tcp socket get keepalive peer: using connection
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 13: github issue #110: ngx.exit with HTTP_NOT_FOUND causes worker process to exit
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    error_page 404 /404.html;
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        access_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port)
+            ngx.exit(404)
+        ';
+        echo hello;
+    }
+--- user_files
+>>> 404.html
+Not found, dear...
+>>> test.lua
+module("test", package.seeall)
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.log(ngx.ERR, "failed to connect: ", err)
+        return
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.log(ngx.ERR, "failed to send request: ", err)
+        return
+    end
+
+    local line, err, part = sock:receive()
+    if not line then
+        ngx.log(ngx.ERR, "failed to receive a line: ", err, " [", part, "]")
+        return
+    end
+
+    -- local ok, err = sock:setkeepalive()
+    -- if not ok then
+        -- ngx.log(ngx.ERR, "failed to set reusable: ", err)
+        -- return
+    -- end
+end
+--- request
+GET /t
+--- response_body
+Not found, dear...
+--- error_code: 404
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/subrequest.t b/src/lua/lua-nginx-module/t/023-rewrite/subrequest.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/subrequest.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/subrequest.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,644 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: DELETE
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+DELETE
+
+
+
+=== TEST 2: DELETE (proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+DELETE
+
+
+
+=== TEST 3: POST (nobody, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+POST
+
+
+
+=== TEST 4: HEAD
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_HEAD });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+HEAD
+
+
+
+=== TEST 5: explicit GET
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_GET });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+
+
+
+=== TEST 6: implicit GET
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo")
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+
+
+
+=== TEST 7: implicit GET (empty option table)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo", {})
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+
+
+
+=== TEST 8: PUT (nobody, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body chomp
+PUT
+hello
+
+
+
+=== TEST 9: PUT (nobody, no proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        #echo_read_request_body;
+
+        echo $echo_request_method;
+        #echo $echo_request_body;
+        echo_request_body;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body chomp
+PUT
+hello
+
+
+
+=== TEST 10: PUT (nobody, no proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        #echo_read_request_body;
+
+        echo $echo_request_method;
+        #echo $echo_request_body;
+        echo_request_body;
+        #echo "[$http_content_length]";
+        echo;
+    }
+
+    location /foo {
+        echo $echo_request_method;
+        echo -n "[$http_content_length]";
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+
+            res = ngx.location.capture("/foo")
+            ngx.say(res.body)
+
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+PUT
+hello
+GET
+[]
+
+
+
+=== TEST 11: POST (with body, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body chomp
+POST
+hello
+
+
+
+=== TEST 12: POST (with body, memc method)
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("cached: " .. res.body);
+
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET: 404
+PUT: 201
+cached: hello
+
+
+
+=== TEST 13: POST (with body, memc method)
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_cmd "";
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            ngx.location.capture("/flush",
+                { share_all_vars = true });
+
+            res = ngx.location.capture("/memc",
+                { share_all_vars = true });
+            ngx.say("GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello", share_all_vars = true });
+            ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc", { share_all_vars = true });
+            ngx.say("cached: " .. res.body);
+
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET: 404
+PUT: 201
+cached: hello
+
+
+
+=== TEST 14: emtpy args option table
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = {} })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body eval: "\n"
+
+
+
+=== TEST 15: non-empty args option table (1 pair)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { ["fo="] = "=>" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+fo%3d=%3d%3e
+
+
+
+=== TEST 16: non-empty args option table (2 pairs)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { ["fo="] = "=>",
+                    ["="] = ":" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like chop
+^(?:fo%3d=%3d%3e\&%3d=%3a|%3d=%3a\&fo%3d=%3d%3e)$
+
+
+
+=== TEST 17: non-empty args option table (2 pairs, no special chars)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { foo = 3,
+                    bar = "hello" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like chop
+^(?:bar=hello\&foo=3|foo=3\&bar=hello)$
+
+
+
+=== TEST 18: non-empty args option table (number key)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { [57] = "hi" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 19: non-empty args option table (plain arrays)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { "hi" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 20: more args
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo?a=3",
+                { args = { b = 4 } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+a=3&b=4
+
+
+
+=== TEST 21: more args
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            res = ngx.location.capture("/foo?a=3",
+                { args = "b=4" })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+a=3&b=4
+
+
+
+=== TEST 22: more args
+--- config
+    location /memc {
+        set $memc_cmd get;
+        set $memc_key $arg_key;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc_set {
+        #set $memc_cmd set;
+        #set $memc_key $arg_key;
+        #memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+        echo OK;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            print("HELLO")
+            local memc_key = "hello"
+            local res = ngx.location.capture("/memc?key=" .. memc_key )
+            ngx.say("copass: res " .. res.status)
+
+            if res.status == 404 then
+                   ngx.say("copas: capture /memc_set")
+                   res = ngx.location.capture("/memc_set?key=" .. memc_key)
+                   ngx.say("copss: status " .. res.status);
+            end
+        ';
+        content_by_lua 'return';
+        #echo Hi;
+    }
+--- request
+    GET /lua
+--- response_body
+copass: res 404
+copas: capture /memc_set
+copss: status 200
+
+
+
+=== TEST 23: I/O in named location
+the nginx core requires the patch https://github.com/agentzh/ngx_openresty/blob/master/patches/nginx-1.0.15-reset_wev_handler_in_named_locations.patch
+--- config
+    location /t {
+        echo_exec @named;
+    }
+
+    location @named {
+        rewrite_by_lua '
+            ngx.location.capture("/hello")
+        ';
+        echo done;
+    }
+
+    location /hello {
+        echo hello;
+    }
+--- request
+    GET /t
+--- response_body
+done
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket.t b/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,2038 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * 87;
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+#log_level 'warn';
+
+#no_long_string();
+#no_diff();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: no trailing newline
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 1234;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            sock:close()
+            ngx.say("closed")
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.print("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 3
+received: Connection: close
+received: 
+failed to receive a line: closed [foo]
+closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: no resolver defined
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 1234;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("agentzh.org", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: no resolver defined to resolve "agentzh.org"
+connected: nil
+failed to send request: closed
+--- error_log
+attempt to send data on a closed socket:
+
+
+
+=== TEST 4: with resolver
+--- timeout: 10
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = 80
+            local ok, err = sock:connect("agentzh.org", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET / HTTP/1.0\\r\\nHost: agentzh.org\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local line, err = sock:receive()
+            if line then
+                ngx.say("first line received: ", line)
+
+            else
+                ngx.say("failed to receive the first line: ", err)
+            end
+
+            line, err = sock:receive()
+            if line then
+                ngx.say("second line received: ", line)
+
+            else
+                ngx.say("failed to receive the second line: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 56
+first line received: HTTP/1.1 200 OK
+second line received: Server: ngx_openresty
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: connection refused (tcp)
+--- config
+    location /test {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", 16787)
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil connection refused
+send: nil closed
+receive: nil closed
+close: nil closed
+--- error_log eval
+qr/connect\(\) failed \(\d+: Connection refused\)/
+
+
+
+=== TEST 6: connection timeout (tcp)
+--- config
+    resolver $TEST_NGINX_RESOLVER;
+    lua_socket_connect_timeout 100ms;
+    lua_socket_send_timeout 100ms;
+    lua_socket_read_timeout 100ms;
+    resolver_timeout 1s;
+    location /test {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 12345)
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil timeout
+send: nil closed
+receive: nil closed
+close: nil closed
+--- error_log
+lua tcp socket connect timed out
+
+
+
+=== TEST 7: not closed manually
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: resolver error (host not found)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = 80
+            local ok, err = sock:connect("blah-blah-not-found.agentzh.org", port)
+            print("connected: ", ok, " ", err, " ", not ok)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET / HTTP/1.0\\r\\nHost: agentzh.org\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body_like
+^failed to connect: blah-blah-not-found\.agentzh\.org could not be resolved(?: \(3: Host not found\))?
+connected: nil
+failed to send request: closed$
+--- error_log
+attempt to send data on a closed socket
+--- timeout: 5
+
+
+
+=== TEST 9: resolver error (timeout)
+--- config
+    server_tokens off;
+    resolver 8.8.8.8;
+    resolver_timeout 1ms;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = 80
+            local ok, err = sock:connect("blah-blah-not-found.agentzh.org", port)
+            print("connected: ", ok, " ", err, " ", not ok)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET / HTTP/1.0\\r\\nHost: agentzh.org\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body_like
+^failed to connect: blah-blah-not-found\.agentzh\.org could not be resolved(?: \(\d+: Operation timed out\))?
+connected: nil
+failed to send request: closed$
+--- error_log
+attempt to send data on a closed socket
+
+
+
+=== TEST 10: explicit *l pattern for receive
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err = sock:receive("*l")
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err)
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: *a pattern for receive
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local data, err = sock:receive("*a")
+            if data then
+                ngx.say("receive: ", data)
+                ngx.say("err: ", err)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+receive: HTTP/1.1 200 OK\r
+Server: nginx\r
+Content-Type: text/plain\r
+Content-Length: 4\r
+Connection: close\r
+\r
+foo
+
+err: nil
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: mixing *a and *l patterns for receive
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local line, err = sock:receive("*l")
+            if line then
+                ngx.say("receive: ", line)
+                ngx.say("err: ", err)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            local data
+            data, err = sock:receive("*a")
+            if data then
+                ngx.say("receive: ", data)
+                ngx.say("err: ", err)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+receive: HTTP/1.1 200 OK
+err: nil
+receive: Server: nginx\r
+Content-Type: text/plain\r
+Content-Length: 4\r
+Connection: close\r
+\r
+foo
+
+err: nil
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: receive by chunks
+--- timeout: 5
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local data, err, partial = sock:receive(10)
+                if data then
+                    local len = string.len(data)
+                    if len == 10 then
+                        ngx.print("[", data, "]")
+                    else
+                        ngx.say("ERROR: returned invalid length of data: ", len)
+                    end
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", partial, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+[HTTP/1.1 2][00 OK\r
+Ser][ver: nginx][\r
+Content-][Type: text][/plain\r
+Co][ntent-Leng][th: 4\r
+Con][nection: c][lose\r
+\r
+fo]failed to receive a line: closed [o
+]
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: receive by chunks (very small buffer)
+--- timeout: 5
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 1;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local data, err, partial = sock:receive(10)
+                if data then
+                    local len = string.len(data)
+                    if len == 10 then
+                        ngx.print("[", data, "]")
+                    else
+                        ngx.say("ERROR: returned invalid length of data: ", len)
+                    end
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", partial, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+[HTTP/1.1 2][00 OK\r
+Ser][ver: nginx][\r
+Content-][Type: text][/plain\r
+Co][ntent-Leng][th: 4\r
+Con][nection: c][lose\r
+\r
+fo]failed to receive a line: closed [o
+]
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: line reading (very small buffer)
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 1;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: ngx.socket.connect (working)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local port = ngx.var.port
+            local sock, err = ngx.socket.connect("127.0.0.1", port)
+            if not sock then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected.")
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected.
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: ngx.socket.connect() shortcut (connection refused)
+--- config
+    location /test {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local sock, err = sock:connect("127.0.0.1", 16787)
+            if not sock then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+    GET /test
+--- response_body
+failed to connect: connection refused
+--- error_log eval
+qr/connect\(\) failed \(\d+: Connection refused\)/
+
+
+
+=== TEST 18: receive by chunks (stringified size)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local data, err, partial = sock:receive("10")
+                if data then
+                    local len = string.len(data)
+                    if len == 10 then
+                        ngx.print("[", data, "]")
+                    else
+                        ngx.say("ERROR: returned invalid length of data: ", len)
+                    end
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", partial, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+[HTTP/1.1 2][00 OK\r
+Ser][ver: nginx][\r
+Content-][Type: text][/plain\r
+Co][ntent-Leng][th: 4\r
+Con][nection: c][lose\r
+\r
+fo]failed to receive a line: closed [o
+]
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: cannot survive across request boundary (send)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        rewrite_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+"^(?:connected: 1
+request sent: 11
+received: OK|failed to send request: closed)\$"
+
+
+
+=== TEST 20: cannot survive across request boundary (receive)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        rewrite_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+
+    else
+        local line, err, part = sock:receive()
+        if line then
+            ngx.say("received: ", line)
+
+        else
+            ngx.say("failed to receive a line: ", err, " [", part, "]")
+        end
+        return
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+qr/^(?:connected: 1
+request sent: 11
+received: OK|failed to receive a line: closed \[nil\])$/
+
+
+
+=== TEST 21: cannot survive across request boundary (close)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        rewrite_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+
+    else
+        local ok, err = sock:close()
+        if ok then
+            ngx.say("successfully closed")
+
+        else
+            ngx.say("failed to close: ", err)
+        end
+        return
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+qr/^(?:connected: 1
+request sent: 11
+received: OK|failed to close: closed)$/
+
+
+
+=== TEST 22: cannot survive across request boundary (connect)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        rewrite_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+            test.go(ngx.var.port)
+        ';
+
+        content_by_lua return;
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+
+    else
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect again: ", err)
+            return
+        end
+
+        ngx.say("connected again: ", ok)
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+qr/^(?:connected(?: again)?: 1
+request sent: 11
+received: OK
+){2}$/
+--- error_log
+lua reuse socket upstream ctx
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: connect again immediately
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected again: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local line, err, part = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+connected again: 1
+request sent: 11
+received: OK
+close: 1 nil
+--- no_error_log
+[error]
+--- error_log eval
+["lua reuse socket upstream", "lua tcp socket reconnect without shutting down"]
+
+
+
+=== TEST 24: two sockets mix together
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port1 $TEST_NGINX_MEMCACHED_PORT;
+        set $port2 $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock1 = ngx.socket.tcp()
+            local sock2 = ngx.socket.tcp()
+
+            local port1 = ngx.var.port1
+            local port2 = ngx.var.port2
+
+            local ok, err = sock1:connect("127.0.0.1", port1)
+            if not ok then
+                ngx.say("1: failed to connect: ", err)
+                return
+            end
+
+            ngx.say("1: connected: ", ok)
+
+            ok, err = sock2:connect("127.0.0.1", port2)
+            if not ok then
+                ngx.say("2: failed to connect: ", err)
+                return
+            end
+
+            ngx.say("2: connected: ", ok)
+
+            local req1 = "flush_all\\r\\n"
+            local bytes, err = sock1:send(req1)
+            if not bytes then
+                ngx.say("1: failed to send request: ", err)
+                return
+            end
+            ngx.say("1: request sent: ", bytes)
+
+            local req2 = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            local bytes, err = sock2:send(req2)
+            if not bytes then
+                ngx.say("2: failed to send request: ", err)
+                return
+            end
+            ngx.say("2: request sent: ", bytes)
+
+            local line, err, part = sock1:receive()
+            if line then
+                ngx.say("1: received: ", line)
+
+            else
+                ngx.say("1: failed to receive a line: ", err, " [", part, "]")
+            end
+
+            line, err, part = sock2:receive()
+            if line then
+                ngx.say("2: received: ", line)
+
+            else
+                ngx.say("2: failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock1:close()
+            ngx.say("1: close: ", ok, " ", err)
+
+            ok, err = sock2:close()
+            ngx.say("2: close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+1: connected: 1
+2: connected: 1
+1: request sent: 11
+2: request sent: 57
+1: received: OK
+2: received: HTTP/1.1 200 OK
+1: close: 1 nil
+2: close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 25: send tables of string fragments
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 26: send tables of string fragments (bad type "nil")
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", nil, 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad argument #1 to 'send' (bad data type nil found)
+
+
+
+=== TEST 27: send tables of string fragments (bad type "boolean")
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", true, 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad argument #1 to 'send' (bad data type boolean found)
+
+
+
+=== TEST 28: send tables of string fragments (bad type ngx.null)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", ngx.null, 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad argument #1 to 'send' (bad data type userdata found)
+
+
+
+=== TEST 29: cosocket before location capture (tcpsock:send did not clear u->waiting)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local line, err, part = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+
+            local resp = ngx.location.capture("/memc")
+            if type(resp) ~= "table" then
+                ngx.say("bad resp: type ", type(resp), ": ", resp)
+                return
+            end
+
+            ngx.print("subrequest: ", resp.status, ", ", resp.body)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /memc {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 11
+received: OK
+close: 1 nil
+subrequest: 200, OK\r
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 30: CR in a line
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo\\r\\rbar\\rbaz")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 13
+received: Connection: close
+received: 
+received: foobarbaz
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+--- SKIP
+
+
+
+=== TEST 31: receive(0)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local data, err, part = sock:receive(0)
+            if not data then
+                ngx.say("failed to receive(0): ", err)
+                return
+            end
+
+            ngx.say("receive(0): [", data, "]")
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+receive(0): []
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 32: send("")
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local bytes, err = sock:send("")
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("send(\\"\\"): ", bytes)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+send(""): 0
+close: 1 nil
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket-timeout.t b/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket-timeout.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket-timeout.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/tcp-socket-timeout.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,616 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+BEGIN {
+    if (!defined $ENV{LD_PRELOAD}) {
+        $ENV{LD_PRELOAD} = '';
+    }
+
+    if ($ENV{LD_PRELOAD} !~ /\bmockeagain\.so\b/) {
+        $ENV{LD_PRELOAD} = "mockeagain.so $ENV{LD_PRELOAD}";
+    }
+
+    if ($ENV{MOCKEAGAIN} eq 'r') {
+        $ENV{MOCKEAGAIN} = 'rw';
+
+    } else {
+        $ENV{MOCKEAGAIN} = 'w';
+    }
+
+    $ENV{TEST_NGINX_EVENT_TYPE} = 'poll';
+    $ENV{MOCKEAGAIN_WRITE_TIMEOUT_PATTERN} = 'get helloworld';
+}
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 14);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+no_long_string();
+no_diff();
+run_tests();
+
+__DATA__
+
+=== TEST 1: lua_socket_connect_timeout only
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t1 {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t1
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 100
+lua tcp socket connect timed out
+--- timeout: 5
+
+
+
+=== TEST 2: sock:settimeout() overrides lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 60s;
+    lua_socket_log_errors off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t2 {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(150)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t2
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 150
+--- no_error_log
+[error]
+[alert]
+--- timeout: 5
+
+
+
+=== TEST 3: sock:settimeout(nil) does not override lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_log_errors off;
+    lua_socket_connect_timeout 102ms;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t3 {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(nil)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t3
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 102
+--- no_error_log
+[error]
+[alert]
+--- timeout: 5
+
+
+
+=== TEST 4: sock:settimeout(0) does not override lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 102ms;
+    lua_socket_log_errors off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t4 {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(0)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t4
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 102
+--- timeout: 5
+--- no_error_log
+[error]
+[alert]
+--- timeout: 5
+
+
+
+=== TEST 5: sock:settimeout(-1) does not override lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 102ms;
+    lua_socket_log_errors off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t5 {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(-1)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t5
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 102
+--- no_error_log
+[error]
+[alert]
+--- timeout: 5
+
+
+
+=== TEST 6: lua_socket_read_timeout only
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 100ms;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket read timeout: 100
+lua tcp socket connect timeout: 60000
+lua tcp socket read timed out
+
+
+
+=== TEST 7: sock:settimeout() overrides lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 60s;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(150)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket read timeout: 150
+lua tcp socket read timed out
+
+
+
+=== TEST 8: sock:settimeout(nil) does not override lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(nil)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket read timeout: 102
+lua tcp socket read timed out
+
+
+
+=== TEST 9: sock:settimeout(0) does not override lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(0)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket read timeout: 102
+lua tcp socket read timed out
+
+
+
+=== TEST 10: sock:settimeout(-1) does not override lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(-1)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket read timeout: 102
+lua tcp socket connect timeout: 60000
+lua tcp socket read timed out
+
+
+
+=== TEST 11: lua_socket_send_timeout only
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket send timeout: 100
+lua tcp socket connect timeout: 60000
+lua tcp socket write timed out
+
+
+
+=== TEST 12: sock:settimeout() overrides lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 60s;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(150)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket send timeout: 150
+lua tcp socket write timed out
+
+
+
+=== TEST 13: sock:settimeout(nil) does not override lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(nil)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket send timeout: 102
+lua tcp socket write timed out
+
+
+
+=== TEST 14: sock:settimeout(0) does not override lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(0)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket send timeout: 102
+lua tcp socket write timed out
+
+
+
+=== TEST 15: sock:settimeout(-1) does not override lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(-1)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket send timeout: 102
+lua tcp socket connect timeout: 60000
+lua tcp socket write timed out
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/unix-socket.t b/src/lua/lua-nginx-module/t/023-rewrite/unix-socket.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/unix-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/unix-socket.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,152 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => blocks() * repeat_each() * 2;
+
+$ENV{TEST_NGINX_HTML_DIR} ||= html_dir();
+
+no_long_string();
+#no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: connection refused (unix domain socket)
+--- config
+    location /test {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("unix:/tmp/nosuchfile.sock")
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil no such file or directory
+send: nil closed
+receive: nil closed
+close: nil closed
+
+
+
+=== TEST 2: invalid host argument
+--- http_server
+    server {
+        listen /tmp/test-nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            content_by_lua 'ngx.say("foo")';
+            more_clear_headers Date;
+        }
+    }
+--- config
+    location /test {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("/tmp/test-nginx.sock")
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+    GET /test
+--- response_body
+failed to connect: failed to parse host name "/tmp/test-nginx.sock": invalid host
+
+
+
+=== TEST 3: sanity
+--- http_config
+    server {
+        listen unix:$TEST_NGINX_HTML_DIR/nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            content_by_lua 'ngx.say("foo")';
+            more_clear_headers Date;
+        }
+    }
+--- config
+    location /test {
+        rewrite_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("unix:$TEST_NGINX_HTML_DIR/nginx.sock")
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                print("calling receive")
+                local line, err = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err)
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+    GET /test
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed
+close: nil closed
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/uthread-exec.t b/src/lua/lua-nginx-module/t/023-rewrite/uthread-exec.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/uthread-exec.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/uthread-exec.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,352 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: exec in user thread (entry still pending)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("hello")
+        ';
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: exec in user thread (entry already quits)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+        ';
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: exec in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+        ';
+        content_by_lua return;
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: exec in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            function g()
+                ngx.sleep(1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+        content_by_lua return;
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: exec in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+
+    location = /foo {
+        echo hello world;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/uthread-exit.t b/src/lua/lua-nginx-module/t/023-rewrite/uthread-exit.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/uthread-exit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/uthread-exit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1383 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: exit in user thread (entry thread is still pending to run)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+M(timer-add) {
+    if ($arg2 == 1000) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+hello in thread
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: exit in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: exit in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f")
+                ngx.exit(0)
+            end
+
+            function g()
+                ngx.sleep(1)
+                ngx.say("g")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+terminate 4: ok
+delete thread 4
+free request
+
+--- response_body
+end
+f
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: exit in user thread (entry already quits)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("exiting the user thread")
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- wait: 0.1
+--- response_body
+before
+after
+exiting the user thread
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: exit in user thread (entry thread is still pending on the DNS resolver for ngx.socket.tcp)
+--- config
+    location /lua {
+        resolver agentzh.org;
+        resolver_timeout 12s;
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.001)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_resolve_start) {
+    println("resolver started")
+}
+
+F(ngx_http_lua_socket_resolve_handler) {
+    println("resolver done")
+}
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+F(ngx_resolve_name) {
+    printf("resolving %s\n", user_string_n($ctx->name->data, $ctx->name->len))
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 1) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_resolve_cleanup) {
+    println("lua tcp resolve cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 1
+resolver started
+resolving agentzh.org
+add timer 12000
+expire timer 1
+terminate 2: ok
+lua tcp resolve cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: exit in user thread (entry thread is still pending on the DNS resolver for ngx.socket.udp)
+--- config
+    location /lua {
+        resolver agentzh.org;
+        #resolver 127.0.0.1;
+        resolver_timeout 12s;
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.001)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("agentzh.org", 80)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_resolve_start) {
+    println("resolver started")
+}
+
+F(ngx_http_lua_socket_resolve_handler) {
+    println("resolver done")
+}
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+F(ngx_resolve_name) {
+    printf("resolving %s\n", user_string_n($ctx->name->data, $ctx->name->len))
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 1) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_udp_resolve_cleanup) {
+    println("lua udp resolve cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 1
+resolver started
+resolving agentzh.org
+add timer 12000
+expire timer 1
+terminate 2: ok
+lua udp resolve cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: exit in user thread (entry thread is still pending on tcpsock:connect)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+            sock:settimeout(12000)
+            local ok, err = sock:connect("106.187.41.147", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: exit in user thread (entry thread is still pending on tcpsock:receive)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, ok = sock:send("blpop not_exists 2\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: exit in user thread (entry thread is still pending on tcpsock:receiveuntil's iterator)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, ok = sock:send("blpop not_exists 2\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local it, err = sock:receiveuntil("\\r\\n")
+            if not it then
+                ngx.say("failed to receive until: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = it()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: exit in user thread (entry thread is still pending on udpsock:receive)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.udp()
+
+            local ok, err = sock:setpeername("8.8.8.8", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_udp_socket_cleanup) {
+    println("lua udp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua udp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: exit in user thread (entry thread is still pending on reqsock:receive)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.req.socket()
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive(1024)
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+
+--- more_headers
+Content-Length: 1024
+
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: exit in user thread (entry thread is still pending on ngx.req.read_body)
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.req.read_body()
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_req_body_cleanup) {
+    println("lua req body cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua req body cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: exit in user thread (entry thread is still pending on ngx.location.capture), with pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 14: exit in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 15: exit in user thread (entry thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture_multi{
+                {"/echo"},
+                {"/sleep"}
+            }
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/uthread-redirect.t b/src/lua/lua-nginx-module/t/023-rewrite/uthread-redirect.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/uthread-redirect.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/uthread-redirect.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,195 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ngx.redirect() in user thread (entry thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.redirect(301)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture_multi{
+                {"/echo"},
+                {"/sleep"}
+            }
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 2: redirect in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.redirect(301)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body_like: 302 Found
+--- error_code: 302
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/023-rewrite/uthread-spawn.t b/src/lua/lua-nginx-module/t/023-rewrite/uthread-spawn.t
--- a/src/lua/lua-nginx-module/t/023-rewrite/uthread-spawn.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/023-rewrite/uthread-spawn.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1528 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 1);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple user thread without I/O
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval
+<<'_EOC_' . $::StapScript;
+
+F(ngx_http_lua_send_chain_link) {
+    printf("send link %p\n", $in)
+}
+
+F(ngx_http_core_content_phase) {
+    println("core content phase")
+}
+
+_EOC_
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: two simple user threads without I/O
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("in thread 1")
+            end
+
+            function g()
+                ngx.say("in thread 2")
+            end
+
+            ngx.say("before 1")
+            ngx.thread.spawn(f)
+            ngx.say("after 1")
+
+            ngx.say("before 2")
+            ngx.thread.spawn(g)
+            ngx.say("after 2")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+terminate 1: ok
+delete thread 2
+delete thread 3
+delete thread 1
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before 1
+in thread 1
+after 1
+before 2
+in thread 2
+after 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: simple user thread with sleep
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before sleep")
+                ngx.sleep(0.1)
+                ngx.say("after sleep")
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before sleep
+after thread create
+after sleep
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: two simple user threads with sleep
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("1: before sleep")
+                ngx.sleep(0.2)
+                ngx.say("1: after sleep")
+            end
+
+            function g()
+                ngx.say("2: before sleep")
+                ngx.sleep(0.1)
+                ngx.say("2: after sleep")
+            end
+
+            ngx.say("1: before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("1: after thread create")
+
+            ngx.say("2: before thread create")
+            ngx.thread.spawn(g)
+            ngx.say("2: after thread create")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2
+terminate 4: ok
+delete thread 4
+
+--- wait: 0.1
+--- response_body
+1: before thread create
+1: before sleep
+1: after thread create
+2: before thread create
+2: before sleep
+2: after thread create
+2: after sleep
+1: after sleep
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: error in user thread
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.blah()
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: fail
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+after
+--- error_log
+lua user thread aborted: runtime error: [string "rewrite_by_lua"]:3: attempt to call field 'blah' (a nil value)
+
+
+
+=== TEST 6: simple user threads doing a single subrequest (entry quits early)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before capture")
+                res = ngx.location.capture("/proxy")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello world;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before capture
+after thread create
+after capture: hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: simple user threads doing a single subrequest (entry also does a subrequest and quits early)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo -n hello bar;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before capture
+after thread create
+capture: hello bar
+after capture: hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: simple user threads doing a single subrequest (entry also does a subrequest and quits late)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo_sleep 0.2;
+        echo -n hello bar;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before capture
+after thread create
+after capture: hello foo
+capture: hello bar
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: two simple user threads doing single subrequests (entry also does a subrequest and quits between)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("f: before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("f: after capture: ", res.body)
+            end
+
+            function g()
+                ngx.say("g: before capture")
+                local res = ngx.location.capture("/proxy?bah")
+                ngx.say("g: after capture: ", res.body)
+            end
+
+            ngx.say("before thread 1 create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread 1 create")
+
+            ngx.say("before thread 2 create")
+            ngx.thread.spawn(g)
+            ngx.say("after thread 2 create")
+
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo_sleep 0.2;
+        echo -n hello bar;
+    }
+
+    location /bah {
+        echo_sleep 0.3;
+        echo -n hello bah;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before thread 1 create
+f: before capture
+after thread 1 create
+before thread 2 create
+g: before capture
+after thread 2 create
+f: after capture: hello foo
+capture: hello bar
+g: after capture: hello bah
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: nested user threads
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            ngx.thread.spawn(f)
+            ngx.say("after f")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 3
+delete thread 2
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before f
+before g
+hello in g()
+after f
+after g
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: nested user threads (with I/O)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.sleep(0.1)
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            ngx.thread.spawn(f)
+            ngx.say("after f")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before f
+before g
+after f
+after g
+hello in g()
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: coroutine status of a running user thread
+--- config
+    location /lua {
+        rewrite_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+                ngx.sleep(0.1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+status: running
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: coroutine status of a dead user thread
+--- config
+    location /lua {
+        rewrite_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+status: zombie
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: coroutine status of a "normal" user thread
+--- config
+    location /lua {
+        rewrite_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+                local co2 = coroutine.create(g)
+                coroutine.resume(co2)
+            end
+
+            function g()
+                ngx.sleep(0.1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+terminate 2: ok
+delete thread 2
+terminate 4: ok
+delete thread 4
+
+--- response_body
+status: normal
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: creating user threads in a user coroutine
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            local co = coroutine.create(f)
+            coroutine.resume(co)
+            ngx.say("after f")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+terminate 2: ok
+delete thread 3
+terminate 1: ok
+delete thread 1
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before f
+before g
+hello in g()
+after g
+after f
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: manual time slicing between a user thread and the entry thread
+--- config
+    location /lua {
+        rewrite_by_lua '
+            local yield = coroutine.yield
+
+            function f()
+                local self = coroutine.running()
+                ngx.say("f 1")
+                yield(self)
+                ngx.say("f 2")
+                yield(self)
+                ngx.say("f 3")
+            end
+
+            local self = coroutine.running()
+            ngx.say("0")
+            yield(self)
+            ngx.say("1")
+            ngx.thread.spawn(f)
+            ngx.say("2")
+            yield(self)
+            ngx.say("3")
+            yield(self)
+            ngx.say("4")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+0
+1
+f 1
+2
+f 2
+3
+f 3
+4
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: manual time slicing between two user threads
+--- config
+    location /lua {
+        rewrite_by_lua '
+            local yield = coroutine.yield
+
+            function f()
+                local self = coroutine.running()
+                ngx.say("f 1")
+                yield(self)
+                ngx.say("f 2")
+                yield(self)
+                ngx.say("f 3")
+            end
+
+            function g()
+                local self = coroutine.running()
+                ngx.say("g 1")
+                yield(self)
+                ngx.say("g 2")
+                yield(self)
+                ngx.say("g 3")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+            ngx.say("done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+f 1
+g 1
+f 2
+done
+g 2
+f 3
+g 3
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: entry thread and a user thread flushing at the same time
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                coroutine.yield(coroutine.running)
+                ngx.flush(true)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.flush(true)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: two user threads flushing at the same time
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.say("hello from f")
+                ngx.flush(true)
+            end
+
+            function g()
+                ngx.say("hello from g")
+                ngx.flush(true)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3|create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+terminate 1: ok
+delete thread 2
+delete thread 3
+delete thread 1)
+terminate 4: ok
+delete thread 4$
+
+--- response_body
+hello from f
+hello from g
+--- no_error_log
+[error]
+
+
+
+=== TEST 20: user threads + ngx.socket.tcp
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+                if not ok then
+                    ngx.say("failed to connect: ", err)
+                    return
+                end
+                local bytes, err = sock:send("flush_all\\r\\n")
+                if not bytes then
+                    ngx.say("failed to send query: ", err)
+                    return
+                end
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+
+                ngx.say("received: ", line)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+after
+received: OK
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: user threads + ngx.socket.udp
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                local sock = ngx.socket.udp()
+                local ok, err = sock:setpeername("127.0.0.1", 12345)
+                local bytes, err = sock:send("blah")
+                if not bytes then
+                    ngx.say("failed to send query: ", err)
+                    return
+                end
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+
+                ngx.say("received: ", line)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+|create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3)$
+
+--- udp_listen: 12345
+--- udp_query: blah
+--- udp_reply: hello udp
+--- response_body_like chop
+^(?:before
+after
+received: hello udp
+|before
+received: hello udp
+after)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 22: simple user thread with ngx.req.read_body()
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.req.read_body()
+                local body = ngx.req.get_body_data()
+                ngx.say("body: ", body)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+hello world
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1|create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2)
+terminate 3: ok
+delete thread 3$
+
+--- response_body_like chop
+^(?:before
+body: hello world
+after|before
+after
+body: hello world)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: simple user thread with ngx.req.socket()
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                local sock = ngx.req.socket()
+                local body, err = sock:receive(11)
+                if not body then
+                    ngx.say("failed to read body: ", err)
+                    return
+                end
+
+                ngx.say("body: ", body)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+hello world
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1|create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2)
+terminate 3: ok
+delete thread 3$
+
+--- response_body_like chop
+^(?:before
+body: hello world
+after|before
+after
+body: hello world)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 24: multiple user threads + subrequests returning 404 immediately
+--- config
+    location /t {
+        rewrite_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 2 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+        content_by_lua return;
+    }
+
+    location ~ ^/proxy/(\d+) {
+        return 404;
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval
+"$::GCScript"
+.
+'
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+'
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+finalize request /proxy/1: rc:404 c:3 a:0
+post subreq: /proxy/1 rc=404, status=0 a=0
+subrequest /proxy/1 done
+terminate 2: ok
+delete thread 2
+finalize request /proxy/2: rc:404 c:2 a:0
+post subreq: /proxy/2 rc=404, status=0 a=0
+subrequest /proxy/2 done
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+finalize request /t: rc:0 c:1 a:1
+(?:finalize request /t: rc:0 c:1 a:1)?$
+
+--- response_body
+ok
+status: 404
+status: 404
+--- no_error_log
+[error]
+--- timeout: 3
+
+
+
+=== TEST 25: multiple user threads + subrequests returning 404 remotely (no wait)
+--- config
+    location /t {
+        rewrite_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 5 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+        content_by_lua return;
+    }
+
+    location ~ ^/proxy/(\d+) {
+        proxy_pass http://127.0.0.1:$server_port/d/$1;
+    }
+
+    location /d {
+        return 404;
+        #echo $uri;
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+create 4 in 1
+spawn user thread 4 in 1
+create 5 in 1
+spawn user thread 5 in 1
+create 6 in 1
+spawn user thread 6 in 1
+terminate 1: ok
+delete thread 1
+(?:terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+terminate 5: ok
+delete thread 5
+terminate 6: ok
+delete thread 6|terminate 6: ok
+delete thread 6
+terminate 5: ok
+delete thread 5
+terminate 4: ok
+delete thread 4
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2)
+terminate 7: ok
+delete thread 7
+
+--- response_body
+ok
+status: 404
+status: 404
+status: 404
+status: 404
+status: 404
+--- no_error_log
+[error]
+--- timeout: 6
+
+
+
+=== TEST 26: multiple user threads + subrequests returning 201 immediately
+--- config
+    location /t {
+        rewrite_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 2 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+        content_by_lua return;
+    }
+
+    location ~ ^/proxy/(\d+) {
+        content_by_lua 'ngx.exit(201)';
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval
+"$::GCScript"
+.
+'
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+'
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 4: ok
+delete thread 4
+finalize request /proxy/1: rc:201 c:3 a:0
+post subreq: /proxy/1 rc=201, status=201 a=0
+subrequest /proxy/1 done
+terminate 2: ok
+delete thread 2
+terminate 5: ok
+delete thread 5
+finalize request /proxy/2: rc:201 c:2 a:0
+post subreq: /proxy/2 rc=201, status=201 a=0
+subrequest /proxy/2 done
+terminate 3: ok
+delete thread 3
+terminate 6: ok
+delete thread 6
+finalize request /t: rc:0 c:1 a:1
+(?:finalize request /t: rc:0 c:1 a:1)?$
+
+--- response_body
+ok
+status: 201
+status: 201
+--- no_error_log
+[error]
+--- timeout: 3
+
+
+
+=== TEST 27: multiple user threads + subrequests returning 204 immediately
+--- config
+    location /t {
+        rewrite_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 2 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+        content_by_lua return;
+    }
+
+    location ~ ^/proxy/(\d+) {
+        content_by_lua 'ngx.exit(204)';
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval
+"$::GCScript"
+.
+'
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+'
+
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 4: ok
+delete thread 4
+finalize request /proxy/1: rc:204 c:3 a:0
+post subreq: /proxy/1 rc=204, status=204 a=0
+subrequest /proxy/1 done
+terminate 2: ok
+delete thread 2
+terminate 5: ok
+delete thread 5
+finalize request /proxy/2: rc:204 c:2 a:0
+post subreq: /proxy/2 rc=204, status=204 a=0
+subrequest /proxy/2 done
+terminate 3: ok
+delete thread 3
+terminate 6: ok
+delete thread 6
+finalize request /t: rc:0 c:1 a:1
+(?:finalize request /t: rc:0 c:1 a:1)?$
+
+--- response_body
+ok
+status: 204
+status: 204
+--- no_error_log
+[error]
+--- timeout: 3
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/auth.t b/src/lua/lua-nginx-module/t/024-access/auth.t
--- a/src/lua/lua-nginx-module/t/024-access/auth.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/auth.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,111 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+#no_nginx_manager();
+
+#repeat_each(1);
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 1);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: basic test passing
+--- config
+    location /lua {
+        lua_need_request_body on;
+        client_max_body_size 100k;
+        client_body_buffer_size 100k;
+
+        access_by_lua '
+            -- check the client IP addr is in our black list
+            if ngx.var.remote_addr == "132.5.72.3" then
+                ngx.exit(ngx.HTTP_FORBIDDEN)
+            end
+
+            -- check if the request body contains bad words
+            if ngx.var.request_body and string.match(ngx.var.request_body, "fuck") then
+                return ngx.redirect("/terms_of_use.html")
+            end
+
+            -- tests passed
+        ';
+
+        echo Logged in;
+    }
+--- request
+GET /lua
+--- response_body
+Logged in
+
+
+
+=== TEST 2: bad words in request body
+--- config
+    location /lua {
+        lua_need_request_body on;
+        client_max_body_size 100k;
+        client_body_buffer_size 100k;
+
+        access_by_lua '
+            -- check the client IP addr is in our black list
+            if ngx.var.remote_addr == "132.5.72.3" then
+                ngx.exit(ngx.HTTP_FORBIDDEN)
+            end
+
+            -- check if the request body contains bad words
+            if ngx.var.request_body and string.match(ngx.var.request_body, "fuck") then
+                return ngx.redirect("/terms_of_use.html")
+            end
+
+            -- tests passed
+        ';
+
+        echo Logged in;
+    }
+--- request
+POST /lua
+He fucks himself!
+--- response_body_like: 302 Found
+--- response_headers_like
+Location: http://[^:]+:\d+/terms_of_use\.html
+--- error_code: 302
+
+
+
+=== TEST 3: client IP
+--- config
+    location /lua {
+        lua_need_request_body on;
+        client_max_body_size 100k;
+        client_body_buffer_size 100k;
+
+        access_by_lua '
+            -- check the client IP addr is in our black list
+            if ngx.var.remote_addr == "127.0.0.1" then
+                ngx.exit(ngx.HTTP_FORBIDDEN)
+            end
+
+            -- check if the request body contains bad words
+            if ngx.var.request_body and string.match(ngx.var.request_body, "fuck") then
+                return ngx.redirect("/terms_of_use.html")
+            end
+
+            -- tests passed
+        ';
+
+        echo Logged in;
+    }
+--- request
+GET /lua
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/client-abort.t b/src/lua/lua-nginx-module/t/024-access/client-abort.t
--- a/src/lua/lua-nginx-module/t/024-access/client-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/client-abort.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,852 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = <<_EOC_;
+$t::StapThread::GCScript
+
+F(ngx_http_lua_check_broken_connection) {
+    println("lua check broken conn")
+}
+
+F(ngx_http_lua_request_cleanup) {
+    println("lua req cleanup")
+}
+_EOC_
+
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 - 1);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 2: sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 3: sleep + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        access_by_lua '
+            ngx.sleep(1)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: subrequest + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location /sub {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 5: subrequest + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        access_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location /sub {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: fail
+lua req cleanup
+delete thread 1
+
+--- wait: 1.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- error_log
+bad things happen
+
+
+
+=== TEST 6: subrequest + stop (proxy, ignore client abort)
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location = /sub {
+        proxy_ignore_client_abort on;
+        proxy_pass http://agentzh.org:12345/;
+    }
+
+    location = /sleep {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 7: subrequest + stop (proxy, check client abort)
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location = /sub {
+        proxy_ignore_client_abort off;
+        proxy_pass http://agentzh.org:12345/;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 8: need body on + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        lua_need_request_body on;
+        access_by_lua '
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 9: ngx.req.read_body + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.req.read_body()
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 10: ngx.req.socket + receive() + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive()
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 11: ngx.req.socket + receive(N) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(5)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 12: ngx.req.socket + receive(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(2)
+            ngx.sleep(1)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:lua check broken conn
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup|lua check broken conn
+lua req cleanup
+delete thread 1)$
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: ngx.req.socket + m * receive(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(2)
+            sock:receive(2)
+            sock:receive(1)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 14: ngx.req.socket + receiveuntil + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            local it = sock:receiveuntil("\\n")
+            it()
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 15: ngx.req.socket + receiveuntil + it(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            local it = sock:receiveuntil("\\n")
+            it(2)
+            it(3)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 16: cosocket + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.req.discard_body()
+
+            local sock, err = ngx.socket.tcp()
+            if not sock then
+                ngx.log(ngx.ERR, "failed to get socket: ", err)
+                return
+            end
+
+            ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("blpop nonexist 2\\r\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "failed to send query: ", err)
+                return
+            end
+
+            -- ngx.log(ngx.ERR, "about to receive")
+
+            local res, err = sock:receive()
+            if not res then
+                ngx.log(ngx.ERR, "failed to receive query: ", err)
+                return
+            end
+
+            ngx.log(ngx.ERR, "res: ", res)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 17: ngx.req.socket + receive n < content-length + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            error("bad")
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 100\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+failed to receive: client aborted
+
+
+
+=== TEST 18: ngx.req.socket + receive n == content-length + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            ngx.sleep(1)
+            error("bad")
+        ';
+
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 5\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 19: ngx.req.socket + receive n == content-length + ignore
+--- config
+    location /t {
+        access_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            ngx.say("done")
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 5\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- shutdown: 1
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 20: ngx.req.read_body + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.req.read_body()
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- shutdown: 1
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: exec to lua + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.exec("/t2")
+        ';
+    }
+
+    location = /t2 {
+        lua_check_client_abort off;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 22: exec to proxy + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.exec("/t2")
+        ';
+    }
+
+    location = /t2 {
+        proxy_ignore_client_abort on;
+        proxy_pass http://127.0.0.1:$server_port/sleep;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 23: exec (named location) to proxy + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            ngx.exec("@t2")
+        ';
+    }
+
+    location @t2 {
+        proxy_ignore_client_abort on;
+        proxy_pass http://127.0.0.1:$server_port/sleep;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/exec.t b/src/lua/lua-nginx-module/t/024-access/exec.t
--- a/src/lua/lua-nginx-module/t/024-access/exec.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/exec.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,352 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => blocks() * repeat_each() * 2;
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec("/hi");
+            ngx.say("Hi");
+        ';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body
+Hello
+
+
+
+=== TEST 2: empty uri arg
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec("");
+            ngx.say("Hi");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 3: no arg
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec();
+            ngx.say("Hi");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: too many args
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec(1, 2, 3, 4);
+            ngx.say("Hi");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 5: null uri
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec(nil)
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo "Hello";
+    }
+--- request
+GET /read
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 6: user args
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec("/hi", "Yichun Zhang")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello Yichun Zhang
+
+
+
+=== TEST 7: args in uri
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec("/hi?agentzh")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello agentzh
+
+
+
+=== TEST 8: args in uri and user args
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec("/hi?a=Yichun", "b=Zhang")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello a=Yichun&b=Zhang
+
+
+
+=== TEST 9: args in uri and user args
+--- config
+    location /read {
+        access_by_lua '
+            ngx.exec("@hi?a=Yichun", "b=Zhang")
+            ngx.say("Hi")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location @hi {
+        echo Hello $query_string;
+    }
+--- request
+GET /read
+--- response_body
+Hello 
+
+
+
+=== TEST 10: exec after location capture
+--- config
+    location /test {
+        access_by_lua_file 'html/test.lua';
+        echo world;
+    }
+
+    location /a {
+        echo "hello";
+    }
+
+    location /b {
+        echo "hello";
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('/b')
+--- request
+    GET /test
+--- response_body
+hello
+
+
+
+=== TEST 11: exec after (named) location capture
+--- config
+    location /test {
+        access_by_lua_file 'html/test.lua';
+    }
+
+    location /a {
+        echo "hello";
+    }
+
+    location @b {
+        echo "hello";
+    }
+
+--- user_files
+>>> test.lua
+ngx.location.capture('/a')
+
+ngx.exec('@b')
+--- request
+    GET /test
+--- response_body
+hello
+
+
+
+=== TEST 12: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /p{
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /lua {
+        access_by_lua '
+            ngx.exec("/p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+--- timeout: 3
+
+
+
+=== TEST 13: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (named location)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location @p {
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /lua {
+        access_by_lua '
+            ngx.exec("@p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 14: github issue #40: 2 Subrequest calls when using access_by_lua, ngx.exec and echo_location (post subrequest)
+--- config
+    location = /hi {
+        echo hello;
+    }
+    location /sub {
+        proxy_pass http://127.0.0.1:$server_port/hi;
+    }
+    location /p{
+        #content_by_lua '
+            #local res = ngx.location.capture("/sub")
+            #ngx.print(res.body)
+        #';
+        echo_location /sub;
+    }
+    location /blah {
+        echo blah;
+    }
+    location /lua {
+        access_by_lua '
+            ngx.location.capture("/blah")
+            ngx.exec("/p")
+        ';
+    }
+--- request
+    GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 15: access_by_lua + ngx.exec + subrequest capture
+--- config
+    location /main {
+        access_by_lua '
+            res = ngx.location.capture("/test_loc");
+            ngx.print("hello, ", res.body)
+        ';
+        content_by_lua return;
+    }
+    location /test_loc {
+        rewrite_by_lua '
+            ngx.exec("@proxy")
+        ';
+    }
+    location @proxy {
+        #echo proxy;
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+    location /foo {
+        echo bah;
+    }
+--- request
+    GET /main
+--- response_body
+hello, bah
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/exit.t b/src/lua/lua-nginx-module/t/024-access/exit.t
--- a/src/lua/lua-nginx-module/t/024-access/exit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/exit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,549 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#repeat_each(20000);
+repeat_each(2);
+
+#master_on();
+#workers(1);
+#log_level('debug');
+#log_level('warn');
+#worker_connections(1024);
+
+plan tests => repeat_each() * (blocks() * 2 + 2);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+
+our $LuaCpath = $ENV{LUA_CPATH} ||
+    '/usr/local/openresty-debug/lualib/?.so;/usr/local/openresty/lualib/?.so;;';
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: throw 403
+--- config
+    location /lua {
+        access_by_lua "ngx.exit(403);ngx.say('hi')";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_code: 403
+--- response_body_like: 403 Forbidden
+
+
+
+=== TEST 2: throw 404
+--- config
+    location /lua {
+        access_by_lua "ngx.exit(404);ngx.say('hi');";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_code: 404
+--- response_body_like: 404 Not Found
+
+
+
+=== TEST 3: throw 404 after sending the header and partial body
+--- config
+    location /lua {
+        access_by_lua "ngx.say('hi');ngx.exit(404);ngx.say(', you')";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+hi
+--- no_error_log
+[alert]
+--- error_log
+attempt to set status 404 via ngx.exit after sending out the response status 200
+
+
+
+=== TEST 4: working with ngx_auth_request (succeeded)
+--- config
+    location /auth {
+        access_by_lua "
+            if ngx.var.user == 'agentzh' then
+                ngx.eof();
+            else
+                ngx.exit(403)
+            end";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+    location /api {
+        set $user $arg_user;
+        auth_request /auth;
+
+        echo "Logged in";
+    }
+--- request
+GET /api?user=agentzh
+--- error_code: 200
+--- response_body
+Logged in
+
+
+
+=== TEST 5: working with ngx_auth_request (failed)
+--- config
+    location /api {
+        set $user $arg_user;
+        access_by_lua "
+            if ngx.var.user == 'agentzh' then
+                ngx.eof();
+            else
+                ngx.exit(403)
+            end";
+
+        echo "Logged in";
+    }
+--- request
+GET /api?user=agentz
+--- error_code: 403
+--- response_body_like: 403 Forbidden
+
+
+
+=== TEST 6: working with ngx_auth_request (simplest form, w/o ngx_memc)
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /api {
+        set $uid $arg_uid;
+        access_by_lua_file 'html/foo.lua';
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    -- ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+--- timeout: 3
+
+
+
+=== TEST 7: working with ngx_auth_request (simplest form)
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /api {
+        set $uid $arg_uid;
+        access_by_lua_file html/foo.lua;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+-- print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+
+
+
+=== TEST 8: working with ngx_auth_request
+--- http_config eval
+"
+    lua_package_cpath '$::LuaCpath';
+    upstream backend {
+        drizzle_server 127.0.0.1:\$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+
+    upstream memc_a {
+        server 127.0.0.1:\$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    upstream memc_b {
+        server 127.0.0.1:\$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    upstream_list memc_cluster memc_a memc_b;
+"
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        set_hashed_upstream $backend memc_cluster $arg_key;
+        memc_pass $backend;
+    }
+
+    location /conv-uid-mysql {
+        internal;
+
+        set $key "conv-uid-$arg_uid";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        drizzle_query "select new_uid as uid from conv_uid where old_uid=$arg_uid";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /api {
+        set $uid $arg_uid;
+        access_by_lua_file html/foo.lua;
+
+        echo "Logged in $uid";
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local old_uid = ngx.var.uid
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-uid-mysql?uid=' .. old_uid)
+-- print('just have run sr' .. res.body)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].uid or
+        not string.match(res[1].uid, '^%d+$')) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.uid = res[1].uid;
+-- print('done')
+--- request
+GET /api?uid=32
+--- response_body
+Logged in 56
+
+
+
+=== TEST 9: working with ngx_auth_request
+--- http_config
+    upstream backend {
+        drizzle_server 127.0.0.1:$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+
+    upstream memc_a {
+        server 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+        keepalive 300;
+    }
+
+    #upstream_list memc_cluster memc_a memc_b;
+
+--- config
+    location /memc {
+        internal;
+
+        set $memc_key $arg_key;
+        set $memc_exptime $arg_exptime;
+
+        #set_hashed_upstream $backend memc_cluster $arg_key;
+        memc_pass memc_a;
+    }
+
+    location /conv-mysql {
+        internal;
+
+        set $key "conv-uri-$query_string";
+
+        #srcache_fetch GET /memc key=$key;
+        #srcache_store PUT /memc key=$key;
+
+        default_type 'application/json';
+
+        set_quote_sql_str $seo_uri $query_string;
+        drizzle_query "select url from my_url_map where seo_url=$seo_uri";
+        drizzle_pass backend;
+
+        rds_json on;
+    }
+
+    location /conv-uid {
+        internal;
+        access_by_lua_file 'html/foo.lua';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+
+    location /baz {
+        set $my_uri $uri;
+        auth_request /conv-uid;
+
+        echo_exec /jump $my_uri;
+    }
+
+    location /jump {
+        internal;
+        rewrite ^ $query_string? redirect;
+    }
+--- user_files
+>>> foo.lua
+local cjson = require('cjson');
+local seo_uri = ngx.var.my_uri
+-- print('about to run sr')
+local res = ngx.location.capture('/conv-mysql?' .. seo_uri)
+if (res.status ~= ngx.HTTP_OK) then
+    ngx.exit(res.status)
+end
+res = cjson.decode(res.body)
+if (not res or not res[1] or not res[1].url) then
+    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+end
+ngx.var.my_uri = res[1].url;
+-- print('done')
+--- request
+GET /baz
+--- response_body_like: 302
+--- error_code: 302
+--- response_headers
+Location: http://localhost:$ServerPort/foo/bar
+--- SKIP
+
+
+
+=== TEST 10: throw 0
+--- config
+    location /lua {
+        access_by_lua "ngx.say('Hi'); ngx.eof(); ngx.exit(0);ngx.say('world')";
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- error_code: 200
+--- response_body
+Hi
+
+
+
+=== TEST 11: throw ngx.OK does *not* skip other later phase handlers
+--- config
+    location /lua {
+        access_by_lua "ngx.exit(ngx.OK)";
+        set $foo hello;
+        echo $foo;
+    }
+--- request
+GET /lua
+--- response_body
+hello
+
+
+
+=== TEST 12: throw ngx.HTTP_OK *does* skip other later phase handlers (by inlined code)
+--- config
+    location /lua {
+        access_by_lua "ngx.exit(ngx.HTTP_OK)";
+        set $foo hello;
+        echo $foo;
+    }
+--- request
+GET /lua
+--- response_body
+
+
+
+=== TEST 13: throw ngx.HTTP_OK *does* skip other rewrite phase handlers (by inlined code + partial output)
+--- config
+    location /lua {
+        rewrite_by_lua "ngx.say('hiya') ngx.exit(ngx.HTTP_OK)";
+        set $foo hello;
+        echo $foo;
+    }
+--- request
+GET /lua
+--- response_body
+hiya
+
+
+
+=== TEST 14: throw ngx.HTTP_OK *does* skip other later phase handlers (by file)
+--- config
+    location /lua {
+        access_by_lua_file html/foo.lua;
+        set $foo hello;
+        echo $foo;
+    }
+--- user_files
+>>> foo.lua
+ngx.exit(ngx.HTTP_OK)
+--- request
+GET /lua
+--- response_body
+
+
+
+=== TEST 15: throw ngx.HTTP_OK *does* skip other rewrite phase handlers (by file + partial output)
+--- config
+    location /lua {
+        rewrite_by_lua_file html/foo.lua;
+        set $foo hello;
+        echo $foo;
+    }
+--- user_files
+>>> foo.lua
+ngx.say("morning")
+ngx.exit(ngx.HTTP_OK)
+--- request
+GET /lua
+--- response_body
+morning
+
+
+
+=== TEST 16: error page with custom body
+--- config
+    error_page 410 @err;
+    location @err {
+        echo blah blah;
+    }
+    location /foo {
+        access_by_lua '
+            ngx.status = ngx.HTTP_GONE
+            ngx.say("This is our own content")
+            -- to cause quit the whole request rather than the current phase handler
+            ngx.exit(ngx.HTTP_OK)
+        ';
+        echo Hello;
+    }
+--- request
+    GET /foo
+--- response_body
+This is our own content
+--- error_code: 410
+
+
+
+=== TEST 17: exit(404) after I/O
+--- config
+    error_page 400 /400.html;
+    error_page 404 /404.html;
+    location /foo {
+        access_by_lua '
+            ngx.location.capture("/sleep")
+            ngx.exit(ngx.HTTP_NOT_FOUND)
+        ';
+        echo Hello;
+    }
+
+    location /sleep {
+        echo_sleep 0.002;
+    }
+--- user_files
+>>> 400.html
+Bad request, dear...
+>>> 404.html
+Not found, dear...
+--- request
+    GET /bah
+--- response_body
+Not found, dear...
+--- error_code: 404
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/mixed.t b/src/lua/lua-nginx-module/t/024-access/mixed.t
--- a/src/lua/lua-nginx-module/t/024-access/mixed.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/mixed.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,241 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: access I/O with content I/O
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        access_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("access GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("access PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("access cached: " .. res.body);
+
+        ';
+
+        content_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("content GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("content PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("content cached: " .. res.body);
+
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+access GET: 404
+access PUT: 201
+access cached: hello
+content GET: 404
+content PUT: 201
+content cached: hello
+
+
+
+=== TEST 2: share data via nginx variables
+--- config
+    location /foo {
+        set $foo '';
+        access_by_lua '
+            ngx.var.foo = 32
+        ';
+
+        content_by_lua '
+            ngx.say(tonumber(ngx.var.foo) * 2)
+        ';
+    }
+--- request
+    GET /foo
+--- response_body
+64
+
+
+
+=== TEST 3: share the request body (need request body explicitly off)
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        set $res '';
+        access_by_lua '
+            ngx.var.res = ngx.var.request_body or "nil"
+        ';
+        content_by_lua '
+            ngx.say(ngx.var.res or "nil")
+            ngx.say(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body
+nil
+nil
+
+
+
+=== TEST 4: share the request body (need request body off by default)
+--- config
+    location /echo_body {
+        #lua_need_request_body off;
+        set $res '';
+        access_by_lua '
+            ngx.var.res = ngx.var.request_body or "nil"
+        ';
+        content_by_lua '
+            ngx.say(ngx.var.res or "nil")
+            ngx.say(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body
+nil
+nil
+
+
+
+=== TEST 5: share the request body (need request body on)
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        set $res '';
+        access_by_lua '
+            ngx.var.res = ngx.var.request_body or "nil"
+        ';
+        content_by_lua '
+            ngx.say(ngx.var.res or "nil")
+            ngx.say(ngx.var.request_body or "nil")
+        ';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff
+hello\x00\x01\x02
+world\x03\x04\xff
+"
+
+
+
+=== TEST 6: rewrite I/O with access I/O with content I/O
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        rewrite_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("rewrite GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("rewrite PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("rewrite cached: " .. res.body);
+
+        ';
+
+        access_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("access GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("access PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("access cached: " .. res.body);
+
+        ';
+
+        content_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("content GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("content PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("content cached: " .. res.body);
+
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+rewrite GET: 404
+rewrite PUT: 201
+rewrite cached: hello
+access GET: 404
+access PUT: 201
+access cached: hello
+content GET: 404
+content PUT: 201
+content cached: hello
+
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/multi-capture.t b/src/lua/lua-nginx-module/t/024-access/multi-capture.t
--- a/src/lua/lua-nginx-module/t/024-access/multi-capture.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/multi-capture.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,396 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(10);
+
+plan tests => blocks() * repeat_each() * 2;
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /foo {
+        access_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+
+
+
+=== TEST 2: 4 concurrent requests
+--- config
+    location /foo {
+        access_by_lua '
+            local res1, res2, res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+                { "/c" },
+                { "/d" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/([a-d])$' {
+        echo -n $1;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+res3.status = 200
+res3.body = c
+res4.status = 200
+res4.body = d
+
+
+
+=== TEST 3: capture multi in series
+--- config
+    location /foo {
+        access_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("2 res1.status = " .. res1.status)
+            ngx.say("2 res1.body = " .. res1.body)
+            ngx.say("2 res2.status = " .. res2.status)
+            ngx.say("2 res2.body = " .. res2.body)
+
+        ';
+        content_by_lua return;
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+2 res1.status = 200
+2 res1.body = a
+2 res2.status = 200
+2 res2.body = b
+
+
+
+=== TEST 4: capture multi in subrequest
+--- config
+    location /foo {
+        rewrite_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+
+            local n = ngx.var.arg_n
+
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /main {
+        access_by_lua '
+            res = ngx.location.capture("/foo?n=1")
+            ngx.say("top res.status = " .. res.status)
+            ngx.say("top res.body = [" .. res.body .. "]")
+        ';
+        content_by_lua return;
+    }
+
+    location /a {
+        echo -n a;
+    }
+
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /main
+--- response_body
+top res.status = 200
+top res.body = [1 res1.status = 200
+1 res1.body = a
+1 res2.status = 200
+1 res2.body = b
+]
+
+
+
+=== TEST 5: capture multi in parallel
+--- config
+    location ~ '^/(foo|bar)$' {
+        set $tag $1;
+        rewrite_by_lua '
+            local res1, res2
+            if ngx.var.tag == "foo" then
+                res1, res2 = ngx.location.capture_multi{
+                    { "/a" },
+                    { "/b" },
+                }
+            else
+                res1, res2 = ngx.location.capture_multi{
+                    { "/c" },
+                    { "/d" },
+                }
+            end
+
+            local n = ngx.var.arg_n
+
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /main {
+        access_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo?n=1" },
+                { "/bar?n=2" },
+            }
+
+            ngx.say("top res1.status = " .. res1.status)
+            ngx.say("top res1.body = [" .. res1.body .. "]")
+            ngx.say("top res2.status = " .. res2.status)
+            ngx.say("top res2.body = [" .. res2.body .. "]")
+        ';
+        content_by_lua return;
+    }
+
+    location ~ '^/([abcd])$' {
+        echo -n $1;
+    }
+--- request
+    GET /main
+--- response_body
+top res1.status = 200
+top res1.body = [1 res1.status = 200
+1 res1.body = a
+1 res2.status = 200
+1 res2.body = b
+]
+top res2.status = 200
+top res2.body = [2 res1.status = 200
+2 res1.body = c
+2 res2.status = 200
+2 res2.body = d
+]
+
+
+
+=== TEST 6: memc sanity
+--- config
+    location /foo {
+        access_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/[ab]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /foo
+--- response_body eval
+"res1.status = 201
+res1.body = STORED\r
+
+res2.status = 201
+res2.body = STORED\r
+
+"
+
+
+
+=== TEST 7: memc muti + multi
+--- config
+    location /main {
+        access_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo?n=1" },
+                { "/bar?n=2" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = [" .. res1.body .. "]")
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = [" .. res2.body .. "]")
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/(foo|bar)$' {
+        set $tag $1;
+        rewrite_by_lua '
+            local res1, res2
+            if ngx.var.tag == "foo" then
+                res1, res2 = ngx.location.capture_multi{
+                    { "/a" },
+                    { "/b" },
+                }
+            else
+                res1, res2 = ngx.location.capture_multi{
+                    { "/c" },
+                    { "/d" },
+                }
+            end
+            print("args: " .. ngx.var.args)
+            local n = ngx.var.arg_n
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/[abcd]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /main
+--- response_body eval
+"res1.status = 200
+res1.body = [1 res1.status = 201
+1 res1.body = STORED\r
+
+1 res2.status = 201
+1 res2.body = STORED\r
+
+]
+res2.status = 200
+res2.body = [2 res1.status = 201
+2 res1.body = STORED\r
+
+2 res2.status = 201
+2 res2.body = STORED\r
+
+]
+"
+
+
+
+=== TEST 8: memc 4 concurrent requests
+--- config
+    location /foo {
+        access_by_lua '
+            local res1, res2, res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+                { "/c" },
+                { "/d" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+        content_by_lua return;
+    }
+    location ~ '^/[a-d]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /foo
+--- response_body eval
+"res1.status = 201
+res1.body = STORED\r
+
+res2.status = 201
+res2.body = STORED\r
+
+res3.status = 201
+res3.body = STORED\r
+
+res4.status = 201
+res4.body = STORED\r
+
+"
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/on-abort.t b/src/lua/lua-nginx-module/t/024-access/on-abort.t
--- a/src/lua/lua-nginx-module/t/024-access/on-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/on-abort.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,663 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = <<_EOC_;
+$t::StapThread::GCScript
+
+F(ngx_http_lua_check_broken_connection) {
+    println("lua check broken conn")
+}
+
+F(ngx_http_lua_request_cleanup) {
+    println("lua req cleanup")
+}
+_EOC_
+
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 15);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ignore the client abort event in the user callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.7
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 2: abort in the user callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 3: ngx.exit(499) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 4: ngx.exit(408) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(408)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.1
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 5: ngx.exit(-1) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(-1)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 6: ngx.exit(0) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(0)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+            ngx.log(ngx.ERR, "main handler done")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.7;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: fail
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.6
+--- ignore_response
+--- error_log
+client prematurely closed connection
+on abort called
+lua user thread aborted: runtime error: [string "access_by_lua"]:4: attempt to abort with pending subrequests
+main handler done
+
+
+
+=== TEST 7: accessing cosocket in callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+                if not ok then
+                    ngx.log(ngx.ERR, "failed to connect to redis: ", err)
+                    ngx.exit(499)
+                end
+                local bytes, err = sock:send("flushall\\r\\n")
+                if not bytes then
+                    ngx.log(ngx.ERR, "failed to send query: ", err)
+                    ngx.exit(499)
+                end
+
+                local res, err = sock:receive()
+                if not res then
+                    ngx.log(ngx.ERR, "failed to receive: ", err)
+                    ngx.exit(499)
+                end
+                ngx.log(ngx.NOTICE, "callback done: ", res)
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.2
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+callback done: +OK
+
+
+
+=== TEST 8: ignore the client abort event in the user callback (no check)
+--- config
+    location /t {
+        lua_check_client_abort off;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("cannot set on_abort: ", err)
+                return
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- response_body
+cannot set on_abort: lua_check_client_abort is off
+--- no_error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 9: regsiter on_abort callback but no client abortion
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.say("done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+delete thread 2
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- response_body
+done
+--- no_error_log
+[error]
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 10: ignore the client abort event in the user callback (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.7)
+                ngx.log(ngx.NOTICE, "main handler done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+lua check broken conn
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.7
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 11: abort in the user callback (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.7)
+                ngx.log(ngx.NOTICE, "main handler done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 3
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 12: regsiter on_abort callback but no client abortion (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.1)
+                ngx.say("done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+delete thread 2
+terminate 4: ok
+delete thread 4
+lua req cleanup
+
+--- response_body
+done
+--- no_error_log
+[error]
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 13: regsiter on_abort callback multiple times
+--- config
+    location /t {
+        lua_check_client_abort on;
+        access_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("1: cannot set on_abort: " .. err)
+                return
+            end
+
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("2: cannot set on_abort: " .. err)
+                return
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.1)
+                ngx.say("done")
+            end)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+delete thread 2
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- response_body
+2: cannot set on_abort: duplicate call
+
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/redirect.t b/src/lua/lua-nginx-module/t/024-access/redirect.t
--- a/src/lua/lua-nginx-module/t/024-access/redirect.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/redirect.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,126 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => blocks() * repeat_each() * 3;
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: default 302
+--- config
+    location /read {
+        access_by_lua '
+            ngx.redirect("http://www.taobao.com/foo");
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://www.taobao.com/foo
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 2: explicit 302
+--- config
+    location /read {
+        access_by_lua '
+            ngx.redirect("http://www.taobao.com/foo", ngx.HTTP_MOVED_TEMPORARILY);
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://www.taobao.com/foo
+--- response_body_like: 302 Found
+--- error_code: 302
+
+
+
+=== TEST 3: explicit 301
+--- config
+    location /read {
+        access_by_lua '
+            ngx.redirect("http://www.taobao.com/foo", ngx.HTTP_MOVED_PERMANENTLY);
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+Location: http://www.taobao.com/foo
+--- response_body_like: 301 Moved Permanently
+--- error_code: 301
+
+
+
+=== TEST 4: bad rc
+--- config
+    location /read {
+        access_by_lua '
+            ngx.redirect("http://www.taobao.com/foo", 404);
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+!Location
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 5: no args
+--- config
+    location /read {
+        access_by_lua '
+            ngx.redirect()
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- response_headers
+!Location
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 6: relative uri
+--- config
+    location /read {
+        access_by_lua '
+            ngx.redirect("/foo")
+            ngx.say("hi")
+        ';
+        content_by_lua 'return';
+    }
+--- request
+GET /read
+--- raw_response_headers_like: Location: http://localhost(?::\d+)?/foo\r\n
+--- response_body_like: 302 Found
+--- error_code: 302
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/req-body.t b/src/lua/lua-nginx-module/t/024-access/req-body.t
--- a/src/lua/lua-nginx-module/t/024-access/req-body.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/req-body.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,125 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 1);
+
+#no_diff();
+#no_long_string();
+#master_on();
+#workers(2);
+run_tests();
+
+__DATA__
+
+=== TEST 1: read buffered body
+--- config
+    location = /test {
+        access_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+
+
+
+=== TEST 2: read buffered body (timed out)
+--- config
+    client_body_timeout 1ms;
+    location = /test {
+        access_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+        content_by_lua return;
+    }
+--- raw_request eval
+"POST /test HTTP/1.1\r
+Host: localhost\r
+Content-Length: 100\r
+Connection: close\r
+\r
+hello, world"
+--- response_body:
+--- error_code_like: ^(?:500)?$
+
+
+
+=== TEST 3: read buffered body and then subrequest
+--- config
+    location /foo {
+        echo -n foo;
+    }
+    location = /test {
+        access_by_lua '
+            ngx.req.read_body()
+            local res = ngx.location.capture("/foo");
+            ngx.say(ngx.var.request_body)
+            ngx.say("sub: ", res.body)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+sub: foo
+
+
+
+=== TEST 4: first subrequest and then read buffered body
+--- config
+    location /foo {
+        echo -n foo;
+    }
+    location = /test {
+        access_by_lua '
+            local res = ngx.location.capture("/foo");
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+            ngx.say("sub: ", res.body)
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+sub: foo
+
+
+
+=== TEST 5: failed to write 100 continue
+--- config
+    location = /test {
+        access_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+            ngx.exit(200)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- more_headers
+Expect: 100-Continue
+--- ignore_response
+--- no_error_log
+[alert]
+[error]
+http finalize request: 500, "/test?" a:1, c:0
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/request_body.t b/src/lua/lua-nginx-module/t/024-access/request_body.t
--- a/src/lua/lua-nginx-module/t/024-access/request_body.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/request_body.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,174 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('debug'); # to ensure any log-level can be outputed
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: test reading request body
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 2: test not reading request body
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 3: test default setting (not reading request body)
+--- config
+    location /echo_body {
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 4: test main conf
+--- http_config
+    lua_need_request_body on;
+--- config
+    location /echo_body {
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 5: test server conf
+--- config
+    lua_need_request_body on;
+
+    location /echo_body {
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"hello\x00\x01\x02
+world\x03\x04\xff"
+
+
+
+=== TEST 6: test override main conf
+--- http_config
+    lua_need_request_body on;
+--- config
+    location /echo_body {
+        lua_need_request_body off;
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 7: test override server conf
+--- config
+    lua_need_request_body on;
+
+    location /echo_body {
+        lua_need_request_body off;
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request eval
+"POST /echo_body
+hello\x00\x01\x02
+world\x03\x04\xff"
+--- response_body eval
+"nil"
+
+
+
+=== TEST 8: Expect: 100-Continue
+--- config
+    location /echo_body {
+        lua_need_request_body on;
+        access_by_lua '
+            ngx.print(ngx.var.request_body or "nil")
+            ngx.exit(200)
+        ';
+    }
+--- request
+POST /echo_body
+hello world
+--- more_headers
+Expect: 100-Continue
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+http finalize request: 500, "/echo_body?" a:1, c:2
+http finalize request: 500, "/echo_body?" a:1, c:0
+--- log_level: debug
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/sanity.t b/src/lua/lua-nginx-module/t/024-access/sanity.t
--- a/src/lua/lua-nginx-module/t/024-access/sanity.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/sanity.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,700 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#log_level('warn');
+#no_nginx_manager();
+#master_on();
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 8);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: basic print
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        access_by_lua 'ngx.print("Hello, Lua!\\n")';
+        content_by_lua return;
+        #content_by_lua 'ngx.say("Hi")';
+    }
+--- request
+GET /lua
+--- response_body
+Hello, Lua!
+
+
+
+=== TEST 2: basic say
+--- config
+    location /say {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        access_by_lua '
+            ngx.say("Hello, Lua!")
+            ngx.say("Yay! ", 123)';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /say
+--- response_body
+Hello, Lua!
+Yay! 123
+
+
+
+=== TEST 3: no ngx.echo
+--- config
+    location /lua {
+        access_by_lua 'ngx.echo("Hello, Lua!\\n")';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: variable
+--- config
+    location /lua {
+        # NOTE: the newline escape sequence must be double-escaped, as nginx config
+        # parser will unescape first!
+        access_by_lua 'v = ngx.var["request_uri"] ngx.print("request_uri: ", v, "\\n")';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua?a=1&b=2
+--- response_body
+request_uri: /lua?a=1&b=2
+
+
+
+=== TEST 5: variable (file)
+--- config
+    location /lua {
+        access_by_lua_file html/test.lua;
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body
+request_uri: /lua?a=1&b=2
+
+
+
+=== TEST 6: calc expression
+--- config
+    location /lua {
+        access_by_lua_file html/calc.lua;
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- user_files
+>>> calc.lua
+local function uri_unescape(uri)
+    local function convert(hex)
+        return string.char(tonumber("0x"..hex))
+    end
+    local s = string.gsub(uri, "%%([0-9a-fA-F][0-9a-fA-F])", convert)
+    return s
+end
+
+local function eval_exp(str)
+    return loadstring("return "..str)()
+end
+
+local exp_str = ngx.var["arg_exp"]
+-- print("exp: '", exp_str, "'\n")
+local status, res
+status, res = pcall(uri_unescape, exp_str)
+if not status then
+    ngx.print("error: ", res, "\n")
+    return
+end
+status, res = pcall(eval_exp, res)
+if status then
+    ngx.print("result: ", res, "\n")
+else
+    ngx.print("error: ", res, "\n")
+end
+--- request
+GET /lua?exp=1%2B2*math.sin(3)%2Fmath.exp(4)-math.sqrt(2)
+--- response_body
+result: -0.4090441561579
+
+
+
+=== TEST 7: read $arg_xxx
+--- config
+    location = /lua {
+        access_by_lua 'who = ngx.var.arg_who
+            ngx.print("Hello, ", who, "!")';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua?who=agentzh
+--- response_body chomp
+Hello, agentzh!
+
+
+
+=== TEST 8: capture location
+--- config
+    location /other {
+        echo "hello, world";
+    }
+
+    location /lua {
+        access_by_lua '
+res = ngx.location.capture("/other")
+ngx.print("status=", res.status, " ")
+ngx.print("body=", res.body)
+';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+status=200 body=hello, world
+
+
+
+=== TEST 9: capture non-existed location
+--- config
+    location /lua {
+        access_by_lua 'res = ngx.location.capture("/other"); ngx.print("status=", res.status)';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body: status=404
+
+
+
+=== TEST 10: invalid capture location (not as expected...)
+--- config
+    location /lua {
+        access_by_lua 'res = ngx.location.capture("*(#*"); ngx.say("res=", res.status)';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+res=404
+
+
+
+=== TEST 11: nil is "nil"
+--- config
+    location /lua {
+        access_by_lua 'ngx.say(nil)';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body
+nil
+
+
+
+=== TEST 12: write boolean
+--- config
+    location /lua {
+        access_by_lua 'ngx.say(true, " ", false)';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body
+true false
+
+
+
+=== TEST 13: bad argument type to ngx.location.capture
+--- config
+    location /lua {
+        access_by_lua 'ngx.location.capture(nil)';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 14: capture location (default 0);
+--- config
+ location /recur {
+       access_by_lua '
+           local num = tonumber(ngx.var.arg_num) or 0;
+           ngx.print("num is: ", num, "\\n");
+
+           if (num > 0) then
+               res = ngx.location.capture("/recur?num="..tostring(num - 1));
+               ngx.print("status=", res.status, " ");
+               ngx.print("body=", res.body, "\\n");
+           else
+               ngx.print("end\\n");
+           end
+           ';
+
+           content_by_lua 'ngx.exit(ngx.OK)';
+   }
+--- request
+GET /recur
+--- response_body
+num is: 0
+end
+
+
+
+=== TEST 15: capture location
+access phase not running in subrequests
+--- config
+ location /recur {
+       access_by_lua '
+           local num = tonumber(ngx.var.arg_num) or 0;
+           ngx.print("num is: ", num, "\\n");
+
+           if (num > 0) then
+               res = ngx.location.capture("/recur?num="..tostring(num - 1));
+               ngx.print("status=", res.status, " ");
+               ngx.print("body=", res.body);
+           else
+               ngx.print("end\\n");
+           end
+           ';
+
+           content_by_lua 'ngx.exit(ngx.OK)';
+   }
+--- request
+GET /recur?num=3
+--- response_body chomp
+num is: 3
+status=200 body=
+
+
+
+=== TEST 16: setting nginx variables from within Lua
+--- config
+ location /set {
+       set $a "";
+       access_by_lua 'ngx.var.a = 32; ngx.say(ngx.var.a)';
+       content_by_lua 'ngx.exit(ngx.OK)';
+       add_header Foo $a;
+   }
+--- request
+GET /set
+--- response_headers
+Foo: 32
+--- response_body
+32
+
+
+
+=== TEST 17: nginx quote sql string 1
+--- config
+ location /set {
+       set $a 'hello\n\r\'"\\'; # this runs after access_by_lua
+       access_by_lua 'ngx.say(ngx.quote_sql_str(ngx.var.a))';
+       content_by_lua 'ngx.exit(ngx.OK)';
+   }
+--- request
+GET /set
+--- response_body
+'hello\n\r\'\"\\'
+
+
+
+=== TEST 18: nginx quote sql string 2
+--- config
+location /set {
+    #set $a "hello\n\r'\"\\";
+    access_by_lua 'ngx.say(ngx.quote_sql_str("hello\\n\\r\'\\"\\\\"))';
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /set
+--- response_body
+'hello\n\r\'\"\\'
+
+
+
+=== TEST 19: use dollar
+--- config
+location /set {
+    access_by_lua '
+        local s = "hello 112";
+        ngx.say(string.find(s, "%d+$"))';
+
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /set
+--- response_body
+79
+
+
+
+=== TEST 20: subrequests do not share variables of main requests by default
+--- config
+location /sub {
+    echo $a;
+}
+location /parent {
+    set $a 12;
+    access_by_lua 'res = ngx.location.capture("/sub"); ngx.print(res.body)';
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /parent
+--- response_body eval: "\n"
+
+
+
+=== TEST 21: subrequests can share variables of main requests
+--- config
+location /sub {
+    echo $a;
+}
+location /parent {
+    set $a '';
+    access_by_lua '
+        ngx.var.a = 12;
+        res = ngx.location.capture(
+            "/sub",
+            { share_all_vars = true }
+        );
+        ngx.print(res.body)
+    ';
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /parent
+--- response_body
+12
+
+
+
+=== TEST 22: main requests use subrequests' variables
+--- config
+location /sub {
+    set $a 12;
+}
+location /parent {
+    access_by_lua '
+        res = ngx.location.capture("/sub", { share_all_vars = true });
+        ngx.say(ngx.var.a)
+    ';
+
+    content_by_lua 'ngx.exit(ngx.OK)';
+}
+--- request
+GET /parent
+--- response_body
+12
+
+
+
+=== TEST 23: main requests do NOT use subrequests' variables
+--- config
+location /sub {
+    set $a 12;
+    content_by_lua return;
+}
+
+location /parent {
+    access_by_lua '
+        res = ngx.location.capture("/sub", { share_all_vars = false });
+        ngx.say(ngx.var.a)
+    ';
+    content_by_lua return;
+}
+--- request
+GET /parent
+--- response_body_like eval: "\n"
+
+
+
+=== TEST 24: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo "hello, world";
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+        ';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+
+
+
+=== TEST 25: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        rewrite_by_lua '
+            ngx.header.Bar = "Bah";
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+            ngx.say("Bar: ", res.header["Bar"]);
+        ';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+Bar: Bah
+
+
+
+=== TEST 26: capture location headers
+--- config
+    location /other {
+        default_type 'foo/bar';
+        access_by_lua '
+            ngx.header.Bar = "Bah";
+            ngx.header.Bar = nil;
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other");
+            ngx.say("type: ", res.header["Content-Type"]);
+            ngx.say("Bar: ", res.header["Bar"] or "nil");
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+type: foo/bar
+Bar: nil
+
+
+
+=== TEST 27: access_by_lua runs after ngx_access
+--- config
+    location /lua {
+        deny all;
+
+        access_by_lua '
+            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
+        ';
+
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+
+
+
+=== TEST 28: auth_request runs before ngx_access
+--- config
+    location /lua {
+        deny all;
+
+        auth_request /auth;
+
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+--- SKIP
+
+
+
+=== TEST 29: access_by_lua shouldn't send headers automatically (on simple return)
+--- config
+    location /lua {
+        access_by_lua 'return';
+
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location = /foo {
+        default_type 'text/css';
+        add_header Bar Baz;
+        echo foo;
+    }
+--- request
+GET /lua
+--- response_headers
+Bar: Baz
+Content-Type: text/css
+--- response_body
+foo
+
+
+
+=== TEST 30: access_by_lua shouldn't send headers automatically (on simple exit)
+--- config
+    location /lua {
+        access_by_lua 'ngx.exit(ngx.OK)';
+
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location = /foo {
+        default_type 'text/css';
+        add_header Bar Baz;
+        echo foo;
+    }
+--- request
+GET /lua
+--- response_headers
+Bar: Baz
+Content-Type: text/css
+--- response_body
+foo
+
+
+
+=== TEST 31: short circuit
+--- config
+    location /lua {
+        access_by_lua '
+            ngx.say("Hi")
+            ngx.eof()
+            ngx.exit(ngx.HTTP_OK)
+        ';
+
+        content_by_lua '
+            print("HERE")
+            ngx.print("BAD")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Hi
+
+
+
+=== TEST 32: nginx vars in script path
+--- config
+    location ~ ^/lua/(.+)$ {
+        access_by_lua_file html/$1.lua;
+
+        content_by_lua '
+            print("HERE")
+            ngx.print("BAD")
+        ';
+    }
+--- user_files
+>>> hi.lua
+ngx.say("Hi")
+ngx.eof()
+ngx.exit(ngx.HTTP_OK)
+--- request
+GET /lua/hi
+--- response_body
+Hi
+
+
+
+=== TEST 33: phase postponing works for various locations (access phase not running in subrequest)
+--- config
+    location ~ '^/lua/(.+)' {
+        set $path $1;
+        access_by_lua 'ngx.say(ngx.var.path)';
+        content_by_lua return;
+    }
+    location ~ '^/lua2/(.+)' {
+        set $path $1;
+        access_by_lua 'ngx.say(ngx.var.path)';
+        content_by_lua return;
+    }
+    location /main {
+        echo_location /lua/foo;
+        echo_location /lua/bar;
+        echo_location /lua2/baz;
+        echo_location /lua2/bah;
+    }
+--- request
+GET /main
+--- response_body
+
+
+
+=== TEST 34: server access_by_lua
+--- config
+    access_by_lua 'ngx.header["X-Foo"] = "bar" -- ngx.send_headers()';
+--- request
+GET /
+--- response_body chop
+<html><head><title>It works!</title></head><body>It works!</body></html>
+--- response_headers
+X-Foo: bar
+
+
+
+=== TEST 35: server access_by_lua_file
+--- config
+    access_by_lua_file html/foo.lua;
+--- user_files
+>>> foo.lua
+ngx.header["X-Foo"] = "bar" -- ngx.send_headers()
+--- request
+GET /
+--- response_body chop
+<html><head><title>It works!</title></head><body>It works!</body></html>
+--- response_headers
+X-Foo: bar
+
+
+
+=== TEST 36: Lua file does not exist
+--- config
+    location /lua {
+        access_by_lua_file html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/satisfy.t b/src/lua/lua-nginx-module/t/024-access/satisfy.t
--- a/src/lua/lua-nginx-module/t/024-access/satisfy.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/satisfy.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,213 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+worker_connections(1014);
+#master_on();
+#workers(4);
+#log_level('warn');
+no_root_location();
+
+#repeat_each(2);
+#repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: satisfy any
+--- config
+    location /test {
+        satisfy any;
+        allow all;
+        access_by_lua 'ngx.exit(403)';
+
+        echo something important;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body
+something important
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: satisfy any
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.exit(403)';
+
+        echo something important;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+--- error_log
+access forbidden by rule
+
+
+
+=== TEST 3: satisfy any (explicit ngx.exit(0))
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.exit(0)';
+
+        echo something important;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body
+something important
+--- error_code: 200
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: satisfy any (simple return)
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua return;
+
+        echo something important;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body
+something important
+--- error_code: 200
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: satisfy any (declined)
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.exit(ngx.DECLINED)';
+
+        echo something important;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+--- error_log
+access forbidden by rule
+
+
+
+=== TEST 6: satisfy any (declined, with I/O)
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.location.capture("/echo") ngx.exit(ngx.DECLINED)';
+
+        echo something important;
+    }
+
+    location /echo {
+        echo hi;
+        #echo_sleep 0.01;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+--- error_log
+access forbidden by rule
+
+
+
+=== TEST 7: satisfy any (simple return, with I/O)
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.location.capture("/echo") return';
+
+        echo something important;
+    }
+
+    location /echo {
+        echo hi;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body
+something important
+--- error_code: 200
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: satisfy any - with I/O
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.location.capture("/echo") ngx.exit(403)';
+
+        echo something important;
+    }
+
+    location /echo {
+        echo hi;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+--- error_log
+access forbidden by rule
+
+
+
+=== TEST 9: satisfy any (explicit ngx.exit(0), with I/O)
+--- config
+    location /test {
+        satisfy any;
+        deny all;
+        access_by_lua 'ngx.location.capture("/echo") ngx.exit(0)';
+
+        echo something important;
+    }
+
+    location /echo {
+        echo hi;
+    }
+--- request
+    GET /test
+--- more_headers
+--- response_body
+something important
+--- error_code: 200
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/sleep.t b/src/lua/lua-nginx-module/t/024-access/sleep.t
--- a/src/lua/lua-nginx-module/t/024-access/sleep.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/sleep.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,223 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * 33;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sleep 0.5
+--- config
+    location /test {
+        access_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep(0.5)
+            local now = ngx.now()
+            ngx.say(now - before)
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:4[5-9]\d*|5[0-5]\d*|5)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+
+
+
+=== TEST 2: sleep ag
+--- config
+    location /test {
+        access_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep("a")
+            local now = ngx.now()
+            ngx.say(now - before)
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /test
+--- error_code: 500
+--- response_body_like: 500 Internal Server Error
+--- error_log
+bad argument #1 to 'sleep'
+
+
+
+=== TEST 3: sleep 0.5 in subrequest
+--- config
+    location /test {
+        access_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.location.capture("/sleep")
+            local now = ngx.now()
+            local delay = now - before
+            ngx.say(delay)
+            ngx.exit(200)
+        ';
+    }
+    location /sleep {
+        content_by_lua 'ngx.sleep(0.5)';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:4[5-9]\d*|5[0-9]\d*|5)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/sleep?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: sleep a in subrequest with bad argument
+--- config
+    location /test {
+        access_by_lua '
+            local res = ngx.location.capture("/sleep");
+            ngx.say(res.status)
+            ngx.exit(200)
+        ';
+    }
+    location /sleep {
+        content_by_lua 'ngx.sleep("a")';
+    }
+--- request
+GET /test
+--- response_body
+500
+--- error_log
+bad argument #1 to 'sleep'
+
+
+
+=== TEST 5: sleep 0.5 - multi-times
+--- config
+    location /test {
+        access_by_lua '
+            ngx.update_time()
+            local start = ngx.now()
+            ngx.sleep(0.3)
+            ngx.sleep(0.3)
+            ngx.sleep(0.3)
+            ngx.say(ngx.now() - start)
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:8[5-9]\d*|9[0-9]\d*|9)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: sleep 0.5 - interleaved by ngx.say() - ended by ngx.sleep
+--- config
+    location /test {
+        access_by_lua '
+            ngx.send_headers()
+            -- ngx.location.capture("/sleep")
+            ngx.sleep(1)
+            ngx.say("blah")
+            ngx.sleep(1)
+            -- ngx.location.capture("/sleep")
+            ngx.exit(200)
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.1;
+    }
+--- request
+GET /test
+--- response_body
+blah
+--- error_log
+lua ready to sleep
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: sleep 0.5 - interleaved by ngx.say() - not ended by ngx.sleep
+--- config
+    location /test {
+        access_by_lua '
+            ngx.send_headers()
+            -- ngx.location.capture("/sleep")
+            ngx.sleep(0.3)
+            ngx.say("blah")
+            ngx.sleep(0.5)
+            -- ngx.location.capture("/sleep")
+            ngx.say("hiya")
+            ngx.exit(200)
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.1;
+    }
+--- request
+GET /test
+--- response_body
+blah
+hiya
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: ngx.location.capture before and after ngx.sleep
+--- config
+    location /test {
+        access_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+
+            ngx.sleep(0.1)
+
+            res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+            ngx.exit(200)
+        ';
+    }
+    location = /hello {
+        echo hello world;
+    }
+    location = /sub {
+        proxy_pass http://127.0.0.1:$server_port/hello;
+    }
+--- request
+GET /test
+--- response_body
+hello world
+hello world
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/subrequest.t b/src/lua/lua-nginx-module/t/024-access/subrequest.t
--- a/src/lua/lua-nginx-module/t/024-access/subrequest.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/subrequest.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,604 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: DELETE
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+DELETE
+
+
+
+=== TEST 2: DELETE (proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_DELETE });
+
+            ngx.print(res.body)
+        ';
+
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+DELETE
+
+
+
+=== TEST 3: POST (nobody, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+POST
+
+
+
+=== TEST 4: HEAD
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_HEAD });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+HEAD
+
+
+
+=== TEST 5: explicit GET
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_GET });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+
+
+
+=== TEST 6: implicit GET
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo")
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+
+
+
+=== TEST 7: implicit GET (empty option table)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo $echo_request_method;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo", {})
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET
+
+
+
+=== TEST 8: PUT (nobody, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body chomp
+PUT
+hello
+
+
+
+=== TEST 9: PUT (nobody, no proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        #echo_read_request_body;
+
+        echo $echo_request_method;
+        #echo $echo_request_body;
+        echo_request_body;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body chomp
+PUT
+hello
+
+
+
+=== TEST 10: PUT (nobody, no proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        #echo_read_request_body;
+
+        echo $echo_request_method;
+        #echo $echo_request_body;
+        echo_request_body;
+        #echo "[$http_content_length]";
+        echo;
+    }
+
+    location /foo {
+        echo $echo_request_method;
+        echo -n "[$http_content_length]";
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/other",
+                { method = ngx.HTTP_PUT, body = "hello" });
+
+            ngx.print(res.body)
+
+            res = ngx.location.capture("/foo")
+            ngx.say(res.body)
+
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+PUT
+hello
+GET
+[]
+
+
+
+=== TEST 11: POST (with body, proxy method)
+--- config
+    location /other {
+        default_type 'foo/bar';
+        echo_read_request_body;
+
+        echo $echo_request_method;
+        echo_request_body;
+    }
+
+    location /foo {
+        proxy_pass http://127.0.0.1:$server_port/other;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { method = ngx.HTTP_POST, body = "hello" });
+
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body chomp
+POST
+hello
+
+
+
+=== TEST 12: POST (with body, memc method)
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        access_by_lua '
+            ngx.location.capture("/flush");
+
+            res = ngx.location.capture("/memc");
+            ngx.say("GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello" });
+            ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc");
+            ngx.say("cached: " .. res.body);
+
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET: 404
+PUT: 201
+cached: hello
+
+
+
+=== TEST 13: POST (with body, memc method)
+--- config
+    location /flush {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /memc {
+        set $memc_cmd "";
+        set $memc_key $echo_request_uri;
+        set $memc_exptime 600;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location /lua {
+        access_by_lua '
+            ngx.location.capture("/flush",
+                { share_all_vars = true });
+
+            res = ngx.location.capture("/memc",
+                { share_all_vars = true });
+            ngx.say("GET: " .. res.status);
+
+            res = ngx.location.capture("/memc",
+                { method = ngx.HTTP_PUT, body = "hello", share_all_vars = true });
+            ngx.say("PUT: " .. res.status);
+
+            res = ngx.location.capture("/memc", { share_all_vars = true });
+            ngx.say("cached: " .. res.body);
+
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+GET: 404
+PUT: 201
+cached: hello
+
+
+
+=== TEST 14: emtpy args option table
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = {} })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body eval: "\n"
+
+
+
+=== TEST 15: non-empty args option table (1 pair)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { ["fo="] = "=>" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+fo%3d=%3d%3e
+
+
+
+=== TEST 16: non-empty args option table (2 pairs)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { ["fo="] = "=>",
+                    ["="] = ":" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like chop
+^(?:fo%3d=%3d%3e\&%3d=%3a|%3d=%3a\&fo%3d=%3d%3e)$
+
+
+
+=== TEST 17: non-empty args option table (2 pairs, no special chars)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { foo = 3,
+                    bar = "hello" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like chop
+^(?:bar=hello\&foo=3|foo=3\&bar=hello)$
+
+
+
+=== TEST 18: non-empty args option table (number key)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { [57] = "hi" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 19: non-empty args option table (plain arrays)
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo",
+                { args = { "hi" } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 20: more args
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo?a=3",
+                { args = { b = 4 } })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+a=3&b=4
+
+
+
+=== TEST 21: more args
+--- config
+    location /foo {
+        echo $query_string;
+    }
+
+    location /lua {
+        access_by_lua '
+            res = ngx.location.capture("/foo?a=3",
+                { args = "b=4" })
+            ngx.print(res.body)
+        ';
+        content_by_lua 'ngx.exit(ngx.OK)';
+    }
+--- request
+GET /lua
+--- response_body
+a=3&b=4
+
+
+
+=== TEST 22: I/O in named location
+the nginx core requires the patch https://github.com/agentzh/ngx_openresty/blob/master/patches/nginx-1.0.15-reset_wev_handler_in_named_locations.patch
+--- config
+    location /t {
+        echo_exec @named;
+    }
+
+    location @named {
+        access_by_lua '
+            ngx.location.capture("/hello")
+        ';
+        echo done;
+    }
+
+    location /hello {
+        echo hello;
+    }
+--- request
+    GET /t
+--- response_body
+done
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/uthread-exec.t b/src/lua/lua-nginx-module/t/024-access/uthread-exec.t
--- a/src/lua/lua-nginx-module/t/024-access/uthread-exec.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/uthread-exec.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,353 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: exec in user thread (entry still pending)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("hello")
+        ';
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: exec in user thread (entry already quits)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+        ';
+        content_by_lua return;
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: exec in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+        ';
+        content_by_lua return;
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: exec in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            function g()
+                ngx.sleep(1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+        content_by_lua return;
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: exec in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+
+    location = /foo {
+        echo hello world;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/uthread-exit.t b/src/lua/lua-nginx-module/t/024-access/uthread-exit.t
--- a/src/lua/lua-nginx-module/t/024-access/uthread-exit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/uthread-exit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1365 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: exit in user thread (entry thread is still pending to run)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+M(timer-add) {
+    if ($arg2 == 1000) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+hello in thread
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: exit in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: exit in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f")
+                ngx.exit(0)
+            end
+
+            function g()
+                ngx.sleep(1)
+                ngx.say("g")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+terminate 4: ok
+delete thread 4
+free request
+
+--- response_body
+end
+f
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: exit in user thread (entry already quits)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("exiting the user thread")
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- wait: 0.1
+--- response_body
+before
+after
+exiting the user thread
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: exit in user thread (entry thread is still pending on the DNS resolver for ngx.socket.tcp)
+--- config
+    location /lua {
+        resolver agentzh.org;
+        resolver_timeout 12s;
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.001)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 80)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+F(ngx_resolve_name) {
+    printf("resolving %s\n", user_string_n($ctx->name->data, $ctx->name->len))
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 1) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_resolve_cleanup) {
+    println("lua tcp resolve cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 1
+resolving agentzh.org
+add timer 12000
+expire timer 1
+terminate 2: ok
+lua tcp resolve cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: exit in user thread (entry thread is still pending on the DNS resolver for ngx.socket.udp)
+--- config
+    location /lua {
+        resolver agentzh.org;
+        resolver_timeout 12s;
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.001)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("agentzh.org", 80)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+F(ngx_resolve_name) {
+    printf("resolving %s\n", user_string_n($ctx->name->data, $ctx->name->len))
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 1) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_udp_resolve_cleanup) {
+    println("lua udp resolve cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 1
+resolving agentzh.org
+add timer 12000
+expire timer 1
+terminate 2: ok
+lua udp resolve cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: exit in user thread (entry thread is still pending on tcpsock:connect)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+            sock:settimeout(12000)
+            local ok, err = sock:connect("106.187.41.147", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: exit in user thread (entry thread is still pending on tcpsock:receive)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, ok = sock:send("blpop not_exists 2\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: exit in user thread (entry thread is still pending on tcpsock:receiveuntil's iterator)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, ok = sock:send("blpop not_exists 2\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local it, err = sock:receiveuntil("\\r\\n")
+            if not it then
+                ngx.say("failed to receive until: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = it()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: exit in user thread (entry thread is still pending on udpsock:receive)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.udp()
+
+            local ok, err = sock:setpeername("8.8.8.8", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_udp_socket_cleanup) {
+    println("lua udp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua udp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: exit in user thread (entry thread is still pending on reqsock:receive)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.req.socket()
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive(1024)
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+
+--- more_headers
+Content-Length: 1024
+
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: exit in user thread (entry thread is still pending on ngx.req.read_body)
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.req.read_body()
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_req_body_cleanup) {
+    println("lua req body cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua req body cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: exit in user thread (entry thread is still pending on ngx.location.capture), with pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 14: exit in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 15: exit in user thread (entry thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture_multi{
+                {"/echo"},
+                {"/sleep"}
+            }
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/uthread-redirect.t b/src/lua/lua-nginx-module/t/024-access/uthread-redirect.t
--- a/src/lua/lua-nginx-module/t/024-access/uthread-redirect.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/uthread-redirect.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,195 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ngx.redirect() in user thread (entry thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.redirect(301)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture_multi{
+                {"/echo"},
+                {"/sleep"}
+            }
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 2: redirect in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.redirect(301)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body_like: 302 Found
+--- error_code: 302
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/024-access/uthread-spawn.t b/src/lua/lua-nginx-module/t/024-access/uthread-spawn.t
--- a/src/lua/lua-nginx-module/t/024-access/uthread-spawn.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/024-access/uthread-spawn.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1190 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 1);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple user thread without I/O
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval
+<<'_EOC_' . $::StapScript;
+
+F(ngx_http_lua_send_chain_link) {
+    printf("send link %p\n", $in)
+}
+
+F(ngx_http_core_content_phase) {
+    println("core content phase")
+}
+
+_EOC_
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: two simple user threads without I/O
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("in thread 1")
+            end
+
+            function g()
+                ngx.say("in thread 2")
+            end
+
+            ngx.say("before 1")
+            ngx.thread.spawn(f)
+            ngx.say("after 1")
+
+            ngx.say("before 2")
+            ngx.thread.spawn(g)
+            ngx.say("after 2")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+terminate 1: ok
+delete thread 2
+delete thread 3
+delete thread 1
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before 1
+in thread 1
+after 1
+before 2
+in thread 2
+after 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: simple user thread with sleep
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before sleep")
+                ngx.sleep(0.1)
+                ngx.say("after sleep")
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before sleep
+after thread create
+after sleep
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: two simple user threads with sleep
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("1: before sleep")
+                ngx.sleep(0.2)
+                ngx.say("1: after sleep")
+            end
+
+            function g()
+                ngx.say("2: before sleep")
+                ngx.sleep(0.1)
+                ngx.say("2: after sleep")
+            end
+
+            ngx.say("1: before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("1: after thread create")
+
+            ngx.say("2: before thread create")
+            ngx.thread.spawn(g)
+            ngx.say("2: after thread create")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2
+terminate 4: ok
+delete thread 4
+
+--- wait: 0.1
+--- response_body
+1: before thread create
+1: before sleep
+1: after thread create
+2: before thread create
+2: before sleep
+2: after thread create
+2: after sleep
+1: after sleep
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: error in user thread
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.blah()
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: fail
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+after
+--- error_log
+lua user thread aborted: runtime error: [string "access_by_lua"]:3: attempt to call field 'blah' (a nil value)
+
+
+
+=== TEST 6: simple user threads doing a single subrequest (entry quits early)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before capture")
+                res = ngx.location.capture("/proxy")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello world;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before capture
+after thread create
+after capture: hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: simple user threads doing a single subrequest (entry also does a subrequest and quits early)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo -n hello bar;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before capture
+after thread create
+capture: hello bar
+after capture: hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: simple user threads doing a single subrequest (entry also does a subrequest and quits late)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo_sleep 0.2;
+        echo -n hello bar;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread create
+before capture
+after thread create
+after capture: hello foo
+capture: hello bar
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: two simple user threads doing single subrequests (entry also does a subrequest and quits between)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("f: before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("f: after capture: ", res.body)
+            end
+
+            function g()
+                ngx.say("g: before capture")
+                local res = ngx.location.capture("/proxy?bah")
+                ngx.say("g: after capture: ", res.body)
+            end
+
+            ngx.say("before thread 1 create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread 1 create")
+
+            ngx.say("before thread 2 create")
+            ngx.thread.spawn(g)
+            ngx.say("after thread 2 create")
+
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+        content_by_lua return;
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo_sleep 0.2;
+        echo -n hello bar;
+    }
+
+    location /bah {
+        echo_sleep 0.3;
+        echo -n hello bah;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before thread 1 create
+f: before capture
+after thread 1 create
+before thread 2 create
+g: before capture
+after thread 2 create
+f: after capture: hello foo
+capture: hello bar
+g: after capture: hello bah
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: nested user threads
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            ngx.thread.spawn(f)
+            ngx.say("after f")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 3
+delete thread 2
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before f
+before g
+hello in g()
+after f
+after g
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: nested user threads (with I/O)
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.sleep(0.1)
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            ngx.thread.spawn(f)
+            ngx.say("after f")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before f
+before g
+after f
+after g
+hello in g()
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: coroutine status of a running user thread
+--- config
+    location /lua {
+        access_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+                ngx.sleep(0.1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+status: running
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: coroutine status of a dead user thread
+--- config
+    location /lua {
+        access_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+status: zombie
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: coroutine status of a "normal" user thread
+--- config
+    location /lua {
+        access_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+                local co2 = coroutine.create(g)
+                coroutine.resume(co2)
+            end
+
+            function g()
+                ngx.sleep(0.1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+terminate 2: ok
+delete thread 2
+terminate 4: ok
+delete thread 4
+
+--- response_body
+status: normal
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: creating user threads in a user coroutine
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            local co = coroutine.create(f)
+            coroutine.resume(co)
+            ngx.say("after f")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+terminate 2: ok
+delete thread 3
+terminate 1: ok
+delete thread 1
+terminate 4: ok
+delete thread 4
+
+--- response_body
+before f
+before g
+hello in g()
+after g
+after f
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: manual time slicing between a user thread and the entry thread
+--- config
+    location /lua {
+        access_by_lua '
+            local yield = coroutine.yield
+
+            function f()
+                local self = coroutine.running()
+                ngx.say("f 1")
+                yield(self)
+                ngx.say("f 2")
+                yield(self)
+                ngx.say("f 3")
+            end
+
+            local self = coroutine.running()
+            ngx.say("0")
+            yield(self)
+            ngx.say("1")
+            ngx.thread.spawn(f)
+            ngx.say("2")
+            yield(self)
+            ngx.say("3")
+            yield(self)
+            ngx.say("4")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+0
+1
+f 1
+2
+f 2
+3
+f 3
+4
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: manual time slicing between two user threads
+--- config
+    location /lua {
+        access_by_lua '
+            local yield = coroutine.yield
+
+            function f()
+                local self = coroutine.running()
+                ngx.say("f 1")
+                yield(self)
+                ngx.say("f 2")
+                yield(self)
+                ngx.say("f 3")
+            end
+
+            function g()
+                local self = coroutine.running()
+                ngx.say("g 1")
+                yield(self)
+                ngx.say("g 2")
+                yield(self)
+                ngx.say("g 3")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+            ngx.say("done")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+f 1
+g 1
+f 2
+done
+g 2
+f 3
+g 3
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: entry thread and a user thread flushing at the same time
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                coroutine.yield(coroutine.running)
+                ngx.flush(true)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.flush(true)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: two user threads flushing at the same time
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.say("hello from f")
+                ngx.flush(true)
+            end
+
+            function g()
+                ngx.say("hello from g")
+                ngx.flush(true)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3|create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+terminate 1: ok
+delete thread 2
+delete thread 3
+delete thread 1)
+terminate 4: ok
+delete thread 4$
+
+--- response_body
+hello from f
+hello from g
+--- no_error_log
+[error]
+
+
+
+=== TEST 20: user threads + ngx.socket.tcp
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+                if not ok then
+                    ngx.say("failed to connect: ", err)
+                    return
+                end
+                local bytes, err = sock:send("flush_all\\r\\n")
+                if not bytes then
+                    ngx.say("failed to send query: ", err)
+                    return
+                end
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+
+                ngx.say("received: ", line)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before
+after
+received: OK
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: user threads + ngx.socket.udp
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                local sock = ngx.socket.udp()
+                local ok, err = sock:setpeername("127.0.0.1", 12345)
+                local bytes, err = sock:send("blah")
+                if not bytes then
+                    ngx.say("failed to send query: ", err)
+                    return
+                end
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+
+                ngx.say("received: ", line)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+|create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3)$
+
+--- udp_listen: 12345
+--- udp_query: blah
+--- udp_reply: hello udp
+--- response_body_like chop
+^(?:before
+after
+received: hello udp
+|before
+received: hello udp
+after)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 22: simple user thread with ngx.req.read_body()
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                ngx.req.read_body()
+                local body = ngx.req.get_body_data()
+                ngx.say("body: ", body)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+hello world
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1|create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2)
+terminate 3: ok
+delete thread 3$
+
+--- response_body_like chop
+^(?:before
+body: hello world
+after|before
+after
+body: hello world)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: simple user thread with ngx.req.socket()
+--- config
+    location /lua {
+        access_by_lua '
+            function f()
+                local sock = ngx.req.socket()
+                local body, err = sock:receive(11)
+                if not body then
+                    ngx.say("failed to read body: ", err)
+                    return
+                end
+
+                ngx.say("body: ", body)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+        content_by_lua return;
+    }
+--- request
+POST /lua
+hello world
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1|create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2)
+terminate 3: ok
+delete thread 3$
+
+--- response_body_like chop
+^(?:before
+body: hello world
+after|before
+after
+body: hello world)$
+
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/025-codecache.t b/src/lua/lua-nginx-module/t/025-codecache.t
--- a/src/lua/lua-nginx-module/t/025-codecache.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/025-codecache.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,662 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 1);
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+
+no_long_string();
+
+our $HtmlDir = html_dir;
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: code cache on by default
+--- config
+    location /lua {
+        content_by_lua_file html/test.lua;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("ngx.say(101)")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+ngx.say(32)
+--- request
+GET /main
+--- response_body
+32
+updated
+32
+--- no_error_log
+[alert]
+
+
+
+=== TEST 2: code cache explicitly on
+--- config
+    location /lua {
+        lua_code_cache on;
+        content_by_lua_file html/test.lua;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("ngx.say(101)")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+ngx.say(32)
+--- request
+GET /main
+--- response_body
+32
+updated
+32
+--- no_error_log
+[alert]
+
+
+
+=== TEST 3: code cache explicitly off
+--- config
+    location /lua {
+        lua_code_cache off;
+        content_by_lua_file html/test.lua;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("ngx.say(101)")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+ngx.say(32)
+--- request
+GET /main
+--- response_body
+32
+updated
+101
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 4: code cache explicitly off (server level)
+--- config
+    lua_code_cache off;
+
+    location /lua {
+        content_by_lua_file html/test.lua;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("ngx.say(101)")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+ngx.say(32)
+--- request
+GET /main
+--- response_body
+32
+updated
+101
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 5: code cache explicitly off (server level) but be overridden in the location
+--- config
+    lua_code_cache off;
+
+    location /lua {
+        lua_code_cache on;
+        content_by_lua_file html/test.lua;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("ngx.say(101)")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+ngx.say(32)
+--- request
+GET /main
+--- response_body
+32
+updated
+32
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+=== TEST 6: code cache explicitly off (affects require) + content_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /lua {
+        lua_code_cache off;
+        content_by_lua '
+            local foo = require "foo";
+        ';
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/foo.lua", "w"))
+            f:write("module(..., package.seeall); ngx.say(102);")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> foo.lua
+module(..., package.seeall); ngx.say(32);
+--- request
+GET /main
+--- response_body
+32
+updated
+102
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+=== TEST 7: code cache explicitly off (affects require) + content_by_lua_file
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /lua {
+        lua_code_cache off;
+        content_by_lua_file html/test.lua;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/foo.lua", "w"))
+            f:write("module(..., package.seeall); ngx.say(102);")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+local foo = require "foo";
+>>> foo.lua
+module(..., package.seeall); ngx.say(32);
+--- request
+GET /main
+--- response_body
+32
+updated
+102
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+=== TEST 8: code cache explicitly off (affects require) + set_by_lua_file
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /lua {
+        lua_code_cache off;
+        set_by_lua_file $a html/test.lua;
+        echo $a;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/foo.lua", "w"))
+            f:write("module(..., package.seeall); return 102;")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+return require "foo"
+>>> foo.lua
+module(..., package.seeall); return 32;
+--- request
+GET /main
+--- response_body
+32
+updated
+102
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+=== TEST 9: code cache explicitly on (affects require) + set_by_lua_file
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /lua {
+        lua_code_cache on;
+        set_by_lua_file $a html/test.lua;
+        echo $a;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/foo.lua", "w"))
+            f:write("module(..., package.seeall); return 102;")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+return require "foo"
+>>> foo.lua
+module(..., package.seeall); return 32;
+--- request
+GET /main
+--- response_body
+32
+updated
+32
+--- no_error_log
+[alert]
+
+
+
+=== TEST 10: code cache explicitly off + set_by_lua_file
+--- config
+    location /lua {
+        lua_code_cache off;
+        set_by_lua_file $a html/test.lua;
+        echo $a;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("return 101")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+return 32
+--- request
+GET /main
+--- response_body
+32
+updated
+101
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+=== TEST 11: code cache explicitly on + set_by_lua_file
+--- config
+    location /lua {
+        lua_code_cache on;
+        set_by_lua_file $a html/test.lua;
+        echo $a;
+    }
+    location /update {
+        content_by_lua '
+            -- os.execute("(echo HERE; pwd) > /dev/stderr")
+            local f = assert(io.open("t/servroot/html/test.lua", "w"))
+            f:write("return 101")
+            f:close()
+            ngx.say("updated")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /update;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+return 32
+--- request
+GET /main
+--- response_body
+32
+updated
+32
+--- no_error_log
+[alert]
+
+
+
+=== TEST 12: no clear builtin lib "string"
+--- config
+    location /lua {
+        lua_code_cache off;
+        content_by_lua_file html/test.lua;
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /lua;
+    }
+--- user_files
+>>> test.lua
+ngx.say(string.len("hello"))
+ngx.say(table.concat({1,2,3}, ", "))
+--- request
+    GET /main
+--- response_body
+5
+1, 2, 3
+5
+1, 2, 3
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 13: no clear builtin lib "string"
+--- config
+    location /lua {
+        lua_code_cache off;
+        content_by_lua '
+            ngx.say(string.len("hello"))
+            ngx.say(table.concat({1,2,3}, ", "))
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /lua;
+    }
+--- request
+    GET /main
+--- response_body
+5
+1, 2, 3
+5
+1, 2, 3
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 14: no clear builtin lib "string"
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    lua_code_cache off;
+    location /lua {
+        content_by_lua '
+            local test = require("test")
+        ';
+    }
+    location /main {
+        echo_location /lua;
+        echo_location /lua;
+    }
+--- request
+    GET /main
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+string = require("string")
+math = require("math")
+io = require("io")
+os = require("os")
+table = require("table")
+coroutine = require("coroutine")
+package = require("package")
+ngx.say("OK")
+--- response_body
+OK
+OK
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 15: skip luarocks
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';
+     lua_code_cache off;"
+--- config
+    location /main {
+        echo_location /load;
+        echo_location /check;
+        echo_location /check;
+    }
+
+    location /load {
+        content_by_lua '
+            package.loaded.luarocks = nil;
+            local foo = require "luarocks";
+            foo.hi()
+        ';
+    }
+
+    location /check {
+        content_by_lua '
+            local foo = package.loaded.luarocks
+            if foo then
+                ngx.say("found")
+            else
+                ngx.say("not found")
+            end
+        ';
+    }
+--- request
+GET /main
+--- user_files
+>>> luarocks.lua
+module(..., package.seeall);
+
+ngx.say("loading");
+
+function hi ()
+    ngx.say("hello, foo")
+end;
+--- response_body
+loading
+hello, foo
+found
+found
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 16: skip luarocks*
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';
+     lua_code_cache off;"
+--- config
+    location /main {
+        echo_location /load;
+        echo_location /check;
+        echo_location /check;
+    }
+
+    location /load {
+        content_by_lua '
+            package.loaded.luarocks2 = nil;
+            local foo = require "luarocks2";
+            foo.hi()
+        ';
+    }
+
+    location /check {
+        content_by_lua '
+            local foo = package.loaded.luarocks2
+            if foo then
+                ngx.say("found")
+            else
+                ngx.say("not found")
+            end
+        ';
+    }
+--- request
+GET /main
+--- user_files
+>>> luarocks2.lua
+module(..., package.seeall);
+
+ngx.say("loading");
+
+function hi ()
+    ngx.say("hello, foo")
+end;
+--- response_body
+loading
+hello, foo
+found
+found
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 17: clear _G table
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    lua_code_cache off;
+    location /t {
+        content_by_lua '
+            if not _G.foo then
+                _G.foo = 1
+            else
+                _G.foo = _G.foo + 1
+            end
+            ngx.say("_G.foo: ", _G.foo)
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+_G.foo: 1
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
+
+
+=== TEST 18: github #257: globals cleared when code cache off
+--- http_config
+    lua_code_cache off;
+    init_by_lua '
+      test = setfenv(
+        function()
+          ngx.say(tostring(table))
+        end,
+        setmetatable({},
+        {
+          __index = function(self, key)
+          return rawget(self, key) or _G[key]
+        end
+      }))';
+--- config
+    location = /t {
+        content_by_lua 'test()';
+    }
+--- request
+GET /t
+--- response_body_like chop
+^table: 0x\d*?[1-9a-fA-F]
+--- no_error_log
+[error]
+--- error_log eval
+qr/\[alert\] \S+ lua_code_cache is off; this will hurt performance/
+
+
diff -rNu a/src/lua/lua-nginx-module/t/026-mysql.t b/src/lua/lua-nginx-module/t/026-mysql.t
--- a/src/lua/lua-nginx-module/t/026-mysql.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/026-mysql.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,132 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => blocks() * repeat_each() * 3;
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: when mysql query timed out, kill that query by Lua
+--- http_config
+    upstream backend {
+        drizzle_server 127.0.0.1:$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+--- config
+    location = /mysql {
+        #internal;
+        drizzle_send_query_timeout 100ms;
+        #drizzle_send_query_timeout 1s;
+        drizzle_query $echo_request_body;
+        drizzle_pass backend;
+
+        #error_page 504 /ret/504;
+        rds_json on;
+        more_set_headers -s 504 "X-Mysql-Tid: $drizzle_thread_id";
+    }
+
+    location /lua {
+        content_by_lua '
+            local sql = "select sleep(5)"
+            local res = ngx.location.capture("/mysql",
+                { method = ngx.HTTP_POST, body = sql })
+
+            ngx.say("status = " .. res.status)
+
+            local tid = res.header["X-Mysql-Tid"]
+            if tid == nil then
+                ngx.say("thread id = nil")
+                return
+            end
+
+            tid = tonumber(tid)
+            ngx.say("thread id = " .. tid)
+
+            res = ngx.location.capture("/mysql",
+                { method = ngx.HTTP_POST,
+                  body = "kill query " .. tid })
+
+            ngx.say("kill status = " .. res.status)
+            ngx.say("kill body = " .. res.body)
+        ';
+    }
+--- request
+    GET /lua
+--- response_body_like
+^status = 504
+thread id = \d+
+kill status = 200
+kill body = {"errcode":0}$
+--- error_log eval
+qr{upstream timed out \(\d+: Connection timed out\) while sending query to drizzle upstream}
+
+
+
+=== TEST 2: no error pages
+--- http_config
+    upstream backend {
+        drizzle_server 127.0.0.1:$TEST_NGINX_MYSQL_PORT protocol=mysql
+                       dbname=ngx_test user=ngx_test password=ngx_test;
+        drizzle_keepalive max=300 mode=single overflow=ignore;
+    }
+--- config
+    location @err { echo Hi; }
+    error_page 504 = @err;
+    location = /mysql {
+        #internal;
+        drizzle_send_query_timeout 100ms;
+        #drizzle_send_query_timeout 1s;
+        drizzle_query $echo_request_body;
+        drizzle_pass backend;
+
+        no_error_pages;
+
+        rds_json on;
+        more_set_headers -s 504 "X-Mysql-Tid: $drizzle_thread_id";
+    }
+
+    location /lua {
+        content_by_lua '
+            local sql = "select sleep(3)"
+            local res = ngx.location.capture("/mysql",
+                { method = ngx.HTTP_POST, body = sql })
+
+            ngx.say("status = " .. res.status)
+
+            local tid = res.header["X-Mysql-Tid"]
+            if tid == nil then
+                ngx.say("thread id = nil")
+                return
+            end
+
+            tid = tonumber(tid)
+            ngx.say("thread id = " .. tid)
+
+            res = ngx.location.capture("/mysql",
+                { method = ngx.HTTP_POST,
+                  body = "kill query " .. tid })
+
+            ngx.say("kill status = " .. res.status)
+            ngx.say("kill body = " .. res.body)
+        ';
+    }
+--- request
+    GET /lua
+--- response_body_like
+^status = 504
+thread id = \d+
+kill status = 200
+kill body = {"errcode":0}$
+--- SKIP
+
diff -rNu a/src/lua/lua-nginx-module/t/027-multi-capture.t b/src/lua/lua-nginx-module/t/027-multi-capture.t
--- a/src/lua/lua-nginx-module/t/027-multi-capture.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/027-multi-capture.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,714 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(10);
+
+plan tests => repeat_each() * (blocks() * 2 + 2);
+
+#$ENV{LUA_PATH} = $ENV{HOME} . '/work/JSON4Lua-0.9.30/json/?.lua';
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#log_level 'warn';
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+        ';
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+
+
+
+=== TEST 2: 4 concurrent requests
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2, res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+                { "/c" },
+                { "/d" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+    }
+    location ~ '^/([a-d])$' {
+        echo -n $1;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+res3.status = 200
+res3.body = c
+res4.status = 200
+res4.body = d
+
+
+
+=== TEST 3: capture multi in series
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("2 res1.status = " .. res1.status)
+            ngx.say("2 res1.body = " .. res1.body)
+            ngx.say("2 res2.status = " .. res2.status)
+            ngx.say("2 res2.body = " .. res2.body)
+
+        ';
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /foo
+--- response_body
+res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+2 res1.status = 200
+2 res1.body = a
+2 res2.status = 200
+2 res2.body = b
+
+
+
+=== TEST 4: capture multi in subrequest
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+
+            local n = ngx.var.arg_n
+
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+    }
+
+    location /main {
+        content_by_lua '
+            res = ngx.location.capture("/foo?n=1")
+            ngx.say("top res.status = " .. res.status)
+            ngx.say("top res.body = [" .. res.body .. "]")
+        ';
+    }
+
+    location /a {
+        echo -n a;
+    }
+
+    location /b {
+        echo -n b;
+    }
+--- request
+    GET /main
+--- response_body
+top res.status = 200
+top res.body = [1 res1.status = 200
+1 res1.body = a
+1 res2.status = 200
+1 res2.body = b
+]
+
+
+
+=== TEST 5: capture multi in parallel
+--- config
+    location ~ '^/(foo|bar)$' {
+        set $tag $1;
+        content_by_lua '
+            local res1, res2
+            if ngx.var.tag == "foo" then
+                res1, res2 = ngx.location.capture_multi{
+                    { "/a" },
+                    { "/b" },
+                }
+            else
+                res1, res2 = ngx.location.capture_multi{
+                    { "/c" },
+                    { "/d" },
+                }
+            end
+
+            local n = ngx.var.arg_n
+
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+    }
+
+    location /main {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo?n=1" },
+                { "/bar?n=2" },
+            }
+
+            ngx.say("top res1.status = " .. res1.status)
+            ngx.say("top res1.body = [" .. res1.body .. "]")
+            ngx.say("top res2.status = " .. res2.status)
+            ngx.say("top res2.body = [" .. res2.body .. "]")
+        ';
+    }
+
+    location ~ '^/([abcd])$' {
+        echo -n $1;
+    }
+--- request
+    GET /main
+--- response_body
+top res1.status = 200
+top res1.body = [1 res1.status = 200
+1 res1.body = a
+1 res2.status = 200
+1 res2.body = b
+]
+top res2.status = 200
+top res2.body = [2 res1.status = 200
+2 res1.body = c
+2 res2.status = 200
+2 res2.body = d
+]
+
+
+
+=== TEST 6: memc sanity
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+        ';
+    }
+    location ~ '^/[ab]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /foo
+--- response_body eval
+"res1.status = 201
+res1.body = STORED\r
+
+res2.status = 201
+res2.body = STORED\r
+
+"
+
+
+
+=== TEST 7: memc muti + multi
+--- config
+    location /main {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo?n=1" },
+                { "/bar?n=2" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = [" .. res1.body .. "]")
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = [" .. res2.body .. "]")
+        ';
+    }
+    location ~ '^/(foo|bar)$' {
+        set $tag $1;
+        content_by_lua '
+            local res1, res2
+            if ngx.var.tag == "foo" then
+                res1, res2 = ngx.location.capture_multi{
+                    { "/a" },
+                    { "/b" },
+                }
+            else
+                res1, res2 = ngx.location.capture_multi{
+                    { "/c" },
+                    { "/d" },
+                }
+            end
+            print("args: " .. ngx.var.args)
+            local n = ngx.var.arg_n
+            ngx.say(n .. " res1.status = " .. res1.status)
+            ngx.say(n .. " res1.body = " .. res1.body)
+            ngx.say(n .. " res2.status = " .. res2.status)
+            ngx.say(n .. " res2.body = " .. res2.body)
+        ';
+    }
+    location ~ '^/[abcd]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /main
+--- response_body eval
+"res1.status = 200
+res1.body = [1 res1.status = 201
+1 res1.body = STORED\r
+
+1 res2.status = 201
+1 res2.body = STORED\r
+
+]
+res2.status = 200
+res2.body = [2 res1.status = 201
+2 res1.body = STORED\r
+
+2 res2.status = 201
+2 res2.body = STORED\r
+
+]
+"
+
+
+
+=== TEST 8: memc 4 concurrent requests
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2, res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+                { "/c" },
+                { "/d" },
+            }
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+    }
+    location ~ '^/[a-d]$' {
+        set $memc_key $uri;
+        set $memc_value hello;
+        set $memc_cmd set;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+    GET /foo
+--- response_body eval
+"res1.status = 201
+res1.body = STORED\r
+
+res2.status = 201
+res2.body = STORED\r
+
+res3.status = 201
+res3.body = STORED\r
+
+res4.status = 201
+res4.body = STORED\r
+
+"
+
+
+
+=== TEST 9: capture multi in series (more complex)
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            local res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            res3, res4 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+
+        ';
+    }
+    location /a {
+        echo -n a;
+    }
+    location /b {
+        echo -n b;
+    }
+    location /main {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo" },
+                { "/foo" },
+            }
+            local res3, res4 = ngx.location.capture_multi{
+                { "/foo" },
+                { "/foo" },
+            }
+            ngx.print(res1.body)
+            ngx.print(res2.body)
+            ngx.print(res3.body)
+            ngx.print(res4.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body eval
+"res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+res3.status = 200
+res3.body = a
+res4.status = 200
+res4.body = b
+" x 4
+
+
+
+=== TEST 10: capture multi in series (more complex, using memc)
+--- config
+    location /foo {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            res1, res2 = ngx.location.capture_multi{
+                { "/a" },
+                { "/b" },
+            }
+            local res3, res4 = ngx.location.capture_multi{
+                { "/c" },
+                { "/d" },
+            }
+            res3, res4 = ngx.location.capture_multi{
+                { "/e" },
+                { "/f" },
+            }
+
+            ngx.say("res1.status = " .. res1.status)
+            ngx.say("res1.body = " .. res1.body)
+            ngx.say("res2.status = " .. res2.status)
+            ngx.say("res2.body = " .. res2.body)
+            ngx.say("res3.status = " .. res3.status)
+            ngx.say("res3.body = " .. res3.body)
+            ngx.say("res4.status = " .. res4.status)
+            ngx.say("res4.body = " .. res4.body)
+        ';
+    }
+
+    location /memc {
+        set $memc_key $arg_val;
+        set $memc_value $arg_val;
+        set $memc_cmd $arg_cmd;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location ~ '^/([a-f])$' {
+        set $tag $1;
+        content_by_lua '
+            ngx.location.capture("/memc?cmd=set&val=" .. ngx.var.tag)
+            local res = ngx.location.capture("/memc?cmd=get&val=" .. ngx.var.tag)
+            ngx.print(res.body)
+        ';
+    }
+
+    location /main {
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                { "/foo" },
+                { "/foo" },
+            }
+            local res3, res4 = ngx.location.capture_multi{
+                { "/foo" },
+                { "/foo" },
+            }
+            ngx.print(res1.body)
+            ngx.print(res2.body)
+            ngx.print(res3.body)
+            ngx.print(res4.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body2
+--- response_body eval
+"res1.status = 200
+res1.body = a
+res2.status = 200
+res2.body = b
+res3.status = 200
+res3.body = e
+res4.status = 200
+res4.body = f
+" x 4
+--- no_error_log eval
+["[error]", "[alert]"]
+--- timeout: 10
+
+
+
+=== TEST 11: a mixture of rewrite, access, content phases
+--- config
+    location /main {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/a")
+            ngx.say("rewrite a: " .. res.body)
+
+            res = ngx.location.capture("/b")
+            ngx.say("rewrite b: " .. res.body)
+
+            res = ngx.location.capture("/c")
+            ngx.say("rewrite c: " .. res.body)
+        ';
+
+        access_by_lua '
+            local res = ngx.location.capture("/A")
+            ngx.say("access A: " .. res.body)
+
+            res = ngx.location.capture("/B")
+            ngx.say("access B: " .. res.body)
+        ';
+
+        content_by_lua '
+            local res = ngx.location.capture("/d")
+            ngx.say("content d: " .. res.body)
+
+            res = ngx.location.capture("/e")
+            ngx.say("content e: " .. res.body)
+
+            res = ngx.location.capture("/f")
+            ngx.say("content f: " .. res.body)
+        ';
+    }
+
+    location /memc {
+        set $memc_key $arg_val;
+        set $memc_value $arg_val;
+        set $memc_cmd $arg_cmd;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location ~ '^/([A-F])$' {
+        echo -n $1;
+    }
+
+    location ~ '^/([a-f])$' {
+        set $tag $1;
+        content_by_lua '
+            ngx.location.capture("/memc?cmd=set&val=" .. ngx.var.tag)
+            local res = ngx.location.capture("/memc?cmd=get&val=" .. ngx.var.tag)
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+rewrite a: a
+rewrite b: b
+rewrite c: c
+access A: A
+access B: B
+content d: d
+content e: e
+content f: f
+
+
+
+=== TEST 12: a mixture of rewrite, access, content phases
+--- config
+    location /main {
+        rewrite_by_lua '
+            local a, b, c = ngx.location.capture_multi{
+                {"/a"}, {"/b"}, {"/c"},
+            }
+            ngx.say("rewrite a: " .. a.body)
+            ngx.say("rewrite b: " .. b.body)
+            ngx.say("rewrite c: " .. c.body)
+        ';
+
+        access_by_lua '
+            local A, B = ngx.location.capture_multi{
+                {"/A"}, {"/B"},
+            }
+            ngx.say("access A: " .. A.body)
+            ngx.say("access B: " .. B.body)
+        ';
+
+        content_by_lua '
+            local d, e, f = ngx.location.capture_multi{
+                {"/d"}, {"/e"}, {"/f"},
+            }
+            ngx.say("content d: " .. d.body)
+            ngx.say("content e: " .. e.body)
+            ngx.say("content f: " .. f.body)
+        ';
+    }
+
+    location /memc {
+        set $memc_key $arg_val;
+        set $memc_value $arg_val;
+        set $memc_cmd $arg_cmd;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+
+    location ~ '^/([A-F])$' {
+        echo -n $1;
+    }
+
+    location ~ '^/([a-f])$' {
+        set $tag $1;
+        content_by_lua '
+            ngx.location.capture("/memc?cmd=set&val=" .. ngx.var.tag)
+            local res = ngx.location.capture("/memc?cmd=get&val=" .. ngx.var.tag)
+            ngx.print(res.body)
+        ';
+    }
+--- request
+    GET /main
+--- stap2
+global delta = "  "
+
+M(http-subrequest-start) {
+    r = $arg1
+    n = ngx_http_subreq_depth(r)
+    pr = ngx_http_req_parent(r)
+    printf("%sbegin %s -> %s (%d)\n", ngx_indent(n, delta),
+        ngx_http_req_uri(pr),
+        ngx_http_req_uri(r),
+        n)
+}
+
+F(ngx_http_lua_run_thread) {
+    r = $r
+    uri = ngx_http_req_uri(r)
+    if (uri == "/main") {
+        printf("run thread %s: %d\n", uri, $nret)
+        #print_ubacktrace()
+    }
+}
+
+M(http-lua-info) {
+    uri = ngx_http_req_uri($r)
+    #if (uri == "/main") {
+    printf("XXX info: %s: %s", uri, user_string($arg1))
+    #}
+}
+
+F(ngx_http_lua_post_subrequest) {
+    r = $r
+    n = ngx_http_subreq_depth(r)
+    pr = ngx_http_req_parent(r)
+
+    printf("%send %s -> %s (%d)\n", ngx_indent(n, delta),
+        ngx_http_req_uri(r),
+        ngx_http_req_uri(pr),
+        n)
+}
+
+F(ngx_http_lua_handle_subreq_responses) {
+    r = $r
+    n = ngx_http_subreq_depth(r)
+    printf("%shandle res %s (%d)\n", ngx_indent(n, delta), ngx_http_req_uri(r), n)
+}
+
+--- response_body
+rewrite a: a
+rewrite b: b
+rewrite c: c
+access A: A
+access B: B
+content d: d
+content e: e
+content f: f
+
diff -rNu a/src/lua/lua-nginx-module/t/028-req-header.t b/src/lua/lua-nginx-module/t/028-req-header.t
--- a/src/lua/lua-nginx-module/t/028-req-header.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/028-req-header.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1311 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (2 * blocks() + 18);
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: random access req headers
+--- config
+    location /req-header {
+        content_by_lua '
+            ngx.say("Foo: ", ngx.req.get_headers()["Foo"] or "nil")
+            ngx.say("Bar: ", ngx.req.get_headers()["Bar"] or "nil")
+        ';
+    }
+--- request
+GET /req-header
+--- more_headers
+Foo: bar
+Bar: baz
+--- response_body
+Foo: bar
+Bar: baz
+
+
+
+=== TEST 2: iterating through headers
+--- config
+    location /req-header {
+        content_by_lua '
+            local h = {}
+            for k, v in pairs(ngx.req.get_headers(nil, true)) do
+                h[k] = v
+            end
+            ngx.say("Foo: ", h["Foo"] or "nil")
+            ngx.say("Bar: ", h["Bar"] or "nil")
+        ';
+    }
+--- request
+GET /req-header
+--- more_headers
+Foo: bar
+Bar: baz
+--- response_body
+Foo: bar
+Bar: baz
+
+
+
+=== TEST 3: set input header
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("Foo", "new value");
+        ';
+
+        echo "Foo: $http_foo";
+    }
+--- request
+GET /req-header
+--- more_headers
+Foo: bar
+Bar: baz
+--- response_body
+Foo: new value
+
+
+
+=== TEST 4: clear input header
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("Foo", nil);
+        ';
+
+        echo "Foo: $http_foo";
+    }
+--- request
+GET /req-header
+--- more_headers
+Foo: bar
+Bar: baz
+--- response_body
+Foo: 
+
+
+
+=== TEST 5: rewrite content length
+--- config
+    location /bar {
+        rewrite_by_lua '
+            ngx.req.set_header("Content-Length", 2048)
+        ';
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request eval
+"POST /bar\n" .
+"a" x 4096
+--- response_body eval
+"a" x 2048
+--- timeout: 15
+
+
+
+=== TEST 6: rewrite content length (normalized form)
+--- config
+    location /bar {
+        rewrite_by_lua '
+            ngx.req.set_header("content-length", 2048)
+        ';
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request eval
+"POST /bar\n" .
+"a" x 4096
+--- response_body eval
+"a" x 2048
+--- timeout: 15
+
+
+
+=== TEST 7: rewrite host and user-agent
+--- config
+    location /bar {
+        rewrite_by_lua '
+            ngx.req.set_header("Host", "foo")
+            ngx.req.set_header("User-Agent", "blah")
+        ';
+        echo "Host: $host";
+        echo "User-Agent: $http_user_agent";
+    }
+--- request
+GET /bar
+--- response_body
+Host: foo
+User-Agent: blah
+
+
+
+=== TEST 8: clear host and user-agent
+$host always has a default value and cannot be really cleared.
+--- config
+    location /bar {
+        rewrite_by_lua '
+            ngx.req.set_header("Host", nil)
+            ngx.req.set_header("User-Agent", nil)
+        ';
+        echo "Host: $host";
+        echo "Host (2): $http_host";
+        echo "User-Agent: $http_user_agent";
+    }
+--- request
+GET /bar
+--- response_body
+Host: localhost
+Host (2): 
+User-Agent: 
+
+
+
+=== TEST 9: clear host and user-agent (the other way)
+--- config
+    location /bar {
+        rewrite_by_lua '
+            ngx.req.clear_header("Host")
+            ngx.req.clear_header("User-Agent")
+            ngx.req.clear_header("X-Foo")
+        ';
+        echo "Host: $host";
+        echo "User-Agent: $http_user_agent";
+        echo "X-Foo: $http_x_foo";
+    }
+--- request
+GET /bar
+--- more_headers
+X-Foo: bar
+--- response_body
+Host: localhost
+User-Agent: 
+X-Foo: 
+
+
+
+=== TEST 10: clear content-length
+--- config
+    location /bar {
+        access_by_lua '
+            ngx.req.clear_header("Content-Length")
+        ';
+        echo "Content-Length: $http_content_length";
+    }
+--- request
+POST /bar
+hello
+--- more_headers
+--- response_body
+Content-Length: 
+
+
+
+=== TEST 11: rewrite type
+--- config
+    location /bar {
+        access_by_lua '
+            ngx.req.set_header("Content-Type", "text/css")
+        ';
+        echo "Content-Type: $content_type";
+    }
+--- request
+POST /bar
+hello
+--- more_headers
+Content-Type: text/plain
+--- response_body
+Content-Type: text/css
+
+
+
+=== TEST 12: clear type
+--- config
+    location /bar {
+        access_by_lua '
+            ngx.req.clear_header("Content-Type")
+        ';
+        echo "Content-Type: $content_type";
+    }
+--- request
+POST /bar
+hello
+--- more_headers
+Content-Type: text/plain
+--- response_body
+Content-Type: 
+
+
+
+=== TEST 13: add multiple request headers
+--- config
+    location /bar {
+        access_by_lua '
+            ngx.req.set_header("Foo", {"a", "b"})
+        ';
+        echo "Foo: $http_foo";
+    }
+--- request
+GET /bar
+--- response_body
+Foo: a
+
+
+
+=== TEST 14: add multiple request headers
+--- config
+    location /bar {
+        access_by_lua '
+            ngx.req.set_header("Foo", {"a", "abc"})
+        ';
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location = /foo {
+        echo $echo_client_request_headers;
+    }
+--- request
+GET /bar
+--- response_body_like chomp
+\bFoo: a\r\n.*?\bFoo: abc\b
+
+
+
+=== TEST 15: set_header and clear_header should refresh ngx.req.get_headers() automatically
+--- config
+    location /foo {
+        content_by_lua '
+            ngx.say("Foo: ", ngx.req.get_headers()["Foo"] or "nil")
+
+            ngx.req.set_header("Foo", 32)
+            ngx.say("Foo 1: ", ngx.req.get_headers()["Foo"] or "nil")
+
+            ngx.req.set_header("Foo", "abc")
+            ngx.say("Foo 2: ", ngx.req.get_headers()["Foo"] or "nil")
+
+            ngx.req.clear_header("Foo")
+            ngx.say("Foo 3: ", ngx.req.get_headers()["Foo"] or "nil")
+        ';
+    }
+--- more_headers
+Foo: foo
+
+--- request
+    GET /foo
+--- response_body
+Foo: foo
+Foo 1: 32
+Foo 2: abc
+Foo 3: nil
+
+
+
+=== TEST 16: duplicate req headers
+--- config
+    location /foo {
+        content_by_lua '
+            local vals = ngx.req.get_headers()["Foo"]
+            ngx.say("value is of type ", type(vals), ".")
+            if type(vals) == "table" then
+                ngx.say("Foo takes ", #vals or "nil", " values.")
+                ngx.say("They are ", table.concat(vals, ", "), ".")
+            end
+        ';
+    }
+--- more_headers
+Foo: foo
+Foo: bar
+Foo: baz
+--- request
+    GET /foo
+--- response_body
+value is of type table.
+Foo takes 3 values.
+They are foo, bar, baz.
+
+
+
+=== TEST 17: Accept-Encoding (scalar)
+--- config
+    location /bar {
+        default_type 'text/plain';
+        rewrite_by_lua '
+            ngx.req.set_header("Accept-Encoding", "gzip")
+        ';
+        gzip on;
+        gzip_min_length  1;
+        gzip_buffers     4 8k;
+        gzip_types       text/plain;
+    }
+--- user_files
+">>> bar
+" . ("hello" x 512)
+--- request
+GET /bar
+--- response_headers
+Content-Encoding: gzip
+--- response_body_like: .{20}
+
+
+
+=== TEST 18: Accept-Encoding (table)
+--- config
+    location /bar {
+        default_type 'text/plain';
+        rewrite_by_lua '
+            ngx.req.set_header("Accept-Encoding", {"gzip"})
+        ';
+        gzip on;
+        gzip_min_length  1;
+        gzip_buffers     4 8k;
+        gzip_types       text/plain;
+    }
+--- user_files
+">>> bar
+" . ("hello" x 512)
+--- request
+GET /bar
+--- response_headers
+Content-Encoding: gzip
+--- response_body_like: .{20}
+
+
+
+=== TEST 19: default max 100 headers
+--- config
+    location /lua {
+        content_by_lua '
+            local headers = ngx.req.get_headers()
+            local keys = {}
+            for key, val in pairs(headers) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, ": ", headers[key])
+            end
+        ';
+    }
+--- request
+GET /lua
+--- more_headers eval
+my $i = 1;
+my $s;
+while ($i <= 102) {
+    $s .= "X-$i:$i\n";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 98) {
+    push @k, "x-$i";
+    $i++;
+}
+push @k, "connection: Close\n";
+push @k, "host: localhost\n";
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= ": $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+--- error_log
+lua hit request header limit 100
+
+
+
+=== TEST 20: custom max 102 headers
+--- config
+    location /lua {
+        content_by_lua '
+            local headers = ngx.req.get_headers(102)
+            local keys = {}
+            for key, val in pairs(headers) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, ": ", headers[key])
+            end
+        ';
+    }
+--- request
+GET /lua
+--- more_headers eval
+my $i = 1;
+my $s;
+while ($i <= 103) {
+    $s .= "X-$i:$i\n";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 100) {
+    push @k, "x-$i";
+    $i++;
+}
+push @k, "connection: Close\n";
+push @k, "host: localhost\n";
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= ": $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+--- error_log
+lua hit request header limit 102
+
+
+
+=== TEST 21: custom unlimited headers
+--- config
+    location /lua {
+        content_by_lua '
+            local headers = ngx.req.get_headers(0)
+            local keys = {}
+            for key, val in pairs(headers) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, ": ", headers[key])
+            end
+        ';
+    }
+--- request
+GET /lua
+--- more_headers eval
+my $s;
+my $i = 1;
+while ($i <= 105) {
+    $s .= "X-$i:$i\n";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 105) {
+    push @k, "x-$i";
+    $i++;
+}
+push @k, "connection: Close\n";
+push @k, "host: localhost\n";
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= ": $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+
+
+
+=== TEST 22: modify subrequest req headers should not affect the parent
+--- config
+    location = /main {
+        rewrite_by_lua '
+            local res = ngx.location.capture("/sub")
+            print("subrequest: ", res.status)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location /sub {
+        content_by_lua '
+            ngx.req.set_header("foo121", 121)
+            ngx.req.set_header("foo122", 122)
+            ngx.say("ok")
+        ';
+    }
+
+    location = /echo {
+        #echo $echo_client_request_headers;
+        echo "foo121: [$http_foo121]";
+        echo "foo122: [$http_foo122]";
+    }
+--- request
+GET /main
+--- more_headers
+Foo: foo
+Bar: bar
+Foo1: foo1
+Foo2: foo2
+Foo3: foo3
+Foo4: foo4
+Foo5: foo5
+Foo6: foo6
+Foo7: foo7
+Foo8: foo8
+Foo9: foo9
+Foo10: foo10
+Foo11: foo11
+Foo12: foo12
+Foo13: foo13
+Foo14: foo14
+Foo15: foo15
+Foo16: foo16
+Foo17: foo17
+Foo18: foo18
+Foo19: foo19
+Foo20: foo20
+--- response_body
+Foo: []
+Bar: []
+--- SKIP
+
+
+
+=== TEST 23: clear_header should clear all the instances of the user custom header
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("Foo")
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location = /echo {
+        echo "Foo: [$http_foo]";
+        echo "Test-Header: [$http_test_header]";
+    }
+--- request
+GET /t
+--- more_headers
+Foo: foo
+Foo: bah
+Test-Header: 1
+--- response_body
+Foo: []
+Test-Header: [1]
+
+
+
+=== TEST 24: clear_header should clear all the instances of the builtin header
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("Content-Type")
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location = /echo {
+        echo "Content-Type: [$http_content_type]";
+        echo "Test-Header: [$http_test_header]";
+        #echo $echo_client_request_headers;
+    }
+--- request
+GET /t
+--- more_headers
+Content-Type: foo
+Content-Type: bah
+Test-Header: 1
+--- response_body
+Content-Type: []
+Test-Header: [1]
+
+
+
+=== TEST 25: Converting POST to GET - clearing headers (bug found by Matthieu Tourne, 411 error page)
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("Content-Type")
+            ngx.req.clear_header("Content-Length")
+        ';
+
+        #proxy_pass http://127.0.0.1:8888;
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+
+    location /back {
+        echo -n $echo_client_request_headers;
+    }
+--- request
+POST /t
+hello world
+--- more_headers
+Content-Type: application/ocsp-request
+Test-Header: 1
+--- response_body_like eval
+qr/Connection: close\r
+Test-Header: 1\r
+\r
+$/
+--- no_error_log
+[error]
+
+
+
+=== TEST 26: clear_header() does not duplicate subsequent headers (old bug)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("Foo")
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location = /echo {
+        echo $echo_client_request_headers;
+    }
+--- request
+GET /t
+--- more_headers
+Bah: bah
+Foo: foo
+Test-Header: 1
+Foo1: foo1
+Foo2: foo2
+Foo3: foo3
+Foo4: foo4
+Foo5: foo5
+Foo6: foo6
+Foo7: foo7
+Foo8: foo8
+Foo9: foo9
+Foo10: foo10
+Foo11: foo11
+Foo12: foo12
+Foo13: foo13
+Foo14: foo14
+Foo15: foo15
+Foo16: foo16
+Foo17: foo17
+Foo18: foo18
+Foo19: foo19
+Foo20: foo20
+Foo21: foo21
+Foo22: foo22
+--- response_body_like eval
+qr/Bah: bah\r
+Test-Header: 1\r
+Foo1: foo1\r
+Foo2: foo2\r
+Foo3: foo3\r
+Foo4: foo4\r
+Foo5: foo5\r
+Foo6: foo6\r
+Foo7: foo7\r
+Foo8: foo8\r
+Foo9: foo9\r
+Foo10: foo10\r
+Foo11: foo11\r
+Foo12: foo12\r
+Foo13: foo13\r
+Foo14: foo14\r
+Foo15: foo15\r
+Foo16: foo16\r
+Foo17: foo17\r
+Foo18: foo18\r
+Foo19: foo19\r
+Foo20: foo20\r
+Foo21: foo21\r
+Foo22: foo22\r
+/
+
+
+
+=== TEST 27: iterating through headers (raw form)
+--- config
+    location /t {
+        content_by_lua '
+            local h = {}
+            for k, v in pairs(ngx.req.get_headers(nil, true)) do
+                ngx.say(k, ": ", v)
+            end
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+My-Foo: bar
+Bar: baz
+--- response_body
+Host: localhost
+Bar: baz
+My-Foo: bar
+Connection: Close
+
+
+
+=== TEST 28: __index metamethod not working for "raw" mode
+--- config
+    location /t {
+        content_by_lua '
+            local h = ngx.req.get_headers(nil, true)
+            ngx.say("My-Foo-Header: ", h.my_foo_header)
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+My-Foo-Header: Hello World
+--- response_body
+My-Foo-Header: nil
+
+
+
+=== TEST 29: __index metamethod not working for the default mode
+--- config
+    location /t {
+        content_by_lua '
+            local h = ngx.req.get_headers()
+            ngx.say("My-Foo-Header: ", h.my_foo_header)
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+My-Foo-Header: Hello World
+--- response_body
+My-Foo-Header: Hello World
+
+
+
+=== TEST 30: clear input header (just more than 20 headers)
+--- config
+    location = /t {
+        rewrite_by_lua 'ngx.req.clear_header("R")';
+        proxy_pass http://127.0.0.1:$server_port/back;
+        proxy_set_header Host foo;
+        #proxy_pass http://127.0.0.1:1234/back;
+    }
+
+    location = /back {
+        echo -n $echo_client_request_headers;
+    }
+--- request
+GET /t
+--- more_headers eval
+my $s = "User-Agent: curl\n";
+
+for my $i ('a' .. 'r') {
+    $s .= uc($i) . ": " . "$i\n"
+}
+$s
+--- response_body eval
+"GET /back HTTP/1.0\r
+Host: foo\r
+Connection: close\r
+User-Agent: curl\r
+A: a\r
+B: b\r
+C: c\r
+D: d\r
+E: e\r
+F: f\r
+G: g\r
+H: h\r
+I: i\r
+J: j\r
+K: k\r
+L: l\r
+M: m\r
+N: n\r
+O: o\r
+P: p\r
+Q: q\r
+\r
+"
+
+
+
+=== TEST 31: clear input header (just more than 20 headers, and add more)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("R")
+            for i = 1, 21 do
+                ngx.req.set_header("foo-" .. i, i)
+            end
+        ';
+        proxy_pass http://127.0.0.1:$server_port/back;
+        proxy_set_header Host foo;
+        #proxy_pass http://127.0.0.1:1234/back;
+    }
+
+    location = /back {
+        echo -n $echo_client_request_headers;
+    }
+--- request
+GET /t
+--- more_headers eval
+my $s = "User-Agent: curl\n";
+
+for my $i ('a' .. 'r') {
+    $s .= uc($i) . ": " . "$i\n"
+}
+$s
+--- response_body eval
+"GET /back HTTP/1.0\r
+Host: foo\r
+Connection: close\r
+User-Agent: curl\r
+A: a\r
+B: b\r
+C: c\r
+D: d\r
+E: e\r
+F: f\r
+G: g\r
+H: h\r
+I: i\r
+J: j\r
+K: k\r
+L: l\r
+M: m\r
+N: n\r
+O: o\r
+P: p\r
+Q: q\r
+foo-1: 1\r
+foo-2: 2\r
+foo-3: 3\r
+foo-4: 4\r
+foo-5: 5\r
+foo-6: 6\r
+foo-7: 7\r
+foo-8: 8\r
+foo-9: 9\r
+foo-10: 10\r
+foo-11: 11\r
+foo-12: 12\r
+foo-13: 13\r
+foo-14: 14\r
+foo-15: 15\r
+foo-16: 16\r
+foo-17: 17\r
+foo-18: 18\r
+foo-19: 19\r
+foo-20: 20\r
+foo-21: 21\r
+\r
+"
+
+
+
+=== TEST 32: clear input header (just more than 21 headers)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("R")
+            ngx.req.clear_header("Q")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/back;
+        proxy_set_header Host foo;
+        #proxy_pass http://127.0.0.1:1234/back;
+    }
+
+    location = /back {
+        echo -n $echo_client_request_headers;
+    }
+--- request
+GET /t
+--- more_headers eval
+my $s = "User-Agent: curl\nBah: bah\n";
+
+for my $i ('a' .. 'r') {
+    $s .= uc($i) . ": " . "$i\n"
+}
+$s
+--- response_body eval
+"GET /back HTTP/1.0\r
+Host: foo\r
+Connection: close\r
+User-Agent: curl\r
+Bah: bah\r
+A: a\r
+B: b\r
+C: c\r
+D: d\r
+E: e\r
+F: f\r
+G: g\r
+H: h\r
+I: i\r
+J: j\r
+K: k\r
+L: l\r
+M: m\r
+N: n\r
+O: o\r
+P: p\r
+\r
+"
+
+
+
+=== TEST 33: clear input header (just more than 21 headers)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.req.clear_header("R")
+            ngx.req.clear_header("Q")
+            for i = 1, 21 do
+                ngx.req.set_header("foo-" .. i, i)
+            end
+        ';
+        proxy_pass http://127.0.0.1:$server_port/back;
+        proxy_set_header Host foo;
+        #proxy_pass http://127.0.0.1:1234/back;
+    }
+
+    location = /back {
+        echo -n $echo_client_request_headers;
+    }
+--- request
+GET /t
+--- more_headers eval
+my $s = "User-Agent: curl\nBah: bah\n";
+
+for my $i ('a' .. 'r') {
+    $s .= uc($i) . ": " . "$i\n"
+}
+$s
+--- response_body eval
+"GET /back HTTP/1.0\r
+Host: foo\r
+Connection: close\r
+User-Agent: curl\r
+Bah: bah\r
+A: a\r
+B: b\r
+C: c\r
+D: d\r
+E: e\r
+F: f\r
+G: g\r
+H: h\r
+I: i\r
+J: j\r
+K: k\r
+L: l\r
+M: m\r
+N: n\r
+O: o\r
+P: p\r
+foo-1: 1\r
+foo-2: 2\r
+foo-3: 3\r
+foo-4: 4\r
+foo-5: 5\r
+foo-6: 6\r
+foo-7: 7\r
+foo-8: 8\r
+foo-9: 9\r
+foo-10: 10\r
+foo-11: 11\r
+foo-12: 12\r
+foo-13: 13\r
+foo-14: 14\r
+foo-15: 15\r
+foo-16: 16\r
+foo-17: 17\r
+foo-18: 18\r
+foo-19: 19\r
+foo-20: 20\r
+foo-21: 21\r
+\r
+"
+
+
+
+=== TEST 34: raw form
+--- config
+    location /t {
+        content_by_lua '
+           -- get ALL the raw headers (0 == no limit, not recommended)
+           local headers = ngx.req.get_headers(0, true)
+           for k, v in pairs(headers) do
+              ngx.say{ k, ": ", v}
+           end
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+My-Foo: bar
+Bar: baz
+--- response_body
+Host: localhost
+Bar: baz
+My-Foo: bar
+Connection: Close
+--- no_error_log
+[error]
+
+
+
+=== TEST 35: clear X-Real-IP
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("X-Real-IP", nil)
+        ';
+        echo "X-Real-IP: $http_x_real_ip";
+    }
+--- request
+GET /t
+--- more_headers
+X-Real-IP: 8.8.8.8
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    if (@defined($r->headers_in->x_real_ip) && $r->headers_in->x_real_ip) {
+        printf("rewrite: x-real-ip: %s\n",
+               user_string_n($r->headers_in->x_real_ip->value->data,
+                             $r->headers_in->x_real_ip->value->len))
+    } else {
+        println("rewrite: no x-real-ip")
+    }
+}
+
+F(ngx_http_core_content_phase) {
+    if (@defined($r->headers_in->x_real_ip) && $r->headers_in->x_real_ip) {
+        printf("content: x-real-ip: %s\n",
+               user_string_n($r->headers_in->x_real_ip->value->data,
+                             $r->headers_in->x_real_ip->value->len))
+    } else {
+        println("content: no x-real-ip")
+    }
+}
+
+--- stap_out
+rewrite: x-real-ip: 8.8.8.8
+content: no x-real-ip
+
+--- response_body
+X-Real-IP: 
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 36: set custom X-Real-IP
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("X-Real-IP", "8.8.4.4")
+        ';
+        echo "X-Real-IP: $http_x_real_ip";
+    }
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    if (@defined($r->headers_in->x_real_ip) && $r->headers_in->x_real_ip) {
+        printf("rewrite: x-real-ip: %s\n",
+               user_string_n($r->headers_in->x_real_ip->value->data,
+                             $r->headers_in->x_real_ip->value->len))
+    } else {
+        println("rewrite: no x-real-ip")
+    }
+
+}
+
+F(ngx_http_core_content_phase) {
+    if (@defined($r->headers_in->x_real_ip) && $r->headers_in->x_real_ip) {
+        printf("content: x-real-ip: %s\n",
+               user_string_n($r->headers_in->x_real_ip->value->data,
+                             $r->headers_in->x_real_ip->value->len))
+    } else {
+        println("content: no x-real-ip")
+    }
+}
+
+--- stap_out
+rewrite: no x-real-ip
+content: x-real-ip: 8.8.4.4
+
+--- response_body
+X-Real-IP: 8.8.4.4
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 37: clear Via
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Via", nil)
+        ';
+        echo "Via: $http_via";
+    }
+--- request
+GET /t
+--- more_headers
+Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    if (@defined($r->headers_in->via) && $r->headers_in->via) {
+        printf("rewrite: via: %s\n",
+               user_string_n($r->headers_in->via->value->data,
+                             $r->headers_in->via->value->len))
+    } else {
+        println("rewrite: no via")
+    }
+}
+
+F(ngx_http_core_content_phase) {
+    if (@defined($r->headers_in->via) && $r->headers_in->via) {
+        printf("content: via: %s\n",
+               user_string_n($r->headers_in->via->value->data,
+                             $r->headers_in->via->value->len))
+    } else {
+        println("content: no via")
+    }
+}
+
+--- stap_out
+rewrite: via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
+content: no via
+
+--- response_body
+Via: 
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 38: set custom Via
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Via", "1.0 fred, 1.1 nowhere.com (Apache/1.1)")
+        ';
+        echo "Via: $http_via";
+    }
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    if (@defined($r->headers_in->via) && $r->headers_in->via) {
+        printf("rewrite: via: %s\n",
+               user_string_n($r->headers_in->via->value->data,
+                             $r->headers_in->via->value->len))
+    } else {
+        println("rewrite: no via")
+    }
+
+}
+
+F(ngx_http_core_content_phase) {
+    if (@defined($r->headers_in->via) && $r->headers_in->via) {
+        printf("content: via: %s\n",
+               user_string_n($r->headers_in->via->value->data,
+                             $r->headers_in->via->value->len))
+    } else {
+        println("content: no via")
+    }
+}
+
+--- stap_out
+rewrite: no via
+content: via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
+
+--- response_body
+Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 39: set input header (with underscores in the header name)
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("foo_bar", "some value");
+        ';
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+    location = /back {
+        echo -n $echo_client_request_headers;
+    }
+--- request
+GET /req-header
+--- response_body_like eval
+qr{^GET /back HTTP/1.0\r
+Host: 127.0.0.1:\d+\r
+Connection: close\r
+foo_bar: some value\r
+\r
+$}
+
+
+
+=== TEST 40: HTTP 0.9 (set & get)
+--- config
+    location /foo {
+        content_by_lua '
+            ngx.req.set_header("X-Foo", "howdy");
+            ngx.say("X-Foo: ", ngx.req.get_headers()["X-Foo"])
+        ';
+    }
+--- raw_request eval
+"GET /foo\r\n"
+--- response_headers
+! X-Foo
+--- response_body
+X-Foo: nil
+--- http09
+--- no_error_log
+[error]
+
+
+
+=== TEST 41: HTTP 0.9 (clear)
+--- config
+    location /foo {
+        content_by_lua '
+            ngx.req.set_header("X-Foo", "howdy");
+            ngx.say("X-Foo: ", ngx.req.get_headers()["X-Foo"])
+        ';
+    }
+--- raw_request eval
+"GET /foo\r\n"
+--- response_headers
+! X-Foo
+--- response_body
+X-Foo: nil
+--- http09
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/029-http-time.t b/src/lua/lua-nginx-module/t/029-http-time.t
--- a/src/lua/lua-nginx-module/t/029-http-time.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/029-http-time.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,89 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: http_time in content_by_lua
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.http_time(1290079655))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Thu, 18 Nov 2010 11:27:35 GMT
+
+
+
+=== TEST 2: http_time in set_by_lua
+--- config
+    location /lua {
+        set_by_lua $a '
+            return ngx.http_time(1290079655)
+        ';
+        echo $a;
+    }
+--- request
+GET /lua
+--- response_body
+Thu, 18 Nov 2010 11:27:35 GMT
+
+
+
+=== TEST 3: parse_http_time in set_by_lua
+--- config
+    location /lua {
+        set_by_lua $a '
+            return ngx.parse_http_time("Thu, 18 Nov 2010 11:27:35 GMT")
+        ';
+        echo $a;
+    }
+--- request
+GET /lua
+--- response_body
+1290079655
+
+
+
+=== TEST 4: parse_http_time in content_by_lua
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.parse_http_time("Thu, 18 Nov 2010 11:27:35 GMT"))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+1290079655
+
+
+
+=== TEST 5: bad arg for parse_http_time in content_by_lua
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.parse_http_time("abc") or "nil")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+nil
+
diff -rNu a/src/lua/lua-nginx-module/t/030-uri-args.t b/src/lua/lua-nginx-module/t/030-uri-args.t
--- a/src/lua/lua-nginx-module/t/030-uri-args.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/030-uri-args.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1342 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2 + 16);
+
+no_root_location();
+
+#no_shuffle();
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+GET /lua?a=3&b=4&c
+--- response_body
+a = 3
+b = 4
+c = true
+
+
+
+=== TEST 2: args take no value
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+GET /lua?foo&baz=&bar=42
+--- response_body
+bar = 42
+baz = 
+foo = true
+
+
+
+=== TEST 3: arg key and value escaped
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("again...")
+
+            args = ngx.req.get_uri_args()
+            keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+GET /lua?%3d&b%20r=4%61+2
+--- response_body
+= = true
+b r = 4a 2
+again...
+= = true
+b r = 4a 2
+
+
+
+=== TEST 4: empty
+--- config
+    location /t {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /t
+--- response_body
+done
+
+
+
+=== TEST 5: empty arg, but with = and &
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?=&&
+--- response_body
+done
+
+
+
+=== TEST 6: multi-value keys
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                local val = args[key]
+                if type(val) == "table" then
+                    ngx.say(key, " = [", table.concat(val, ", "), "]")
+                else
+                    ngx.say(key, " = ", val)
+                end
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?foo=32&foo==&foo=baz
+--- response_body
+foo = [32, =, baz]
+done
+
+
+
+=== TEST 7: multi-value keys
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                local val = args[key]
+                if type(val) == "table" then
+                    ngx.say(key, " = [", table.concat(val, ", "), "]")
+                else
+                    ngx.say(key, " = ", val)
+                end
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?foo=32&foo==&bar=baz
+--- response_body
+bar = baz
+foo = [32, =]
+done
+
+
+
+=== TEST 8: empty arg
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            -- ngx.say(args)
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?&=
+--- response_body
+done
+
+
+
+=== TEST 9: = in value
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            -- ngx.say(args)
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?foo===
+--- response_body
+foo = ==
+done
+
+
+
+=== TEST 10: empty key, but non-emtpy values
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?=hello&=world
+--- response_body
+done
+
+
+
+=== TEST 11: updating args with $args
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("updating args...")
+
+            ngx.var.args = "a=3&b=4"
+
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?foo=bar
+--- response_body
+foo = bar
+updating args...
+a = 3
+b = 4
+done
+
+
+
+=== TEST 12: rewrite uri and args
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        rewrite_by_lua '
+            ngx.req.set_uri_args("hello")
+            ngx.req.set_uri("/bar", true);
+        ';
+        proxy_pass http://agentzh.org:12345;
+    }
+--- request
+    GET /foo?world
+--- response_body
+hello
+--- error_log
+lua set uri jump to "/bar"
+--- log_level: debug
+
+
+
+=== TEST 13: rewrite args (not break cycle by default)
+--- config
+    location /bar {
+        echo "bar: $uri?$args";
+    }
+    location /foo {
+        #set $args 'hello';
+        rewrite_by_lua '
+            ngx.req.set_uri_args("hello")
+            ngx.req.set_uri("/bar", true)
+        ';
+        echo "foo: $uri?$args";
+    }
+--- request
+    GET /foo?world
+--- response_body
+bar: /bar?hello
+
+
+
+=== TEST 14: rewrite (not break cycle explicitly)
+--- config
+    location /bar {
+        echo "bar: $uri?$args";
+    }
+    location /foo {
+        #set $args 'hello';
+        rewrite_by_lua '
+            ngx.req.set_uri_args("hello")
+            ngx.req.set_uri("/bar", true)
+        ';
+        echo "foo: $uri?$args";
+    }
+--- request
+    GET /foo?world
+--- response_body
+bar: /bar?hello
+
+
+
+=== TEST 15: rewrite (break cycle explicitly)
+--- config
+    location /bar {
+        echo "bar: $uri?$args";
+    }
+    location /foo {
+        #set $args 'hello';
+        rewrite_by_lua '
+            ngx.req.set_uri("/bar")
+            ngx.req.set_uri_args("hello")
+        ';
+        echo "foo: $uri?$args";
+    }
+--- request
+    GET /foo?world
+--- response_body
+foo: /bar?hello
+
+
+
+=== TEST 16: rewrite uri (zero-length)
+--- config
+    location /foo {
+        #set $args 'hello';
+        rewrite_by_lua '
+            local res, err = pcall(ngx.req.set_uri, "")
+            ngx.say("err: ", err)
+        ';
+        content_by_lua '
+            ngx.say("foo: ", ngx.var.uri, "?", ngx.var.args)
+        ';
+    }
+--- request
+    GET /foo?world
+--- response_body
+err: attempt to use zero-length uri
+foo: /foo?world
+
+
+
+=== TEST 17: rewrite uri and args
+--- config
+    location /bar {
+        echo $server_protocol $query_string;
+    }
+    location /foo {
+        #rewrite ^ /bar?hello? break;
+        rewrite_by_lua '
+            ngx.req.set_uri_args("hello")
+            ngx.req.set_uri("/bar")
+        ';
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT;
+    }
+--- request
+    GET /foo?world
+--- response_body
+HTTP/1.0 hello
+
+
+
+=== TEST 18: rewrite uri and args (table args)
+--- config
+    location /bar {
+        echo $server_protocol $query_string;
+    }
+    location /foo {
+        #rewrite ^ /bar?hello? break;
+        rewrite_by_lua '
+            ngx.req.set_uri("/bar")
+            ngx.req.set_uri_args({["ca t"] = "%"})
+        ';
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT;
+    }
+--- request
+    GET /foo?world
+--- response_body
+HTTP/1.0 ca%20t=%25
+
+
+
+=== TEST 19: rewrite uri and args (never returns)
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        rewrite_by_lua '
+            ngx.req.set_uri_args("hello")
+            ngx.req.set_uri("/bar", true);
+            ngx.exit(503)
+        ';
+        proxy_pass http://agentzh.org:12345;
+    }
+--- request
+    GET /foo?world
+--- response_body
+hello
+
+
+
+=== TEST 20: ngx.req.set_uri with jump not allowed in access phase
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        set $err '';
+        access_by_lua '
+            res, err = pcall(ngx.req.set_uri, "/bar", true);
+            ngx.var.err = err
+        ';
+        echo "err: $err";
+    }
+--- request
+    GET /foo?world
+--- response_body
+err: API disabled in the context of access_by_lua*
+
+
+
+=== TEST 21: ngx.req.set_uri without jump allowed in access phase
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        set $err '';
+        access_by_lua '
+            ngx.req.set_uri("/bar")
+        ';
+        echo "uri: $uri";
+    }
+--- request
+    GET /foo?world
+--- response_body
+uri: /bar
+
+
+
+=== TEST 22: ngx.req.set_uri with jump not allowed in content phase
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        content_by_lua '
+            res, err = pcall(ngx.req.set_uri, "/bar", true);
+            ngx.say("err: ", err)
+        ';
+    }
+--- request
+    GET /foo?world
+--- response_body
+err: API disabled in the context of content_by_lua*
+
+
+
+=== TEST 23: ngx.req.set_uri without jump allowed in content phase
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        set $err '';
+        content_by_lua '
+            ngx.req.set_uri("/bar")
+            ngx.say("uri: ", ngx.var.uri)
+        ';
+    }
+--- request
+    GET /foo?world
+--- response_body
+uri: /bar
+
+
+
+=== TEST 24: ngx.req.set_uri with jump not allowed in set_by_lua
+--- config
+    location /bar {
+        echo $query_string;
+    }
+    location /foo {
+        #set $args 'hello';
+        set_by_lua $err '
+            res, err = pcall(ngx.req.set_uri, "/bar", true);
+            return err
+        ';
+        echo "err: $err";
+    }
+--- request
+    GET /foo?world
+--- response_body
+err: API disabled in the context of set_by_lua*
+
+
+
+=== TEST 25: ngx.encode_args (sanity)
+--- config
+    location /lua {
+        set_by_lua $args_str '
+            local t = {a = "bar", b = "foo"}
+            return ngx.encode_args(t)
+        ';
+        echo $args_str;
+    }
+--- request
+GET /lua
+--- response_body
+a=bar&b=foo
+
+
+
+=== TEST 26: ngx.encode_args (empty table)
+--- config
+    location /lua {
+        content_by_lua '
+            local t = {a = nil}
+            ngx.say("args:" .. ngx.encode_args(t))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+args:
+
+
+
+=== TEST 27: ngx.encode_args (value is table)
+--- config
+    location /lua {
+        content_by_lua '
+            local t = {a = {9, 2}, b = 3}
+            ngx.say("args:" .. ngx.encode_args(t))
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like
+^args:(?:a=9&a=2&b=3|b=3&a=9&a=2)$
+
+
+
+=== TEST 28: ngx.encode_args (boolean values)
+--- config
+    location /lua {
+        content_by_lua '
+            local t = {a = true, foo = 3}
+            ngx.say("args: " .. ngx.encode_args(t))
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like
+^args: (?:a&foo=3|foo=3&a)$
+
+
+
+=== TEST 29: ngx.encode_args (boolean values, false)
+--- config
+    location /lua {
+        content_by_lua '
+            local t = {a = false, foo = 3}
+            ngx.say("args: " .. ngx.encode_args(t))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+args: foo=3
+
+
+
+=== TEST 30: boolean values in ngx.encode_args
+--- config
+    location /lua {
+        set_by_lua $args_str '
+            local t = {bar = {32, true}, foo = 3}
+            return ngx.encode_args(t)
+        ';
+        echo $args_str;
+    }
+--- request
+GET /lua
+--- response_body
+foo=3&bar=32&bar
+--- no_error_log
+[error]
+
+
+
+=== TEST 31: ngx.encode_args (bad user data value)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location /lua {
+        content_by_lua '
+            local t = {bar = ngx.shared.dogs, foo = 3}
+            rc, err = pcall(ngx.encode_args, t)
+            ngx.say("rc: ", rc, ", err: ", err)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+rc: false, err: attempt to use userdata as query arg value
+
+
+
+=== TEST 32: ngx.encode_args (empty table)
+--- config
+    location /lua {
+        content_by_lua '
+            local t = {}
+            ngx.say("args: ", ngx.encode_args(t))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+args: 
+
+
+
+=== TEST 33: ngx.encode_args (bad arg)
+--- config
+    location /lua {
+        content_by_lua '
+            local rc, err = pcall(ngx.encode_args, true)
+            ngx.say("rc: ", rc, ", err: ", err)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+rc: false, err: bad argument #1 to '?' (table expected, got boolean)
+
+
+
+=== TEST 34: max args (limited after normal key=value)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args(2)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+GET /lua?foo=3&bar=4&baz=2
+--- response_body
+bar = 4
+foo = 3
+--- error_log
+lua hit query args limit 2
+--- log_level: debug
+
+
+
+=== TEST 35: max args (limited after an orphan key)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args(2)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+GET /lua?foo=3&bar&baz=2
+--- response_body
+bar = true
+foo = 3
+--- error_log
+lua hit query args limit 2
+--- log_level: debug
+
+
+
+=== TEST 36: max args (limited after an empty key, but non-emtpy values)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args(2)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua?foo=3&=hello&=world
+--- response_body
+foo = 3
+done
+--- error_log
+lua hit query args limit 2
+--- log_level: debug
+
+
+
+=== TEST 37: default max 100 args
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request eval
+my $s = "GET /lua?";
+my $i = 1;
+while ($i <= 102) {
+    if ($i != 1) {
+        $s .= '&';
+    }
+    $s .= "a$i=$i";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 100) {
+    push @k, "a$i";
+    $i++;
+}
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= " = $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+--- error_log
+lua hit query args limit 100
+--- log_level: debug
+
+
+
+=== TEST 38: custom max 102 args
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args(102)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request eval
+my $s = "GET /lua?";
+my $i = 1;
+while ($i <= 103) {
+    if ($i != 1) {
+        $s .= '&';
+    }
+    $s .= "a$i=$i";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 102) {
+    push @k, "a$i";
+    $i++;
+}
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= " = $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+--- error_log
+lua hit query args limit 102
+--- log_level: debug
+
+
+
+=== TEST 39: custom unlimited args
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ngx.req.get_uri_args(0)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request eval
+my $s = "GET /lua?";
+my $i = 1;
+while ($i <= 105) {
+    if ($i != 1) {
+        $s .= '&';
+    }
+    $s .= "a$i=$i";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 105) {
+    push @k, "a$i";
+    $i++;
+}
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= " = $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+
+
+
+=== TEST 40: rewrite uri and args (multi-value args)
+--- config
+    location /bar {
+        echo $server_protocol $query_string;
+    }
+    location /foo {
+        #rewrite ^ /bar?hello? break;
+        rewrite_by_lua '
+            ngx.req.set_uri_args({a = 3, b = {5, 6}})
+            ngx.req.set_uri("/bar")
+        ';
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT;
+    }
+--- request
+    GET /foo?world
+--- response_body
+HTTP/1.0 a=3&b=5&b=6
+
+
+
+=== TEST 41: ngx.decode_args (sanity)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = "a=bar&b=foo"
+            args = ngx.decode_args(args)
+            ngx.say("a = ", args.a)
+            ngx.say("b = ", args.b)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a = bar
+b = foo
+
+
+
+=== TEST 42: ngx.decode_args (multi-value)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = "a=bar&b=foo&a=baz"
+            args = ngx.decode_args(args)
+            ngx.say("a = ", table.concat(args.a, ", "))
+            ngx.say("b = ", args.b)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a = bar, baz
+b = foo
+
+
+
+=== TEST 43: ngx.decode_args (empty string)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = ""
+            args = ngx.decode_args(args)
+            ngx.say("n = ", #args)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+n = 0
+
+
+
+=== TEST 44: ngx.decode_args (boolean args)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = "a&b"
+            args = ngx.decode_args(args)
+            ngx.say("a = ", args.a)
+            ngx.say("b = ", args.b)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a = true
+b = true
+
+
+
+=== TEST 45: ngx.decode_args (empty value args)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = "a=&b="
+            args = ngx.decode_args(args)
+            ngx.say("a = ", args.a)
+            ngx.say("b = ", args.b)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a = 
+b = 
+
+
+
+=== TEST 46: ngx.decode_args (max_args = 1)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = "a=bar&b=foo"
+            args = ngx.decode_args(args, 1)
+            ngx.say("a = ", args.a)
+            ngx.say("b = ", args.b)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a = bar
+b = nil
+
+
+
+=== TEST 47: ngx.decode_args (max_args = -1)
+--- config
+    location /lua {
+        content_by_lua '
+            local args = "a=bar&b=foo"
+            args = ngx.decode_args(args, -1)
+            ngx.say("a = ", args.a)
+            ngx.say("b = ", args.b)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+a = bar
+b = foo
+
+
+
+=== TEST 48: ngx.decode_args should not modify lua strings in place
+--- config
+    location /lua {
+        content_by_lua '
+            local s = "f+f=bar&B=foo"
+            args = ngx.decode_args(s)
+            for k, v in pairs(args) do
+                ngx.say("key: ", k)
+            end
+            ngx.say("s = ", s)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+key: f f
+key: B
+s = f+f=bar&B=foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 49: ngx.decode_args should not modify lua strings in place (sample from Xu Jian)
+--- config
+    lua_need_request_body on;
+    location /t {
+        content_by_lua '
+            function split(s, delimiter)
+                local result = {}
+                local from = 1
+                local delim_from, delim_to = string.find(s, delimiter, from)
+                while delim_from do
+                    table.insert(result, string.sub(s, from, delim_from - 1))
+                    from = delim_to + 1
+                    delim_from, delim_to = string.find(s, delimiter, from)
+                end
+                table.insert(result, string.sub(s, from))
+                return result
+            end
+
+            local post_data = ngx.req.get_body_data()
+
+            local commands = split(post_data, "||")
+            for _, command in pairs(commands) do
+                --command = ngx.unescape_uri(command)
+                local request_args = ngx.decode_args(command, 0)
+                for key, value in pairs(request_args) do
+                    ngx.say(key, ": ", value)
+                end
+                ngx.say(" ===============")
+            end
+        ';
+    }
+--- request
+POST /t
+method=zadd&key=User%3A1227713%3Alikes%3Atwitters&arg1=1356514698&arg2=780984852||method=zadd&key=User%3A1227713%3Alikes%3Atwitters&arg1=1356514698&arg2=780984852||method=zadd&key=User%3A1227713%3Alikes%3Atwitters&arg1=1356514698&arg2=780984852
+--- response_body
+arg2: 780984852
+method: zadd
+key: User:1227713:likes:twitters
+arg1: 1356514698
+ ===============
+arg2: 780984852
+method: zadd
+key: User:1227713:likes:twitters
+arg1: 1356514698
+ ===============
+arg2: 780984852
+method: zadd
+key: User:1227713:likes:twitters
+arg1: 1356514698
+ ===============
+--- no_error_log
+[error]
+
+
+
+=== TEST 50: recursive rewrite
+--- config
+    rewrite_by_lua '
+        local args = ngx.var.args
+        if args == "jump" then
+            ngx.req.set_uri("/jump",true)
+        end
+    ';
+
+    location /jump {
+        echo "Jump around!";
+    }
+
+    location / {
+        echo "$scheme://$http_host$request_uri";
+    }
+--- request
+GET /?jump
+
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+--- no_error_log
+[alert]
+[crit]
+--- error_log
+rewrite or internal redirection cycle while processing "/jump"
+--- timeout: 10
+--- log_level: debug
+
+
+
+=== TEST 51: boolean values in ngx.encode_args (trailing arg)
+--- config
+    location /lua {
+        set_by_lua $args_str '
+            local t = {a = {32, true}, foo = 3, bar = 5}
+            return ngx.encode_args(t)
+        ';
+        echo $args_str;
+    }
+--- request
+GET /lua
+--- response_body
+foo=3&a=32&a&bar=5
+--- no_error_log
+[error]
+
+
+
+=== TEST 52: false boolean values in ngx.encode_args
+--- config
+    location /lua {
+        set_by_lua $args_str '
+            local t = {a = {32, false}, foo = 3, bar = 5}
+            return ngx.encode_args(t)
+        ';
+        echo $args_str;
+    }
+--- request
+GET /lua
+--- response_body
+foo=3&a=32&bar=5
+--- no_error_log
+[error]
+
+
+
+=== TEST 53: false boolean values in ngx.encode_args (escaping)
+--- config
+    location /lua {
+        set_by_lua $args_str '
+            local t = {["a b"] = {32, false}, foo = 3, bar = 5}
+            return ngx.encode_args(t)
+        ';
+        echo $args_str;
+    }
+--- request
+GET /lua
+--- response_body
+foo=3&a%20b=32&bar=5
+--- no_error_log
+[error]
+
+
+
+=== TEST 54: true boolean values in ngx.encode_args (escaping)
+--- config
+    location /lua {
+        set_by_lua $args_str '
+            local t = {["a b"] = {32, true}, foo = 3, bar = 5}
+            return ngx.encode_args(t)
+        ';
+        echo $args_str;
+    }
+--- request
+GET /lua
+--- response_body
+foo=3&a%20b=32&a%20b&bar=5
+--- no_error_log
+[error]
+
+
+
+=== TEST 55: rewrite uri and args (boolean in multi-value args)
+--- config
+    location /bar {
+        echo $server_protocol $query_string;
+    }
+    location /foo {
+        #rewrite ^ /bar?hello? break;
+        rewrite_by_lua '
+            ngx.req.set_uri_args({a = 3, b = {5, true, 6}})
+            ngx.req.set_uri("/bar")
+        ';
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT;
+    }
+--- request
+    GET /foo?world
+--- response_body
+HTTP/1.0 a=3&b=5&b&b=6
+
+
+
+=== TEST 56: rewrite uri and args (boolean value)
+--- config
+    location /bar {
+        echo $server_protocol $query_string;
+    }
+    location /foo {
+        #rewrite ^ /bar?hello? break;
+        rewrite_by_lua '
+            ngx.req.set_uri_args({a = 3, b = true})
+            ngx.req.set_uri("/bar")
+        ';
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT;
+    }
+--- request
+    GET /foo?world
+--- response_body
+HTTP/1.0 a=3&b
+
diff -rNu a/src/lua/lua-nginx-module/t/031-post-args.t b/src/lua/lua-nginx-module/t/031-post-args.t
--- a/src/lua/lua-nginx-module/t/031-post-args.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/031-post-args.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,326 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2 + 5);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /lua {
+        lua_need_request_body on;
+        content_by_lua '
+            local args = ngx.req.get_post_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+POST /lua
+a=3&b=4&c
+--- response_body
+a = 3
+b = 4
+c = true
+
+
+
+=== TEST 2: lua_need_request_body off
+--- config
+    location /lua {
+        lua_need_request_body off;
+        content_by_lua '
+            local args = ngx.req.get_post_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+POST /lua
+a=3&b=4&c
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 3: empty request body
+--- config
+    location /lua {
+        lua_need_request_body on;
+        content_by_lua '
+            local args = ngx.req.get_post_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                local val = args[key]
+                if type(val) == "table" then
+                    ngx.say(key, ": ", table.concat(val, ", "))
+                else
+                    ngx.say(key, ": ", val)
+                end
+            end
+        ';
+    }
+--- request
+POST /lua
+--- response_body
+
+
+
+=== TEST 4: max args (limited after normal key=value)
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body();
+            local args = ngx.req.get_post_args(2)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+POST /lua
+foo=3&bar=4&baz=2
+--- response_body
+bar = 4
+foo = 3
+--- error_log
+lua hit query args limit 2
+
+
+
+=== TEST 5: max args (limited after an orphan key)
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body();
+            local args = ngx.req.get_post_args(2)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request
+POST /lua
+foo=3&bar&baz=2
+--- response_body
+bar = true
+foo = 3
+--- error_log
+lua hit query args limit 2
+
+
+
+=== TEST 6: max args (limited after an empty key, but non-emtpy values)
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body();
+            local args = ngx.req.get_post_args(2)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+POST /lua
+foo=3&=hello&=world
+--- response_body
+foo = 3
+done
+--- error_log
+lua hit query args limit 2
+
+
+
+=== TEST 7: default max 100 args
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body();
+            local args = ngx.req.get_post_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request eval
+my $s = "POST /lua\n";
+my $i = 1;
+while ($i <= 102) {
+    if ($i != 1) {
+        $s .= '&';
+    }
+    $s .= "a$i=$i";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 100) {
+    push @k, "a$i";
+    $i++;
+}
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= " = $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+--- error_log
+lua hit query args limit 100
+
+
+
+=== TEST 8: custom max 102 args
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+            local args = ngx.req.get_post_args(102)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request eval
+my $s = "POST /lua\n";
+my $i = 1;
+while ($i <= 103) {
+    if ($i != 1) {
+        $s .= '&';
+    }
+    $s .= "a$i=$i";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 102) {
+    push @k, "a$i";
+    $i++;
+}
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= " = $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+--- error_log
+lua hit query args limit 102
+
+
+
+=== TEST 9: custom unlimited args
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.req.read_body()
+            local args = ngx.req.get_post_args(0)
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                ngx.say(key, " = ", args[key])
+            end
+        ';
+    }
+--- request eval
+my $s = "POST /lua\n";
+my $i = 1;
+while ($i <= 105) {
+    if ($i != 1) {
+        $s .= '&';
+    }
+    $s .= "a$i=$i";
+    $i++;
+}
+$s
+--- response_body eval
+my @k;
+my $i = 1;
+while ($i <= 105) {
+    push @k, "a$i";
+    $i++;
+}
+@k = sort @k;
+for my $k (@k) {
+    if ($k =~ /\d+/) {
+        $k .= " = $&\n";
+    }
+}
+CORE::join("", @k);
+--- timeout: 4
+
diff -rNu a/src/lua/lua-nginx-module/t/032-iolist.t b/src/lua/lua-nginx-module/t/032-iolist.t
--- a/src/lua/lua-nginx-module/t/032-iolist.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/032-iolist.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,80 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /lua {
+        content_by_lua '
+            local table = {"hello", nil, true, false, 32.5, 56}
+            ngx.say(table)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+helloniltruefalse32.556
+
+
+
+=== TEST 2: nested table
+--- config
+    location /lua {
+        content_by_lua '
+            local table = {"hello", nil, true, false, 32.5, 56}
+            local table2 = {table, "--", table}
+            ngx.say(table2)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+helloniltruefalse32.556--helloniltruefalse32.556
+
+
+
+=== TEST 3: non-array table
+--- config
+    location /lua {
+        content_by_lua '
+            local table = {foo = 3}
+            ngx.say(table)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
+
+
+=== TEST 4: bad data type in table
+--- config
+    location /lua {
+        content_by_lua '
+            local f = function () return end
+            local table = {1, 3, f}
+            ngx.say(table)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+
diff -rNu a/src/lua/lua-nginx-module/t/033-ctx.t b/src/lua/lua-nginx-module/t/033-ctx.t
--- a/src/lua/lua-nginx-module/t/033-ctx.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/033-ctx.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,392 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3 + 7);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+32
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: rewrite, access, and content
+--- config
+    location /lua {
+        rewrite_by_lua '
+            ngx.say("foo = ", ngx.ctx.foo)
+            ngx.ctx.foo = 76
+        ';
+        access_by_lua '
+            ngx.ctx.foo = ngx.ctx.foo + 3
+        ';
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+foo = nil
+79
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: interal redirect clears ngx.ctx
+--- config
+    location /echo {
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+    location /lua {
+        content_by_lua '
+            ngx.ctx.foo = ngx.var.arg_data
+            -- ngx.say(ngx.ctx.foo)
+            ngx.exec("/echo")
+        ';
+    }
+--- request
+GET /lua?data=hello
+--- response_body
+nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: subrequest has its own ctx
+--- config
+    location /sub {
+        content_by_lua '
+            ngx.say("sub pre: ", ngx.ctx.blah)
+            ngx.ctx.blah = 32
+            ngx.say("sub post: ", ngx.ctx.blah)
+        ';
+    }
+    location /main {
+        content_by_lua '
+            ngx.ctx.blah = 73
+            ngx.say("main pre: ", ngx.ctx.blah)
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+            ngx.say("main post: ", ngx.ctx.blah)
+        ';
+    }
+--- request
+    GET /main
+--- response_body
+main pre: 73
+sub pre: nil
+sub post: 32
+main post: 73
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: overriding ctx
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.ctx = { foo = 32, bar = 54 };
+            ngx.say(ngx.ctx.foo)
+            ngx.say(ngx.ctx.bar)
+
+            ngx.ctx = { baz = 56  };
+            ngx.say(ngx.ctx.foo)
+            ngx.say(ngx.ctx.baz)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+32
+54
+nil
+56
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: header filter
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.say(ngx.ctx.foo)
+        ';
+        header_filter_by_lua '
+            ngx.header.blah = ngx.ctx.foo + 1
+        ';
+    }
+--- request
+GET /lua
+--- response_headers
+blah: 33
+--- response_body
+32
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: capture_multi
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.ctx.dog)
+        ';
+    }
+
+    location /lua {
+        set $dog 'blah';
+        set $cat 'foo';
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                {"/other/1",
+                    { ctx = { dog = "hello" }}
+                },
+                {"/other/2",
+                    { ctx = { dog = "hiya" }}
+                }
+            };
+
+            ngx.print(res1.body)
+            ngx.print(res2.body)
+            ngx.say("parent: ", ngx.ctx.dog)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+dog = hello
+dog = hiya
+parent: nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: set_by_lua
+--- config
+    location /lua {
+        set_by_lua $bar 'ngx.ctx.foo = 3 return 4';
+        set_by_lua $foo 'return ngx.ctx.foo';
+        echo "foo = $foo, bar = $bar";
+    }
+--- request
+GET /lua
+--- response_body
+foo = 3, bar = 4
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: ngx.ctx leaks with ngx.exec + log_by_lua
+--- config
+    location = /t {
+        content_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.exec("/f")
+        ';
+        log_by_lua 'ngx.log(ngx.WARN, "ctx.foo = ", ngx.ctx.foo)';
+    }
+    location = /f {
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+nil
+--- no_error_log
+[error]
+ctx.foo = 
+
+
+
+=== TEST 10: memory leaks with ngx.ctx + ngx.req.set_uri + log_by_lua
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.req.set_uri("/f", true)
+        ';
+        log_by_lua 'ngx.log(ngx.WARN, "ctx.foo = ", ngx.ctx.foo)';
+    }
+    location = /f {
+        content_by_lua '
+            ngx.say(ngx.ctx.foo)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+nil
+--- no_error_log
+[error]
+ctx.foo = 
+
+
+
+=== TEST 11: ngx.ctx + ngx.exit(ngx.ERROR) + log_by_lua
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.exit(ngx.ERROR)
+        ';
+        log_by_lua 'ngx.log(ngx.WARN, "ngx.ctx = ", ngx.ctx.foo)';
+    }
+--- request
+GET /t
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+ngx.ctx = 32
+
+
+
+=== TEST 12: ngx.ctx + ngx.exit(200) + log_by_lua
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.say(ngx.ctx.foo)
+            ngx.exit(200)
+        ';
+        log_by_lua 'ngx.log(ngx.WARN, "ctx.foo = ", ngx.ctx.foo)';
+    }
+--- request
+GET /t
+--- response_body
+32
+--- no_error_log
+[error]
+--- error_log
+ctx.foo = 32
+
+
+
+=== TEST 13: ngx.ctx + ngx.redirect + log_by_lua
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.redirect("/f")
+        ';
+        log_by_lua 'ngx.log(ngx.WARN, "ngx.ctx.foo = ", 32)';
+    }
+--- request
+GET /t
+--- response_body_like: 302 Found
+--- error_code: 302
+--- error_log
+ctx.foo = 32
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: set ngx.ctx before internal redirects performed by other nginx modules
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.ctx.foo = "hello world";
+        ';
+        echo_exec /foo;
+    }
+
+    location = /foo {
+        echo hello;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua release ngx.ctx at ref
+
+
+
+=== TEST 15: set ngx.ctx before internal redirects performed by other nginx modules (with log_by_lua)
+--- config
+    location = /t {
+        rewrite_by_lua '
+            ngx.ctx.foo = "hello world";
+        ';
+        echo_exec /foo;
+    }
+
+    location = /foo {
+        echo hello;
+        log_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua release ngx.ctx at ref
+
+
+
+=== TEST 16: set ngx.ctx before simple uri rewrite performed by other nginx modules
+--- config
+    location = /t {
+        set_by_lua $a 'ngx.ctx.foo = "hello world"; return 1';
+        rewrite ^ /foo last;
+        echo blah;
+    }
+
+    location = /foo {
+        echo foo;
+    }
+--- request
+GET /t
+--- response_body
+foo
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua release ngx.ctx at ref
+
diff -rNu a/src/lua/lua-nginx-module/t/034-match.t b/src/lua/lua-nginx-module/t/034-match.t
--- a/src/lua/lua-nginx-module/t/034-match.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/034-match.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1095 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 14);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 2: escaping sequences
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "(\\\\d+)")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 3: escaping sequences (bad)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "(\\d+)")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like: 500 Internal Server Error
+--- error_log eval
+[qr/invalid escape sequence near '"\('/]
+--- error_code: 500
+
+
+
+=== TEST 4: escaping sequences in [[ ... ]]
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "[[\\d+]]")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like: 500 Internal Server Error
+--- error_log eval
+[qr/invalid escape sequence near '"\[\['/]
+--- error_code: 500
+
+
+
+=== TEST 5: single capture
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]{2})[0-9]+")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+12
+
+
+
+=== TEST 6: multiple captures
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([a-z]+).*?([0-9]{2})[0-9]+", "")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+12
+
+
+
+=== TEST 7: multiple captures (with o)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([a-z]+).*?([0-9]{2})[0-9]+", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+12
+
+
+
+=== TEST 8: not matched
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "foo")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched: nil
+
+
+
+=== TEST 9: case sensitive by default
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "HELLO")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched: nil
+
+
+
+=== TEST 10: case sensitive by default
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "HELLO", "i")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 11: UTF-8 mode
+--- config
+    location /re {
+        content_by_lua '
+            rc, err = pcall(ngx.re.match, "hello章亦春", "HELLO.{2}", "iu")
+            if not rc then
+                ngx.say("FAIL: ", err)
+                return
+            end
+            local m = err
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like chop
+^(?:FAIL: bad argument \#2 to '\?' \(pcre_compile\(\) failed: this version of PCRE is not compiled with PCRE_UTF8 support in "HELLO\.\{2\}" at "HELLO\.\{2\}"\)|hello章亦)$
+
+
+
+=== TEST 12: multi-line mode (^ at line head)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", "^world", "m")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+world
+
+
+
+=== TEST 13: multi-line mode (. does not match \n)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", ".*", "m")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 14: single-line mode (^ as normal)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", "^world", "s")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched: nil
+
+
+
+=== TEST 15: single-line mode (dot all)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", ".*", "s")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+
+
+
+=== TEST 16: extended mode (ignore whitespaces)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", "\\\\w     \\\\w", "x")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+he
+
+
+
+=== TEST 17: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local m, err = ngx.re.match("hello\\nworld", "(abc")
+            if m then
+                ngx.say(m[0])
+
+            else
+                if err then
+                    ngx.say("error: ", err)
+
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: bad option
+--- config
+    location /re {
+        content_by_lua '
+            rc, m = pcall(ngx.re.match, "hello\\nworld", ".*", "H")
+            if rc then
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            else
+                ngx.say("error: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like chop
+error: .*?unknown flag "H"
+
+
+
+=== TEST 19: extended mode (ignore whitespaces)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, world", "(world)|(hello)", "x")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+nil
+hello
+
+
+
+=== TEST 20: optional trailing captures
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)(h?)")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body eval
+"1234
+1234
+
+"
+
+
+
+=== TEST 21: anchored match (failed)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)", "a")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched!
+
+
+
+=== TEST 22: anchored match (succeeded)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("1234, hello", "([0-9]+)", "a")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 23: match with ctx but no pos
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = {}
+            m = ngx.re.match("1234, hello", "([0-9]+)", "", ctx)
+            if m then
+                ngx.say(m[0])
+                ngx.say(ctx.pos)
+            else
+                ngx.say("not matched!")
+                ngx.say(ctx.pos)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+4
+
+
+
+=== TEST 24: match with ctx and a pos
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = { pos = 2 }
+            m = ngx.re.match("1234, hello", "([0-9]+)", "", ctx)
+            if m then
+                ngx.say(m[0])
+                ngx.say(ctx.pos)
+            else
+                ngx.say("not matched!")
+                ngx.say(ctx.pos)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+34
+4
+
+
+
+=== TEST 25: sanity (set_by_lua)
+--- config
+    location /re {
+        set_by_lua $res '
+            m = ngx.re.match("hello, 1234", "([0-9]+)")
+            if m then
+                return m[0]
+            else
+                return "not matched!"
+            end
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 26: match (look-behind assertion)
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = {}
+            local m = ngx.re.match("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz", "", ctx)
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz", "", ctx)
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+bar
+baz
+
+
+
+=== TEST 27: escaping sequences
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+--- user_files
+>>> a.lua
+m = ngx.re.match("hello, 1234", "(\\\s+)")
+if m then
+    ngx.say("[", m[0], "]")
+else
+    ngx.say("not matched!")
+end
+--- request
+    GET /re
+--- response_body_like: 500 Internal Server Error
+--- error_log eval
+[qr/invalid escape sequence near '"\(\\'/]
+--- error_code: 500
+
+
+
+=== TEST 28: escaping sequences
+--- config
+    location /re {
+        access_by_lua_file html/a.lua;
+        content_by_lua return;
+    }
+--- user_files
+>>> a.lua
+local uri = "<impact>2</impact>"
+local regex = '(?:>[\\w\\s]*</?\\w{2,}>)';
+ngx.say("regex: ", regex)
+m = ngx.re.match(uri, regex, "oi")
+if m then
+    ngx.say("[", m[0], "]")
+else
+    ngx.say("not matched!")
+end
+--- request
+    GET /re
+--- response_body
+regex: (?:>[\w\s]*</?\w{2,}>)
+[>2</impact>]
+
+
+
+=== TEST 29: long brackets
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", [[\\d+]])
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 30: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local m, err = ngx.re.match("hello, 1234", "([0-9]+")
+            if m then
+                ngx.say(m[0])
+
+            else
+                if err then
+                    ngx.say("error: ", err)
+
+                else
+                    ngx.say("not matched!")
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "([0-9]+"
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 31: long brackets containing [...]
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", [[([0-9]+)]])
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 32: bug report (github issue #72)
+--- config
+    location /re {
+        content_by_lua '
+            ngx.re.match("hello", "hello", "j")
+            ngx.say("done")
+        ';
+        header_filter_by_lua '
+            ngx.re.match("hello", "world", "j")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+
+
+
+=== TEST 33: bug report (github issue #72)
+--- config
+    location /re {
+        content_by_lua '
+            ngx.re.match("hello", "hello", "j")
+            ngx.exec("/foo")
+        ';
+    }
+
+    location /foo {
+        content_by_lua '
+            ngx.re.match("hello", "world", "j")
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+
+
+
+=== TEST 34: non-empty subject, empty pattern
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = {}
+            local m = ngx.re.match("hello, 1234", "", "", ctx)
+            if m then
+                ngx.say("pos: ", ctx.pos)
+                ngx.say("m: ", m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+pos: 0
+m: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 35: named subpatterns w/ extraction
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "(?<first>[a-z]+), [0-9]+")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m.first)
+                ngx.say(m.second)
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+hello
+nil
+
+
+
+=== TEST 36: duplicate named subpatterns w/ extraction
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "(?<first>[a-z]+), (?<first>[0-9]+)", "D")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(table.concat(m.first,"-"))
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+1234
+hello-1234
+
+
+
+=== TEST 37: named captures are empty strings
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("1234", "(?<first>[a-z]*)([0-9]+)")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m.first)
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+1234
+
+
+
+=== TEST 38: named captures are nil
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, world", "(world)|(hello)|(?<named>howdy)")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(m[3])
+                ngx.say(m["named"])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+nil
+hello
+nil
+nil
+
+
+
+=== TEST 39: duplicate named subpatterns
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, world",
+                                   "(?<named>\\\\w+), (?<named>\\\\w+)",
+                                   "D")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(table.concat(m.named,"-"))
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world
+hello
+world
+hello-world
+--- no_error_log
+[error]
+
+
+
+=== TEST 40: Javascript compatible mode
+--- config
+    location /t {
+        content_by_lua '
+            local m = ngx.re.match("章", [[\\u7AE0]], "uJ")
+            if m then
+                ngx.say("matched: ", m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+matched: 章
+--- no_error_log
+[error]
+
+
+
+=== TEST 41: empty duplicate captures
+--- config
+    location = /t {
+        content_by_lua "
+            local target = 'test'
+            local regex = '^(?:(?<group1>(?:foo))|(?<group2>(?:bar))|(?<group3>(?:test)))$'
+
+            -- Note the D here
+            local m = ngx.re.match(target, regex, 'D')
+
+            ngx.say(type(m.group1))
+            ngx.say(type(m.group2))
+        ";
+    }
+--- request
+GET /t
+--- response_body
+nil
+nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 42: bad UTF-8
+--- config
+    location = /t {
+        content_by_lua '
+            local target = "你好"
+            local regex = "你好"
+
+            -- Note the D here
+            local m, err = ngx.re.match(string.sub(target, 1, 4), regex, "u")
+
+            if err then
+                ngx.say("error: ", err)
+                return
+            end
+
+            if m then
+                ngx.say("matched: ", m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body_like chop
+^error: pcre_exec\(\) failed: -10$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 43: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("你好", ".", "U")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
+
+
+=== TEST 44: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("你好", ".", "u")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
+
+
+=== TEST 45: just hit match limit
+--- http_config
+    lua_regex_match_limit 5600;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local res, err = ngx.re.match(s, re, "o")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if not res then
+    if err then
+        ngx.say("error: ", err)
+        return
+    end
+    ngx.say("failed to match")
+    return
+end
+
+--- request
+    GET /re
+--- response_body
+error: pcre_exec() failed: -8
+
+
+
+=== TEST 46: just not hit match limit
+--- http_config
+    lua_regex_match_limit 5700;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local res, err = ngx.re.match(s, re, "o")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if not res then
+    if err then
+        ngx.say("error: ", err)
+        return
+    end
+    ngx.say("failed to match")
+    return
+end
+
+--- request
+    GET /re
+--- response_body
+failed to match
+
diff -rNu a/src/lua/lua-nginx-module/t/035-gmatch.t b/src/lua/lua-nginx-module/t/035-gmatch.t
--- a/src/lua/lua-nginx-module/t/035-gmatch.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/035-gmatch.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,905 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(5);
+
+plan tests => repeat_each() * (blocks() * 2 + 7);
+
+our $HtmlDir = html_dir;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: gmatch
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello, world", "[a-z]+") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+
+
+
+=== TEST 2: fail to match
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[0-9]")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+nil
+nil
+nil
+
+
+
+=== TEST 3: match but iterate more times (not just match at the end)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world!", "[a-z]+")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+nil
+nil
+
+
+
+=== TEST 4: match but iterate more times (just matched at the end)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+nil
+nil
+
+
+
+=== TEST 5: anchored match (failed)
+--- config
+    location /re {
+        content_by_lua '
+            it = ngx.re.gmatch("hello, 1234", "([0-9]+)", "a")
+            ngx.say(it())
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+nil
+
+
+
+=== TEST 6: anchored match (succeeded)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("12 hello 34", "[0-9]", "a")
+            local m = it()
+            ngx.say(m[0])
+            m = it()
+            ngx.say(m[0])
+            ngx.say(it())
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1
+2
+nil
+
+
+
+=== TEST 7: non-anchored gmatch (without regex cache)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("12 hello 34", "[0-9]")
+            local m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1
+2
+3
+4
+nil
+
+
+
+=== TEST 8: non-anchored gmatch (with regex cache)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("12 hello 34", "[0-9]", "o")
+            local m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+            m = it()
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1
+2
+3
+4
+nil
+
+
+
+=== TEST 9: anchored match (succeeded)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("12 hello 34", "[0-9]", "a")
+            local m = it()
+            ngx.say(m[0])
+            m = it()
+            ngx.say(m[0])
+            ngx.say(it())
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1
+2
+nil
+
+
+
+=== TEST 10: anchored match (succeeded, set_by_lua)
+--- config
+    location /re {
+        set_by_lua $res '
+            local it = ngx.re.gmatch("12 hello 34", "[0-9]", "a")
+            local m = it()
+            return m[0]
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+1
+
+
+
+=== TEST 11: gmatch (look-behind assertion)
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("{foobar}, {foobaz}", "(?<=foo)ba[rz]") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+bar
+baz
+
+
+
+=== TEST 12: gmatch (look-behind assertion 2)
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+bar
+baz
+
+
+
+=== TEST 13: with regex cache
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, 1234", "([A-Z]+)", "io")
+            local m = it()
+            ngx.say(m and m[0])
+
+            it = ngx.re.gmatch("1234, okay", "([A-Z]+)", "io")
+            m = it()
+            ngx.say(m and m[0])
+
+            it = ngx.re.gmatch("hi, 1234", "([A-Z]+)", "o")
+            m = it()
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- stap2
+F(ngx_http_lua_ngx_re_gmatch_iterator) { println("iterator") }
+F(ngx_http_lua_ngx_re_gmatch_gc) { println("gc") }
+F(ngx_http_lua_ngx_re_gmatch_cleanup) { println("cleanup") }
+--- response_body
+hello
+okay
+nil
+
+
+
+=== TEST 14: exceeding regex cache max entries
+--- http_config
+    lua_regex_cache_max_entries 2;
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, 1234", "([0-9]+)", "o")
+            local m = it()
+            ngx.say(m and m[0])
+
+            it = ngx.re.gmatch("howdy, 567", "([0-9]+)", "oi")
+            m = it()
+            ngx.say(m and m[0])
+
+            it = ngx.re.gmatch("hiya, 98", "([0-9]+)", "ox")
+            m = it()
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+567
+98
+
+
+
+=== TEST 15: disable regex cache completely
+--- http_config
+    lua_regex_cache_max_entries 0;
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, 1234", "([0-9]+)", "o")
+            local m = it()
+            ngx.say(m and m[0])
+
+            it = ngx.re.gmatch("howdy, 567", "([0-9]+)", "oi")
+            local m = it()
+            ngx.say(m and m[0])
+
+            it = ngx.re.gmatch("hiya, 98", "([0-9]+)", "ox")
+            local m = it()
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+567
+98
+
+
+
+=== TEST 16: gmatch matched but no iterate
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+")
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+
+
+
+=== TEST 17: gmatch matched but only iterate once and still matches remain
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 18: gmatch matched but no iterate and early forced GC
+--- config
+    location /re {
+        content_by_lua '
+            local a = {}
+            for i = 1, 3 do
+                it = ngx.re.gmatch("hello, world", "[a-z]+")
+                it()
+                collectgarbage()
+                table.insert(a, {"hello", "world"})
+            end
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+
+
+
+=== TEST 19: gmatch iterator used by another request
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;;';"
+--- config
+    location /main {
+        content_by_lua '
+            package.loaded.foo = nil
+
+            local res = ngx.location.capture("/t")
+            if res.status == 200 then
+                ngx.print(res.body)
+            else
+                ngx.say("sr failed: ", res.status)
+            end
+
+            res = ngx.location.capture("/t")
+            if res.status == 200 then
+                ngx.print(res.body)
+            else
+                ngx.say("sr failed: ", res.status)
+            end
+        ';
+    }
+
+    location /t {
+        content_by_lua '
+            local foo = require "foo"
+            local m = foo.go()
+            ngx.say(m and "matched" or "no")
+        ';
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+local it
+
+function go()
+    if not it then
+        it = ngx.re.gmatch("hello, world", "[a-z]+")
+    end
+
+    return it()
+end
+--- request
+    GET /main
+--- response_body
+matched
+sr failed: 500
+--- error_log
+attempt to use ngx.re.gmatch iterator in a request that did not create it
+
+
+
+=== TEST 20: gmatch (empty matched string)
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello", "a|") do
+                if m then
+                    ngx.say("matched: [", m[0], "]")
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+matched: []
+matched: []
+matched: []
+matched: []
+matched: []
+matched: []
+
+
+
+=== TEST 21: gmatch with named pattern
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("1234, 1234", "(?<first>[0-9]+)")
+            m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m["first"])
+            else
+                ngx.say("not matched!")
+            end
+
+            m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m["first"])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+1234
+1234
+1234
+1234
+1234
+
+
+
+=== TEST 22: gmatch with multiple named pattern
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("1234, abcd, 1234", "(?<first>[0-9]+)|(?<second>[a-z]+)")
+
+            m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(m["first"])
+                ngx.say(m["second"])
+            else
+                ngx.say("not matched!")
+            end
+
+            m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(m["first"])
+                ngx.say(m["second"])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+1234
+nil
+1234
+nil
+abcd
+nil
+abcd
+nil
+abcd
+
+
+
+=== TEST 23: gmatch with duplicate named pattern w/ extraction
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, 1234", "(?<first>[a-z]+), (?<first>[0-9]+)", "D")
+            m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(table.concat(m.first,"-"))
+            else
+                ngx.say("not matched!")
+            end
+
+            m = it()
+            if m then
+             ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(table.concat(m.first,"-"))
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+1234
+hello-1234
+not matched!
+
+
+
+=== TEST 24: named captures are empty
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("1234", "(?<first>[a-z]*)([0-9]+)", "")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m.first)
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+1234
+
+
+
+=== TEST 25: named captures are empty (with regex cache)
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("1234", "(?<first>[a-z]*)([0-9]+)", "o")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+                ngx.say(m.first)
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+1234
+
+
+
+=== TEST 26: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local it, err = ngx.re.gmatch("hello\\nworld", "(abc")
+            if not err then
+                ngx.say("good")
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 27: bad UTF-8
+--- config
+    location = /t {
+        content_by_lua '
+            local target = "你好"
+            local regex = "你好"
+
+            -- Note the D here
+            local it, err = ngx.re.gmatch(string.sub(target, 1, 4), regex, "u")
+
+            if err then
+                ngx.say("error: ", err)
+                return
+            end
+
+            local m, err = it()
+            if err then
+                ngx.say("error: ", err)
+                return
+            end
+
+            if m then
+                ngx.say("matched: ", m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body_like chop
+error: pcre_exec\(\) failed: -10
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 28: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("你好", ".", "U")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
+
+
+=== TEST 29: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("你好", ".", "u")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
+
+
+=== TEST 30: just hit match limit
+--- http_config
+    lua_regex_match_limit 5600;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local it, err = ngx.re.gmatch(s, re, "o")
+if not it then
+    ngx.say("failed to gen iterator: ", err)
+    return
+end
+
+local res, err = it()
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if not res then
+    if err then
+        ngx.say("error: ", err)
+        return
+    end
+    ngx.say("failed to match")
+    return
+end
+
+--- request
+    GET /re
+--- response_body
+error: pcre_exec() failed: -8
+
+
+
+=== TEST 31: just not hit match limit
+--- http_config
+    lua_regex_match_limit 5700;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local it, err = ngx.re.gmatch(s, re, "o")
+if not it then
+    ngx.say("failed to gen iterator: ", err)
+    return
+end
+
+res, err = it()
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if not res then
+    if err then
+        ngx.say("error: ", err)
+        return
+    end
+    ngx.say("failed to match")
+    return
+end
+
+--- request
+    GET /re
+--- response_body
+failed to match
+
diff -rNu a/src/lua/lua-nginx-module/t/036-sub.t b/src/lua/lua-nginx-module/t/036-sub.t
--- a/src/lua/lua-nginx-module/t/036-sub.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/036-sub.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,647 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 13);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched but w/o variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[a-z]+", "howdy")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+howdy, world
+1
+
+
+
+=== TEST 2: not matched
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[A-Z]+", "howdy")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world
+0
+
+
+
+=== TEST 3: matched and with variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("a b c d", "(b) (c)", "[$0] [$1] [$2] [$3] [$134]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] [] [] d
+1
+
+
+
+=== TEST 4: matched and with named variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("a b c d",
+                "(b) (c)", "[$0] [$1] [$2] [$3] [$hello]")
+            if s then
+                ngx.say(s, ": ", n)
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+attempt to use named capturing variable "hello" (named captures not supported yet)
+
+
+
+=== TEST 5: matched and with named variables (bracketed)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("a b c d",
+                "(b) (c)", "[$0] [$1] [$2] [$3] [${hello}]")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+attempt to use named capturing variable "hello" (named captures not supported yet)
+
+
+
+=== TEST 6: matched and with bracketed variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${134}]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[b c] [b] [c] [] [] d
+1
+
+
+
+=== TEST 7: matched and with bracketed variables (unmatched brackets)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${134]")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+the closing bracket in "134" variable is missing
+
+
+
+=== TEST 8: matched and with bracketed variables (unmatched brackets)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${134")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+the closing bracket in "134" variable is missing
+
+
+
+=== TEST 9: matched and with bracketed variables (unmatched brackets)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+lua script: invalid capturing variable name found in "[$0] [$1] [${2}] [$3] [${"
+
+
+
+=== TEST 10: trailing $
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [$")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+lua script: invalid capturing variable name found in "[$0] [$1] [${2}] [$3] [$"
+
+
+
+=== TEST 11: matched but w/o variables and with literal $
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[a-z]+", "ho$$wdy")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+ho$wdy, world
+1
+
+
+
+=== TEST 12: non-anchored match
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "[0-9]", "x")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, x234
+1
+
+
+
+=== TEST 13: anchored match
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "[0-9]", "x", "a")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+0
+
+
+
+=== TEST 14: function replace
+--- config
+    location /re {
+        content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "] [" .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.sub("hello, 34", "([0-9])", repl)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, [3] [3]4
+1
+
+
+
+=== TEST 15: function replace (failed)
+--- config
+    location /re {
+        content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "] [" .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.sub("hello, 34", "([A-Z])", repl)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 34
+0
+
+
+
+=== TEST 16: bad repl arg type
+--- config
+    location /re {
+        content_by_lua '
+            local rc, s, n = pcall(ngx.re.sub, "hello, 34", "([A-Z])", true)
+            ngx.say(rc)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+false
+bad argument #3 to '?' (string, number, or function expected, got boolean)
+nil
+
+
+
+=== TEST 17: use number to replace
+--- config
+    location /re {
+        content_by_lua '
+            local rc, s, n = pcall(ngx.re.sub, "hello, 34", "([0-9])", 72)
+            ngx.say(rc)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+true
+hello, 724
+1
+
+
+
+=== TEST 18: bad function return value type
+--- config
+    location /re {
+        content_by_lua '
+            local f = function (m) end
+            local rc, s, n = pcall(ngx.re.sub, "hello, 34", "([0-9])", f)
+            ngx.say(rc)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+false
+bad argument #3 to '?' (string or number expected to be returned by the replace function, got nil)
+nil
+
+
+
+=== TEST 19: matched but w/o variables (set_by_lua)
+--- config
+    location /re {
+        set_by_lua $res '
+            local s, n = ngx.re.sub("hello, world", "[a-z]+", "howdy")
+            return s
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+howdy, world
+
+
+
+=== TEST 20: matched and with variables w/o using named patterns in sub
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("a b c d", "(?<first>b) (?<second>c)", "[$0] [$1] [$2] [$3] [$134]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] [] [] d
+1
+
+
+
+=== TEST 21: matched and with variables using named patterns in func
+--- config
+    error_log /tmp/nginx_error debug;
+    location /re {
+        content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "] [" .. m["first"] .. "] [" .. m[2] .. "]"
+            end
+
+            local s, n = ngx.re.sub("a b c d", "(?<first>b) (?<second>c)", repl)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] d
+1
+
+
+
+=== TEST 22: matched and with variables w/ using named patterns in sub
+This is still a TODO
+--- SKIP
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("a b c d", "(?<first>b) (?<second>c)", "[$0] [${first}] [${second}] [$3] [$134]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] [] [] d
+1
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: $0 without parens
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("a b c d", [[\w]], "[$0]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[a] b c d
+1
+--- no_error_log
+[error]
+
+
+
+=== TEST 24: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("hello\\nworld", "(abc", "")
+            if s then
+                ngx.say("subs: ", n)
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 25: bad UTF-8
+--- config
+    location = /t {
+        content_by_lua '
+            local target = "你好"
+            local regex = "你好"
+
+            -- Note the D here
+            local s, n, err = ngx.re.sub(string.sub(target, 1, 4), regex, "", "u")
+
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body_like chop
+error: pcre_exec\(\) failed: -10
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 26: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("你好", ".", "a", "U")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+s: a好
+--- no_error_log
+[error]
+
+
+
+=== TEST 27: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("你好", ".", "a", "u")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+s: a好
+--- no_error_log
+[error]
+
+
+
+=== TEST 28: just hit match limit
+--- http_config
+    lua_regex_match_limit 5600;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local res, cnt, err = ngx.re.sub(s, re, "", "o")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if err then
+    ngx.say("error: ", err)
+    return
+end
+ngx.say("sub: ", cnt)
+
+--- request
+    GET /re
+--- response_body
+error: pcre_exec() failed: -8
+
+
+
+=== TEST 29: just not hit match limit
+--- http_config
+    lua_regex_match_limit 5700;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+local s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local res, cnt, err = ngx.re.sub(s, re, "", "o")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if err then
+    ngx.say("error: ", err)
+    return
+end
+ngx.say("sub: ", cnt)
+
+--- request
+    GET /re
+--- response_body
+sub: 0
+
diff -rNu a/src/lua/lua-nginx-module/t/037-gsub.t b/src/lua/lua-nginx-module/t/037-gsub.t
--- a/src/lua/lua-nginx-module/t/037-gsub.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/037-gsub.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,575 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 14);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("[hello, world]", "[a-z]+", "howdy")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[howdy, howdy]
+2
+
+
+
+=== TEST 2: trimmed
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[a-z]+", "howdy")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+howdy, howdy
+2
+
+
+
+=== TEST 3: not matched
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[A-Z]+", "howdy")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world
+0
+
+
+
+=== TEST 4: replace by function (trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local f = function (m)
+                return "[" .. m[0] .. "," .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", f)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[hello,h], [world,w]
+2
+
+
+
+=== TEST 5: replace by function (not trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local f = function (m)
+                return "[" .. m[0] .. "," .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("{hello, world}", "([a-z])[a-z]+", f)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+{[hello,h], [world,w]}
+2
+
+
+
+=== TEST 6: replace by script (trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[hello,h], [world,w]
+2
+
+
+
+=== TEST 7: replace by script (not trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("{hello, world}", "([a-z])[a-z]+", "[$0,$1]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+{[hello,h], [world,w]}
+2
+
+
+
+=== TEST 8: set_by_lua
+--- config
+    location /re {
+        set_by_lua $res '
+            local f = function (m)
+                return "[" .. m[0] .. "," .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("{hello, world}", "([a-z])[a-z]+", f)
+            return s
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+{[hello,h], [world,w]}
+
+
+
+=== TEST 9: look-behind assertion
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz", "h$0")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+{foohbarhbaz}
+2
+
+
+
+=== TEST 10: gsub with a patch matching an empty substring (string template)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello", "a|", "b")
+            ngx.say("s: ", s)
+            ngx.say("n: ", n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+s: bhbeblblbob
+n: 6
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: gsub with a patch matching an empty substring (string template, empty subj)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("", "a|", "b")
+            ngx.say("s: ", s)
+            ngx.say("n: ", n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+s: b
+n: 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: gsub with a patch matching an empty substring (func)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello", "a|", function () return "b" end)
+            ngx.say("s: ", s)
+            ngx.say("n: ", n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+s: bhbeblblbob
+n: 6
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: gsub with a patch matching an empty substring (func, empty subj)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("", "a|", function () return "b" end)
+            ngx.say("s: ", s)
+            ngx.say("n: ", n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+s: b
+n: 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: big subject string exceeding the luabuf chunk size (with trailing unmatched data, func repl)
+--- config
+    location /re {
+        content_by_lua '
+            local subj = string.rep("a", 8000)
+                .. string.rep("b", 1000)
+                .. string.rep("a", 8000)
+                .. string.rep("b", 1000)
+                .. "aaa"
+
+            local function repl(m)
+                return string.rep("c", string.len(m[0]))
+            end
+
+            local s, n = ngx.re.gsub(subj, "b+", repl)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body eval
+("a" x 8000) . ("c" x 1000) . ("a" x 8000) . ("c" x 1000)
+. "aaa
+2
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: big subject string exceeding the luabuf chunk size (without trailing unmatched data, func repl)
+--- config
+    location /re {
+        content_by_lua '
+            local subj = string.rep("a", 8000)
+                .. string.rep("b", 1000)
+                .. string.rep("a", 8000)
+                .. string.rep("b", 1000)
+
+            local function repl(m)
+                return string.rep("c", string.len(m[0]))
+            end
+
+            local s, n = ngx.re.gsub(subj, "b+", repl)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body eval
+("a" x 8000) . ("c" x 1000) . ("a" x 8000) . ("c" x 1000)
+. "\n2\n"
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: big subject string exceeding the luabuf chunk size (with trailing unmatched data, str repl)
+--- config
+    location /re {
+        content_by_lua '
+            local subj = string.rep("a", 8000)
+                .. string.rep("b", 1000)
+                .. string.rep("a", 8000)
+                .. string.rep("b", 1000)
+                .. "aaa"
+
+            local s, n = ngx.re.gsub(subj, "b(b+)(b)", "$1 $2")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body eval
+("a" x 8000) . ("b" x 998) . " b" . ("a" x 8000) . ("b" x 998) . " baaa
+2
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: big subject string exceeding the luabuf chunk size (without trailing unmatched data, str repl)
+--- config
+    location /re {
+        content_by_lua '
+            local subj = string.rep("a", 8000)
+                .. string.rep("b", 1000)
+                .. string.rep("a", 8000)
+                .. string.rep("b", 1000)
+
+            local s, n = ngx.re.gsub(subj, "b(b+)(b)", "$1 $2")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body eval
+("a" x 8000) . ("b" x 998) . " b" . ("a" x 8000) . ("b" x 998) . " b\n2\n"
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: named pattern repl w/ callback
+--- config
+    location /re {
+       content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "," .. m["first"] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("hello, world", "(?<first>[a-z])[a-z]+", repl)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[hello,h], [world,w]
+2
+
+
+
+=== TEST 19: $0 without parens
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("a b c d", [[\w]], "[$0]")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[a] [b] [c] [d]
+4
+--- no_error_log
+[error]
+
+
+
+=== TEST 20: bad UTF-8
+--- config
+    location = /t {
+        content_by_lua '
+            local target = "你好"
+            local regex = "你好"
+
+            -- Note the D here
+            local s, n, err = ngx.re.gsub(string.sub(target, 1, 4), regex, "", "u")
+
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+       ';
+    }
+--- request
+GET /t
+--- response_body_like chop
+error: pcre_exec\(\) failed: -10
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("你好", ".", "a", "U")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+exec opts: 2000
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+s: aa
+--- no_error_log
+[error]
+
+
+
+=== TEST 22: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("你好", ".", "a", "u")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+exec opts: 0
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+s: aa
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: just hit match limit
+--- http_config
+    lua_regex_match_limit 5600;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local res, cnt, err = ngx.re.gsub(s, re, "", "o")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if err then
+    ngx.say("error: ", err)
+    return
+end
+ngx.say("gsub: ", cnt)
+
+--- request
+    GET /re
+--- response_body
+error: pcre_exec() failed: -8
+
+
+
+=== TEST 24: just not hit match limit
+--- http_config
+    lua_regex_match_limit 5700;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+local s = string.rep([[ABCDEFG]], 10)
+
+local start = ngx.now()
+
+local res, cnt, err = ngx.re.gsub(s, re, "", "o")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if err then
+    ngx.say("error: ", err)
+    return
+end
+ngx.say("gsub: ", cnt)
+
+--- request
+    GET /re
+--- response_body
+gsub: 0
+--- timeout: 10
+
diff -rNu a/src/lua/lua-nginx-module/t/038-match-o.t b/src/lua/lua-nginx-module/t/038-match-o.t
--- a/src/lua/lua-nginx-module/t/038-match-o.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/038-match-o.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,744 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)", "o")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 2: escaping sequences
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "(\\\\d+)", "o")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 3: escaping sequences (bad)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "(\\d+)", "o")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+[qr/invalid escape sequence near '"\('/]
+
+
+
+=== TEST 4: escaping sequences in [[ ... ]]
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "[[\\d+]]", "o")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log eval
+[qr/invalid escape sequence near '"\[\['/]
+
+
+
+=== TEST 5: single capture
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]{2})[0-9]+", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+12
+
+
+
+=== TEST 6: multiple captures
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([a-z]+).*?([0-9]{2})[0-9]+", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+12
+
+
+
+=== TEST 7: not matched
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "foo", "o")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched: nil
+
+
+
+=== TEST 8: case sensitive by default
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "HELLO", "o")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched: nil
+
+
+
+=== TEST 9: case sensitive by default
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "HELLO", "oi")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 10: UTF-8 mode
+--- config
+    location /re {
+        content_by_lua '
+            local rc, m = pcall(ngx.re.match, "hello章亦春", "HELLO.{2}", "iou")
+            if not rc then
+                ngx.say("error: ", m)
+                return
+            end
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like chop
+this version of PCRE is not compiled with PCRE_UTF8 support|^hello章亦$
+
+
+
+=== TEST 11: multi-line mode (^ at line head)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", "^world", "mo")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+world
+
+
+
+=== TEST 12: multi-line mode (. does not match \n)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", ".*", "om")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 13: single-line mode (^ as normal)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", "^world", "so")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched: nil
+
+
+
+=== TEST 14: single-line mode (dot all)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", ".*", "os")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+
+
+
+=== TEST 15: extended mode (ignore whitespaces)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello\\nworld", "\\\\w     \\\\w", "xo")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+he
+
+
+
+=== TEST 16: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local m, err = ngx.re.match("hello\\nworld", "(abc", "o")
+            if m then
+                ngx.say(m[0])
+
+            else
+                if err then
+                    ngx.say("error: ", err)
+
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: bad option
+--- config
+    location /re {
+        content_by_lua '
+            rc, m = pcall(ngx.re.match, "hello\\nworld", ".*", "Ho")
+            if rc then
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            else
+                ngx.say("error: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body_like chop
+^error: .*?unknown flag "H"
+
+
+
+=== TEST 18: extended mode (ignore whitespaces)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, world", "(world)|(hello)", "xo")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched: ", m)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+nil
+hello
+
+
+
+=== TEST 19: optional trailing captures
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)(h?)", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body eval
+"1234
+1234
+
+"
+
+
+
+=== TEST 20: anchored match (failed)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)", "oa")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched!
+
+
+
+=== TEST 21: anchored match (succeeded)
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("1234, hello", "([0-9]+)", "ao")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 22: match with ctx but no pos
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = {}
+            m = ngx.re.match("1234, hello", "([0-9]+)", "o", ctx)
+            if m then
+                ngx.say(m[0])
+                ngx.say(ctx.pos)
+            else
+                ngx.say("not matched!")
+                ngx.say(ctx.pos)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+4
+
+
+
+=== TEST 23: match with ctx and a pos
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = { pos = 2 }
+            m = ngx.re.match("1234, hello", "([0-9]+)", "o", ctx)
+            if m then
+                ngx.say(m[0])
+                ngx.say(ctx.pos)
+            else
+                ngx.say("not matched!")
+                ngx.say(ctx.pos)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+34
+4
+
+
+
+=== TEST 24: sanity (set_by_lua)
+--- config
+    location /re {
+        set_by_lua $res '
+            m = ngx.re.match("hello, 1234", "([0-9]+)", "o")
+            if m then
+                return m[0]
+            else
+                return "not matched!"
+            end
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+
+=== TEST 25: match (look-behind assertion)
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = {}
+            local m = ngx.re.match("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz", "o", ctx)
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz", "o", ctx)
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+bar
+baz
+
+
+
+=== TEST 26: match (with regex cache)
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "([A-Z]+)", "io")
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("1234, okay", "([A-Z]+)", "io")
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("hello, 1234", "([A-Z]+)", "o")
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+okay
+nil
+
+
+
+=== TEST 27: match (with regex cache and ctx)
+--- config
+    location /re {
+        content_by_lua '
+            local ctx = {}
+            local m = ngx.re.match("hello, 1234", "([A-Z]+)", "io", ctx)
+            ngx.say(m and m[0])
+            ngx.say(ctx.pos)
+
+            m = ngx.re.match("1234, okay", "([A-Z]+)", "io", ctx)
+            ngx.say(m and m[0])
+            ngx.say(ctx.pos)
+
+            ctx.pos = 0
+            m = ngx.re.match("hi, 1234", "([A-Z]+)", "o", ctx)
+            ngx.say(m and m[0])
+            ngx.say(ctx.pos)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+5
+okay
+10
+nil
+0
+
+
+
+=== TEST 28: exceeding regex cache max entries
+--- http_config
+    lua_regex_cache_max_entries 2;
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "([0-9]+)", "o")
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("howdy, 567", "([0-9]+)", "oi")
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("hiya, 98", "([0-9]+)", "ox")
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+567
+98
+
+
+
+=== TEST 29: disable regex cache completely
+--- http_config
+    lua_regex_cache_max_entries 0;
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "([0-9]+)", "o")
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("howdy, 567", "([0-9]+)", "oi")
+            ngx.say(m and m[0])
+
+            m = ngx.re.match("hiya, 98", "([0-9]+)", "ox")
+            ngx.say(m and m[0])
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+567
+98
+
+
+
+=== TEST 30: named subpatterns w/ extraction
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "(?<first>[a-z]+), [0-9]+", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m.first)
+                ngx.say(m.second)
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+hello
+nil
+
+
+
+=== TEST 31: duplicate named subpatterns w/ extraction
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, 1234", "(?<first>[a-z]+), (?<first>[0-9]+)", "Do")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(table.concat(m.first,"-"))
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+hello
+1234
+hello-1234
+
+
+
+=== TEST 32: named captures are empty strings
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("1234", "(?<first>[a-z]*)([0-9]+)", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m.first)
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+
+
+1234
+
+
+
+=== TEST 33: named captures are nil
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("hello, world", "(world)|(hello)|(?<named>howdy)", "o")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+                ngx.say(m[3])
+                ngx.say(m["named"])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+nil
+hello
+nil
+nil
+
diff -rNu a/src/lua/lua-nginx-module/t/039-sub-o.t b/src/lua/lua-nginx-module/t/039-sub-o.t
--- a/src/lua/lua-nginx-module/t/039-sub-o.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/039-sub-o.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,580 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 6);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched but w/o variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[a-z]+", "howdy", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+howdy, world
+1
+
+
+
+=== TEST 2: not matched
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[A-Z]+", "howdy", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world
+0
+
+
+
+=== TEST 3: matched and with variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("a b c d", "(b) (c)", "[$0] [$1] [$2] [$3] [$134]", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] [] [] d
+1
+
+
+
+=== TEST 4: matched and with named variables (bad template)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("a b c d",
+                                         "(b) (c)",
+                                         "[$0] [$1] [$2] [$3] [$hello]",
+                                         "o")
+            if s then
+                ngx.say(s, ": ", n)
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+attempt to use named capturing variable "hello" (named captures not supported yet)
+
+
+
+=== TEST 5: matched and with named variables (bracketed)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("a b c d",
+                                         "(b) (c)",
+                                         "[$0] [$1] [$2] [$3] [${hello}]",
+                                         "o")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+attempt to use named capturing variable "hello" (named captures not supported yet)
+
+
+
+=== TEST 6: matched and with bracketed variables
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${134}]", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[b c] [b] [c] [] [] d
+1
+
+
+
+=== TEST 7: matched and with bracketed variables (unmatched brackets)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${134]", "o")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+the closing bracket in "134" variable is missing
+
+
+
+=== TEST 8: matched and with bracketed variables (unmatched brackets)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${134", "o")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+the closing bracket in "134" variable is missing
+
+
+
+=== TEST 9: matched and with bracketed variables (unmatched brackets)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [${", "o")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+lua script: invalid capturing variable name found in "[$0] [$1] [${2}] [$3] [${"
+
+
+
+=== TEST 10: trailing $
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("b c d", "(b) (c)", "[$0] [$1] [${2}] [$3] [$", "o")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: failed to compile the replacement template
+--- error_log
+lua script: invalid capturing variable name found in "[$0] [$1] [${2}] [$3] [$"
+
+
+
+=== TEST 11: matched but w/o variables and with literal $
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[a-z]+", "ho$$wdy", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+ho$wdy, world
+1
+
+
+
+=== TEST 12: non-anchored match
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", " [0-9] ", "x", "xo")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, x234
+1
+
+
+
+=== TEST 13: anchored match
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "[0-9]", "x", "ao")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 1234
+0
+
+
+
+=== TEST 14: function replace
+--- config
+    location /re {
+        content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "] [" .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.sub("hello, 34", "([0-9])", repl, "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, [3] [3]4
+1
+
+
+
+=== TEST 15: function replace (failed)
+--- config
+    location /re {
+        content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "] [" .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.sub("hello, 34", "([A-Z])", repl, "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 34
+0
+
+
+
+=== TEST 16: bad repl arg type
+--- config
+    location /re {
+        content_by_lua '
+            local rc, s, n = pcall(ngx.re.sub, "hello, 34", "([A-Z])", true, "o")
+            ngx.say(rc)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+false
+bad argument #3 to '?' (string, number, or function expected, got boolean)
+nil
+
+
+
+=== TEST 17: use number to replace
+--- config
+    location /re {
+        content_by_lua '
+            local rc, s, n = pcall(ngx.re.sub, "hello, 34", "([0-9])", 72, "o")
+            ngx.say(rc)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+true
+hello, 724
+1
+
+
+
+=== TEST 18: bad function return value type
+--- config
+    location /re {
+        content_by_lua '
+            local f = function (m) end
+            local rc, s, n = pcall(ngx.re.sub, "hello, 34", "([0-9])", f, "o")
+            ngx.say(rc)
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+false
+bad argument #3 to '?' (string or number expected to be returned by the replace function, got nil)
+nil
+
+
+
+=== TEST 19: matched but w/o variables (set_by_lua)
+--- config
+    location /re {
+        set_by_lua $res '
+            local s, n = ngx.re.sub("hello, world", "[a-z]+", "howdy", "o")
+            return s
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+howdy, world
+
+
+
+=== TEST 20: with regex cache (with text replace)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "([A-Z]+)", "baz", "io")
+            ngx.say(s)
+            ngx.say(n)
+
+            local s, n = ngx.re.sub("howdy, 1234", "([A-Z]+)", "baz", "io")
+            ngx.say(s)
+            ngx.say(n)
+
+
+            s, n = ngx.re.sub("1234, okay", "([A-Z]+)", "blah", "io")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("hi, 1234", "([A-Z]+)", "hello", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+baz, 1234
+1
+baz, 1234
+1
+1234, blah
+1
+hi, 1234
+0
+
+
+
+=== TEST 21: with regex cache (with func replace)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "([A-Z]+)", "baz", "io")
+            ngx.say(s)
+            ngx.say(n)
+
+            local s, n = ngx.re.sub("howdy, 1234", "([A-Z]+)", function () return "bah" end, "io")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("1234, okay", "([A-Z]+)", function () return "blah" end, "io")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("hi, 1234", "([A-Z]+)", "hello", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+baz, 1234
+1
+bah, 1234
+1
+1234, blah
+1
+hi, 1234
+0
+
+
+
+=== TEST 22: exceeding regex cache max entries
+--- http_config
+    lua_regex_cache_max_entries 2;
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "([0-9]+)", "hello", "o")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("howdy, 567", "([0-9]+)", "hello", "oi")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("hiya, 98", "([0-9]+)", "hello", "ox")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, hello
+1
+howdy, hello
+1
+hiya, hello
+1
+
+
+
+=== TEST 23: disable regex cache completely
+--- http_config
+    lua_regex_cache_max_entries 0;
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "([0-9]+)", "hello", "o")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("howdy, 567", "([0-9]+)", "hello", "oi")
+            ngx.say(s)
+            ngx.say(n)
+
+            s, n = ngx.re.sub("hiya, 98", "([0-9]+)", "hello", "ox")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, hello
+1
+howdy, hello
+1
+hiya, hello
+1
+
+
+
+=== TEST 24: empty replace
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234", "([0-9]+)", "", "o")
+            ngx.say(s)
+            ngx.say(n)
+
+            local s, n = ngx.re.sub("hi, 5432", "([0-9]+)", "", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, 
+1
+hi, 
+1
+
+
+
+=== TEST 25: matched and with variables w/o using named patterns in sub
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("a b c d", "(?<first>b) (?<second>c)", "[$0] [$1] [$2] [$3] [$134]", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] [] [] d
+1
+
+
+
+=== TEST 26: matched and with variables using named patterns in func
+--- config
+    error_log /tmp/nginx_error debug;
+    location /re {
+        content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "] [" .. m["first"] .. "] [" .. m[2] .. "]"
+            end
+
+            local s, n = ngx.re.sub("a b c d", "(?<first>b) (?<second>c)", repl, "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+a [b c] [b] [c] d
+1
+
diff -rNu a/src/lua/lua-nginx-module/t/040-gsub-o.t b/src/lua/lua-nginx-module/t/040-gsub-o.t
--- a/src/lua/lua-nginx-module/t/040-gsub-o.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/040-gsub-o.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,202 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("[hello, world]", "[a-z]+", "howdy", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[howdy, howdy]
+2
+
+
+
+=== TEST 2: trimmed
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[a-z]+", "howdy", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+howdy, howdy
+2
+
+
+
+=== TEST 3: not matched
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[A-Z]+", "howdy", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world
+0
+
+
+
+=== TEST 4: replace by function (trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local f = function (m)
+                return "[" .. m[0] .. "," .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", f, "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[hello,h], [world,w]
+2
+
+
+
+=== TEST 5: replace by function (not trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local f = function (m)
+                return "[" .. m[0] .. "," .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("{hello, world}", "([a-z])[a-z]+", f, "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+{[hello,h], [world,w]}
+2
+
+
+
+=== TEST 6: replace by script (trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[hello,h], [world,w]
+2
+
+
+
+=== TEST 7: replace by script (not trimmed)
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("{hello, world}", "([a-z])[a-z]+", "[$0,$1]", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+{[hello,h], [world,w]}
+2
+
+
+
+=== TEST 8: set_by_lua
+--- config
+    location /re {
+        set_by_lua $res '
+            local f = function (m)
+                return "[" .. m[0] .. "," .. m[1] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("{hello, world}", "([a-z])[a-z]+", f, "o")
+            return s
+        ';
+        echo $res;
+    }
+--- request
+    GET /re
+--- response_body
+{[hello,h], [world,w]}
+
+
+
+=== TEST 9: look-behind assertion
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("{foobarbaz}", "(?<=foo)bar|(?<=bar)baz", "h$0", "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+{foohbarhbaz}
+2
+
+
+
+=== TEST 10: named pattern repl w/ callback
+--- config
+    location /re {
+       content_by_lua '
+            local repl = function (m)
+                return "[" .. m[0] .. "," .. m["first"] .. "]"
+            end
+
+            local s, n = ngx.re.gsub("hello, world", "(?<first>[a-z])[a-z]+", repl, "o")
+            ngx.say(s)
+            ngx.say(n)
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+[hello,h], [world,w]
+2
+
diff -rNu a/src/lua/lua-nginx-module/t/041-header-filter.t b/src/lua/lua-nginx-module/t/041-header-filter.t
--- a/src/lua/lua-nginx-module/t/041-header-filter.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/041-header-filter.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,783 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * 92;
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: set response content-type header
+--- config
+    location /read {
+        echo "Hi";
+        header_filter_by_lua '
+            ngx.header.content_type = "text/my-plain";
+        ';
+
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 2: server config
+--- config
+    header_filter_by_lua '
+        ngx.header.content_type = "text/my-plain";
+    ';
+
+    location /read {
+        echo "Hi";
+
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 3: set in http
+--- http_config
+    header_filter_by_lua '
+        ngx.header.content_type = "text/my-plain";
+    ';
+--- config
+    location /read {
+        echo "Hi";
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 4: overriding config
+--- config
+    header_filter_by_lua '
+        ngx.header.content_type = "text/my-plain";
+    ';
+    location /read {
+        echo "Hi";
+        header_filter_by_lua '
+            ngx.header.content_type = "text/read-plain";
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/read-plain
+--- response_body
+Hi
+
+
+
+=== TEST 5: set response content-type header
+--- config
+    location /read {
+        echo "Hi";
+        header_filter_by_lua '
+            ngx.header.content_type = "text/my-plain";
+        ';
+
+    }
+--- request
+GET /read
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 6: lua code run failed
+--- config
+    location /read {
+        echo "Hi";
+        header_filter_by_lua '
+            ngx.header.content_length = "text/my-plain";
+        ';
+    }
+--- request
+GET /read
+--- error_code
+--- response_body
+
+
+
+=== TEST 7: use variable generated by content phrase
+--- config
+   location /read {
+        set $strvar '1';
+        content_by_lua '
+            ngx.var.strvar = "127.0.0.1:8080";
+            ngx.say("Hi");
+        ';
+        header_filter_by_lua '
+            ngx.header.uid = ngx.var.strvar;
+        ';
+    }
+--- request
+GET /read
+--- response_headers
+uid: 127.0.0.1:8080
+--- response_body
+Hi
+
+
+
+=== TEST 8: use variable generated by content phrase for HEAD
+--- config
+   location /read {
+        set $strvar '1';
+        content_by_lua '
+            ngx.var.strvar = "127.0.0.1:8080";
+            ngx.say("Hi");
+        ';
+        header_filter_by_lua '
+            ngx.header.uid = ngx.var.strvar;
+        ';
+    }
+--- request
+HEAD /read
+--- response_headers
+uid: 127.0.0.1:8080
+--- response_body
+
+
+
+=== TEST 9: use variable generated by content phrase for HTTP 1.0
+--- config
+   location /read {
+        set $strvar '1';
+        content_by_lua '
+            ngx.var.strvar = "127.0.0.1:8080";
+            ngx.say("Hi");
+        ';
+        header_filter_by_lua '
+            ngx.header.uid = ngx.var.strvar;
+        ';
+
+    }
+--- request
+GET /read HTTP/1.0
+--- response_headers
+uid: 127.0.0.1:8080
+--- response_body
+Hi
+
+
+
+=== TEST 10: use capture and header_filter_by
+--- config
+   location /sub {
+        content_by_lua '
+            ngx.say("Hi");
+        ';
+        header_filter_by_lua '
+            ngx.header.uid = "sub";
+        ';
+    }
+
+    location /parent {
+        content_by_lua '
+            local res = ngx.location.capture("/sub")
+            if res.status == 200 then
+                ngx.say(res.header.uid)
+            else
+                ngx.say("parent")
+            end
+        ';
+        header_filter_by_lua '
+            ngx.header.uid = "parent";
+        ';
+    }
+
+--- request
+GET /parent
+--- response_headers
+uid: parent
+--- response_body
+sub
+
+
+
+=== TEST 11: overriding ctx
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.ctx.foo = 32;
+            ngx.say(ngx.ctx.foo)
+        ';
+        header_filter_by_lua '
+            ngx.ctx.foo = ngx.ctx.foo + 1;
+            ngx.header.uid = ngx.ctx.foo;
+        ';
+    }
+--- request
+GET /lua
+--- response_headers
+uid: 33
+--- response_body
+32
+
+
+
+=== TEST 12: use req
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("Hi");
+        ';
+
+        header_filter_by_lua '
+            local str = "";
+            local args = ngx.req.get_uri_args()
+            local keys = {}
+            for key, val in pairs(args) do
+                table.insert(keys, key)
+            end
+            table.sort(keys)
+            for i, key in ipairs(keys) do
+                local val = args[key]
+                if type(val) == "table" then
+                    str = str .. table.concat(val, ", ")
+                else
+                    str = str .. ":" .. val
+                end
+            end
+
+            ngx.header.uid = str;
+        ';
+    }
+--- request
+GET /lua?a=1&b=2
+--- response_headers
+uid: :1:2
+--- response_body
+Hi
+
+
+
+=== TEST 13: use ngx md5 function
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("Hi");
+        ';
+        header_filter_by_lua '
+            ngx.header.uid = ngx.md5("Hi");
+        ';
+    }
+--- request
+GET /lua
+--- response_headers
+uid: c1a5298f939e87e8f962a5edfc206918
+--- response_body
+Hi
+
+
+
+=== TEST 14: set response content-type header (by file)
+--- config
+    location /read {
+        echo "Hi";
+        header_filter_by_lua_file 'html/foo.lua';
+    }
+--- request
+GET /read
+--- user_files
+>>> foo.lua
+ngx.header.content_type = "text/my-plain";
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 15: by_lua_file server config
+--- config
+    header_filter_by_lua_file 'html/foo.lua';
+
+    location /read {
+        echo "Hi";
+    }
+--- request
+GET /read
+--- user_files
+>>> foo.lua
+ngx.header.content_type = "text/my-plain";
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 16: by_lua_file set in http
+--- http_config
+    header_filter_by_lua_file 'html/foo.lua';
+--- config
+    location /read {
+        echo "Hi";
+    }
+--- request
+GET /read
+--- user_files
+>>> foo.lua
+ngx.header.content_type = "text/my-plain";
+--- response_headers
+Content-Type: text/my-plain
+--- response_body
+Hi
+
+
+
+=== TEST 17: by_lua_file overriding config
+--- config
+    header_filter_by_lua 'html/foo.lua';
+    location /read {
+        echo "Hi";
+        header_filter_by_lua_file 'html/bar.lua';
+    }
+--- request
+GET /read
+--- user_files
+>>> foo.lua
+ngx.header.content_type = "text/my-plain";
+>>> bar.lua
+ngx.header.content_type = "text/read-plain";
+--- response_headers
+Content-Type: text/read-plain
+--- response_body
+Hi
+
+
+
+=== TEST 18: ngx.ctx available in header_filter_by_lua (already defined)
+--- config
+    location /lua {
+        content_by_lua 'ngx.ctx.counter = 3 ngx.say(ngx.ctx.counter)';
+        header_filter_by_lua 'ngx.log(ngx.ERR, "ngx.ctx.counter: ", ngx.ctx.counter)';
+    }
+--- request
+GET /lua
+--- response_body
+3
+--- error_log
+ngx.ctx.counter: 3
+lua release ngx.ctx
+
+
+
+=== TEST 19: ngx.ctx available in header_filter_by_lua (not defined yet)
+--- config
+    location /lua {
+        echo hello;
+        header_filter_by_lua '
+            ngx.log(ngx.ERR, "ngx.ctx.counter: ", ngx.ctx.counter)
+            ngx.ctx.counter = "hello world"
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+hello
+--- error_log
+ngx.ctx.counter: nil
+lua release ngx.ctx
+
+
+
+=== TEST 20: global got cleared for each single request
+--- config
+    location /lua {
+        set $foo '';
+        content_by_lua '
+            ngx.send_headers()
+            ngx.say(ngx.var.foo)
+        ';
+        header_filter_by_lua '
+            if not foo then
+                foo = 1
+            else
+                foo = foo + 1
+            end
+            ngx.var.foo = foo
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+1
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: lua error (string)
+--- config
+    location /lua {
+        set $foo '';
+        content_by_lua '
+            ngx.send_headers()
+            ngx.say(ngx.var.foo)
+        ';
+        header_filter_by_lua '
+            error("Something bad")
+        ';
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+failed to run header_filter_by_lua*: [string "header_filter_by_lua"]:2: Something bad
+--- no_error_log
+[alert]
+
+
+
+=== TEST 22: lua error (nil)
+--- config
+    location /lua {
+        set $foo '';
+        content_by_lua '
+            ngx.send_headers()
+            ngx.say(ngx.var.foo)
+        ';
+        header_filter_by_lua '
+            error(nil)
+        ';
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+failed to run header_filter_by_lua*: unknown reason
+--- no_error_log
+[alert]
+
+
+
+=== TEST 23: no ngx.print
+--- config
+    location /lua {
+        header_filter_by_lua "ngx.print(32) return 1";
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 24: no ngx.say
+--- config
+    location /lua {
+        header_filter_by_lua "ngx.say(32) return 1";
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 25: no ngx.flush
+--- config
+    location /lua {
+        header_filter_by_lua "ngx.flush()";
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 26: no ngx.eof
+--- config
+    location /lua {
+        header_filter_by_lua "ngx.eof()";
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 27: no ngx.send_headers
+--- config
+    location /lua {
+        header_filter_by_lua "ngx.send_headers()";
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 28: no ngx.location.capture
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.location.capture("/sub")';
+        echo ok;
+    }
+
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 29: no ngx.location.capture_multi
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.location.capture_multi{{"/sub"}}';
+        echo ok;
+    }
+
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 30: no ngx.exit
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.exit(0)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 31: no ngx.redirect
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.redirect("/blah")';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 32: no ngx.exec
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.exec("/blah")';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 33: no ngx.req.set_uri(uri, true)
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.req.set_uri("/blah", true)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 34: ngx.req.set_uri(uri) exists
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.req.set_uri("/blah") return 1';
+        content_by_lua '
+            ngx.send_headers()
+            ngx.say("uri: ", ngx.var.uri)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+uri: /blah
+--- no_error_log
+[error]
+
+
+
+=== TEST 35: no ngx.req.read_body()
+--- config
+    location /lua {
+        header_filter_by_lua 'ngx.req.read_body()';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 36: no ngx.req.socket()
+--- config
+    location /lua {
+        header_filter_by_lua 'return ngx.req.socket()';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 37: no ngx.socket.tcp()
+--- config
+    location /lua {
+        header_filter_by_lua 'return ngx.socket.tcp()';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 38: no ngx.socket.connect()
+--- config
+    location /lua {
+        header_filter_by_lua 'return ngx.socket.connect("127.0.0.1", 80)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 39: clear content-length
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.content_length = 12
+            ngx.say("hello world")
+        ';
+        header_filter_by_lua 'ngx.header.content_length = nil';
+    }
+--- request
+GET /lua
+--- response_headers
+!content-length
+--- response_body
+hello world
+
+
+
+=== TEST 40: backtrace
+--- config
+    location /t {
+        header_filter_by_lua '
+            function foo()
+                bar()
+            end
+
+            function bar()
+                error("something bad happened")
+            end
+
+            foo()
+        ';
+        echo ok;
+    }
+--- request
+    GET /t
+--- ignore_response
+--- error_log
+something bad happened
+stack traceback:
+in function 'error'
+in function 'bar'
+in function 'foo'
+
+
+
+=== TEST 41: Lua file does not exist
+--- config
+    location /lua {
+        echo ok;
+        header_filter_by_lua_file html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- ignore_response
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
diff -rNu a/src/lua/lua-nginx-module/t/042-crc32.t b/src/lua/lua-nginx-module/t/042-crc32.t
--- a/src/lua/lua-nginx-module/t/042-crc32.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/042-crc32.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,58 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: short sanity
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.say(ngx.crc32_short("hello, world"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+4289425978
+
+
+
+=== TEST 2: long sanity
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.say(ngx.crc32_long("hello, world"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+4289425978
+
+
+
+=== TEST 3: long sanity (empty)
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.say(ngx.crc32_long(""))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+0
+
diff -rNu a/src/lua/lua-nginx-module/t/043-shdict.t b/src/lua/lua-nginx-module/t/043-shdict.t
--- a/src/lua/lua-nginx-module/t/043-shdict.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/043-shdict.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1477 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+#repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 15);
+
+#no_diff();
+no_long_string();
+#master_on();
+#workers(2);
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: string key, int value
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            dogs:set("bah", 10502)
+            local val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32 number
+10502 number
+
+
+
+=== TEST 2: string key, floating-point value
+--- http_config
+    lua_shared_dict cats 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local cats = ngx.shared.cats
+            cats:set("foo", 3.14159)
+            cats:set("baz", 1.28)
+            cats:set("baz", 3.96)
+            local val = cats:get("foo")
+            ngx.say(val, " ", type(val))
+            val = cats:get("baz")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+3.14159 number
+3.96 number
+
+
+
+=== TEST 3: string key, boolean value
+--- http_config
+    lua_shared_dict cats 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local cats = ngx.shared.cats
+            cats:set("foo", true)
+            cats:set("bar", false)
+            local val = cats:get("foo")
+            ngx.say(val, " ", type(val))
+            val = cats:get("bar")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+true boolean
+false boolean
+
+
+
+=== TEST 4: number keys, string values
+--- http_config
+    lua_shared_dict cats 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local cats = ngx.shared.cats
+            ngx.say(cats:set(1234, "cat"))
+            ngx.say(cats:set("1234", "dog"))
+            ngx.say(cats:set(256, "bird"))
+            ngx.say(cats:get(1234))
+            ngx.say(cats:get("1234"))
+            local val = cats:get("256")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+truenilfalse
+truenilfalse
+truenilfalse
+dog
+dog
+bird string
+
+
+
+=== TEST 5: different-size values set to the same key
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", "hello")
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", "hello, world")
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", "hello")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+hello
+hello, world
+hello
+
+
+
+=== TEST 6: expired entries (can be auto-removed by get)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32, 0.01)
+            ngx.location.capture("/sleep/0.01")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+    location ~ '^/sleep/(.+)' {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+nil
+
+
+
+=== TEST 7: expired entries (can NOT be auto-removed by get)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bar", 56, 0.001)
+            dogs:set("baz", 78, 0.001)
+            dogs:set("foo", 32, 0.01)
+            ngx.location.capture("/sleep/0.012")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+    location ~ '^/sleep/(.+)' {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+nil
+
+
+
+=== TEST 8: not yet expired entries
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32, 0.5)
+            ngx.location.capture("/sleep/0.01")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+    location ~ '^/sleep/(.+)' {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+32
+
+
+
+=== TEST 9: forcibly override other valid entries
+--- http_config
+    lua_shared_dict dogs 100k;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local i = 0
+            while i < 1000 do
+                i = i + 1
+                local val = string.rep(" hello", 10) .. i
+                local res, err, forcible = dogs:set("key_" .. i, val)
+                if not res or forcible then
+                    ngx.say(res, " ", err, " ", forcible)
+                    break
+                end
+            end
+            ngx.say("abort at ", i)
+            ngx.say("cur value: ", dogs:get("key_" .. i))
+            if i > 1 then
+                ngx.say("1st value: ", dogs:get("key_1"))
+            end
+            if i > 2 then
+                ngx.say("2nd value: ", dogs:get("key_2"))
+            end
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test"]
+--- response_body eval
+my $a = "true nil true\nabort at (353|705)\ncur value: " . (" hello" x 10) . "\\1\n1st value: nil\n2nd value: " . (" hello" x 10) . "2\n";
+[qr/$a/,
+"true nil true\nabort at 1\ncur value: " . (" hello" x 10) . "1\n"
+]
+
+
+
+=== TEST 10: forcibly override other valid entries and test LRU
+--- http_config
+    lua_shared_dict dogs 100k;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local i = 0
+            while i < 1000 do
+                i = i + 1
+                local val = string.rep(" hello", 10) .. i
+                if i == 10 then
+                    dogs:get("key_1")
+                end
+                local res, err, forcible = dogs:set("key_" .. i, val)
+                if not res or forcible then
+                    ngx.say(res, " ", err, " ", forcible)
+                    break
+                end
+            end
+            ngx.say("abort at ", i)
+            ngx.say("cur value: ", dogs:get("key_" .. i))
+            if i > 1 then
+                ngx.say("1st value: ", dogs:get("key_1"))
+            end
+            if i > 2 then
+                ngx.say("2nd value: ", dogs:get("key_2"))
+            end
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test"]
+--- response_body eval
+my $a = "true nil true\nabort at (353|705)\ncur value: " . (" hello" x 10) . "\\1\n1st value: " . (" hello" x 10) . "1\n2nd value: nil\n";
+[qr/$a/,
+"true nil true\nabort at 2\ncur value: " . (" hello" x 10) . "2\n1st value: " . (" hello" x 10) . "1\n"
+]
+
+
+
+=== TEST 11: dogs and cats dicts
+--- http_config
+    lua_shared_dict dogs 1m;
+    lua_shared_dict cats 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local cats = ngx.shared.cats
+            dogs:set("foo", 32)
+            cats:set("foo", "hello, world")
+            ngx.say(dogs:get("foo"))
+            ngx.say(cats:get("foo"))
+            dogs:set("foo", 56)
+            ngx.say(dogs:get("foo"))
+            ngx.say(cats:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32
+hello, world
+56
+hello, world
+
+
+
+=== TEST 12: get non-existent keys
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            ngx.say(dogs:get("foo"))
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+nil
+nil
+
+
+
+=== TEST 13: not feed the object into the call
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local rc, err = pcall(dogs.set, "foo", 3, 0.01)
+            ngx.say(rc, " ", err)
+            rc, err = pcall(dogs.set, "foo", 3)
+            ngx.say(rc, " ", err)
+            rc, err = pcall(dogs.get, "foo")
+            ngx.say(rc, " ", err)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+false bad argument #1 to '?' (userdata expected, got string)
+false expecting 3, 4 or 5 arguments, but only seen 2
+false expecting exactly two arguments, but only seen 1
+
+
+
+=== TEST 14: too big value
+--- http_config
+    lua_shared_dict dogs 50k;
+--- config
+    location = /test {
+        content_by_lua '
+            collectgarbage("collect")
+            local dogs = ngx.shared.dogs
+            local res, err, forcible = dogs:set("foo", string.rep("helloworld", 10000))
+            ngx.say(res, " ", err, " ", forcible)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+false no memory false
+--- log_level: info
+--- error_log eval
+qr/\[info\] .* ngx_slab_alloc\(\) failed: no memory in lua_shared_dict zone "dogs"/
+
+
+
+=== TEST 15: too big key
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local key = string.rep("a", 65535)
+            local rc, err = dogs:set(key, "hello")
+            ngx.say(rc, " ", err)
+            ngx.say(dogs:get(key))
+
+            key = string.rep("a", 65536)
+            rc, err = pcall(dogs.set, dogs, key, "world")
+            ngx.say(rc, " ", err)
+
+        ';
+    }
+--- request
+GET /test
+--- response_body
+true nil
+hello
+false the key argument is more than 65535 bytes: 65536
+
+
+
+=== TEST 16: bad value type
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local rc, err = pcall(dogs.set, dogs, "foo", dogs)
+            ngx.say(rc, " ", err)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+false unsupported value type for key "foo" in shared_dict "dogs": userdata
+
+
+
+=== TEST 17: delete after setting values
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            ngx.say(dogs:get("foo"))
+            dogs:delete("foo")
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", "hello, world")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32
+nil
+hello, world
+
+
+
+=== TEST 18: delete at first
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:delete("foo")
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", "hello, world")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+nil
+hello, world
+
+
+
+=== TEST 19: set nil after setting values
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", nil)
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", "hello, world")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32
+nil
+hello, world
+
+
+
+=== TEST 20: set nil at first
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", nil)
+            ngx.say(dogs:get("foo"))
+            dogs:set("foo", "hello, world")
+            ngx.say(dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+nil
+hello, world
+
+
+
+=== TEST 21: fail to allocate memory
+--- http_config
+    lua_shared_dict dogs 100k;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local i = 0
+            while i < 1000 do
+                i = i + 1
+                local val = string.rep("hello", i )
+                local res, err, forcible = dogs:set("key_" .. i, val)
+                if not res or forcible then
+                    ngx.say(res, " ", err, " ", forcible)
+                    break
+                end
+            end
+            ngx.say("abort at ", i)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like
+^true nil true\nabort at (?:139|140)$
+
+
+
+=== TEST 22: string key, int value (write_by_lua)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        rewrite_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            dogs:set("bah", 10502)
+            local val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /test
+--- response_body
+32 number
+10502 number
+
+
+
+=== TEST 23: string key, int value (access_by_lua)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        access_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            dogs:set("bah", 10502)
+            local val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /test
+--- response_body
+32 number
+10502 number
+
+
+
+=== TEST 24: string key, int value (set_by_lua)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        set_by_lua $res '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            return dogs:get("foo")
+        ';
+        echo $res;
+    }
+--- request
+GET /test
+--- response_body
+32
+
+
+
+=== TEST 25: string key, int value (header_by_lua)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        echo hello;
+        header_filter_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            ngx.header["X-Foo"] = dogs:get("foo")
+        ';
+    }
+--- request
+GET /test
+--- response_headers
+X-Foo: 32
+--- response_body
+hello
+
+
+
+=== TEST 26: too big value (forcible)
+--- http_config
+    lua_shared_dict dogs 50k;
+--- config
+    location = /test {
+        content_by_lua '
+            collectgarbage("collect")
+            local dogs = ngx.shared.dogs
+            dogs:set("bah", "hello")
+            local res, err, forcible = dogs:set("foo", string.rep("helloworld", 10000))
+            ngx.say(res, " ", err, " ", forcible)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+false no memory true
+--- log_level: info
+--- error_log eval
+qr/\[info\] .* ngx_slab_alloc\(\) failed: no memory in lua_shared_dict zone "dogs"/
+
+
+
+=== TEST 27: add key (key exists)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            local res, err, forcible = dogs:add("foo", 10502)
+            ngx.say("add: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+add: false exists false
+foo = 32
+
+
+
+=== TEST 28: add key (key not exists)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bah", 32)
+            local res, err, forcible = dogs:add("foo", 10502)
+            ngx.say("add: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+add: true nil false
+foo = 10502
+
+
+
+=== TEST 29: add key (key expired)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bar", 32, 0.001)
+            dogs:set("baz", 32, 0.001)
+            dogs:set("foo", 32, 0.001)
+            ngx.location.capture("/sleep/0.002")
+            local res, err, forcible = dogs:add("foo", 10502)
+            ngx.say("add: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+    location ~ ^/sleep/(.+) {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+add: true nil false
+foo = 10502
+
+
+
+=== TEST 30: add key (key expired and value size unmatched)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bar", 32, 0.001)
+            dogs:set("baz", 32, 0.001)
+            dogs:set("foo", "hi", 0.001)
+            ngx.location.capture("/sleep/0.002")
+            local res, err, forcible = dogs:add("foo", "hello")
+            ngx.say("add: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+    location ~ ^/sleep/(.+) {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+add: true nil false
+foo = hello
+
+
+
+=== TEST 31: incr key (key exists)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            local res, err, forcible = dogs:replace("foo", 10502)
+            ngx.say("replace: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+
+            local res, err, forcible = dogs:replace("foo", "hello")
+            ngx.say("replace: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+
+        ';
+    }
+--- request
+GET /test
+--- response_body
+replace: true nil false
+foo = 10502
+replace: true nil false
+foo = hello
+
+
+
+=== TEST 32: replace key (key not exists)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bah", 32)
+            local res, err, forcible = dogs:replace("foo", 10502)
+            ngx.say("replace: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+replace: false not found false
+foo = nil
+
+
+
+=== TEST 33: replace key (key expired)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bar", 3, 0.001)
+            dogs:set("baz", 2, 0.001)
+            dogs:set("foo", 32, 0.001)
+            ngx.location.capture("/sleep/0.002")
+            local res, err, forcible = dogs:replace("foo", 10502)
+            ngx.say("replace: ", res, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+    location ~ ^/sleep/(.+) {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+replace: false not found false
+foo = nil
+
+
+
+=== TEST 34: replace key (key expired and value size unmatched)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bar", 32, 0.001)
+            dogs:set("baz", 32, 0.001)
+            dogs:set("foo", "hi", 0.001)
+            ngx.location.capture("/sleep/0.002")
+            local rc, err, forcible = dogs:replace("foo", "hello")
+            ngx.say("replace: ", rc, " ", err, " ", forcible)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+    location ~ ^/sleep/(.+) {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+replace: false not found false
+foo = nil
+
+
+
+=== TEST 35: incr key (key exists)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            local res, err = dogs:incr("foo", 10502)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+incr: 10534 nil
+foo = 10534
+
+
+
+=== TEST 36: replace key (key not exists)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bah", 32)
+            local res, err = dogs:incr("foo", 2)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+incr: nil not found
+foo = nil
+
+
+
+=== TEST 37: replace key (key expired)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("bar", 3, 0.001)
+            dogs:set("baz", 2, 0.001)
+            dogs:set("foo", 32, 0.001)
+            ngx.location.capture("/sleep/0.002")
+            local res, err = dogs:incr("foo", 10502)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+    location ~ ^/sleep/(.+) {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+incr: nil not found
+foo = nil
+
+
+
+=== TEST 38: incr key (incr by 0)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            local res, err = dogs:incr("foo", 0)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+incr: 32 nil
+foo = 32
+
+
+
+=== TEST 39: incr key (incr by floating point number)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            local res, err = dogs:incr("foo", 0.14)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+incr: 32.14 nil
+foo = 32.14
+
+
+
+=== TEST 40: incr key (incr by negative numbers)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            local res, err = dogs:incr("foo", -0.14)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+incr: 31.86 nil
+foo = 31.86
+
+
+
+=== TEST 41: incr key (original value is not number)
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", true)
+            local res, err = dogs:incr("foo", -0.14)
+            ngx.say("incr: ", res, " ", err)
+            ngx.say("foo = ", dogs:get("foo"))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+incr: nil not a number
+foo = true
+
+
+
+=== TEST 42: get and set with flags
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32, 0, 199)
+            dogs:set("bah", 10502, 202)
+            local val, flags = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            ngx.say(flags, " ", type(flags))
+            val, flags = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+            ngx.say(flags, " ", type(flags))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32 number
+199 number
+10502 number
+nil nil
+
+
+
+=== TEST 43: expired entries (can be auto-removed by get), with flags set
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32, 0.01, 255)
+            ngx.location.capture("/sleep/0.01")
+            local res, flags = dogs:get("foo")
+            ngx.say("res = ", res, ", flags = ", flags)
+        ';
+    }
+    location ~ '^/sleep/(.+)' {
+        echo_sleep $1;
+    }
+--- request
+GET /test
+--- response_body
+res = nil, flags = nil
+
+
+
+=== TEST 44: flush_all
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            dogs:set("bah", 10502)
+
+            local val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+
+            dogs:flush_all()
+
+            val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /t
+--- response_body
+32 number
+10502 number
+nil nil
+nil nil
+
+
+
+=== TEST 45: flush_expires
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", "x", 1)
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 100)
+
+            ngx.sleep(1.5)
+
+            local num = dogs:flush_expired()
+            ngx.say(num)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+1
+
+
+
+=== TEST 46: flush_expires with number
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            for i=1,100 do
+                dogs:set(tostring(i), "x", 1)
+            end
+
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 100)
+
+            ngx.sleep(1.5)
+
+            local num = dogs:flush_expired(42)
+            ngx.say(num)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+42
+
+
+
+=== TEST 47: flush_expires an empty dict
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            local num = dogs:flush_expired()
+            ngx.say(num)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+0
+
+
+
+=== TEST 48: flush_expires a dict without expired items
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 100)
+
+            local num = dogs:flush_expired()
+            ngx.say(num)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+0
+
+
+
+=== TEST 49: list all keys in a shdict
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 0)
+            local keys = dogs:get_keys()
+            ngx.say(#keys)
+            table.sort(keys)
+            for _,k in ipairs(keys) do
+                ngx.say(k)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+2
+bah
+bar
+
+
+
+=== TEST 50: list keys in a shdict with limit
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 0)
+            local keys = dogs:get_keys(1)
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+1
+
+
+
+=== TEST 51: list all keys in a shdict with expires
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", "x", 1)
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 100)
+
+            ngx.sleep(1.5)
+
+            local keys = dogs:get_keys()
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+2
+
+
+
+=== TEST 52: list keys in a shdict with limit larger than number of keys
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            dogs:set("bah", "y", 0)
+            dogs:set("bar", "z", 0)
+            local keys = dogs:get_keys(3)
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+2
+
+
+
+=== TEST 53: list keys in an empty shdict
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local keys = dogs:get_keys()
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+0
+
+
+
+=== TEST 54: list keys in an empty shdict with a limit
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local keys = dogs:get_keys(4)
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+0
+
+
+
+=== TEST 55: list all keys in a shdict with all keys expired
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", "x", 1)
+            dogs:set("bah", "y", 1)
+            dogs:set("bar", "z", 1)
+
+            ngx.sleep(1.5)
+
+            local keys = dogs:get_keys()
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+0
+
+
+
+=== TEST 56: list all keys in a shdict with more than 1024 keys with no limit set
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            for i=1,2048 do
+                dogs:set(tostring(i), i)
+            end
+            local keys = dogs:get_keys()
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+1024
+
+
+
+=== TEST 57: list all keys in a shdict with more than 1024 keys with 0 limit set
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /t {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            for i=1,2048 do
+                dogs:set(tostring(i), i)
+            end
+            local keys = dogs:get_keys(0)
+            ngx.say(#keys)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+2048
+
+
+
+=== TEST 58: safe_set
+--- http_config
+    lua_shared_dict dogs 100k;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local i = 0
+            while i < 1000 do
+                i = i + 1
+                local val = string.rep(" hello", 10) .. i
+                local res, err = dogs:safe_set("key_" .. i, val)
+                if not res then
+                    ngx.say(res, " ", err)
+                    break
+                end
+            end
+            ngx.say("abort at ", i)
+            ngx.say("cur value: ", dogs:get("key_" .. i))
+            if i > 1 then
+                ngx.say("1st value: ", dogs:get("key_1"))
+            end
+            if i > 2 then
+                ngx.say("2nd value: ", dogs:get("key_2"))
+            end
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test"]
+--- response_body eval
+my $a = "nil no memory\nabort at (353|705)\ncur value: nil\n1st value: " . (" hello" x 10) . "1\n2nd value: " . (" hello" x 10) . "2\n";
+[qr/$a/, qr/$a/]
+--- no_error_log
+[error]
+
+
+
+=== TEST 59: safe_add
+--- http_config
+    lua_shared_dict dogs 100k;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local i = 0
+            while i < 1000 do
+                i = i + 1
+                local val = string.rep(" hello", 10) .. i
+                local res, err = dogs:safe_add("key_" .. i, val)
+                if not res then
+                    ngx.say(res, " ", err)
+                    break
+                end
+            end
+            ngx.say("abort at ", i)
+            ngx.say("cur value: ", dogs:get("key_" .. i))
+            if i > 1 then
+                ngx.say("1st value: ", dogs:get("key_1"))
+            end
+            if i > 2 then
+                ngx.say("2nd value: ", dogs:get("key_2"))
+            end
+        ';
+    }
+--- pipelined_requests eval
+["GET /test", "GET /test"]
+--- response_body eval
+my $a = "nil no memory\nabort at (353|705)\ncur value: nil\n1st value: " . (" hello" x 10) . "1\n2nd value: " . (" hello" x 10) . "2\n";
+[qr/$a/,
+q{false exists
+abort at 1
+cur value:  hello hello hello hello hello hello hello hello hello hello1
+}
+]
+--- no_error_log
+[error]
+
+
+
+=== TEST 60: get_stale: expired entries can still be fetched
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32, 0.01)
+            dogs:set("blah", 33, 0.1)
+            ngx.sleep(0.02)
+            local val, flags, stale = dogs:get_stale("foo")
+            ngx.say(val, ", ", flags, ", ", stale)
+            local val, flags, stale = dogs:get_stale("blah")
+            ngx.say(val, ", ", flags, ", ", stale)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32, nil, true
+33, nil, false
diff -rNu a/src/lua/lua-nginx-module/t/044-req-body.t b/src/lua/lua-nginx-module/t/044-req-body.t
--- a/src/lua/lua-nginx-module/t/044-req-body.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/044-req-body.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1482 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 35);
+
+#no_diff();
+no_long_string();
+#master_on();
+#workers(2);
+run_tests();
+
+__DATA__
+
+=== TEST 1: read buffered body
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 2: read buffered body (timed out)
+--- config
+    client_body_timeout 1ms;
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+    }
+--- raw_request eval
+"POST /test HTTP/1.1\r
+Host: localhost\r
+Content-Length: 100\r
+Connection: close\r
+\r
+hello, world"
+--- response_body:
+--- error_code_like: ^(?:500)?$
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 3: read buffered body and then subrequest
+--- config
+    location /foo {
+        echo -n foo;
+    }
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            local res = ngx.location.capture("/foo");
+            ngx.say(ngx.var.request_body)
+            ngx.say("sub: ", res.body)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+sub: foo
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 4: first subrequest and then read buffered body
+--- config
+    location /foo {
+        echo -n foo;
+    }
+    location = /test {
+        content_by_lua '
+            local res = ngx.location.capture("/foo");
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+            ngx.say("sub: ", res.body)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+sub: foo
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 5: discard body
+--- config
+    location = /foo {
+        content_by_lua '
+            ngx.req.discard_body()
+            ngx.say("body: ", ngx.var.request_body)
+        ';
+    }
+    location = /bar {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say("body: ", ngx.var.request_body)
+        ';
+
+    }
+--- pipelined_requests eval
+["POST /foo
+hello, world",
+"POST /bar
+hiya, world"]
+--- response_body eval
+["body: nil\n",
+"body: hiya, world\n"]
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 6: not discard body
+--- config
+    location = /foo {
+        content_by_lua '
+            -- ngx.req.discard_body()
+            ngx.say("body: ", ngx.var.request_body)
+        ';
+    }
+    location = /bar {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say("body: ", ngx.var.request_body)
+        ';
+    }
+--- pipelined_requests eval
+["POST /foo
+hello, world",
+"POST /bar
+hiya, world"]
+--- response_body eval
+["body: nil\n",
+qr/400 Bad Request/]
+--- error_code eval
+[200, '']
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 7: read buffered body and retrieve the data
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hello, world
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 8: read buffered body to file and call get_body_data
+--- config
+    client_body_in_file_only on;
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+nil
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 9: read buffered body to file and call get_body_file
+--- config
+    client_body_in_file_only on;
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_file())
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body_like: client_body_temp/
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 10: read buffered body to memory and retrieve the file
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_file())
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+nil
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 11: read buffered body to memory and reset it with data in memory
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("hiya, dear")
+            ngx.say(ngx.req.get_body_data())
+            ngx.say(ngx.var.request_body)
+            ngx.say(ngx.var.echo_request_body)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- response_body
+hiya, dear
+hiya, dear
+hiya, dear
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 12: read body to file and then override it with data in memory
+--- config
+    client_body_in_file_only on;
+
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("hello, baby")
+            ngx.say(ngx.req.get_body_data())
+            ngx.say(ngx.var.request_body)
+        ';
+    }
+--- request
+POST /test
+yeah
+--- response_body
+hello, baby
+hello, baby
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 13: do not read the current request body but replace it with our own in memory
+--- config
+    client_body_in_file_only on;
+
+    location = /test {
+        content_by_lua '
+            ngx.req.set_body_data("hello, baby")
+            ngx.say(ngx.req.get_body_data())
+            ngx.say(ngx.var.request_body)
+            -- ngx.location.capture("/sleep")
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.5;
+    }
+--- request
+POST /test
+yeah
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+lua entry thread aborted: runtime error: [string "content_by_lua"]:2: request body not read yet
+--- no_error_log
+[alert]
+
+
+
+=== TEST 14: read buffered body to file and reset it to a new file
+--- config
+
+    location = /test {
+        client_body_in_file_only on;
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.var.old = ngx.req.get_body_file()
+            ngx.req.set_body_file(ngx.var.realpath_root .. "/a.txt")
+            ngx.var.new = ngx.req.get_body_file()
+        ';
+        #echo_request_body;
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        #proxy_pass http://127.0.0.1:7890/echo;
+        add_header X-Old $old;
+        add_header X-New $new;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+--- user_files
+>>> a.txt
+Will you change this world?
+--- raw_response_headers_like
+X-Old: \S+/client_body_temp/\d+\r
+.*?X-New: \S+/html/a\.txt\r
+--- response_body
+Will you change this world?
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 15: read buffered body to file and reset it to a new file
+--- config
+    location = /test {
+        client_body_in_file_only on;
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.var.old = ngx.req.get_body_file() or ""
+            ngx.req.set_body_file(ngx.var.realpath_root .. "/a.txt")
+            ngx.var.new = ngx.req.get_body_file()
+        ';
+        #echo_request_body;
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        #proxy_pass http://127.0.0.1:7890/echo;
+        add_header X-Old $old;
+        add_header X-New $new;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world!
+--- user_files
+>>> a.txt
+Will you change this world?
+--- raw_response_headers_like
+X-Old: \S+/client_body_temp/\d+\r
+.*?X-New: \S+/html/a\.txt\r
+--- response_body
+Will you change this world?
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 16: read buffered body to file and reset it to a new file (auto-clean)
+--- config
+    client_body_in_file_only on;
+
+    location = /test {
+        set $old '';
+        set $new '';
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.var.old = ngx.req.get_body_file()
+            local a_file = ngx.var.realpath_root .. "/a.txt"
+            ngx.req.set_body_file(a_file, true)
+            local b_file = ngx.var.realpath_root .. "/b.txt"
+            ngx.req.set_body_file(b_file, true)
+            ngx.say("a.txt exists: ", io.open(a_file) and "yes" or "no")
+            ngx.say("b.txt exists: ", io.open(b_file) and "yes" or "no")
+        ';
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+--- user_files
+>>> a.txt
+Will you change this world?
+>>> b.txt
+Sure I will!
+--- response_body
+a.txt exists: no
+b.txt exists: yes
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 17: read buffered body to memoary and reset it to a new file (auto-clean)
+--- config
+    client_body_in_file_only off;
+
+    location = /test {
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.read_body()
+            local a_file = ngx.var.realpath_root .. "/a.txt"
+            ngx.req.set_body_file(a_file, true)
+        ';
+        echo_request_body;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- pipelined_requests eval
+["POST /test
+hello, world",
+"POST /test
+hey, you"]
+--- user_files
+>>> a.txt
+Will you change this world?
+--- response_body eval
+["Will you change this world?\n",
+qr/500 Internal Server Error/]
+--- error_code eval
+[200, 500]
+--- no_error_log
+[alert]
+
+
+
+=== TEST 18: read buffered body to memoary and reset it to a new file (no auto-clean)
+--- config
+    client_body_in_file_only off;
+
+    location = /test {
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.read_body()
+            local a_file = ngx.var.realpath_root .. "/a.txt"
+            ngx.req.set_body_file(a_file, false)
+        ';
+        echo_request_body;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- pipelined_requests eval
+["POST /test
+hello, world",
+"POST /test
+hey, you"]
+--- user_files
+>>> a.txt
+Will you change this world?
+--- response_body eval
+["Will you change this world?\n",
+"Will you change this world?\n"]
+--- error_code eval
+[200, 200]
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 19: request body discarded and reset it to a new file (auto-clean)
+--- config
+    client_body_in_file_only off;
+    client_header_buffer_size 80;
+
+    location = /test {
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.discard_body()
+            local a_file = ngx.var.realpath_root .. "/a.txt"
+            ngx.req.set_body_file(a_file, false)
+        ';
+        echo_request_body;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+
+--- user_files
+>>> a.txt
+Will you change this world?
+
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- no_error_log
+[alert]
+
+
+
+=== TEST 20: no request body and reset it to a new file (no auto-clean)
+--- config
+    client_body_in_file_only off;
+
+    location = /test {
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            local a_file = ngx.var.realpath_root .. "/a.txt"
+            ngx.req.set_body_file(a_file, true)
+        ';
+        echo_request_body;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+
+--- user_files
+>>> a.txt
+Will you change this world?
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+lua entry thread aborted: runtime error: [string "rewrite_by_lua"]:3: request body not read yet
+--- no_error_log
+[alert]
+
+
+
+=== TEST 21: read buffered body to memory and reset it with data in memory + proxy
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("hiya, dear dear friend!")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+    location = /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+--- response_body chomp
+hiya, dear dear friend!
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 22: discard request body and reset it to a new file (no auto-clean)
+--- config
+    client_body_in_file_only off;
+
+    location = /test {
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.discard_body()
+            local a_file = ngx.var.realpath_root .. "/a.txt"
+            ngx.req.set_body_file(a_file, true)
+        ';
+        echo_request_body;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+
+--- user_files
+>>> a.txt
+Will you change this world?
+
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- no_error_log
+[alert]
+
+
+
+=== TEST 23: discard body and then read
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.req.discard_body()
+            ngx.req.read_body()
+            ngx.print(ngx.req.get_body_data())
+        ';
+    }
+--- pipelined_requests eval
+["POST /test
+hello, world",
+"POST /test
+hello, world"]
+--- response_body eval
+["nil","nil"]
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 24: set empty request body in memory
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+    location = /echo {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say("body: [", ngx.req.get_body_data(), "]")
+        ';
+    }
+--- pipelined_requests eval
+["POST /test
+hello, world",
+"POST /test
+hello, world"]
+--- response_body eval
+["body: [nil]\n","body: [nil]\n"]
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 25: set empty request body in file
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_file(ngx.var.realpath_root .. "/a.txt")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+    location = /echo {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say("body: [", ngx.req.get_body_data(), "]")
+        ';
+    }
+--- user_files
+>>> a.txt
+--- pipelined_requests eval
+["POST /test
+hello, world",
+"POST /test
+hello, world"]
+--- response_body eval
+["body: [nil]\n","body: [nil]\n"]
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 26: read and set body
+--- config
+    location /test {
+        lua_need_request_body on;
+        access_by_lua_file html/myscript.lua;
+        echo_request_body;
+    }
+--- user_files
+>>> myscript.lua
+    local data, data2 = ngx.req.get_post_args(), {}
+    for k, v in pairs(data) do
+        if type(v) == "table" then
+            for i, val in ipairs(v) do
+                local s = ngx.escape_uri(string.upper(k)) .. '='
+                        .. ngx.escape_uri(string.upper(val))
+                table.insert(data2, s)
+            end
+        else
+            local s = ngx.escape_uri(string.upper(k)) .. '='
+                    .. ngx.escape_uri(string.upper(v))
+            table.insert(data2, s)
+        end
+    end
+    ngx.req.set_body_data(table.concat(data2, "&"))
+--- request
+POST /test
+a=1&a=2&b=hello&c=world
+--- response_body
+B=HELLO&A=1&A=2&C=WORLD
+--- no_error_log
+[error]
+--- SKIP
+
+
+
+=== TEST 27: read buffered body to memory and reset it with data in memory + proxy twice
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("hiya, dear dear friend!")
+            ngx.req.set_body_data("howdy, my dear little sister!")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+    location = /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+--- response_body chomp
+howdy, my dear little sister!
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 28: read buffered body to memory and reset it with data in memory and then reset it to file
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("hiya, dear dear friend!")
+            ngx.req.set_body_file(ngx.var.realpath_root .. "/a.txt")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+    location = /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- user_files
+>>> a.txt
+howdy, my dear little sister!
+--- request
+POST /test
+hello, world
+--- response_body
+howdy, my dear little sister!
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 29: read buffered body to memory and reset it with empty string + proxy twice
+--- config
+    location = /test {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_data("hiya, dear dear friend!")
+            ngx.req.set_body_data("")
+        ';
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+    location = /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+hello, world
+--- response_body chomp
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 30: multi-buffer request body
+--- config
+    location /foo {
+        default_type text/css;
+        srcache_store POST /store;
+
+        echo hello;
+        echo world;
+    }
+
+    location /store {
+        content_by_lua '
+            local body = ngx.req.get_body_data()
+            ngx.log(ngx.WARN, "srcache_store: request body len: ", #body)
+        ';
+    }
+--- request
+GET /foo
+--- response_body
+hello
+world
+--- error_log
+srcache_store: request body len: 55
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 31: init & append & finish (just in buffer)
+--- config
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.req.init_body(4)
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+        ';
+    }
+--- request
+    GET /t
+--- stap2
+F(ngx_http_lua_write_request_body) {
+    b = ngx_chain_buf($body)
+    println("buf: ", b,
+        ", in-mem: ", ngx_buf_in_memory(b),
+        ", size: ", ngx_buf_size(b),
+        ", data: ", ngx_buf_data(b))
+}
+--- response_body
+content length: 4
+body: hell
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 32: init & append & finish (exceeding the buffer size)
+--- config
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.req.init_body(4)
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.append_body("o")
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+            local file = ngx.req.get_body_file()
+            if not file then
+                ngx.say("body file: ", file)
+                return
+            end
+
+            local f, err = io.open(file, "r")
+            if not f then
+                ngx.say("failed to open file: ", err)
+                return
+            end
+
+            local data = f:read("*a")
+            f:close()
+            ngx.say("body file: ", data)
+        ';
+    }
+--- request
+    GET /t
+--- stap2
+F(ngx_http_lua_write_request_body) {
+    b = ngx_chain_buf($body)
+    println("buf: ", b,
+        ", in-mem: ", ngx_buf_in_memory(b),
+        ", size: ", ngx_buf_size(b),
+        ", data: ", ngx_buf_data(b))
+}
+F(ngx_open_tempfile) {
+    println("open temp file ", user_string($name), ", persist: ", $persistent)
+}
+F(ngx_pool_delete_file) {
+    println("delete ", ngx_pool_cleanup_file_name($data))
+}
+--- response_body
+content length: 5
+body: nil
+body file: hello
+--- no_error_log
+[error]
+[alert]
+--- error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 33: init & append & finish (use default buffer size) - body not read yet
+--- config
+    location /t {
+        client_body_buffer_size 4;
+        content_by_lua '
+            ngx.req.init_body()
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+        ';
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+lua entry thread aborted: runtime error: [string "content_by_lua"]:2: request body not read yet
+--- no_error_log
+[alert]
+
+
+
+=== TEST 34: init & append & finish (use default buffer size)
+--- config
+    location /t {
+        client_body_buffer_size 4;
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.req.init_body()
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+content length: 4
+body: hell
+--- no_error_log
+[error]
+[alert]
+--- no_error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 35: init & append & finish (exceeding the buffer size, proxy)
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.init_body(4)
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.append_body("o\\n")
+            ngx.req.finish_body()
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+
+    location = /back {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /t
+i do like the sky
+
+--- stap
+global valid = 0
+
+F(ngx_http_handler) { valid = 1  }
+
+probe syscall.unlink {
+    if (valid && pid() == target()) {
+        println(name, "(", argstr, ")")
+    }
+}
+
+--- stap_out_like chop
+^unlink\(".*?client_body_temp/\d+"\)$
+--- response_body
+hello
+--- no_error_log
+[error]
+[alert]
+--- error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 36: init & append & finish (just in buffer, proxy)
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.init_body(4)
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.finish_body()
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/back;
+    }
+
+    location = /back {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /t
+i do like the sky
+--- response_body chop
+hell
+--- no_error_log
+[error]
+[alert]
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 37: init & append & finish (exceeding buffer size, discard on-disk buffer)
+--- config
+    client_header_buffer_size 100;
+    location /t {
+        client_body_buffer_size 4;
+
+        content_by_lua '
+            ngx.req.read_body()
+
+            -- ngx.say("original body: ", ngx.req.get_body_data())
+            -- ngx.say("original body file: ", ngx.req.get_body_file())
+
+            ngx.req.init_body(4)
+            ngx.req.append_body("h")
+            ngx.req.append_body("ell")
+            ngx.req.append_body("o")
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+            local file = ngx.req.get_body_file()
+            if not file then
+                ngx.say("body file: ", file)
+                return
+            end
+
+            local f, err = io.open(file, "r")
+            if not f then
+                ngx.say("failed to open file: ", err)
+                return
+            end
+
+            local data = f:read("*a")
+            f:close()
+            ngx.say("body file: ", data)
+        ';
+    }
+--- request eval
+"POST /t
+" . ("howdyworld" x 15)
+--- stap
+/*
+F(ngx_http_read_client_request_body) { T() }
+M(http-read-body-abort) { println("read body aborted: ", user_string($arg2)) }
+M(http-read-req-header-done) { println("req header: ", ngx_table_elt_key($arg2), ": ", ngx_table_elt_value($arg2)) }
+#probe syscall.open { if (isinstr(argstr, "temp")) { println(name, ": ", argstr) } }
+
+probe syscall.unlink {
+    println(name, ": ", argstr, " :", target(), " == ", pid(), ": ", execname())
+    system(sprintf("ps aux|grep %d|grep -v grep > /dev/stderr", target()))
+    system(sprintf("ps aux|grep %d|grep -v grep  > /dev/stderr", pid()))
+}
+*/
+
+global valid = 0
+
+F(ngx_http_handler) { valid = 1  }
+#F(ngx_http_free_request) { valid = 0 }
+
+probe syscall.unlink {
+    if (valid && pid() == target()) {
+        println(name, "(", argstr, ")")
+        #print_ubacktrace()
+    }
+}
+
+/*
+probe syscall.close, syscall.open, syscall.unlink {
+    if (valid && pid() == target()) {
+        print(name, "(", argstr, ")")
+        #print_ubacktrace()
+    }
+}
+
+probe syscall.close.return, syscall.open.return, syscall.unlink.return {
+    if (valid && pid() == target()) {
+        println(" = ", retstr)
+    }
+}
+*/
+--- stap_out_like chop
+^unlink\(".*?client_body_temp/\d+"\)
+unlink\(".*?client_body_temp/\d+"\)$
+--- response_body
+content length: 5
+body: nil
+body file: hello
+--- no_error_log
+[error]
+[alert]
+--- error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 38: ngx.req.socket + init & append & finish (requests)
+--- config
+    location = /t {
+        client_body_buffer_size 1;
+        lua_socket_buffer_size 1;
+        content_by_lua '
+            local sock,err = ngx.req.socket()
+            if not sock then
+                ngx.say("failed to get req socket: ", err)
+                return
+            end
+
+            ngx.req.init_body(100)
+
+            while true do
+                local data, err = sock:receive(1)
+                if not data then
+                    if err == "closed" then
+                        break
+                    else
+                        ngx.say("failed to read body: ", err)
+                        return
+                    end
+                end
+                ngx.req.append_body(data)
+            end
+
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+        ';
+    }
+--- request
+POST /t
+hello, my dear friend!
+--- response_body
+content length: 22
+body: hello, my dear friend!
+--- no_error_log
+[error]
+[alert]
+--- no_error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 39: ngx.req.socket + init & append & finish (pipelined requests, small buffer size)
+--- config
+    location = /t {
+        client_body_buffer_size 1;
+        lua_socket_buffer_size 1;
+        content_by_lua '
+            local sock,err = ngx.req.socket()
+            if not sock then
+                ngx.say("failed to get req socket: ", err)
+                return
+            end
+
+            ngx.req.init_body(100)
+
+            while true do
+                local data, err = sock:receive(1)
+                if not data then
+                    if err == "closed" then
+                        break
+                    else
+                        ngx.say("failed to read body: ", err)
+                        return
+                    end
+                end
+                ngx.req.append_body(data)
+            end
+
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+        ';
+    }
+--- pipelined_requests eval
+["POST /t
+hello, my dear friend!",
+"POST /t
+blah blah blah"]
+--- response_body eval
+["content length: 22
+body: hello, my dear friend!
+","content length: 14
+body: blah blah blah
+"]
+--- no_error_log
+[error]
+[alert]
+--- no_error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 40: ngx.req.socket + init & append & finish (pipelined requests, big buffer size)
+--- config
+    location = /t {
+        client_body_buffer_size 100;
+        lua_socket_buffer_size 100;
+        content_by_lua '
+            local sock,err = ngx.req.socket()
+            if not sock then
+                ngx.say("failed to get req socket: ", err)
+                return
+            end
+
+            ngx.req.init_body(100)
+
+            while true do
+                local data, err, partial = sock:receive(100)
+                if not data then
+                    if err == "closed" then
+                        ngx.req.append_body(partial)
+                        break
+                    else
+                        ngx.say("failed to read body: ", err)
+                        return
+                    end
+                end
+                ngx.req.append_body(data)
+            end
+
+            ngx.req.finish_body()
+
+            ngx.say("content length: ", ngx.var.http_content_length)
+
+            local data = ngx.req.get_body_data()
+            ngx.say("body: ", data)
+
+        ';
+    }
+--- pipelined_requests eval
+["POST /t
+hello, my dear friend!",
+"POST /t
+blah blah blah"]
+--- response_body eval
+["content length: 22
+body: hello, my dear friend!
+","content length: 14
+body: blah blah blah
+"]
+--- no_error_log
+[error]
+[alert]
+--- no_error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 41: calling ngx.req.socket after ngx.req.read_body
+--- config
+    location = /t {
+        client_body_buffer_size 100;
+        lua_socket_buffer_size 100;
+        content_by_lua '
+            ngx.req.read_body()
+
+            local sock, err = ngx.req.socket()
+            if not sock then
+                ngx.say("failed to get req socket: ", err)
+                return
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+POST /t
+hello, my dear friend!
+--- response_body
+failed to get req socket: request body already exists
+--- no_error_log
+[error]
+[alert]
+--- no_error_log
+a client request body is buffered to a temporary file
+
+
+
+=== TEST 42: failed to write 100 continue
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.var.request_body)
+        ';
+    }
+--- request
+POST /test
+hello, world
+--- more_headers
+Expect: 100-Continue
+--- ignore_response
+--- no_error_log
+[alert]
+[error]
+http finalize request: 500, "/test?" a:1, c:0
+
+
+
+=== TEST 43: chunked support in ngx.req.read_body
+--- config
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.1\r
+Host: localhost\r
+Transfer-Encoding: chunked\r
+Connection: close\r
+\r
+5\r
+hello\r
+1\r
+,\r
+1\r
+ \r
+5\r
+world\r
+0\r
+\r
+"
+
+--- response_body
+hello, world
+--- no_error_log
+[error]
+[alert]
+--- skip_nginx: 4: <1.3.9
+
+
+
+=== TEST 44: zero size request body and reset it to a new file
+--- config
+    location = /test {
+        client_body_in_file_only on;
+        set $old '';
+        set $new '';
+        rewrite_by_lua '
+            ngx.req.read_body()
+            ngx.req.set_body_file(ngx.var.realpath_root .. "/a.txt")
+            ngx.var.new = ngx.req.get_body_file()
+        ';
+        #echo_request_body;
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        #proxy_pass http://127.0.0.1:7890/echo;
+        add_header X-Old $old;
+        add_header X-New $new;
+    }
+    location /echo {
+        echo_read_request_body;
+        echo_request_body;
+    }
+--- request
+POST /test
+--- user_files
+>>> a.txt
+Will you change this world?
+
+--- stap
+probe syscall.fcntl {
+    O_DIRECT = 0x4000
+    if (pid() == target() && ($arg & O_DIRECT)) {
+        println("fcntl(O_DIRECT)")
+    }
+}
+--- stap_out_unlike
+fcntl\(O_DIRECT\)
+
+--- raw_response_headers_like
+.*?X-New: \S+/html/a\.txt\r
+--- response_body
+Will you change this world?
+--- no_error_log
+[error]
+[alert]
+
diff -rNu a/src/lua/lua-nginx-module/t/045-ngx-var.t b/src/lua/lua-nginx-module/t/045-ngx-var.t
--- a/src/lua/lua-nginx-module/t/045-ngx-var.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/045-ngx-var.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,155 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 2);
+
+#no_diff();
+#no_long_string();
+#master_on();
+#workers(2);
+run_tests();
+
+__DATA__
+
+=== TEST 1: set indexed variables to nil
+--- config
+    location = /test {
+        set $var 32;
+        content_by_lua '
+            ngx.say("old: ", ngx.var.var)
+            ngx.var.var = nil
+            ngx.say("new: ", ngx.var.var)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+old: 32
+new: nil
+
+
+
+=== TEST 2: set variables with set_handler to nil
+--- config
+    location = /test {
+        content_by_lua '
+            ngx.say("old: ", ngx.var.args)
+            ngx.var.args = nil
+            ngx.say("new: ", ngx.var.args)
+        ';
+    }
+--- request
+GET /test?hello=world
+--- response_body
+old: hello=world
+new: nil
+
+
+
+=== TEST 3: reference nonexistent variable
+--- config
+    location = /test {
+        set $var 32;
+        content_by_lua '
+            ngx.say("value: ", ngx.var.notfound)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+value: nil
+
+
+
+=== TEST 4: no-hash variables
+--- config
+    location = /test {
+        proxy_pass http://127.0.0.1:$server_port/foo;
+        header_filter_by_lua '
+            ngx.header["X-My-Host"] = ngx.var.proxy_host
+        ';
+    }
+
+    location = /foo {
+        echo foo;
+    }
+--- request
+GET /test
+--- response_headers
+X-My-Host: foo
+--- response_body
+foo
+--- SKIP
+
+
+
+=== TEST 5: variable name is caseless
+--- config
+    location = /test {
+        set $Var 32;
+        content_by_lua '
+            ngx.say("value: ", ngx.var.VAR)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+value: 32
+
+
+
+=== TEST 6: true $invalid_referer variable value in Lua
+github issue #239
+--- config
+    location = /t {
+        valid_referers www.foo.com;
+        content_by_lua '
+            ngx.say("invalid referer: ", ngx.var.invalid_referer)
+            ngx.exit(200)
+        ';
+        #echo $invalid_referer;
+    }
+
+--- request
+GET /t
+--- more_headers
+Referer: http://www.foo.com/
+
+--- response_body
+invalid referer: 
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: false $invalid_referer variable value in Lua
+github issue #239
+--- config
+    location = /t {
+        valid_referers www.foo.com;
+        content_by_lua '
+            ngx.say("invalid referer: ", ngx.var.invalid_referer)
+            ngx.exit(200)
+        ';
+        #echo $invalid_referer;
+    }
+
+--- request
+GET /t
+--- more_headers
+Referer: http://www.bar.com
+
+--- response_body
+invalid referer: 1
+
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/046-hmac.t b/src/lua/lua-nginx-module/t/046-hmac.t
--- a/src/lua/lua-nginx-module/t/046-hmac.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/046-hmac.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,33 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /lua {
+        content_by_lua '
+            local digest = ngx.hmac_sha1("thisisverysecretstuff", "some string we want to sign")
+            ngx.say(ngx.encode_base64(digest))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+R/pvxzHC4NLtj7S+kXFg/NePTmk=
+
diff -rNu a/src/lua/lua-nginx-module/t/047-match-jit.t b/src/lua/lua-nginx-module/t/047-match-jit.t
--- a/src/lua/lua-nginx-module/t/047-match-jit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/047-match-jit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,208 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 5);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched with j
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)", "j")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 2: not matched with j
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, world", "([0-9]+)", "j")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched!
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 3: matched with jo
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, 1234", "([0-9]+)", "jo")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+1234
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 4: not matched with jo
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello, world", "([0-9]+)", "jo")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched!
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 5: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local m, err = ngx.re.match("hello\\nworld", "(abc", "j")
+            if m then
+                ngx.say(m[0])
+
+            else
+                if err then
+                    ngx.say("error: ", err)
+
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: just hit match limit
+--- http_config
+    lua_regex_match_limit 2940;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 21)
+
+local start = ngx.now()
+
+local res, err = ngx.re.match(s, re, "jo")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if not res then
+    if err then
+        ngx.say("error: ", err)
+        return
+    end
+    ngx.say("failed to match")
+    return
+end
+
+--- request
+    GET /re
+--- response_body
+error: pcre_exec() failed: -8
+
+
+
+=== TEST 7: just not hit match limit
+--- http_config
+    lua_regex_match_limit 2950;
+--- config
+    location /re {
+        content_by_lua_file html/a.lua;
+    }
+
+--- user_files
+>>> a.lua
+local re = [==[(?i:([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:=|<=>|r?like|sounds\s+like|regexp)([\s'\"`´’‘\(\)]*)?\2|([\s'\"`´’‘\(\)]*)?([\d\w]+)([\s'\"`´’‘\(\)]*)?(?:!=|<=|>=|<>|<|>|\^|is\s+not|not\s+like|not\s+regexp)([\s'\"`´’‘\(\)]*)?(?!\6)([\d\w]+))]==]
+
+s = string.rep([[ABCDEFG]], 21)
+
+local start = ngx.now()
+
+local res, err = ngx.re.match(s, re, "jo")
+
+--[[
+ngx.update_time()
+local elapsed = ngx.now() - start
+ngx.say(elapsed, " sec elapsed.")
+]]
+
+if not res then
+    if err then
+        ngx.say("error: ", err)
+        return
+    end
+    ngx.say("failed to match")
+    return
+end
+
+--- request
+    GET /re
+--- response_body
+failed to match
+
diff -rNu a/src/lua/lua-nginx-module/t/048-match-dfa.t b/src/lua/lua-nginx-module/t/048-match-dfa.t
--- a/src/lua/lua-nginx-module/t/048-match-dfa.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/048-match-dfa.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,184 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 4);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched with d
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello", "(he|hell)", "d")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hell
+
+
+
+=== TEST 2: matched with d + j
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello", "(he|hell)", "jd")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hell
+
+
+
+=== TEST 3: not matched with j
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("world", "(he|hell)", "d")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched!
+
+
+
+=== TEST 4: matched with do
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("hello", "he|hell", "do")
+            if m then
+                ngx.say(m[0])
+                ngx.say(m[1])
+                ngx.say(m[2])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hell
+nil
+nil
+
+
+
+=== TEST 5: not matched with do
+--- config
+    location /re {
+        content_by_lua '
+            m = ngx.re.match("world", "([0-9]+)", "do")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+not matched!
+
+
+
+=== TEST 6: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("你好", ".", "Ud")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local m = ngx.re.match("你好", ".", "ud")
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/049-gmatch-jit.t b/src/lua/lua-nginx-module/t/049-gmatch-jit.t
--- a/src/lua/lua-nginx-module/t/049-gmatch-jit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/049-gmatch-jit.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,214 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 9);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: gmatch matched
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello, world", "[a-z]+", "j") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 2: fail to match
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[0-9]", "j")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+nil
+nil
+nil
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 3: gmatch matched but no iterate
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "j")
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 4: gmatch matched but only iterate once and still matches remain
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "j")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 5: gmatch matched + o
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello, world", "[a-z]+", "jo") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 6: fail to match + o
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[0-9]", "jo")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+nil
+nil
+nil
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 7: gmatch matched but no iterate + o
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "jo")
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 8: gmatch matched but only iterate once and still matches remain + o
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "jo")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 9: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local m, err = ngx.re.gmatch("hello\\nworld", "(abc", "j")
+            if not m then
+                ngx.say("error: ", err)
+                return
+            end
+            ngx.say("success")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/050-gmatch-dfa.t b/src/lua/lua-nginx-module/t/050-gmatch-dfa.t
--- a/src/lua/lua-nginx-module/t/050-gmatch-dfa.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/050-gmatch-dfa.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,289 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 5);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: gmatch matched
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello, halo", "h[a-z]|h[a-z][a-z]", "d") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hel
+hal
+
+
+
+=== TEST 2: d + j
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello, halo", "h[a-z]|h[a-z][a-z]", "dj") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hel
+hal
+
+
+
+=== TEST 3: fail to match
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[0-9]", "d")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+nil
+nil
+nil
+
+
+
+=== TEST 4: gmatch matched but no iterate
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "d")
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+
+
+
+=== TEST 5: gmatch matched but only iterate once and still matches remain
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "d")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 6: gmatch matched + o
+--- config
+    location /re {
+        content_by_lua '
+            for m in ngx.re.gmatch("hello, world", "[a-z]+", "do") do
+                if m then
+                    ngx.say(m[0])
+                else
+                    ngx.say("not matched: ", m)
+                end
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+world
+
+
+
+=== TEST 7: fail to match + o
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[0-9]", "do")
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+
+            local m = it()
+            if m then ngx.say(m[0]) else ngx.say(m) end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+nil
+nil
+nil
+
+
+
+=== TEST 8: gmatch matched but no iterate + o
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "do")
+            ngx.say("done")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+done
+
+
+
+=== TEST 9: gmatch matched but only iterate once and still matches remain + o
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("hello, world", "[a-z]+", "do")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched")
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello
+
+
+
+=== TEST 10: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local it, err = ngx.re.gmatch("hello\\nworld", "(abc", "d")
+            if not it then
+                ngx.say("error: ", err)
+                return
+            end
+            ngx.say("success")
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("你好", ".", "Ud")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local it = ngx.re.gmatch("你好", ".", "ud")
+            local m = it()
+            if m then
+                ngx.say(m[0])
+            else
+                ngx.say("not matched!")
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+你
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/051-sub-jit.t b/src/lua/lua-nginx-module/t/051-sub-jit.t
--- a/src/lua/lua-nginx-module/t/051-sub-jit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/051-sub-jit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,143 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 6);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched with j
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234 5678", "([0-9]+)", "world", "j")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world 5678: 1
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 2: not matched with j
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[0-9]+", "hiya", "j")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 3: matched with jo
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234 5678", "([0-9]+)", "world", "jo")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world 5678: 1
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 4: not matched with jo
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[0-9]+", "hiya", "jo")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 5: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("hello\\nworld", "(abc", "world", "j")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: bad pattern + o
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub( "hello\\nworld", "(abc", "world", "jo")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/052-sub-dfa.t b/src/lua/lua-nginx-module/t/052-sub-dfa.t
--- a/src/lua/lua-nginx-module/t/052-sub-dfa.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/052-sub-dfa.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,201 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 6);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched with d
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234 5678", "[0-9]|[0-9][0-9]", "world", "d")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world34 5678: 1
+
+
+
+=== TEST 2: not matched with d
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[0-9]+", "hiya", "d")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+
+
+
+=== TEST 3: matched with do
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, 1234 5678", "[0-9]|[0-9][0-9]", "world", "do")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world34 5678: 1
+
+
+
+=== TEST 4: not matched with do
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.sub("hello, world", "[0-9]+", "hiya", "do")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+
+
+
+=== TEST 5: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("hello\\nworld", "(abc", "world", "j")
+            if s then
+                ngx.say(s, ": ", n)
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: bad pattern + o
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("hello\\nworld", "(abc", "world", "jo")
+            if s then
+                ngx.say(s, ": ", n)
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("你好", ".", "a", "Ud")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+s: a好
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.sub("你好", ".", "a", "ud")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+s: a好
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/053-gsub-jit.t b/src/lua/lua-nginx-module/t/053-gsub-jit.t
--- a/src/lua/lua-nginx-module/t/053-gsub-jit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/053-gsub-jit.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,143 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 6);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched with j
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, 1234 5678", "([0-9]+)", "world", "j")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world world: 2
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 2: not matched with j
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[0-9]+", "hiya", "j")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 3: matched with jo
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, 1234 5678", "([0-9]+)", "world", "jo")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world world: 2
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 4: not matched with jo
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[0-9]+", "hiya", "jo")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+--- error_log
+pcre JIT compiling result: 1
+
+
+
+=== TEST 5: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("hello\\nworld", "(abc", "world", "j")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: bad pattern + o
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("hello\\nworld", "(abc", "world", "jo")
+            if s then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/054-gsub-dfa.t b/src/lua/lua-nginx-module/t/054-gsub-dfa.t
--- a/src/lua/lua-nginx-module/t/054-gsub-dfa.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/054-gsub-dfa.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,202 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 5);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: matched with d
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, 1234 5678", "[0-9]|[0-9][0-9]", "world", "d")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, worldworld worldworld: 4
+
+
+
+=== TEST 2: not matched with d
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[0-9]+", "hiya", "d")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+
+
+
+=== TEST 3: matched with do
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, 1234 5678", "[0-9]|[0-9][0-9]", "world", "do")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, worldworld worldworld: 4
+
+
+
+=== TEST 4: not matched with do
+--- config
+    location /re {
+        content_by_lua '
+            local s, n = ngx.re.gsub("hello, world", "[0-9]+", "hiya", "do")
+            if n then
+                ngx.say(s, ": ", n)
+            else
+                ngx.say(s)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+hello, world: 0
+
+
+
+=== TEST 5: bad pattern
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("hello\\nworld", "(abc", "world", "j")
+            if s then
+                ngx.say("gsub: ", n)
+
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+
+
+
+=== TEST 6: bad pattern + o
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("hello\\nworld", "(abc", "world", "jo")
+            if s then
+                ngx.say("gsub: ", n)
+            else
+                ngx.say("error: ", err)
+            end
+        ';
+    }
+--- request
+    GET /re
+--- response_body
+error: pcre_compile() failed: missing ) in "(abc"
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: UTF-8 mode without UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("你好", ".", "a", "Ud")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 2000
+exec opts: 2000
+exec opts: 2000
+
+--- request
+    GET /re
+--- response_body
+s: aa
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: UTF-8 mode with UTF-8 sequence checks
+--- config
+    location /re {
+        content_by_lua '
+            local s, n, err = ngx.re.gsub("你好", ".", "a", "ud")
+            if s then
+                ngx.say("s: ", s)
+            end
+        ';
+    }
+--- stap
+probe process("$LIBPCRE_PATH").function("pcre_compile") {
+    printf("compile opts: %x\n", $options)
+}
+
+probe process("$LIBPCRE_PATH").function("pcre_dfa_exec") {
+    printf("exec opts: %x\n", $options)
+}
+
+--- stap_out
+compile opts: 800
+exec opts: 0
+exec opts: 0
+exec opts: 0
+
+--- request
+    GET /re
+--- response_body
+s: aa
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/055-subreq-vars.t b/src/lua/lua-nginx-module/t/055-subreq-vars.t
--- a/src/lua/lua-nginx-module/t/055-subreq-vars.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/055-subreq-vars.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,340 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2 + 5);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: set non-existent variables via "vars" option
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { dog = "hello", cat = 32 }});
+
+            ngx.print(res.body)
+        ';
+    }
+
+--- stap2
+
+global delta = "  "
+
+F(ngx_http_finalize_request) {
+    uri = ngx_http_req_uri($r)
+    printf("finalize req %s: %d\n", uri, $rc)
+    if ($rc == 500) {
+        print_ubacktrace()
+    }
+}
+
+F(ngx_http_lua_run_thread) {
+    uri = ngx_http_req_uri($r)
+    printf("lua run thread %s\n", uri)
+}
+
+M(http-subrequest-start) {
+    r = $arg1
+    n = ngx_http_subreq_depth(r)
+    pr = ngx_http_req_parent(r)
+    printf("%sbegin %s -> %s (%d)\n", ngx_indent(n, delta),
+        ngx_http_req_uri(pr),
+        ngx_http_req_uri(r),
+        n)
+}
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_log chop
+variable "dog" cannot be assigned a value (maybe you forgot to define it first?)
+--- error_code: 500
+
+
+
+=== TEST 2: set non-existent variables via "vars" option
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog '';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { dog = "hello", cat = 32 }});
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_log chop
+variable "cat" cannot be assigned a value (maybe you forgot to define it first?)
+--- error_code: 500
+
+
+
+=== TEST 3: good "vars" option: user variables
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog '';
+        set $cat '';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { dog = "hello", cat = 32 }});
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+dog = hello
+cat = 32
+
+
+
+=== TEST 4: bad "vars" option value
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog '';
+        set $cat '';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = "hello" });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log chop
+Bad vars option value
+
+
+
+=== TEST 5: bad "vars" option value value
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog '';
+        set $cat '';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { cat = true } });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log chop
+attempt to use bad variable value type boolean
+
+
+
+=== TEST 6: good "vars" option: builtin variables
+--- config
+    location /other {
+        echo "args: $args";
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { args = "a=hello&b=32" }});
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+args: a=hello&b=32
+
+
+
+=== TEST 7: setting non-changeable vars
+--- config
+    location /other {
+        echo "query string: $query_string";
+    }
+
+    location /lua {
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { query_string = "hello" } });
+
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log chop
+variable "query_string" not changeable
+
+
+
+=== TEST 8: copy all vars
+--- config
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { copy_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+/other dog: hello world
+/lua: hello
+
+
+
+=== TEST 9: share all vars
+--- config
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { share_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+/other dog: hello world
+/lua: hello world
+
+
+
+=== TEST 10: vars takes priority over copy_all_vars
+--- config
+    location /other {
+        set $dog "$dog world";
+        echo "$uri dog: $dog";
+    }
+
+    location /lua {
+        set $dog 'hello';
+        content_by_lua '
+            res = ngx.location.capture("/other",
+                { vars = { dog = "hiya" }, copy_all_vars = true });
+
+            ngx.print(res.body)
+            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+/other dog: hiya world
+/lua: hello
+
+
+
+=== TEST 11: capture_multi: good "vars" option: user variables
+--- config
+    location /other {
+        content_by_lua '
+            ngx.say("dog = ", ngx.var.dog)
+            ngx.say("cat = ", ngx.var.cat)
+        ';
+    }
+
+    location /lua {
+        set $dog 'blah';
+        set $cat 'foo';
+        content_by_lua '
+            local res1, res2 = ngx.location.capture_multi{
+                {"/other/1",
+                    { vars = { dog = "hello", cat = 32 }}
+                },
+                {"/other/2",
+                    { vars = { dog = "hiya", cat = 56 }}
+                }
+            };
+
+            ngx.print(res1.body)
+            ngx.print(res2.body)
+            ngx.say("parent dog: ", ngx.var.dog)
+            ngx.say("parent cat: ", ngx.var.cat)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+dog = hello
+cat = 32
+dog = hiya
+cat = 56
+parent dog: blah
+parent cat: foo
+
diff -rNu a/src/lua/lua-nginx-module/t/056-flush.t b/src/lua/lua-nginx-module/t/056-flush.t
--- a/src/lua/lua-nginx-module/t/056-flush.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/056-flush.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,429 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+BEGIN {
+    $ENV{TEST_NGINX_POSTPONE_OUTPUT} = 1;
+}
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * 50;
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: flush wait - content
+--- config
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            local ok, err = ngx.flush(true)
+            if not ok then
+                ngx.log(ngx.ERR, "flush failed: ", err)
+                return
+            end
+            ngx.say("hiya")
+        ';
+    }
+--- request
+GET /test
+--- response_body
+hello, world
+hiya
+--- no_error_log
+[error]
+--- error_log
+lua reuse free buf memory 13 >= 5
+
+
+
+=== TEST 2: flush no wait - content
+--- config
+    send_timeout 500ms;
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            local ok, err = ngx.flush(false)
+            if not ok then
+                ngx.log(ngx.ERR, "flush failed: ", err)
+                return
+            end
+            ngx.say("hiya")
+        ';
+    }
+--- request
+GET /test
+--- response_body
+hello, world
+hiya
+
+
+
+=== TEST 3: flush wait - rewrite
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(true)
+            ngx.say("hiya")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /test
+--- response_body
+hello, world
+hiya
+
+
+
+=== TEST 4: flush no wait - rewrite
+--- config
+    location /test {
+        rewrite_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(false)
+            ngx.say("hiya")
+        ';
+        content_by_lua return;
+    }
+--- request
+GET /test
+--- response_body
+hello, world
+hiya
+
+
+
+=== TEST 5: http 1.0 (sync)
+--- config
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(true)
+            ngx.say("hiya")
+            ngx.flush(true)
+            ngx.say("blah")
+        ';
+    }
+--- request
+GET /test HTTP/1.0
+--- response_body
+hello, world
+hiya
+blah
+--- response_headers
+Content-Length: 23
+--- timeout: 5
+--- error_log
+lua buffering output bufs for the HTTP 1.0 request
+lua http 1.0 buffering makes ngx.flush() a no-op
+
+
+
+=== TEST 6: http 1.0 (async)
+--- config
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            local ok, err = ngx.flush(false)
+            if not ok then
+                ngx.log(ngx.WARN, "1: failed to flush: ", err)
+            end
+            ngx.say("hiya")
+            local ok, err = ngx.flush(false)
+            if not ok then
+                ngx.log(ngx.WARN, "2: failed to flush: ", err)
+            end
+            ngx.say("blah")
+        ';
+    }
+--- request
+GET /test HTTP/1.0
+--- response_body
+hello, world
+hiya
+blah
+--- response_headers
+Content-Length: 23
+--- error_log
+lua buffering output bufs for the HTTP 1.0 request
+lua http 1.0 buffering makes ngx.flush() a no-op
+1: failed to flush: buffering
+2: failed to flush: buffering
+--- timeout: 5
+
+
+
+=== TEST 7: flush wait - big data
+--- config
+    location /test {
+        content_by_lua '
+            ngx.say(string.rep("a", 1024 * 64))
+            ngx.flush(true)
+            ngx.say("hiya")
+        ';
+    }
+--- request
+GET /test
+--- response_body
+hello, world
+hiya
+--- SKIP
+
+
+
+=== TEST 8: flush wait - content
+--- config
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(true)
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+            ngx.flush(true)
+        ';
+    }
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /test
+--- response_body
+hello, world
+sub
+
+
+
+=== TEST 9: http 1.0 (sync + buffering off)
+--- config
+    lua_http10_buffering off;
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(true)
+            ngx.say("hiya")
+            ngx.flush(true)
+            ngx.say("blah")
+        ';
+    }
+--- request
+GET /test HTTP/1.0
+--- response_body
+hello, world
+hiya
+blah
+--- response_headers
+!Content-Length
+--- timeout: 5
+--- no_error_log
+lua buffering output bufs for the HTTP 1.0 request
+lua http 1.0 buffering makes ngx.flush() a no-op
+
+
+
+=== TEST 10: http 1.0 (async)
+--- config
+    lua_http10_buffering on;
+    location /test {
+        lua_http10_buffering off;
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(false)
+            ngx.say("hiya")
+            ngx.flush(false)
+            ngx.say("blah")
+        ';
+    }
+--- request
+GET /test HTTP/1.0
+--- response_body
+hello, world
+hiya
+blah
+--- response_headers
+!Content-Length
+--- no_error_log
+lua buffering output bufs for the HTTP 1.0 request
+lua http 1.0 buffering makes ngx.flush() a no-op
+--- timeout: 5
+
+
+
+=== TEST 11: http 1.0 (sync) - buffering explicitly off
+--- config
+    location /test {
+        lua_http10_buffering on;
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(true)
+            ngx.say("hiya")
+            ngx.flush(true)
+            ngx.say("blah")
+        ';
+    }
+--- request
+GET /test HTTP/1.0
+--- response_body
+hello, world
+hiya
+blah
+--- response_headers
+Content-Length: 23
+--- timeout: 5
+--- error_log
+lua buffering output bufs for the HTTP 1.0 request
+lua http 1.0 buffering makes ngx.flush() a no-op
+
+
+
+=== TEST 12: http 1.0 (async) - buffering explicitly off
+--- config
+    location /test {
+        lua_http10_buffering on;
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(false)
+            ngx.say("hiya")
+            ngx.flush(false)
+            ngx.say("blah")
+        ';
+    }
+--- request
+GET /test HTTP/1.0
+--- response_body
+hello, world
+hiya
+blah
+--- response_headers
+Content-Length: 23
+--- error_log
+lua buffering output bufs for the HTTP 1.0 request
+lua http 1.0 buffering makes ngx.flush() a no-op
+--- timeout: 5
+
+
+
+=== TEST 13: flush wait in a user coroutine
+--- config
+    location /test {
+        content_by_lua '
+            function f()
+                ngx.say("hello, world")
+                ngx.flush(true)
+                coroutine.yield()
+                ngx.say("hiya")
+            end
+            local c = coroutine.create(f)
+            ngx.say(coroutine.resume(c))
+            ngx.say(coroutine.resume(c))
+        ';
+    }
+--- request
+GET /test
+--- stap2
+F(ngx_http_lua_wev_handler) {
+    printf("wev handler: wev:%d\n", $r->connection->write->ready)
+}
+
+global ids, cur
+
+function gen_id(k) {
+    if (ids[k]) return ids[k]
+    ids[k] = ++cur
+    return cur
+}
+
+F(ngx_http_handler) {
+    delete ids
+    cur = 0
+}
+
+/*
+F(ngx_http_lua_run_thread) {
+    id = gen_id($ctx->cur_co)
+    printf("run thread %d\n", id)
+}
+
+probe process("/usr/local/openresty-debug/luajit/lib/libluajit-5.1.so.2").function("lua_resume") {
+    id = gen_id($L)
+    printf("lua resume %d\n", id)
+}
+*/
+
+M(http-lua-user-coroutine-resume) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("resume %x in %x\n", c, p)
+}
+
+M(http-lua-entry-coroutine-yield) {
+    println("entry coroutine yield")
+}
+
+/*
+F(ngx_http_lua_coroutine_yield) {
+    printf("yield %x\n", gen_id($L))
+}
+*/
+
+M(http-lua-user-coroutine-yield) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("yield %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_atpanic) {
+    printf("lua atpanic(%d):", gen_id($L))
+    print_ubacktrace();
+}
+
+M(http-lua-user-coroutine-create) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("create %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_ngx_exec) { println("exec") }
+
+F(ngx_http_lua_ngx_exit) { println("exit") }
+
+F(ngx_http_writer) { println("http writer") }
+
+--- response_body
+hello, world
+true
+hiya
+true
+--- error_log
+lua reuse free buf memory 13 >= 5
+
+
+
+=== TEST 14: flush before sending out the header
+--- config
+    location /test {
+        content_by_lua '
+            ngx.flush()
+            ngx.status = 404
+            ngx.say("not found")
+        ';
+    }
+--- request
+GET /test
+--- response_body
+not found
+--- error_code: 404
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/057-flush-timeout.t b/src/lua/lua-nginx-module/t/057-flush-timeout.t
--- a/src/lua/lua-nginx-module/t/057-flush-timeout.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/057-flush-timeout.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,218 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+BEGIN {
+    if (!defined $ENV{LD_PRELOAD}) {
+        $ENV{LD_PRELOAD} = '';
+    }
+
+    if ($ENV{LD_PRELOAD} !~ /\bmockeagain\.so\b/) {
+        $ENV{LD_PRELOAD} = "mockeagain.so $ENV{LD_PRELOAD}";
+    }
+
+    if ($ENV{MOCKEAGAIN} eq 'r') {
+        $ENV{MOCKEAGAIN} = 'rw';
+
+    } else {
+        $ENV{MOCKEAGAIN} = 'w';
+    }
+
+    $ENV{TEST_NGINX_EVENT_TYPE} = 'poll';
+    $ENV{MOCKEAGAIN_WRITE_TIMEOUT_PATTERN} = 'hello, world';
+    $ENV{TEST_NGINX_POSTPONE_OUTPUT} = 1;
+}
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 1 + 2);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: flush wait - timeout
+--- config
+    send_timeout 100ms;
+    location /test {
+        content_by_lua '
+            ngx.say("hello, world")
+            ngx.flush(true)
+            ngx.say("hiya")
+        ';
+    }
+--- request
+GET /test
+--- ignore_response
+--- error_log eval
+[qr/client timed out \(\d+: .*?timed out\)/]
+
+
+
+=== TEST 2: send timeout timer got removed in time
+--- config
+    send_timeout 1234ms;
+    location /test {
+        content_by_lua '
+            ngx.say(string.rep("blah blah blah", 10))
+            -- ngx.flush(true)
+            ngx.eof()
+            for i = 1, 20 do
+                ngx.sleep(0.1)
+            end
+        ';
+    }
+--- request
+GET /test
+--- stap
+global evtime
+
+F(ngx_http_handler) {
+    delete evtime
+}
+
+M(timer-add) {
+    if ($arg2 == 1234) {
+        printf("add timer %d\n", $arg2)
+        evtime[$arg1] = $arg2
+    }
+}
+
+M(timer-del) {
+    time = evtime[$arg1]
+    if (time == 1234) {
+        printf("del timer %d\n", time)
+    }
+}
+
+M(timer-expire) {
+    time = evtime[$arg1]
+    if (time == 1234) {
+        printf("expire timer %d\n", time)
+        #print_ubacktrace()
+    }
+}
+/*
+probe syscall.writev.return {
+    if (pid() == target()) {
+        printf("writev: %s\n", retstr)
+    }
+}
+*/
+--- stap_out
+add timer 1234
+del timer 1234
+--- ignore_response
+--- no_error_log
+[error]
+--- timeout: 3
+
+
+
+=== TEST 3: exit in user thread (entry thread is still pending on ngx.flush)
+--- config
+    send_timeout 200ms;
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.say("hello, world!")
+            ngx.flush(true)
+
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+
+/*
+F(ngx_http_finalize_request) {
+    printf("finalize request: c:%d, a:%d, cb:%d, rb:%d\n", $r->main->count,
+        $r == $r->connection->data, $r->connection->buffered, $r->buffered)
+}
+
+F(ngx_http_set_write_handler) {
+    println("set write handler")
+}
+*/
+
+F(ngx_http_lua_flush_cleanup) {
+    println("lua flush cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: ok
+lua flush cleanup
+delete timer 200
+delete thread 2
+delete thread 1
+add timer 200
+expire timer 200
+free request
+
+--- ignore_response
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/058-tcp-socket.t b/src/lua/lua-nginx-module/t/058-tcp-socket.t
--- a/src/lua/lua-nginx-module/t/058-tcp-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/058-tcp-socket.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,2577 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * 126;
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+#log_level 'warn';
+log_level 'debug';
+
+#no_long_string();
+#no_diff();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: no trailing newline
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 1234;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            sock:close()
+            ngx.say("closed")
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.print("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 3
+received: Connection: close
+received: 
+failed to receive a line: closed [foo]
+closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: no resolver defined
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 1234;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("agentzh.org", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: no resolver defined to resolve "agentzh.org"
+connected: nil
+failed to send request: closed
+--- error_log
+attempt to send data on a closed socket:
+
+
+
+=== TEST 4: with resolver
+--- timeout: 10
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = 80
+            local ok, err = sock:connect("agentzh.org", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET / HTTP/1.0\\r\\nHost: agentzh.org\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local line, err = sock:receive()
+            if line then
+                ngx.say("first line received: ", line)
+
+            else
+                ngx.say("failed to receive the first line: ", err)
+            end
+
+            line, err = sock:receive()
+            if line then
+                ngx.say("second line received: ", line)
+
+            else
+                ngx.say("failed to receive the second line: ", err)
+            end
+        ';
+    }
+
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 56
+first line received: HTTP/1.1 200 OK
+second line received: Server: ngx_openresty
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 5: connection refused (tcp)
+--- config
+    location /test {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", 16787)
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil connection refused
+send: nil closed
+receive: nil closed
+close: nil closed
+--- error_log eval
+qr/connect\(\) failed \(\d+: Connection refused\)/
+
+
+
+=== TEST 6: connection timeout (tcp)
+--- config
+    resolver $TEST_NGINX_RESOLVER;
+    lua_socket_connect_timeout 100ms;
+    lua_socket_send_timeout 100ms;
+    lua_socket_read_timeout 100ms;
+    resolver_timeout 1s;
+    location /test {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 12345)
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil timeout
+send: nil closed
+receive: nil closed
+close: nil closed
+--- error_log
+lua tcp socket connect timed out
+
+
+
+=== TEST 7: not closed manually
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: resolver error (host not found)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = 80
+            local ok, err = sock:connect("blah-blah-not-found.agentzh.org", port)
+            print("connected: ", ok, " ", err, " ", not ok)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET / HTTP/1.0\\r\\nHost: agentzh.org\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+        ';
+    }
+--- request
+GET /t
+--- response_body_like
+^failed to connect: blah-blah-not-found\.agentzh\.org could not be resolved(?: \(3: Host not found\))?
+connected: nil
+failed to send request: closed$
+--- error_log
+attempt to send data on a closed socket
+--- timeout: 5
+
+
+
+=== TEST 9: resolver error (timeout)
+--- config
+    server_tokens off;
+    resolver 8.8.8.8;
+    resolver_timeout 1ms;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = 80
+            local ok, err = sock:connect("blah-blah-not-found.agentzh.org", port)
+            print("connected: ", ok, " ", err, " ", not ok)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET / HTTP/1.0\\r\\nHost: agentzh.org\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+        ';
+    }
+--- request
+GET /t
+--- response_body_like
+^failed to connect: blah-blah-not-found\.agentzh\.org could not be resolved(?: \(\d+: Operation timed out\))?
+connected: nil
+failed to send request: closed$
+--- error_log
+attempt to send data on a closed socket
+
+
+
+=== TEST 10: explicit *l pattern for receive
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err = sock:receive("*l")
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err)
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: *a pattern for receive
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local data, err = sock:receive("*a")
+            if data then
+                ngx.say("receive: ", data)
+                ngx.say("err: ", err)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+receive: HTTP/1.1 200 OK\r
+Server: nginx\r
+Content-Type: text/plain\r
+Content-Length: 4\r
+Connection: close\r
+\r
+foo
+
+err: nil
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: mixing *a and *l patterns for receive
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local line, err = sock:receive("*l")
+            if line then
+                ngx.say("receive: ", line)
+                ngx.say("err: ", err)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            local data
+            data, err = sock:receive("*a")
+            if data then
+                ngx.say("receive: ", data)
+                ngx.say("err: ", err)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+receive: HTTP/1.1 200 OK
+err: nil
+receive: Server: nginx\r
+Content-Type: text/plain\r
+Content-Length: 4\r
+Connection: close\r
+\r
+foo
+
+err: nil
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: receive by chunks
+--- timeout: 5
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local data, err, partial = sock:receive(10)
+                if data then
+                    local len = string.len(data)
+                    if len == 10 then
+                        ngx.print("[", data, "]")
+                    else
+                        ngx.say("ERROR: returned invalid length of data: ", len)
+                    end
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", partial, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+[HTTP/1.1 2][00 OK\r
+Ser][ver: nginx][\r
+Content-][Type: text][/plain\r
+Co][ntent-Leng][th: 4\r
+Con][nection: c][lose\r
+\r
+fo]failed to receive a line: closed [o
+]
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: receive by chunks (very small buffer)
+--- timeout: 5
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 1;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local data, err, partial = sock:receive(10)
+                if data then
+                    local len = string.len(data)
+                    if len == 10 then
+                        ngx.print("[", data, "]")
+                    else
+                        ngx.say("ERROR: returned invalid length of data: ", len)
+                    end
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", partial, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+[HTTP/1.1 2][00 OK\r
+Ser][ver: nginx][\r
+Content-][Type: text][/plain\r
+Co][ntent-Leng][th: 4\r
+Con][nection: c][lose\r
+\r
+fo]failed to receive a line: closed [o
+]
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: line reading (very small buffer)
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 1;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: ngx.socket.connect (working)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local port = ngx.var.port
+            local sock, err = ngx.socket.connect("127.0.0.1", port)
+            if not sock then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected.")
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected.
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: ngx.socket.connect() shortcut (connection refused)
+--- config
+    location /test {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local sock, err = sock:connect("127.0.0.1", 16787)
+            if not sock then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+    GET /test
+
+--- stap2
+M(http-lua-info) {
+    printf("tcp resume: %p\n", $coctx)
+    print_ubacktrace()
+}
+
+--- response_body
+failed to connect: connection refused
+--- error_log eval
+qr/connect\(\) failed \(\d+: Connection refused\)/
+
+
+
+=== TEST 18: receive by chunks (stringified size)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local data, err, partial = sock:receive("10")
+                if data then
+                    local len = string.len(data)
+                    if len == 10 then
+                        ngx.print("[", data, "]")
+                    else
+                        ngx.say("ERROR: returned invalid length of data: ", len)
+                    end
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", partial, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 57
+[HTTP/1.1 2][00 OK\r
+Ser][ver: nginx][\r
+Content-][Type: text][/plain\r
+Co][ntent-Leng][th: 4\r
+Con][nection: c][lose\r
+\r
+fo]failed to receive a line: closed [o
+]
+close: nil closed
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: cannot survive across request boundary (send)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+"^(?:connected: 1
+request sent: 11
+received: OK|failed to send request: closed)\$"
+
+
+
+=== TEST 20: cannot survive across request boundary (receive)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+
+    else
+        local line, err, part = sock:receive()
+        if line then
+            ngx.say("received: ", line)
+
+        else
+            ngx.say("failed to receive a line: ", err, " [", part, "]")
+        end
+        return
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+
+--- stap2
+M(http-lua-info) {
+    printf("tcp resume\n")
+    print_ubacktrace()
+}
+--- request
+GET /t
+--- response_body_like eval
+qr/^(?:connected: 1
+request sent: 11
+received: OK|failed to receive a line: closed \[nil\])$/
+
+
+
+=== TEST 21: cannot survive across request boundary (close)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+
+    else
+        local ok, err = sock:close()
+        if ok then
+            ngx.say("successfully closed")
+
+        else
+            ngx.say("failed to close: ", err)
+        end
+        return
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+qr/^(?:connected: 1
+request sent: 11
+received: OK|failed to close: closed)$/
+
+
+
+=== TEST 22: cannot survive across request boundary (connect)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local test = require "test"
+            test.go(ngx.var.port)
+            test.go(ngx.var.port)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock
+
+function go(port)
+    if not sock then
+        sock = ngx.socket.tcp()
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect: ", err)
+            return
+        end
+
+        ngx.say("connected: ", ok)
+
+    else
+        local port = ngx.var.port
+        local ok, err = sock:connect("127.0.0.1", port)
+        if not ok then
+            ngx.say("failed to connect again: ", err)
+            return
+        end
+
+        ngx.say("connected again: ", ok)
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+end
+--- request
+GET /t
+--- response_body_like eval
+qr/^(?:connected(?: again)?: 1
+request sent: 11
+received: OK
+){2}$/
+--- error_log
+lua reuse socket upstream ctx
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: connect again immediately
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected again: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local line, err, part = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+connected again: 1
+request sent: 11
+received: OK
+close: 1 nil
+--- no_error_log
+[error]
+--- error_log eval
+["lua reuse socket upstream", "lua tcp socket reconnect without shutting down"]
+
+
+
+=== TEST 24: two sockets mix together
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port1 $TEST_NGINX_MEMCACHED_PORT;
+        set $port2 $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock1 = ngx.socket.tcp()
+            local sock2 = ngx.socket.tcp()
+
+            local port1 = ngx.var.port1
+            local port2 = ngx.var.port2
+
+            local ok, err = sock1:connect("127.0.0.1", port1)
+            if not ok then
+                ngx.say("1: failed to connect: ", err)
+                return
+            end
+
+            ngx.say("1: connected: ", ok)
+
+            ok, err = sock2:connect("127.0.0.1", port2)
+            if not ok then
+                ngx.say("2: failed to connect: ", err)
+                return
+            end
+
+            ngx.say("2: connected: ", ok)
+
+            local req1 = "flush_all\\r\\n"
+            local bytes, err = sock1:send(req1)
+            if not bytes then
+                ngx.say("1: failed to send request: ", err)
+                return
+            end
+            ngx.say("1: request sent: ", bytes)
+
+            local req2 = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            local bytes, err = sock2:send(req2)
+            if not bytes then
+                ngx.say("2: failed to send request: ", err)
+                return
+            end
+            ngx.say("2: request sent: ", bytes)
+
+            local line, err, part = sock1:receive()
+            if line then
+                ngx.say("1: received: ", line)
+
+            else
+                ngx.say("1: failed to receive a line: ", err, " [", part, "]")
+            end
+
+            line, err, part = sock2:receive()
+            if line then
+                ngx.say("2: received: ", line)
+
+            else
+                ngx.say("2: failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock1:close()
+            ngx.say("1: close: ", ok, " ", err)
+
+            ok, err = sock2:close()
+            ngx.say("2: close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+1: connected: 1
+2: connected: 1
+1: request sent: 11
+2: request sent: 57
+1: received: OK
+2: received: HTTP/1.1 200 OK
+1: close: 1 nil
+2: close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 25: send tables of string fragments
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+
+
+
+=== TEST 26: send tables of string fragments (bad type "nil")
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", nil, 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad argument #1 to 'send' (bad data type nil found)
+
+
+
+=== TEST 27: send tables of string fragments (bad type "boolean")
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", true, 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad argument #1 to 'send' (bad data type boolean found)
+
+
+
+=== TEST 28: send tables of string fragments (bad type ngx.null)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = {"GET", " ", "/foo", " HTTP/", ngx.null, 1, ".", 0, "\\r\\n",
+                         "Host: localhost\\r\\n", "Connection: close\\r\\n",
+                         "\\r\\n"}
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad argument #1 to 'send' (bad data type userdata found)
+
+
+
+=== TEST 29: cosocket before location capture (tcpsock:send did not clear u->waiting)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local line, err, part = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+
+            local resp = ngx.location.capture("/memc")
+            if type(resp) ~= "table" then
+                ngx.say("bad resp: type ", type(resp), ": ", resp)
+                return
+            end
+
+            ngx.print("subrequest: ", resp.status, ", ", resp.body)
+        ';
+    }
+
+    location /memc {
+        set $memc_cmd flush_all;
+        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+request sent: 11
+received: OK
+close: 1 nil
+subrequest: 200, OK\r
+"
+--- no_error_log
+[error]
+
+
+
+=== TEST 30: CR in a line
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                local line, err, part = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err, " [", part, "]")
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo "foo\r\rbar\rbaz";
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 13
+received: Connection: close
+received: 
+received: foobarbaz
+failed to receive a line: closed []
+close: nil closed
+--- no_error_log
+[error]
+--- SKIP
+
+
+
+=== TEST 31: receive(0)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local data, err, part = sock:receive(0)
+            if not data then
+                ngx.say("failed to receive(0): ", err)
+                return
+            end
+
+            ngx.say("receive(0): [", data, "]")
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+receive(0): []
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 32: send("")
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local bytes, err = sock:send("")
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("send(\\"\\"): ", bytes)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 57
+send(""): 0
+close: 1 nil
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 33: github issue #215: Handle the posted requests in lua cosocket api (failed to resolve)
+--- config
+    resolver 8.8.8.8;
+
+    location = /sub {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("xxx", 80)
+            if not ok then
+                ngx.say("failed to connect to xxx: ", err)
+                return
+            end
+            ngx.say("successfully connected to xxx!")
+            sock:close()
+        ';
+    }
+
+    location = /lua {
+        content_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+
+--- stap
+F(ngx_resolve_name_done) {
+    println("resolve name done")
+    #print_ubacktrace()
+}
+
+--- stap_out
+resolve name done
+
+--- response_body_like chop
+^failed to connect to xxx: xxx could not be resolved.*?Host not found
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 34: github issue #215: Handle the posted requests in lua cosocket api (successfully resolved)
+--- config
+    resolver 8.8.8.8;
+
+    location = /sub {
+        content_by_lua '
+            if not package.i then
+                package.i = 1
+            end
+
+            local servers = {"openresty.org", "agentzh.org", "sregex.org"}
+            local server = servers[package.i]
+            package.i = package.i + 1
+
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect(server, 80)
+            if not ok then
+                ngx.say("failed to connect to agentzh.org: ", err)
+                return
+            end
+            ngx.say("successfully connected to xxx!")
+            sock:close()
+        ';
+    }
+
+    location = /lua {
+        content_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+successfully connected to xxx!
+
+--- stap
+F(ngx_http_lua_socket_resolve_handler) {
+    println("lua socket resolve handler")
+}
+
+F(ngx_http_lua_socket_tcp_connect_retval_handler) {
+    println("lua socket tcp connect retval handler")
+}
+
+F(ngx_http_run_posted_requests) {
+    println("run posted requests")
+}
+
+--- stap_out_like
+run posted requests
+lua socket resolve handler
+run posted requests
+lua socket tcp connect retval handler
+run posted requests
+
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 35: connection refused (tcp) - lua_socket_log_errors off
+--- config
+    location /test {
+        lua_socket_log_errors off;
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", 16787)
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil connection refused
+send: nil closed
+receive: nil closed
+close: nil closed
+--- no_error_log eval
+[qr/connect\(\) failed \(\d+: Connection refused\)/]
+
+
+
+=== TEST 36: reread after a read time out happen (receive -> receive)
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+
+                line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                end
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+failed to receive: timeout
+--- error_log
+lua tcp socket read timeout: 100
+lua tcp socket connect timeout: 60000
+lua tcp socket read timed out
+
+
+
+=== TEST 37: successful reread after a read time out happen (receive -> receive)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("GET /back HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to read the response header: ", err)
+                return
+            end
+
+            sock:settimeout(100)
+
+            local data, err, partial = sock:receive(100)
+            if data then
+                ngx.say("received: ", data)
+            else
+                ngx.say("failed to receive: ", err, ", partial: ", partial)
+
+                sock:settimeout(123)
+                ngx.sleep(0.1)
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location /back {
+        content_by_lua '
+            ngx.print("hi")
+            ngx.flush(true)
+            ngx.sleep(0.2)
+            ngx.print("world")
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+"failed to receive: timeout, partial: 2\r
+hi\r
+
+received: 5
+received: world
+"
+--- error_log
+lua tcp socket read timed out
+--- no_error_log
+[alert]
+
+
+
+=== TEST 38: successful reread after a read time out happen (receive -> receiveuntil)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("GET /back HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to read the response header: ", err)
+                return
+            end
+
+            sock:settimeout(100)
+
+            local data, err, partial = sock:receive(100)
+            if data then
+                ngx.say("received: ", data)
+            else
+                ngx.say("failed to receive: ", err, ", partial: ", partial)
+
+                ngx.sleep(0.1)
+
+                sock:settimeout(123)
+                local reader = sock:receiveuntil("\\r\\n")
+
+                local line, err = reader()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+
+                local line, err = reader()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location /back {
+        content_by_lua '
+            ngx.print("hi")
+            ngx.flush(true)
+            ngx.sleep(0.2)
+            ngx.print("world")
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+"failed to receive: timeout, partial: 2\r
+hi\r
+
+received: 5
+received: world
+"
+--- error_log
+lua tcp socket read timed out
+--- no_error_log
+[alert]
+
+
+
+=== TEST 39: successful reread after a read time out happen (receiveuntil -> receiveuntil)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("GET /back HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to read the response header: ", err)
+                return
+            end
+
+            sock:settimeout(100)
+
+            local reader = sock:receiveuntil("no-such-terminator")
+            local data, err, partial = reader()
+            if data then
+                ngx.say("received: ", data)
+            else
+                ngx.say("failed to receive: ", err, ", partial: ", partial)
+
+                ngx.sleep(0.1)
+
+                sock:settimeout(123)
+
+                local reader = sock:receiveuntil("\\r\\n")
+
+                local line, err = reader()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+
+                local line, err = reader()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location /back {
+        content_by_lua '
+            ngx.print("hi")
+            ngx.flush(true)
+            ngx.sleep(0.2)
+            ngx.print("world")
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+"failed to receive: timeout, partial: 2\r
+hi\r
+
+received: 5
+received: world
+"
+--- error_log
+lua tcp socket read timed out
+--- no_error_log
+[alert]
+
+
+
+=== TEST 40: successful reread after a read time out happen (receiveuntil -> receive)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("GET /back HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to read the response header: ", err)
+                return
+            end
+
+            sock:settimeout(100)
+
+            local reader = sock:receiveuntil("no-such-terminator")
+            local data, err, partial = reader()
+            if data then
+                ngx.say("received: ", data)
+            else
+                ngx.say("failed to receive: ", err, ", partial: ", partial)
+
+                ngx.sleep(0.1)
+
+                sock:settimeout(123)
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location /back {
+        content_by_lua '
+            ngx.print("hi")
+            ngx.flush(true)
+            ngx.sleep(0.2)
+            ngx.print("world")
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+"failed to receive: timeout, partial: 2\r
+hi\r
+
+received: 5
+received: world
+"
+--- error_log
+lua tcp socket read timed out
+--- no_error_log
+[alert]
+
+
+
+=== TEST 41: receive(0)
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local data, err = sock:receive(0)
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("received: ", data)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+connected: 1
+received: 
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 42: empty options table
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port, {})
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+connected: 1
+close: 1 nil
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/059-unix-socket.t b/src/lua/lua-nginx-module/t/059-unix-socket.t
--- a/src/lua/lua-nginx-module/t/059-unix-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/059-unix-socket.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,146 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => blocks() * repeat_each() * 2;
+
+$ENV{TEST_NGINX_HTML_DIR} ||= html_dir();
+
+no_long_string();
+#no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: connection refused (unix domain socket)
+--- config
+    location /test {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("unix:/tmp/nosuchfile.sock")
+            ngx.say("connect: ", ok, " ", err)
+
+            local bytes
+            bytes, err = sock:send("hello")
+            ngx.say("send: ", bytes, " ", err)
+
+            local line
+            line, err = sock:receive()
+            ngx.say("receive: ", line, " ", err)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+connect: nil no such file or directory
+send: nil closed
+receive: nil closed
+close: nil closed
+
+
+
+=== TEST 2: invalid host argument
+--- http_server
+    server {
+        listen /tmp/test-nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            echo foo;
+            more_clear_headers Date;
+        }
+    }
+--- config
+    location /test {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("/tmp/test-nginx.sock")
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+failed to connect: failed to parse host name "/tmp/test-nginx.sock": invalid host
+
+
+
+=== TEST 3: sanity
+--- http_config
+    server {
+        listen unix:$TEST_NGINX_HTML_DIR/nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            content_by_lua 'ngx.say("foo")';
+            more_clear_headers Date;
+        }
+    }
+--- config
+    location /test {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("unix:$TEST_NGINX_HTML_DIR/nginx.sock")
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            while true do
+                print("calling receive")
+                local line, err = sock:receive()
+                if line then
+                    ngx.say("received: ", line)
+
+                else
+                    ngx.say("failed to receive a line: ", err)
+                    break
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+connected: 1
+request sent: 57
+received: HTTP/1.1 200 OK
+received: Server: nginx
+received: Content-Type: text/plain
+received: Content-Length: 4
+received: Connection: close
+received: 
+received: foo
+failed to receive a line: closed
+close: nil closed
+
diff -rNu a/src/lua/lua-nginx-module/t/060-lua-memcached.t b/src/lua/lua-nginx-module/t/060-lua-memcached.t
--- a/src/lua/lua-nginx-module/t/060-lua-memcached.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/060-lua-memcached.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,170 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 1);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+my $pwd = `pwd`;
+chomp $pwd;
+$ENV{TEST_NGINX_PWD} ||= $pwd;
+
+#master_on();
+workers(1);
+#log_level('warn');
+#worker_connections(1014);
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- http_config
+    lua_package_path '$TEST_NGINX_PWD/t/lib/?.lua;;';
+--- config
+    location /test {
+        content_by_lua '
+            package.loaded["socket"] = ngx.socket
+            local Memcached = require "Memcached"
+            Memcached.socket = ngx.socket
+
+            local memc = Memcached.Connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+
+            memc:set("some_key", "hello 1234")
+            local data = memc:get("some_key")
+            ngx.say("some_key: ", data)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+some_key: hello 1234
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: raw memcached
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;;';"
+--- config
+    location /t {
+        content_by_lua '
+            local memcached = require "resty.memcached"
+            local memc, err = memcached.connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+
+            local ok, err = memc:set("some_key", "hello 1234")
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set some_key: ", err)
+                ngx.exit(500)
+            end
+
+            local data, err = memc:get("some_key")
+            if not data and err then
+                ngx.log(ngx.ERR, "failed to get some_key: ", err)
+                ngx.exit(500)
+            end
+
+            ngx.say("some_key: ", data)
+
+            local res, err = memc:set_keepalive()
+            if not res then
+                ngx.say("failed to set keepalive: ", err)
+                return
+            end
+        ';
+    }
+--- user_files
+>>> resty/memcached.lua
+module("resty.memcached", package.seeall)
+
+local mt = { __index = resty.memcached }
+local sub = string.sub
+local escape_uri = ngx.escape_uri
+local socket_connect = ngx.socket.connect
+local match = string.match
+
+function connect(...)
+    local sock, err = socket_connect(...)
+    return setmetatable({ sock = sock }, mt)
+end
+
+function get(self, key)
+    local cmd = "get " .. escape_uri(key) .. "\r\n"
+    local bytes, err = self.sock:send(cmd)
+    if not bytes then
+        return nil, err
+    end
+
+    local line, err = self.sock:receive()
+    if line == 'END' then
+        return nil, nil
+    end
+
+    local flags, len = match(line, [[^VALUE %S+ (%d+) (%d+)]])
+    if not flags then
+        return nil, "bad response: " .. line
+    end
+
+    print("size: ", size, ", flags: ", len)
+
+    local data, err = self.sock:receive(len)
+    if not data then
+        return nil, err
+    end
+
+    line, err = self.sock:receive(2) -- discard the trailing CRLF
+    if not line then
+        return nil, nil, "failed to receive CRLF: " .. (err or "")
+    end
+
+    line, err = self.sock:receive() -- discard "END\r\n"
+    if not line then
+        return nil, nil, "failed to receive END CRLF: " .. (err or "")
+    end
+
+    return data
+end
+
+function set(self, key, value, exptime, flags)
+    if not exptime then
+        exptime = 0
+    end
+
+    if not flags then
+        flags = 0
+    end
+
+    local cmd = table.concat({"set ", escape_uri(key), " ", flags, " ", exptime, " ", #value, "\r\n", value, "\r\n"}, "")
+
+    local bytes, err = self.sock:send(cmd)
+    if not bytes then
+        return nil, err
+    end
+
+    local data, err = self.sock:receive()
+    if sub(data, 1, 6) == "STORED" then
+        return true
+    end
+
+    return false, err
+end
+
+function set_keepalive(self)
+    return self.sock:setkeepalive(0, 100)
+end
+--- request
+    GET /t
+--- response_body
+some_key: hello 1234
+--- no_error_log
+[error]
+--- error_log
+lua reuse free buf memory
+
diff -rNu a/src/lua/lua-nginx-module/t/061-lua-redis.t b/src/lua/lua-nginx-module/t/061-lua-redis.t
--- a/src/lua/lua-nginx-module/t/061-lua-redis.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/061-lua-redis.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,186 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+$ENV{TEST_NGINX_REDIS_PORT} ||= 6379;
+
+#log_level "warn";
+#worker_connections(1024);
+#master_on();
+
+my $pwd = `pwd`;
+chomp $pwd;
+$ENV{TEST_NGINX_PWD} ||= $pwd;
+
+our $LuaCpath = $ENV{LUA_CPATH} ||
+    '/usr/local/openresty-debug/lualib/?.so;/usr/local/openresty/lualib/?.so;;';
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- http_config
+    lua_package_path '$TEST_NGINX_PWD/t/lib/?.lua;;';
+--- config
+    location /test {
+        content_by_lua '
+            package.loaded["socket"] = ngx.socket
+            local Redis = require "Redis"
+
+            local redis = Redis.connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+
+            redis:set("some_key", "hello 1234")
+            local data = redis:get("some_key")
+            ngx.say("some_key: ", data)
+        ';
+    }
+--- request
+    GET /test
+--- response_body
+some_key: hello 1234
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: coroutine-based pub/sub
+--- http_config eval
+qq{
+    lua_package_path '\$TEST_NGINX_PWD/t/lib/?.lua;;';
+    lua_package_cpath '$::LuaCpath';
+}
+--- config
+    location /test {
+        content_by_lua '
+            package.loaded["socket"] = ngx.socket
+            local Redis = require "Redis"
+
+            local cjson = require "cjson"
+
+            local r1 = Redis.connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+
+            local r2 = Redis.connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+
+            local loop = r2:pubsub({ subscribe = "foo" })
+            local msg, abort = loop()
+            ngx.say("msg type: ", type(msg))
+            ngx.say("abort: ", type(abort))
+
+            if msg then
+                ngx.say("msg: ", cjson.encode(msg))
+            end
+
+            for i = 1, 3 do
+                r1:publish("foo", "test " .. i)
+                msg, abort = loop()
+                if msg then
+                    ngx.say("msg: ", cjson.encode(msg))
+                end
+                ngx.say("abort: ", type(abort))
+            end
+
+            abort()
+
+            msg, abort = loop()
+            ngx.say("msg type: ", type(msg))
+        ';
+    }
+--- stap2
+global ids, cur
+
+function gen_id(k) {
+    if (ids[k]) return ids[k]
+    ids[k] = ++cur
+    return cur
+}
+
+F(ngx_http_handler) {
+    delete ids
+    cur = 0
+}
+
+/*
+probe process("/usr/local/openresty-debug/luajit/lib/libluajit-5.1.so.2").function("lua_yield") {
+    id = gen_id($L)
+    printf("raw lua yield %d\n", id)
+    #print_ubacktrace()
+}
+
+probe process("/usr/local/openresty-debug/luajit/lib/libluajit-5.1.so.2").function("lua_resume") {
+    id = gen_id($L)
+    printf("raw lua resume %d\n", id)
+}
+*/
+
+/*
+F(ngx_http_lua_run_thread) {
+    id = gen_id($ctx->cur_co)
+    printf("run thread %d\n", id)
+}
+*/
+
+M(http-lua-user-coroutine-resume) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("resume %x in %x\n", c, p)
+}
+
+M(http-lua-entry-coroutine-yield) {
+    println("entry coroutine yield")
+}
+
+F(ngx_http_lua_coroutine_yield) {
+    printf("yield %x\n", gen_id($L))
+}
+
+/*
+F(ngx_http_lua_coroutine_resume) {
+    printf("resume %x\n", gen_id($L))
+}
+*/
+
+M(http-lua-user-coroutine-yield) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("yield %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_atpanic) {
+    printf("lua atpanic(%d):", gen_id($L))
+    print_ubacktrace();
+}
+
+M(http-lua-user-coroutine-create) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("create %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_ngx_exec) { println("exec") }
+
+F(ngx_http_lua_ngx_exit) { println("exit") }
+
+--- request
+    GET /test
+--- response_body
+msg type: table
+abort: function
+msg: {"payload":1,"channel":"foo","kind":"subscribe"}
+msg: {"payload":"test 1","channel":"foo","kind":"message"}
+abort: function
+msg: {"payload":"test 2","channel":"foo","kind":"message"}
+abort: function
+msg: {"payload":"test 3","channel":"foo","kind":"message"}
+abort: function
+msg type: nil
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/062-count.t b/src/lua/lua-nginx-module/t/062-count.t
--- a/src/lua/lua-nginx-module/t/062-count.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/062-count.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,365 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(4);
+#log_level('warn');
+no_root_location();
+
+#repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+#$ENV{LUA_CPATH} = "/usr/local/openresty/lualib/?.so;" . $ENV{LUA_CPATH};
+
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: entries under ngx. (content by lua)
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx) do
+                    n = n + 1
+                end
+                ngx.say("ngx: ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+ngx: 96
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: entries under ngx. (set by lua)
+--- config
+        location = /test {
+            set_by_lua $n '
+                local n = 0
+                for k, v in pairs(ngx) do
+                    n = n + 1
+                end
+                return n;
+            ';
+            echo $n;
+        }
+--- request
+GET /test
+--- response_body
+96
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: entries under ngx. (header filter by lua)
+--- config
+        location = /test {
+            set $n '';
+
+            content_by_lua '
+                ngx.send_headers()
+                ngx.say("n = ", ngx.var.n)
+            ';
+
+            header_filter_by_lua '
+                local n = 0
+                for k, v in pairs(ngx) do
+                    n = n + 1
+                end
+
+                ngx.var.n = n
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 96
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: entries under ndk. (content by lua)
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ndk) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: entries under ngx.req (content by lua)
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.req) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 23
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: entries under ngx.req (set by lua)
+--- config
+        location = /test {
+            set_by_lua $n '
+                local n = 0
+                for k, v in pairs(ngx.req) do
+                    n = n + 1
+                end
+                return n
+            ';
+
+            echo "n = $n";
+        }
+--- request
+GET /test
+--- response_body
+n = 23
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: entries under ngx.req (header filter by lua)
+--- config
+        location = /test {
+            set $n '';
+
+            header_filter_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.req) do
+                    n = n + 1
+                end
+                ngx.var.n = n
+            ';
+
+            content_by_lua '
+                ngx.send_headers()
+                ngx.say("n = ", ngx.var.n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 23
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: entries under ngx.location
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.location) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: entries under ngx.socket
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.socket) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 3
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: entries under ngx._tcp_meta
+--- SKIP
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx._tcp_meta) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 10
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: entries under ngx._reqsock_meta
+--- SKIP
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx._reqsock_meta) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 4
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: shdict metatable
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            local mt = dogs.__index
+            local n = 0
+            for k, v in pairs(mt) do
+                n = n + 1
+            end
+            ngx.say("n = ", n)
+        ';
+    }
+--- request
+GET /test
+--- response_body
+n = 13
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: entries under ngx. (log by lua)
+--- config
+    location = /t {
+        log_by_lua '
+            local n = 0
+            for k, v in pairs(ngx) do
+                n = n + 1
+            end
+            ngx.log(ngx.ERR, "ngx. entry count: ", n)
+        ';
+    }
+--- request
+GET /t
+--- response_body_like: 404 Not Found
+--- error_code: 404
+--- error_log
+ngx. entry count: 96
+
+
+
+=== TEST 14: entries under ngx.timer
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.timer) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: entries under ngx.config
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.config) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: entries under ngx.re
+--- config
+        location = /test {
+            content_by_lua '
+                local n = 0
+                for k, v in pairs(ngx.re) do
+                    n = n + 1
+                end
+                ngx.say("n = ", n)
+            ';
+        }
+--- request
+GET /test
+--- response_body
+n = 4
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/063-abort.t b/src/lua/lua-nginx-module/t/063-abort.t
--- a/src/lua/lua-nginx-module/t/063-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/063-abort.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1021 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+worker_connections(1014);
+#master_on();
+#workers(4);
+#log_level('warn');
+no_root_location();
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 2);
+
+our $HtmlDir = html_dir;
+
+#$ENV{LUA_CPATH} = "/usr/local/openresty/lualib/?.so;" . $ENV{LUA_CPATH};
+
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ngx.exit(400) should abort print
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /memc_query {
+            internal;
+            set               $memc_cmd     $arg_cmd;
+            set_unescape_uri  $memc_key     $arg_key;
+            set_unescape_uri  $memc_value   $arg_value;
+            set $memc_exptime $arg_exptime;
+
+            memc_cmds_allowed get set add delete;
+            memc_pass 127.0.0.1:11211;
+        }
+
+        location = /test {
+            content_by_lua_file html/test.lua;
+        }
+--- user_files
+>>> test.lua
+local memd = require 'memd'
+ngx.exit(400)
+local res = memd.query( { cmd = 'get', key = id } )
+>>> memd.lua
+module('memd', package.seeall)
+
+local URL = '/memc_query'
+local capture = ngx.location.capture
+
+function query(arg)
+    if type(arg) ~= 'table' then
+        return nil
+    end
+
+    print("HELLO WORLD")
+    return capture(URL, { args = arg } )
+end
+--- request
+GET /test?a
+--- response_body_like: 400 Bad Request
+--- no_error_log eval
+["lua print: HELLO WORLD", q{the "$memc_key" variable is not set}]
+--- error_code: 400
+
+
+
+=== TEST 2: ngx.exit(400) should abort ngx.log
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /memc_query {
+            internal;
+            set               $memc_cmd     $arg_cmd;
+            set_unescape_uri  $memc_key     $arg_key;
+            set_unescape_uri  $memc_value   $arg_value;
+            set $memc_exptime $arg_exptime;
+
+            memc_cmds_allowed get set add delete;
+            memc_pass 127.0.0.1:11211;
+        }
+
+        location = /test {
+            content_by_lua_file html/test.lua;
+        }
+--- user_files
+>>> test.lua
+local memd = require 'memd'
+ngx.exit(400)
+local res = memd.query( { cmd = 'get', key = id } )
+>>> memd.lua
+module('memd', package.seeall)
+
+local URL = '/memc_query'
+local capture = ngx.location.capture
+local log = ngx.log
+local level = ngx.ERR
+
+function query(arg)
+    if type(arg) ~= 'table' then
+        return nil
+    end
+
+    log(level, "HELLO WORLD")
+    return capture(URL, { args = arg } )
+end
+--- request
+GET /test?a
+--- response_body_like: 400 Bad Request
+--- no_error_log eval
+["HELLO WORLD", q{the "$memc_key" variable is not set}]
+--- error_code: 400
+
+
+
+=== TEST 3: ngx.exit(400) should abort ngx.location.capture
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /memc_query {
+            internal;
+            set               $memc_cmd     $arg_cmd;
+            set_unescape_uri  $memc_key     $arg_key;
+            set_unescape_uri  $memc_value   $arg_value;
+            set $memc_exptime $arg_exptime;
+
+            memc_cmds_allowed get set add delete;
+            memc_pass 127.0.0.1:11211;
+        }
+
+        location = /test {
+            content_by_lua_file html/test.lua;
+        }
+--- user_files
+>>> test.lua
+local memd = require 'memd'
+ngx.exit(400)
+local res = memd.query( { cmd = 'get', key = id } )
+>>> memd.lua
+module('memd', package.seeall)
+
+local URL = '/memc_query'
+local capture = ngx.location.capture
+
+function query(arg)
+    if type(arg) ~= 'table' then
+        return nil
+    end
+
+    return capture(URL, { args = arg } )
+end
+--- request
+GET /test?a
+--- response_body_like: 400 Bad Request
+--- no_error_log
+the "$memc_key" variable is not set
+--- error_code: 400
+
+
+
+=== TEST 4: ngx.exit(400) should abort ngx.location.capture_multi
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /memc_query {
+            internal;
+            set               $memc_cmd     $arg_cmd;
+            set_unescape_uri  $memc_key     $arg_key;
+            set_unescape_uri  $memc_value   $arg_value;
+            set $memc_exptime $arg_exptime;
+
+            memc_cmds_allowed get set add delete;
+            memc_pass 127.0.0.1:11211;
+        }
+
+        location = /test {
+            content_by_lua_file html/test.lua;
+        }
+--- user_files
+>>> test.lua
+local memd = require 'memd'
+ngx.exit(400)
+local res = memd.query( { cmd = 'get', key = id } )
+>>> memd.lua
+module('memd', package.seeall)
+
+local URL = '/memc_query'
+local capture_multi = ngx.location.capture_multi
+
+function query(arg)
+    if type(arg) ~= 'table' then
+        return nil
+    end
+
+    return capture_multi{ {URL, { args = arg }} }
+end
+--- request
+GET /test?a
+--- response_body_like: 400 Bad Request
+--- no_error_log
+the "$memc_key" variable is not set
+--- error_code: 400
+
+
+
+=== TEST 5: ngx.exit(400) should abort ngx.redirect
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.redirect("/blah")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua redirect to "/blah" with code 302
+--- error_code: 400
+
+
+
+=== TEST 6: ngx.exit(400) should abort ngx.exit
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.exit(503)
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua exit with code 503
+--- error_code: 400
+
+
+
+=== TEST 7: ngx.exit(400) should abort ngx.exec
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.exec("/blah")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua exec "/blah?"
+--- error_code: 400
+
+
+
+=== TEST 8: ngx.exit(400) should abort ngx.send_headers
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.send_headers()
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua send headers
+--- error_code: 400
+
+
+
+=== TEST 9: ngx.exit(400) should abort ngx.print
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.print("HELLO WORLD")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua print response
+--- error_code: 400
+
+
+
+=== TEST 10: ngx.exit(400) should abort ngx.say
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.say("HELLO WORLD")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua say response
+--- error_code: 400
+
+
+
+=== TEST 11: ngx.exit(400) should abort ngx.flush
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.flush()
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua flush asynchronously
+--- error_code: 400
+
+
+
+=== TEST 12: ngx.exit(400) should abort ngx.eof
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.eof()
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua send eof
+--- error_code: 400
+
+
+
+=== TEST 13: ngx.exit(400) should abort ngx.re.match
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.re.match("a", "a", "jo")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua compiling match regex "a" with options "jo"
+--- error_code: 400
+
+
+
+=== TEST 14: ngx.exit(400) should abort ngx.re.gmatch
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.re.gmatch("a", "a", "jo")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua compiling gmatch regex "a" with options "jo"
+--- error_code: 400
+
+
+
+=== TEST 15: ngx.exit(400) should abort ngx.re.sub
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.re.sub("a", "a", "", "jo")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua compiling sub regex "a" with options "jo"
+--- error_code: 400
+
+
+
+=== TEST 16: ngx.exit(400) should abort ngx.re.gsub
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go()
+    ngx.re.gsub("a", "a", "", "jo")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+lua compiling gsub regex "a" with options "jo"
+--- error_code: 400
+
+
+
+=== TEST 17: ngx.exit(400) should abort ngx.shared.DICT (set)
+--- http_config eval
+    "lua_shared_dict dogs 1m; lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                local dogs = ngx.shared.dogs
+                print("foo = ", dogs:get("foo"))
+                dogs:set("foo", 32)
+                ngx.exit(400)
+                test.go(dogs)
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go(dogs)
+    dogs:set("foo", 56)
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+foo = 56
+--- error_code: 400
+
+
+
+=== TEST 18: ngx.exit(400) should abort ngx.shared.DICT (replace)
+--- http_config eval
+    "lua_shared_dict dogs 1m; lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                local dogs = ngx.shared.dogs
+                print("foo = ", dogs:get("foo"))
+                dogs:set("foo", 32)
+                ngx.exit(400)
+                test.go(dogs)
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go(dogs)
+    dogs:replace("foo", 56)
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+foo = 56
+--- error_code: 400
+
+
+
+=== TEST 19: ngx.exit(400) should abort ngx.shared.DICT (incr)
+--- http_config eval
+    "lua_shared_dict dogs 1m; lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                local dogs = ngx.shared.dogs
+                print("foo = ", dogs:get("foo"))
+                dogs:set("foo", 32)
+                ngx.exit(400)
+                test.go(dogs)
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go(dogs)
+    dogs:incr("foo", 56)
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+foo = 88
+--- error_code: 400
+
+
+
+=== TEST 20: ngx.exit(400) should abort ngx.shared.DICT (get)
+--- http_config eval
+    "lua_shared_dict dogs 1m; lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                local dogs = ngx.shared.dogs
+                dogs:set("foo", 32)
+                ngx.exit(400)
+                test.go(dogs)
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+function go(dogs)
+    dogs:get("foo")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+fetching key "foo" in shared dict "dogs"
+--- error_code: 400
+
+
+
+=== TEST 21: ngx.exit(400) should skip os.execute
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                ngx.exit(400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- error_code: 400
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 22: ngx.exit(400) should break pcall and skip os.execute
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                pcall(ngx.exit, 400)
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- no_error_log
+fetching key "foo" in shared dict "dogs"
+--- error_code: 400
+--- timeout: 2
+
+
+
+=== TEST 23: ngx.exit(400) should break pcall and skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    pcall(ngx.exit, 400)
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- error_code: 400
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 24: ngx.redirect() should break pcall and skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    pcall(ngx.redirect, "/blah")
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body_like: 302 Found
+--- no_error_log
+[error]
+--- error_code: 302
+--- timeout: 2
+
+
+
+=== TEST 25: ngx.redirect() should skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    ngx.redirect("/blah")
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body_like: 302 Found
+--- no_error_log
+[error]
+--- error_code: 302
+--- timeout: 2
+
+
+
+=== TEST 26: ngx.exec() should break pcall and skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+        location = /foo {
+            echo foo;
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    pcall(ngx.exec, "/foo")
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body
+foo
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 27: ngx.exec() should skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+        location = /foo {
+            echo foo;
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    ngx.exec("/foo")
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body
+foo
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 28: ngx.set_uri(uri, true) should break pcall and skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            rewrite_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+            echo hello;
+        }
+        location = /foo {
+            echo foo;
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function go()
+    local ok, err = pcall(ngx.req.set_uri, "/foo", true)
+    if not ok then
+        ngx.log(ngx.ERR, "error: ", err)
+    end
+
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body
+foo
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 29: abort does not affect following coroutines
+--- config
+        location = /test {
+            rewrite_by_lua 'ngx.exit(0)';
+            content_by_lua '
+                pcall(ngx.say, "hello world")
+            ';
+        }
+--- request
+GET /test
+--- response_body
+hello world
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 30: ngx.exit(400) should break xpcall and skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+--- user_files
+>>> test.lua
+module('test', package.seeall)
+
+local exec = os.execute
+
+function myexit()
+    ngx.exit(400)
+end
+
+function go()
+    xpcall(myexit, function () end)
+    exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body_like: 400 Bad Request
+--- error_code: 400
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 31: ngx.exec() should skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+        location = /foo {
+            echo foo;
+        }
+--- user_files
+>>> test.lua
+local os_exec = os.execute
+local ngx_exec = ngx.exec
+module('test')
+
+function go()
+    ngx_exec("/foo")
+    os_exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body
+foo
+--- no_error_log
+[error]
+--- timeout: 2
+
+
+
+=== TEST 32: ngx.exec() should break pcall and skip os.execute (all in user module)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                local test = require "test"
+                test.go()
+            ';
+        }
+        location = /foo {
+            echo foo;
+        }
+--- user_files
+>>> test.lua
+local os_exec = os.execute
+local ngx_exec = ngx.exec
+local pcall = pcall
+module('test')
+
+function go()
+    pcall(ngx_exec, "/foo")
+    os_exec("sleep 5")
+end
+--- request
+GET /test
+--- response_body
+foo
+--- no_error_log
+[error]
+--- timeout: 2
+
diff -rNu a/src/lua/lua-nginx-module/t/064-pcall.t b/src/lua/lua-nginx-module/t/064-pcall.t
--- a/src/lua/lua-nginx-module/t/064-pcall.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/064-pcall.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,105 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+worker_connections(1014);
+#master_on();
+#workers(4);
+#log_level('warn');
+no_root_location();
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+#$ENV{LUA_CPATH} = "/usr/local/openresty/lualib/?.so;" . $ENV{LUA_CPATH};
+
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: pcall works
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                function f(a, b)
+                    if a == 0 and b == 0 then
+                        error("zero error")
+                    end
+
+                    return 23, "hello", true
+                end
+
+                local res = {pcall(f, 0, 0)}
+                ngx.say("res len: ", #res)
+                ngx.say("res: ", unpack(res))
+
+                res = {pcall(f, 0)}
+                ngx.say("res len: ", #res)
+                ngx.say("res: ", unpack(res))
+            ';
+        }
+--- request
+GET /test
+--- response_body
+res len: 2
+res: false[string "content_by_lua"]:4: zero error
+res len: 4
+res: true23hellotrue
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: xpcall works
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+        location = /test {
+            content_by_lua '
+                function f(a, b)
+                    if a == 0 and b == 0 then
+                        error("zero error")
+                    end
+
+                    return 23, "hello", true
+                end
+
+                function g()
+                    return f(0, 0)
+                end
+
+                function h()
+                    return f(0)
+                end
+
+                function err(...)
+                    ngx.say("error handler called: ", ...)
+                    return "this is the new err"
+                end
+
+                local res = {xpcall(g, err)}
+                ngx.say("res len: ", #res)
+                ngx.say("res: ", unpack(res))
+
+                res = {xpcall(h, err)}
+                ngx.say("res len: ", #res)
+                ngx.say("res: ", unpack(res))
+            ';
+        }
+--- request
+GET /test
+--- response_body
+error handler called: [string "content_by_lua"]:4: zero error
+res len: 2
+res: falsethis is the new err
+res len: 4
+res: true23hellotrue
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/065-tcp-socket-timeout.t b/src/lua/lua-nginx-module/t/065-tcp-socket-timeout.t
--- a/src/lua/lua-nginx-module/t/065-tcp-socket-timeout.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/065-tcp-socket-timeout.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,773 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+BEGIN {
+    if (!defined $ENV{LD_PRELOAD}) {
+        $ENV{LD_PRELOAD} = '';
+    }
+
+    if ($ENV{LD_PRELOAD} !~ /\bmockeagain\.so\b/) {
+        $ENV{LD_PRELOAD} = "mockeagain.so $ENV{LD_PRELOAD}";
+    }
+
+    if ($ENV{MOCKEAGAIN} eq 'r') {
+        $ENV{MOCKEAGAIN} = 'rw';
+
+    } else {
+        $ENV{MOCKEAGAIN} = 'w';
+    }
+
+    $ENV{TEST_NGINX_EVENT_TYPE} = 'poll';
+    $ENV{MOCKEAGAIN_WRITE_TIMEOUT_PATTERN} = 'get helloworld';
+}
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 11);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+log_level("debug");
+no_long_string();
+#no_diff();
+run_tests();
+
+__DATA__
+
+=== TEST 1: lua_socket_connect_timeout only
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 100
+lua tcp socket connect timed out
+
+
+
+=== TEST 2: sock:settimeout() overrides lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 60s;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(150)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 150
+lua tcp socket connect timed out
+
+
+
+=== TEST 3: sock:settimeout(nil) does not override lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 102ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(nil)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 102
+lua tcp socket connect timed out
+
+
+
+=== TEST 4: sock:settimeout(0) does not override lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 102ms;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 3s;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(0)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 102
+lua tcp socket connect timed out
+--- timeout: 5
+
+
+
+=== TEST 5: sock:settimeout(-1) does not override lua_socket_connect_timeout
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 102ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            sock:settimeout(-1)
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+failed to connect: timeout
+--- error_log
+lua tcp socket connect timeout: 102
+lua tcp socket connect timed out
+
+
+
+=== TEST 6: lua_socket_read_timeout only
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket read timeout: 100
+lua tcp socket connect timeout: 60000
+lua tcp socket read timed out
+
+
+
+=== TEST 7: sock:settimeout() overrides lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 60s;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(150)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket read timeout: 150
+lua tcp socket read timed out
+
+
+
+=== TEST 8: sock:settimeout(nil) does not override lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(nil)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket read timeout: 102
+lua tcp socket read timed out
+
+
+
+=== TEST 9: sock:settimeout(0) does not override lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(0)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket read timeout: 102
+lua tcp socket read timed out
+
+
+
+=== TEST 10: sock:settimeout(-1) does not override lua_socket_read_timeout
+--- config
+    server_tokens off;
+    lua_socket_read_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(-1)
+
+            local line
+            line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+            else
+                ngx.say("failed to receive: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua tcp socket read timeout: 102
+lua tcp socket connect timeout: 60000
+lua tcp socket read timed out
+
+
+
+=== TEST 11: lua_socket_send_timeout only
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- stap2
+global active = 0
+F(ngx_http_lua_socket_send) {
+    active = 1
+    println(probefunc())
+}
+probe syscall.send,
+    syscall.sendto,
+    syscall.writev
+{
+    if (active && pid() == target()) {
+        println(probefunc())
+    }
+}
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket send timeout: 100
+lua tcp socket connect timeout: 60000
+lua tcp socket write timed out
+
+
+
+=== TEST 12: sock:settimeout() overrides lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 60s;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(150)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket send timeout: 150
+lua tcp socket write timed out
+
+
+
+=== TEST 13: sock:settimeout(nil) does not override lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(nil)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket send timeout: 102
+lua tcp socket write timed out
+
+
+
+=== TEST 14: sock:settimeout(0) does not override lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(0)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket connect timeout: 60000
+lua tcp socket send timeout: 102
+lua tcp socket write timed out
+
+
+
+=== TEST 15: sock:settimeout(-1) does not override lua_socket_send_timeout
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 102ms;
+    #resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            sock:settimeout(-1)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to send: timeout
+--- error_log
+lua tcp socket send timeout: 102
+lua tcp socket connect timeout: 60000
+lua tcp socket write timed out
+
+
+
+=== TEST 16: exit in user thread (entry thread is still pending on tcpsock:send)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local bytes, ok = sock:send("get helloworld!")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: re-connect after timed out
+--- config
+    server_tokens off;
+    lua_socket_connect_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    resolver_timeout 1s;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 12345)
+            if not ok then
+                ngx.say("1: failed to connect: ", err)
+
+                local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+                if not ok then
+                    ngx.say("2: failed to connect: ", err)
+                    return
+                end
+
+                ngx.say("2: connected: ", ok)
+                return
+            end
+
+            ngx.say("1: connected: ", ok)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+1: failed to connect: timeout
+2: connected: 1
+--- error_log
+lua tcp socket connect timeout: 100
+lua tcp socket connect timed out
+
+
+
+=== TEST 18: re-send on the same object after a send timeout happens
+--- config
+    server_tokens off;
+    lua_socket_send_timeout 100ms;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local bytes
+            bytes, err = sock:send("get helloworld!")
+            if bytes then
+                ngx.say("sent: ", bytes)
+            else
+                ngx.say("failed to send: ", err)
+                bytes, err = sock:send("blah")
+                if not bytes then
+                    ngx.say("failed to send again: ", err)
+                end
+            end
+        ';
+    }
+--- request
+GET /t
+--- stap2
+global active = 0
+F(ngx_http_lua_socket_send) {
+    active = 1
+    println(probefunc())
+}
+probe syscall.send,
+    syscall.sendto,
+    syscall.writev
+{
+    if (active && pid() == target()) {
+        println(probefunc())
+    }
+}
+--- response_body
+connected: 1
+failed to send: timeout
+failed to send again: closed
+--- error_log
+lua tcp socket send timeout: 100
+lua tcp socket connect timeout: 60000
+lua tcp socket write timed out
+
diff -rNu a/src/lua/lua-nginx-module/t/066-socket-receiveuntil.t b/src/lua/lua-nginx-module/t/066-socket-receiveuntil.t
--- a/src/lua/lua-nginx-module/t/066-socket-receiveuntil.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/066-socket-receiveuntil.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1333 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: memcached read lines
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local readline = sock:receiveuntil("\\r\\n")
+            local line, err, part = readline()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 11
+received: OK
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: http read lines
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local readline = sock:receiveuntil("\\r\\n")
+            local line, err, part
+
+            for i = 1, 7 do
+                line, err, part = readline()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: HTTP/1.1 200 OK
+read: Server: nginx
+read: Content-Type: text/plain
+read: Content-Length: 4
+read: Connection: close
+read: 
+failed to read a line: closed [foo
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: http read all the headers in a single run
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local line, err, part
+
+            for i = 1, 2 do
+                line, err, part = read_headers()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: HTTP/1.1 200 OK\r
+Server: nginx\r
+Content-Type: text/plain\r
+Content-Length: 4\r
+Connection: close
+failed to read a line: closed [foo
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: ambiguous boundary patterns (abcabd)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabd")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("abcabcabd")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abc
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: ambiguous boundary patterns (aa)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aa")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        content_by_lua 'ngx.say("abcabcaad")';
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabc
+failed to read a line: closed [d
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: ambiguous boundary patterns (aaa)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aaa")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abaabcaaaef;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abaabc
+failed to read a line: closed [ef
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: ambiguous boundary patterns (aaaaad)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aaaaad")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo baaaaaaaaeaaaaaaadf;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: baaaaaaaaeaa
+failed to read a line: closed [f
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: ambiguous boundary patterns (aaaaad), small buffer, 2 bytes
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 2;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aaaaad")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo baaaaaaaaeaaaaaaadf;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: baaaaaaaaeaa
+failed to read a line: closed [f
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: ambiguous boundary patterns (aaaaad), small buffer, 1 byte
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 1;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aaaaad")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo baaaaaaaaeaaaaaaadf;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: baaaaaaaaeaa
+failed to read a line: closed [f
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: ambiguous boundary patterns (abcabdabcabe)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabdabcabe")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabdabcabdabcabe;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabd
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: ambiguous boundary patterns (abcabdabcabe 2)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabdabcabe")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabdabcabcabdabcabe;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabdabc
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: ambiguous boundary patterns (abcabdabcabe 3)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabdabcabe")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcabdabcabe;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abc
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: ambiguous boundary patterns (abcabdabcabe 4)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabdabcabe")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo ababcabdabcabe;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: ab
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: ambiguous boundary patterns (--abc)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("--abc")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo -- ----abc;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: --
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: ambiguous boundary patterns (--abc)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("--abc")
+
+            for i = 1, 7 do
+                line, err, part = reader(4)
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo "hello, world ----abc";
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: hell
+read: o, w
+read: orld
+read:  --
+read: 
+failed to read a line: nil [nil]
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: ambiguous boundary patterns (--abc), small buffer
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+        lua_socket_buffer_size 1;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("--abc")
+
+            for i = 1, 7 do
+                line, err, part = reader(4)
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo "hello, world ----abc";
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: hell
+read: o, w
+read: orld
+read:  --
+read: 
+failed to read a line: nil [nil]
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: ambiguous boundary patterns (--abc), small buffer, mixed by other reading calls
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+        lua_socket_buffer_size 1;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("--abc")
+
+            for i = 1, 7 do
+                line, err, part = reader(4)
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a chunk: ", err, " [", part, "]")
+                end
+
+                local data, err, part = sock:receive(1)
+                if not data then
+                    ngx.say("failed to read a byte: ", err, " [", part, "]")
+                    break
+                else
+                    ngx.say("read one byte: ", data)
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo "hello, world ----abc";
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: hell
+read one byte: o
+read: , wo
+read one byte: r
+read: ld -
+read one byte: -
+read: 
+read one byte: 
+
+failed to read a chunk: nil [nil]
+failed to read a byte: closed []
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: ambiguous boundary patterns (abcabd), small buffer
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 3;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabd")
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcabd;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abc
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: long patterns
+this exposed a memory leak in receiveuntil
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if not sock then
+                ngx.say("failed to get req socket: ", err)
+                return
+            end
+            local reader, err = sock:receiveuntil("------------------------------------------- abcdefghijklmnopqrstuvwxyz")
+            if not reader then
+                ngx.say("failed to get reader: ", err)
+                return
+            end
+            ngx.say("ok")
+        ';
+    }
+--- request
+    POST /t
+
+--- more_headers: Content-Length: 1024
+--- response_body
+ok
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/067-req-socket.t b/src/lua/lua-nginx-module/t/067-req-socket.t
--- a/src/lua/lua-nginx-module/t/067-req-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/067-req-socket.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1067 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 8);
+
+our $HtmlDir = html_dir;
+
+#$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            for i = 1, 3 do
+                local data, err, part = sock:receive(5)
+                if data then
+                    ngx.say("received: ", data)
+                else
+                    ngx.say("failed to receive: ", err, " [", part, "]")
+                end
+            end
+        ';
+    }
+--- request
+POST /t
+hello world
+--- response_body
+got the request socket
+received: hello
+received:  worl
+failed to receive: closed [d]
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: multipart rfc sample (just partial streaming)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            local boundary
+            local header = ngx.var.http_content_type
+            local m = ngx.re.match(header, [[; +boundary=(?:"(.*?)"|(\\w+))]], "jo")
+            if m then
+                boundary = m[1] or m[2]
+
+            else
+                ngx.say("invalid content-type header")
+                return
+            end
+
+            local read_to_boundary = sock:receiveuntil("\\r\\n--" .. boundary)
+            local read_line = sock:receiveuntil("\\r\\n")
+
+            local data, err, part = read_to_boundary()
+            if data then
+                ngx.say("preamble: [" .. data .. "]")
+            else
+                ngx.say("failed to read the first boundary: ", err)
+                return
+            end
+
+            local i = 1
+            while true do
+                local line, err = read_line()
+
+                if not line then
+                    ngx.say("failed to read post-boundary line: ", err)
+                    return
+                end
+
+                m = ngx.re.match(line, "--$", "jo")
+                if m then
+                    ngx.say("found the end of the stream")
+                    return
+                end
+
+                while true do
+                    local line, err = read_line()
+                    if not line then
+                        ngx.say("failed to read part ", i, " header: ", err)
+                        return
+                    end
+
+                    if line == "" then
+                        -- the header part completes
+                        break
+                    end
+
+                    ngx.say("part ", i, " header: [", line, "]")
+                end
+
+                local data, err, part = read_to_boundary()
+                if data then
+                    ngx.say("part ", i, " body: [" .. data .. "]")
+                else
+                    ngx.say("failed to read part ", i + 1, " boundary: ", err)
+                    return
+                end
+
+                i = i + 1
+            end
+        ';
+    }
+--- request eval
+"POST /t
+This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.\r
+--simple boundary\r
+\r
+This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.\r
+--simple boundary\r
+Content-type: text/plain; charset=us-ascii\r
+\r
+This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+\r
+--simple boundary--\r
+This is the epilogue.  It is also to be ignored.
+"
+--- more_headers
+Content-Type: multipart/mixed; boundary="simple boundary"
+--- response_body
+got the request socket
+preamble: [This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.]
+part 1 body: [This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.]
+part 2 header: [Content-type: text/plain; charset=us-ascii]
+part 2 body: [This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+]
+found the end of the stream
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: multipart rfc sample (completely streaming)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            local boundary
+            local header = ngx.var.http_content_type
+            local m = ngx.re.match(header, [[; +boundary=(?:"(.*?)"|(\\w+))]], "jo")
+            if m then
+                boundary = m[1] or m[2]
+
+            else
+                ngx.say("invalid content-type header")
+                return
+            end
+
+            local read_to_boundary = sock:receiveuntil("\\r\\n--" .. boundary)
+            local read_line = sock:receiveuntil("\\r\\n")
+
+            local preamble = ""
+            while true do
+                local data, err, part = read_to_boundary(1)
+                if data then
+                    preamble = preamble .. data
+
+                elseif not err then
+                    break
+
+                else
+                    ngx.say("failed to read the first boundary: ", err)
+                    return
+                end
+            end
+
+            ngx.say("preamble: [" .. preamble .. "]")
+
+            local i = 1
+            while true do
+                local line, err = read_line(50)
+
+                if not line and err then
+                    ngx.say("1: failed to read post-boundary line: ", err)
+                    return
+                end
+
+                if line then
+                    local dummy
+                    dummy, err = read_line(1)
+                    if err then
+                        ngx.say("2: failed to read post-boundary line: ", err)
+                        return
+                    end
+
+                    if dummy then
+                        ngx.say("bad post-boundary line: ", dummy)
+                        return
+                    end
+
+                    m = ngx.re.match(line, "--$", "jo")
+                    if m then
+                        ngx.say("found the end of the stream")
+                        return
+                    end
+                end
+
+                while true do
+                    local line, err = read_line(50)
+                    if not line and err then
+                        ngx.say("failed to read part ", i, " header: ", err)
+                        return
+                    end
+
+                    if line then
+                        local line, err = read_line(1)
+                        if line or err then
+                            ngx.say("error")
+                            return
+                        end
+                    end
+
+                    if line == "" then
+                        -- the header part completes
+                        break
+                    end
+
+                    ngx.say("part ", i, " header: [", line, "]")
+                end
+
+                local body = ""
+
+                while true do
+                    local data, err, part = read_to_boundary(1)
+                    if data then
+                        body = body .. data
+
+                    elseif err then
+                        ngx.say("failed to read part ", i + 1, " boundary: ", err)
+                        return
+
+                    else
+                        break
+                    end
+                end
+
+                ngx.say("part ", i, " body: [" .. body .. "]")
+
+                i = i + 1
+            end
+        ';
+    }
+--- request eval
+"POST /t
+This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.\r
+--simple boundary\r
+\r
+This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.\r
+--simple boundary\r
+Content-type: text/plain; charset=us-ascii\r
+\r
+This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+\r
+--simple boundary--\r
+This is the epilogue.  It is also to be ignored.
+"
+--- more_headers
+Content-Type: multipart/mixed; boundary="simple boundary"
+--- response_body
+got the request socket
+preamble: [This is the preamble.  It is to be ignored, though it
+is a handy place for mail composers to include an
+explanatory note to non-MIME compliant readers.]
+part 1 body: [This is implicitly typed plain ASCII text.
+It does NOT end with a linebreak.]
+part 2 header: [Content-type: text/plain; charset=us-ascii]
+part 2 body: [This is explicitly typed plain ASCII text.
+It DOES end with a linebreak.
+]
+found the end of the stream
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: attempt to use the req socket across request boundary
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        content_by_lua '
+            local test = require "test"
+            test.go()
+            ngx.say("done")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local sock, err
+
+function go()
+    if not sock then
+        sock, err = ngx.req.socket()
+        if sock then
+            ngx.say("got the request socket")
+        else
+            ngx.say("failed to get the request socket: ", err)
+        end
+    else
+        for i = 1, 3 do
+            local data, err, part = sock:receive(5)
+            if data then
+                ngx.say("received: ", data)
+            else
+                ngx.say("failed to receive: ", err, " [", part, "]")
+            end
+        end
+    end
+end
+--- request
+POST /t
+hello world
+--- response_body_like
+(?:got the request socket
+|failed to receive: closed [d]
+)?done
+--- no_error_log
+[alert]
+
+
+
+=== TEST 5: receive until on request_body - receiveuntil(1) on the last byte of the body
+See https://groups.google.com/group/openresty/browse_thread/thread/43cf01da3c681aba for details
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        content_by_lua '
+            local test = require "test"
+            test.go()
+            ngx.say("done")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go()
+   local sock, err = ngx.req.socket()
+   if sock then
+      ngx.say("got the request socket")
+   else
+      ngx.say("failed to get the request socket: ", err)
+      return
+   end
+
+   local data, err, part = sock:receive(56)
+   if data then
+      ngx.say("received: ", data)
+   else
+      ngx.say("failed to receive: ", err, " [", part, "]")
+   end
+
+   local discard_line = sock:receiveuntil('\r\n')
+
+   local data, err, part = discard_line(8192)
+   if data then
+      ngx.say("received len: ", #data)
+   else
+      ngx.say("failed to receive: ", err, " [", part, "]")
+   end
+
+   local data, err, part = discard_line(1)
+   if data then
+      ngx.say("received: ", data)
+   else
+      ngx.say("failed to receive: ", err, " [", part, "]")
+   end
+end
+--- request
+POST /t
+-----------------------------820127721219505131303151179################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################$
+--- response_body
+got the request socket
+received: -----------------------------820127721219505131303151179
+received len: 8192
+received: $
+done
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 6: pipelined POST requests
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        content_by_lua '
+            local test = require "test"
+            test.go()
+            ngx.say("done")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go()
+   local sock, err = ngx.req.socket()
+   if sock then
+      ngx.say("got the request socket")
+   else
+      ngx.say("failed to get the request socket: ", err)
+      return
+   end
+
+   while true do
+       local data, err, part = sock:receive(4)
+       if data then
+          ngx.say("received: ", data)
+       else
+          ngx.say("failed to receive: ", err, " [", part, "]")
+          return
+       end
+   end
+end
+--- pipelined_requests eval
+["POST /t
+hello, world",
+"POST /t
+hiya, world"]
+--- response_body eval
+["got the request socket
+received: hell
+received: o, w
+received: orld
+failed to receive: closed []
+done
+",
+"got the request socket
+received: hiya
+received: , wo
+failed to receive: closed [rld]
+done
+"]
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: Expect & 100 Continue
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+                return
+            end
+
+            for i = 1, 3 do
+                local data, err, part = sock:receive(5)
+                if data then
+                    ngx.say("received: ", data)
+                else
+                    ngx.say("failed to receive: ", err, " [", part, "]")
+                end
+            end
+        ';
+    }
+--- request
+POST /t
+hello world
+--- more_headers
+Expect: 100-Continue
+--- error_code: 100
+--- response_body_like chomp
+\breceived: hello\b.*?\breceived:  worl\b
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: pipelined requests, big buffer, small steps
+--- config
+    location /t {
+        lua_socket_buffer_size 5;
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.say("failed to get the request socket: ", err)
+            end
+
+            for i = 1, 6 do
+                local data, err, part = sock:receive(2)
+                if data then
+                    ngx.say("received: ", data)
+                else
+                    ngx.say("failed to receive: ", err, " [", part, "]")
+                end
+            end
+        ';
+    }
+--- stap2
+M(http-lua-req-socket-consume-preread) {
+    println("preread: ", user_string_n($arg2, $arg3))
+}
+
+--- pipelined_requests eval
+["POST /t
+hello world","POST /t
+hiya globe"]
+--- response_body eval
+["got the request socket
+received: he
+received: ll
+received: o 
+received: wo
+received: rl
+failed to receive: closed [d]
+","got the request socket
+received: hi
+received: ya
+received:  g
+received: lo
+received: be
+failed to receive: closed []
+"]
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: chunked support is still a TODO
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            if sock then
+                ngx.say("got the request socket")
+            else
+                ngx.req.read_body()
+                ngx.say("failed to get the request socket: ", err)
+                return
+            end
+
+            for i = 1, 3 do
+                local data, err, part = sock:receive(5)
+                if data then
+                    ngx.say("received: ", data)
+                else
+                    ngx.say("failed to receive: ", err, " [", part, "]")
+                end
+            end
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.1\r
+Host: localhost\r
+Transfer-Encoding: chunked\r
+Connection: close\r
+\r
+b\r
+hello world\r
+0\r
+\r
+"
+--- stap2
+/*
+F(ngx_http_finalize_request) {
+    if ($r->main->count == 2) {
+        print_ubacktrace()
+    }
+}
+F(ngx_http_free_request) {
+    print_ubacktrace()
+}
+*/
+--- response_body
+failed to get the request socket: chunked request bodies not supported yet
+--- no_error_log
+[error]
+[alert]
+--- skip_nginx: 4: <1.3.9
+
+
+
+=== TEST 10: chunked support in ngx.req.read_body
+--- config
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.say(ngx.req.get_body_data())
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.1\r
+Host: localhost\r
+Transfer-Encoding: chunked\r
+Connection: close\r
+\r
+b\r
+hello world\r
+0\r
+\r
+"
+--- stap2
+/*
+F(ngx_http_finalize_request) {
+    if ($r->main->count == 2) {
+        print_ubacktrace()
+    }
+}
+F(ngx_http_free_request) {
+    print_ubacktrace()
+}
+*/
+--- response_body
+hello world
+--- no_error_log
+[error]
+[alert]
+--- skip_nginx: 4: <1.3.9
+
+
+
+=== TEST 11: downstream cosocket for GET requests (w/o request bodies)
+--- config
+    #resolver 8.8.8.8;
+    location = /t {
+        content_by_lua '
+           local sock, err = ngx.req.socket()
+
+           if not sock then
+              ngx.say("failed to get socket: ", err)
+              return nil
+           end
+
+           while true do
+              local data, err, partial = sock:receive(4096)
+
+              ngx.log(ngx.INFO, "Received data")
+
+              if err then
+                 ngx.say("err: ", err)
+                 if partial then
+                    ngx.print(partial)
+                 end
+
+                 break
+              end
+
+              if data then
+                 ngx.print(data)
+              end
+           end
+        ';
+    }
+
+--- request
+GET /t
+--- response_body
+failed to get socket: no body
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: downstream cosocket for POST requests with 0 size bodies
+--- config
+    #resolver 8.8.8.8;
+    location = /t {
+        content_by_lua '
+           local sock, err = ngx.req.socket()
+
+           if not sock then
+              ngx.say("failed to get socket: ", err)
+              return nil
+           end
+
+           while true do
+              local data, err, partial = sock:receive(4096)
+
+              ngx.log(ngx.INFO, "Received data")
+
+              if err then
+                 ngx.say("err: ", err)
+                 if partial then
+                    ngx.print(partial)
+                 end
+
+                 break
+              end
+
+              if data then
+                 ngx.print(data)
+              end
+           end
+        ';
+    }
+
+--- request
+POST /t
+--- more_headers
+Content-Length: 0
+--- response_body
+failed to get socket: no body
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: failing reread after reading timeout happens
+--- config
+    location = /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+
+            if not sock then
+               ngx.say("failed to get socket: ", err)
+               return nil
+            end
+
+            sock:settimeout(100);
+
+            local data, err, partial = sock:receive(4096)
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+            end
+
+            local data, err, partial = sock:receive(4096)
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+               return
+            end
+        ';
+    }
+
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Content-Length: 10245\r
+\r
+hello"
+--- response_body
+err: timeout, partial: hello
+err: timeout, partial: 
+
+--- error_log
+lua tcp socket read timed out
+
+
+
+=== TEST 14: successful reread after reading timeout happens (receive -> receive)
+--- config
+    location = /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("POST /back HTTP/1.0\\r\\nHost: localhost\\r\\nContent-Length: 1024\\r\\n\\r\\nabc")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+            else
+                ngx.say("sent: ", bytes)
+            end
+
+            ngx.sleep(0.2)
+
+            local bytes, err = sock:send("hello world")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+            else
+                ngx.say("sent: ", bytes)
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to receive header: ", err)
+                return
+            end
+
+            for i = 1, 2 do
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive line: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location = /back {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+
+            local sock, err = ngx.req.socket()
+
+            if not sock then
+               ngx.say("failed to get socket: ", err)
+               return nil
+            end
+
+            sock:settimeout(100);
+
+            local data, err, partial = sock:receive(4096)
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+            else
+                ngx.say("received: ", data)
+            end
+
+            ngx.sleep(0.1)
+
+            local data, err, partial = sock:receive(11)
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+            else
+                ngx.say("received: ", data)
+            end
+        ';
+    }
+
+--- request
+GET /t
+--- response_body
+sent: 65
+sent: 11
+received: err: timeout, partial: abc
+received: received: hello world
+
+--- error_log
+lua tcp socket read timed out
+
+
+
+=== TEST 15: successful reread after reading timeout happens (receive -> receiveuntil)
+--- config
+    location = /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("POST /back HTTP/1.0\\r\\nHost: localhost\\r\\nContent-Length: 1024\\r\\n\\r\\nabc")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+            else
+                ngx.say("sent: ", bytes)
+            end
+
+            ngx.sleep(0.2)
+
+            local bytes, err = sock:send("hello world\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+            else
+                ngx.say("sent: ", bytes)
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to receive header: ", err)
+                return
+            end
+
+            for i = 1, 2 do
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive line: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location = /back {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+
+            local sock, err = ngx.req.socket()
+
+            if not sock then
+               ngx.say("failed to get socket: ", err)
+               return nil
+            end
+
+            sock:settimeout(100);
+
+            local data, err, partial = sock:receive(4096)
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+            else
+                ngx.say("received: ", data)
+            end
+
+            ngx.sleep(0.1)
+
+            local reader = sock:receiveuntil("\\n")
+            local data, err, partial = reader()
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+            else
+                ngx.say("received: ", data)
+            end
+        ';
+    }
+
+--- request
+GET /t
+--- response_body
+sent: 65
+sent: 12
+received: err: timeout, partial: abc
+received: received: hello world
+
+--- error_log
+lua tcp socket read timed out
+
+
+
+=== TEST 16: successful reread after reading timeout happens (receiveuntil -> receive)
+--- config
+    location = /t {
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("127.0.0.1", ngx.var.server_port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("POST /back HTTP/1.0\\r\\nHost: localhost\\r\\nContent-Length: 1024\\r\\n\\r\\nabc")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+            else
+                ngx.say("sent: ", bytes)
+            end
+
+            ngx.sleep(0.2)
+
+            local bytes, err = sock:send("hello world\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+            else
+                ngx.say("sent: ", bytes)
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local header, err = reader()
+            if not header then
+                ngx.say("failed to receive header: ", err)
+                return
+            end
+
+            for i = 1, 2 do
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive line: ", err)
+                    return
+                end
+                ngx.say("received: ", line)
+            end
+        ';
+    }
+
+    location = /back {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+
+            local sock, err = ngx.req.socket()
+
+            if not sock then
+               ngx.say("failed to get socket: ", err)
+               return nil
+            end
+
+            sock:settimeout(100);
+
+            local reader = sock:receiveuntil("no-such-terminator")
+            local data, err, partial = reader()
+            if not data then
+               ngx.say("err: ", err, ", partial: ", partial)
+            else
+                ngx.say("received: ", data)
+            end
+
+            ngx.sleep(0.1)
+
+            local data, err, partial = sock:receive()
+            if err then
+               ngx.say("err: ", err, ", partial: ", partial)
+            else
+                ngx.say("received: ", data)
+            end
+        ';
+    }
+
+--- request
+GET /t
+--- response_body
+sent: 65
+sent: 12
+received: err: timeout, partial: abc
+received: received: hello world
+
+--- error_log
+lua tcp socket read timed out
+
diff -rNu a/src/lua/lua-nginx-module/t/068-socket-keepalive.t b/src/lua/lua-nginx-module/t/068-socket-keepalive.t
--- a/src/lua/lua-nginx-module/t/068-socket-keepalive.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/068-socket-keepalive.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1479 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 5 + 7);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_HTML_DIR} = $HtmlDir;
+$ENV{TEST_NGINX_REDIS_PORT} ||= 6379;
+
+$ENV{LUA_PATH} ||=
+    '/usr/local/openresty-debug/lualib/?.lua;/usr/local/openresty/lualib/?.lua;;';
+
+no_long_string();
+#no_diff();
+
+#log_level 'warn';
+log_level 'debug';
+
+no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port)
+            test.go(port)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+request sent: 11
+received: OK
+connected: 1, reused: 1
+request sent: 11
+received: OK
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for "]
+--- error_log eval
+qq{lua tcp socket get keepalive peer: using connection
+lua tcp socket keepalive create connection pool for key "127.0.0.1:$ENV{TEST_NGINX_MEMCACHED_PORT}"
+}
+
+
+
+=== TEST 2: free up the whole connection pool if no active connections
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port, true)
+            test.go(port, false)
+        ';
+    }
+--- request
+GET /t
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, keepalive)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    if keepalive then
+        local ok, err = sock:setkeepalive()
+        if not ok then
+            ngx.say("failed to set reusable: ", err)
+        end
+
+    else
+        sock:close()
+    end
+end
+--- response_body
+connected: 1, reused: 0
+request sent: 11
+received: OK
+connected: 1, reused: 1
+request sent: 11
+received: OK
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket get keepalive peer: using connection",
+"lua tcp socket keepalive: free connection pool for "]
+
+
+
+=== TEST 3: upstream sockets close prematurely
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+   server_tokens off;
+   keepalive_timeout 100ms;
+   location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, err = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for "]
+--- timeout: 3
+
+
+
+=== TEST 4: http keepalive
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+   server_tokens off;
+   location /t {
+        keepalive_timeout 60s;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, err = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive close handler: fd:",
+"lua tcp socket keepalive: free connection pool for "]
+--- timeout: 4
+
+
+
+=== TEST 5: lua_socket_keepalive_timeout
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 100ms;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 100 ms",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 6: lua_socket_pool_size
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 100ms;
+       lua_socket_pool_size 1;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 100 ms",
+qr/lua tcp socket connection pool size: 1\b/]
+--- timeout: 4
+
+
+
+=== TEST 7: "lua_socket_keepalive_timeout 0" means unlimited
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 0;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive timeout: unlimited",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 8: setkeepalive(timeout) overrides lua_socket_keepalive_timeout
+--- config
+   server_tokens off;
+   location /t {
+        keepalive_timeout 60s;
+        lua_socket_keepalive_timeout 60s;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive(123)
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 123 ms",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 9: sock:setkeepalive(timeout, size) overrides lua_socket_pool_size
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 100ms;
+       lua_socket_pool_size 100;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive(101, 25)
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive close handler",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket keepalive timeout: 101 ms",
+qr/lua tcp socket connection pool size: 25\b/]
+--- timeout: 4
+
+
+
+=== TEST 10: sock:keepalive_timeout(0) means unlimited
+--- config
+   server_tokens off;
+   location /t {
+       keepalive_timeout 60s;
+       lua_socket_keepalive_timeout 1000ms;
+
+        set $port $TEST_NGINX_SERVER_PORT;
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keepalive\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("\\r\\n0\\r\\n\\r\\n")
+            local data, res = reader()
+
+            if not data then
+                ngx.say("failed to receive response body: ", err)
+                return
+            end
+
+            ngx.say("received response of ", #data, " bytes")
+
+            local ok, err = sock:setkeepalive(0)
+            if not ok then
+                ngx.say("failed to set reusable: ", err)
+            end
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("done")
+        ';
+    }
+
+    location /foo {
+        echo foo;
+    }
+
+    location /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 61
+received response of 156 bytes
+done
+--- no_error_log
+[error]
+--- error_log eval
+["lua tcp socket keepalive timeout: unlimited",
+qr/lua tcp socket connection pool size: 30\b/]
+--- timeout: 4
+
+
+
+=== TEST 11: sanity (uds)
+--- http_config eval
+"
+    lua_package_path '$::HtmlDir/?.lua;./?.lua';
+    server {
+        listen unix:$::HtmlDir/nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            echo foo;
+            more_clear_headers Date;
+        }
+    }
+"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local path = "$TEST_NGINX_HTML_DIR/nginx.sock";
+            local port = ngx.var.port
+            test.go(path, port)
+            test.go(path, port)
+        ';
+    }
+--- request
+GET /t
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(path, port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("unix:" .. path)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "GET /foo HTTP/1.1\r\nHost: localhost\r\nConnection: keepalive\r\n\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+    ngx.say("request sent: ", bytes)
+
+    local reader = sock:receiveuntil("\r\n0\r\n\r\n")
+    local data, err = reader()
+
+    if not data then
+        ngx.say("failed to receive response body: ", err)
+        return
+    end
+
+    ngx.say("received response of ", #data, " bytes")
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- response_body
+connected: 1, reused: 0
+request sent: 61
+received response of 119 bytes
+connected: 1, reused: 1
+request sent: 61
+received response of 119 bytes
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for "]
+--- error_log eval
+["lua tcp socket get keepalive peer: using connection",
+'lua tcp socket keepalive create connection pool for key "unix:']
+
+
+
+=== TEST 12: github issue #108: ngx.locaiton.capture + redis.set_keepalive
+--- http_config eval
+    qq{
+        lua_package_path "$::HtmlDir/?.lua;;";
+    }
+--- config
+    location /t {
+        default_type text/html;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #lua_code_cache off;
+        lua_need_request_body on;
+        content_by_lua_file html/t.lua;
+    }
+
+    location /anyurl {
+        internal;
+        proxy_pass http://127.0.0.1:$server_port/dummy;
+    }
+
+    location = /dummy {
+        echo dummy;
+    }
+--- user_files
+>>> t.lua
+local sock, err = ngx.socket.connect("127.0.0.1", ngx.var.port)
+if not sock then ngx.say(err) return end
+sock:send("flush_all\r\n")
+sock:receive()
+sock:setkeepalive()
+
+sock, err = ngx.socket.connect("127.0.0.1", ngx.var.port)
+if not sock then ngx.say(err) return end
+local res = ngx.location.capture("/anyurl") --3
+
+ngx.say("ok")
+--- request
+    GET /t
+--- response_body
+ok
+--- error_log
+lua tcp socket get keepalive peer: using connection
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 13: github issue #110: ngx.exit with HTTP_NOT_FOUND causes worker process to exit
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    error_page 404 /404.html;
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        access_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port)
+            ngx.exit(404)
+        ';
+        echo hello;
+    }
+--- user_files
+>>> 404.html
+Not found, dear...
+>>> test.lua
+module("test", package.seeall)
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.log(ngx.ERR, "failed to connect: ", err)
+        return
+    end
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.log(ngx.ERR, "failed to send request: ", err)
+        return
+    end
+
+    local line, err, part = sock:receive()
+    if not line then
+        ngx.log(ngx.ERR, "failed to receive a line: ", err, " [", part, "]")
+        return
+    end
+
+    -- local ok, err = sock:setkeepalive()
+    -- if not ok then
+        -- ngx.log(ngx.ERR, "failed to set reusable: ", err)
+        -- return
+    -- end
+end
+--- request
+GET /t
+--- response_body
+Not found, dear...
+--- error_code: 404
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: custom pools (different pool for the same host:port) - tcp
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port, "A")
+            test.go(port, "B")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+connected: 1, reused: 0
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket get keepalive peer: using connection"
+]
+--- error_log
+lua tcp socket keepalive create connection pool for key "A"
+lua tcp socket keepalive create connection pool for key "B"
+
+
+
+=== TEST 15: custom pools (same pool for different host:port) - tcp
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go($TEST_NGINX_MEMCACHED_PORT, "foo")
+            test.go($TEST_NGINX_SERVER_PORT, "foo")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+connected: 1, reused: 1
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for ",
+]
+--- error_log
+lua tcp socket keepalive create connection pool for key "foo"
+lua tcp socket get keepalive peer: using connection
+
+
+
+=== TEST 16: custom pools (different pool for the same host:port) - unix
+--- http_config eval
+"
+    lua_package_path '$::HtmlDir/?.lua;./?.lua';
+    server {
+        listen unix:$::HtmlDir/nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+        location /foo {
+            echo foo;
+            more_clear_headers Date;
+        }
+    }
+"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local path = "$TEST_NGINX_HTML_DIR/nginx.sock";
+            test.go(path, "A")
+            test.go(path, "B")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(path, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("unix:" .. path, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+connected: 1, reused: 0
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for ",
+"lua tcp socket get keepalive peer: using connection"
+]
+--- error_log
+lua tcp socket keepalive create connection pool for key "A"
+lua tcp socket keepalive create connection pool for key "B"
+
+
+
+=== TEST 17: custom pools (same pool for the same path) - unix
+--- http_config eval
+"
+    lua_package_path '$::HtmlDir/?.lua;./?.lua';
+    server {
+        listen unix:$::HtmlDir/nginx.sock;
+        default_type 'text/plain';
+
+        server_tokens off;
+    }
+"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local path = "$TEST_NGINX_HTML_DIR/nginx.sock";
+            test.go(path, "A")
+            test.go(path, "A")
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(path, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("unix:" .. path, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+connected: 1, reused: 1
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for ",
+]
+--- error_log
+lua tcp socket keepalive create connection pool for key "A"
+lua tcp socket get keepalive peer: using connection
+
+
+
+=== TEST 18: numeric pool option value
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go($TEST_NGINX_MEMCACHED_PORT, 3.14)
+            test.go($TEST_NGINX_SERVER_PORT, 3.14)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+connected: 1, reused: 1
+--- no_error_log eval
+["[error]",
+"lua tcp socket keepalive: free connection pool for ",
+]
+--- error_log
+lua tcp socket keepalive create connection pool for key "3.14"
+lua tcp socket get keepalive peer: using connection
+
+
+
+=== TEST 19: nil pool option value
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go($TEST_NGINX_MEMCACHED_PORT, nil)
+            test.go($TEST_NGINX_SERVER_PORT, nil)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body
+connected: 1, reused: 0
+connected: 1, reused: 0
+--- error_code: 200
+--- no_error_log
+[error]
+
+
+
+=== TEST 20: (bad) table pool option value
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go($TEST_NGINX_MEMCACHED_PORT, {})
+            test.go($TEST_NGINX_SERVER_PORT, {})
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #3 to 'connect' (bad "pool" option type: table)
+
+
+
+=== TEST 21: (bad) boolean pool option value
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go($TEST_NGINX_MEMCACHED_PORT, true)
+            test.go($TEST_NGINX_SERVER_PORT, false)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port, pool)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port, {pool = pool})
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    ngx.say("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+end
+--- request
+GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #3 to 'connect' (bad "pool" option type: boolean)
+
+
+
+=== TEST 22: clear the redis store
+--- config
+    location /t {
+        redis2_query flushall;
+        redis2_pass 127.0.0.1:$TEST_NGINX_REDIS_PORT;
+    }
+--- request
+    GET /t
+--- response_body eval
+"+OK\r\n"
+--- no_error_log
+[error]
+[alert]
+[warn]
+
+
+
+=== TEST 23: bug in send(): clear the chain writer ctx
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+--- config
+    location /t {
+        set $port $TEST_NGINX_REDIS_PORT;
+        content_by_lua '
+            local test = require "test"
+            local port = ngx.var.port
+            test.go(port)
+        ';
+    }
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        ngx.say("failed to connect: ", err)
+        return
+    end
+
+    local bytes, err = sock:send({})
+    if err then
+        ngx.say("failed to send empty request: ", err)
+        return
+    end
+
+    local req = "*2\r\n$3\r\nget\r\n$3\r\ndog\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        ngx.say("failed to send request: ", err)
+        return
+    end
+
+    local line, err, part = sock:receive()
+    if line then
+        ngx.say("received: ", line)
+
+    else
+        ngx.say("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        ngx.say("failed to set reusable: ", err)
+    end
+
+    ngx.say("done")
+end
+--- request
+GET /t
+--- stap2
+global active
+M(http-lua-socket-tcp-send-start) {
+    active = 1
+    printf("send [%s] %d\n", text_str(user_string_n($arg3, $arg4)), $arg4)
+}
+M(http-lua-socket-tcp-receive-done) {
+    printf("receive [%s]\n", text_str(user_string_n($arg3, $arg4)))
+}
+F(ngx_output_chain) {
+    #printf("ctx->in: %s\n", ngx_chain_dump($ctx->in))
+    #printf("ctx->busy: %s\n", ngx_chain_dump($ctx->busy))
+    printf("output chain: %s\n", ngx_chain_dump($in))
+}
+F(ngx_linux_sendfile_chain) {
+    printf("linux sendfile chain: %s\n", ngx_chain_dump($in))
+}
+F(ngx_chain_writer) {
+    printf("chain writer ctx out: %p\n", $data)
+    printf("nginx chain writer: %s\n", ngx_chain_dump($in))
+}
+F(ngx_http_lua_socket_tcp_setkeepalive) {
+    delete active
+}
+M(http-lua-socket-tcp-setkeepalive-buf-unread) {
+    printf("setkeepalive unread: [%s]\n", text_str(user_string_n($arg3, $arg4)))
+}
+probe syscall.recvfrom {
+    if (active && pid() == target()) {
+        printf("recvfrom(%s)", argstr)
+    }
+}
+probe syscall.recvfrom.return {
+    if (active && pid() == target()) {
+        printf(" = %s, data [%s]\n", retstr, text_str(user_string_n($ubuf, $size)))
+    }
+}
+probe syscall.writev {
+    if (active && pid() == target()) {
+        printf("writev(%s)", ngx_iovec_dump($vec, $vlen))
+        /*
+        for (i = 0; i < $vlen; i++) {
+            printf(" %p [%s]", $vec[i]->iov_base, text_str(user_string_n($vec[i]->iov_base, $vec[i]->iov_len)))
+        }
+        */
+    }
+}
+probe syscall.writev.return {
+    if (active && pid() == target()) {
+        printf(" = %s\n", retstr)
+    }
+}
+--- response_body
+received: $-1
+done
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/069-null.t b/src/lua/lua-nginx-module/t/069-null.t
--- a/src/lua/lua-nginx-module/t/069-null.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/069-null.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,97 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+#master_on();
+#workers(1);
+#log_level('debug');
+#log_level('warn');
+#worker_connections(1024);
+
+plan tests => repeat_each() * (blocks() * 3 + 1);
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_MYSQL_PORT} ||= 3306;
+
+our $LuaCpath = $ENV{LUA_CPATH} ||
+    '/usr/local/openresty-debug/lualib/?.so;/usr/local/openresty/lualib/?.so;;';
+
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: compare ngx.null with cjson.null
+--- http_config eval
+    "lua_package_cpath '$::LuaCpath';";
+--- config
+    location /lua {
+        content_by_lua '
+            local cjson = require "cjson"
+            ngx.say(cjson.null == ngx.null)
+            ngx.say(cjson.encode(ngx.null))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+true
+null
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: output ngx.null
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("ngx.null: ", ngx.null)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+ngx.null: null
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: output ngx.null in a table
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say({"ngx.null: ", ngx.null})
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+ngx.null: null
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: log ngx.null
+--- config
+    location /lua {
+        content_by_lua '
+            print("ngx.null: ", ngx.null)
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+done
+--- error_log
+ngx.null: null
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/070-sha1.t b/src/lua/lua-nginx-module/t/070-sha1.t
--- a/src/lua/lua-nginx-module/t/070-sha1.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/070-sha1.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,52 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: set sha1 hello
+--- config
+    location = /sha1 {
+        content_by_lua 'ngx.say(ngx.encode_base64(ngx.sha1_bin("hello")))';
+    }
+--- request
+GET /sha1
+--- response_body
+qvTGHdzF6KLavt4PO0gs2a6pQ00=
+
+
+
+=== TEST 2: set sha1 ""
+--- config
+    location = /sha1 {
+        content_by_lua 'ngx.say(ngx.encode_base64(ngx.sha1_bin("")))';
+    }
+--- request
+GET /sha1
+--- response_body
+2jmj7l5rSw0yVb/vlWAYkK/YBwk=
+
+
+
+=== TEST 3: set sha1 nil
+--- config
+    location = /sha1 {
+        content_by_lua 'ngx.say(ngx.encode_base64(ngx.sha1_bin(nil)))';
+    }
+--- request
+GET /sha1
+--- response_body
+2jmj7l5rSw0yVb/vlWAYkK/YBwk=
+
diff -rNu a/src/lua/lua-nginx-module/t/071-idle-socket.t b/src/lua/lua-nginx-module/t/071-idle-socket.t
--- a/src/lua/lua-nginx-module/t/071-idle-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/071-idle-socket.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,435 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: read events come when socket is idle
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("foofoo\\r\\n")
+            local line, err, part = reader()
+            if line then
+                ngx.print("read: ", line)
+
+            else
+                ngx.say("failed to read a line: ", err, " [", part, "]")
+            end
+
+            ngx.location.capture("/sleep")
+
+            local data, err, part = sock:receive("*a")
+            if not data then
+                ngx.say("failed to read the 2nd part: ", err)
+            else
+                ngx.say("2nd part: [", data, "]")
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /sleep {
+        echo_sleep 0.5;
+        more_clear_headers Date;
+    }
+
+    location /foo {
+        echo -n foofoo;
+        echo_flush;
+        echo_sleep 0.3;
+        echo -n barbar;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: HTTP/1.1 200 OK\r
+Server: nginx\r
+Content-Type: text/plain\r
+Transfer-Encoding: chunked\r
+Connection: close\r
+\r
+6\r
+2nd part: [6\r
+barbar\r
+0\r
+\r
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: read timer cleared in time
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            sock:settimeout(400)
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local line, err, part = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+            end
+
+            ngx.location.capture("/sleep")
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent again: ", bytes)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /sleep {
+        echo_sleep 0.5;
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 11
+received: OK
+request sent again: 11
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: connect timer cleared in time
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            sock:settimeout(300)
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            ngx.location.capture("/sleep")
+
+            local req = "flush_all\\r\\n"
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /sleep {
+        echo_sleep 0.5;
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 11
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: send timer cleared in time
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            sock:settimeout(300)
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            ngx.location.capture("/sleep")
+
+            local line, err, part = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive a line: ", err, " [", part, "]")
+                return
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /sleep {
+        echo_sleep 0.5;
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+request sent: 11
+received: OK
+close: 1 nil
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: set keepalive when system socket recv buffer has unread data
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local reader = sock:receiveuntil("foofoo\\r\\n")
+            local line, err, part = reader()
+            if line then
+                ngx.print("read: ", line)
+
+            else
+                ngx.say("failed to read a line: ", err, " [", part, "]")
+            end
+
+            ngx.location.capture("/sleep")
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set keepalive: ", err)
+            end
+        ';
+    }
+
+    location /sleep {
+        echo_sleep 0.5;
+        more_clear_headers Date;
+    }
+
+    location /foo {
+        echo -n foofoo;
+        echo_flush;
+        echo_sleep 0.3;
+        echo -n barbar;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body_like eval
+qr{connected: 1
+request sent: 57
+read: HTTP/1\.1 200 OK\r
+Server: nginx\r
+Content-Type: text/plain\r
+Transfer-Encoding: chunked\r
+Connection: close\r
+\r
+6\r
+failed to set keepalive: (?:unread data in buffer|connection in dubious state)
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: set keepalive when cosocket recv buffer has unread data
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "flush_all\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            ngx.say("request sent: ", bytes)
+
+            local data, err = sock:receive(1)
+            if not data then
+                ngx.say("failed to read the 1st byte: ", err)
+                return
+            end
+
+            ngx.say("read: ", data)
+
+            local ok, err = sock:setkeepalive()
+            if not ok then
+                ngx.say("failed to set keepalive: ", err)
+            end
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 11
+read: O
+failed to set keepalive: unread data in buffer
+}
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/072-conditional-get.t b/src/lua/lua-nginx-module/t/072-conditional-get.t
--- a/src/lua/lua-nginx-module/t/072-conditional-get.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/072-conditional-get.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,92 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: If-Modified-Since true
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.header.last_modified = "Thu, 10 May 2012 07:50:59 GMT"
+            ngx.say("hello")
+        ';
+    }
+--- request
+GET /lua
+--- more_headers
+If-Modified-Since: Thu, 10 May 2012 07:50:59 GMT
+--- response_body
+--- error_code: 304
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: If-Modified-Since true
+--- config
+    location /lua {
+        if_modified_since before;
+        content_by_lua '
+            ngx.header.last_modified = "Thu, 10 May 2012 07:50:48 GMT"
+            ngx.say("hello")
+        ';
+    }
+--- request
+GET /lua
+--- more_headers
+If-Modified-Since: Thu, 10 May 2012 07:50:59 GMT
+--- response_body
+--- error_code: 304
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: If-Unmodified-Since false
+--- config
+    location /lua {
+        #if_modified_since before;
+        content_by_lua '
+            ngx.header.last_modified = "Thu, 10 May 2012 07:50:48 GMT"
+            local ok, err = ngx.say("hello")
+            if not ok then
+                ngx.log(ngx.WARN, "say failed: ", err)
+            end
+        ';
+    }
+--- request
+GET /lua
+--- more_headers
+If-Unmodified-Since: Thu, 10 May 2012 07:50:47 GMT
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+
+--- response_body_like: 412 Precondition Failed
+--- error_code: 412
+--- error_log
+say failed: nginx output filter error
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/073-backtrace.t b/src/lua/lua-nginx-module/t/073-backtrace.t
--- a/src/lua/lua-nginx-module/t/073-backtrace.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/073-backtrace.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,189 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * 51;
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    location /lua {
+        content_by_lua
+        '   function bar()
+                return lua_concat(3)
+            end
+            function foo()
+                bar()
+            end
+            foo()
+        ';
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+attempt to call global 'lua_concat'
+: in function 'bar'
+:5: in function 'foo'
+:7: in function
+
+
+
+=== TEST 2: error(nil)
+--- config
+    location /lua {
+        content_by_lua
+        '   function bar()
+                error(nil)
+            end
+            function foo()
+                bar()
+            end
+            foo()
+        ';
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+lua entry thread aborted: runtime error: unknown reason
+stack traceback:
+ in function 'error'
+: in function 'bar'
+:5: in function 'foo'
+:7: in function <[string "content_by_lua"]:1>
+
+
+
+=== TEST 3: deep backtrace in a single coroutine (more than 15)
+--- config eval
+my $s = "
+    location /lua {
+        content_by_lua '
+";
+my $prev;
+for my $i (1..18) {
+    if (!defined $prev) {
+        $s .= "
+            local function func$i()
+                return error([[blah]])
+            end";
+    } else {
+        $s .= "
+            local function func$i()
+                local v = func$prev()
+                return v
+            end";
+    }
+    $prev = $i;
+}
+$s .= "
+            func$prev()
+        ';
+    }
+";
+--- request
+GET /lua
+--- stap2
+probe process("$LIBLUA_PATH").function("lua_concat") {
+    println("lua concat")
+    //print_ubacktrace()
+}
+--- stap_out2
+--- ignore_response
+--- error_log
+: blah
+: in function 'func1'
+:7: in function 'func2'
+:11: in function 'func3'
+:15: in function 'func4'
+:19: in function 'func5'
+:23: in function 'func6'
+:27: in function 'func7'
+:31: in function 'func8'
+:35: in function 'func9'
+:39: in function 'func10'
+:43: in function 'func11'
+:47: in function 'func12'
+:51: in function 'func13'
+:55: in function 'func14'
+:59: in function 'func15'
+:63: in function 'func16'
+:67: in function 'func17'
+:71: in function 'func18'
+:74: in function
+
+
+
+=== TEST 4: deep backtrace in a single coroutine (more than 22)
+--- config eval
+my $s = "
+    location /lua {
+        content_by_lua '
+";
+my $prev;
+for my $i (1..23) {
+    if (!defined $prev) {
+        $s .= "
+            local function func$i()
+                return error([[blah]])
+            end";
+    } else {
+        $s .= "
+            local function func$i()
+                local v = func$prev()
+                return v
+            end";
+    }
+    $prev = $i;
+}
+$s .= "
+            func$prev()
+        ';
+    }
+";
+--- request
+GET /lua
+--- stap2
+probe process("$LIBLUA_PATH").function("lua_concat") {
+    println("lua concat")
+    //print_ubacktrace()
+}
+--- stap_out2
+--- ignore_response
+--- error_log
+: blah
+: in function 'func1'
+:7: in function 'func2'
+:11: in function 'func3'
+:15: in function 'func4'
+:19: in function 'func5'
+:23: in function 'func6'
+:27: in function 'func7'
+:31: in function 'func8'
+:35: in function 'func9'
+:39: in function 'func10'
+:43: in function 'func11'
+:47: in function 'func12'
+:59: in function 'func15'
+:63: in function 'func16'
+:67: in function 'func17'
+:71: in function 'func18'
+:75: in function 'func19'
+:79: in function 'func20'
+:83: in function 'func21'
+...
+
diff -rNu a/src/lua/lua-nginx-module/t/074-prefix-var.t b/src/lua/lua-nginx-module/t/074-prefix-var.t
--- a/src/lua/lua-nginx-module/t/074-prefix-var.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/074-prefix-var.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,68 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: $prefix
+--- http_config: lua_package_path "$prefix/html/?.lua;;";
+--- config
+    location /t {
+        content_by_lua '
+            local foo = require "foo"
+            foo.go()
+        ';
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+function go()
+    ngx.say("Greetings from module foo.")
+end
+--- request
+GET /t
+--- response_body
+Greetings from module foo.
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: ${prefix}
+--- http_config: lua_package_path "${prefix}html/?.lua;;";
+--- config
+    location /t {
+        content_by_lua '
+            local foo = require "foo"
+            foo.go()
+        ';
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+function go()
+    ngx.say("Greetings from module foo.")
+end
+--- request
+GET /t
+--- response_body
+Greetings from module foo.
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/075-logby.t b/src/lua/lua-nginx-module/t/075-logby.t
--- a/src/lua/lua-nginx-module/t/075-logby.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/075-logby.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,566 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 9);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: log_by_lua
+--- config
+    location /lua {
+        echo hello;
+        log_by_lua 'ngx.log(ngx.ERR, "Hello from log_by_lua: ", ngx.var.uri)';
+    }
+--- request
+GET /lua
+--- response_body
+hello
+--- error_log
+Hello from log_by_lua: /lua
+
+
+
+=== TEST 2: log_by_lua_file
+--- config
+    location /lua {
+        echo hello;
+        log_by_lua_file html/a.lua;
+    }
+--- user_files
+>>> a.lua
+ngx.log(ngx.ERR, "Hello from log_by_lua: ", ngx.var.uri)
+--- request
+GET /lua
+--- response_body
+hello
+--- error_log
+Hello from log_by_lua: /lua
+
+
+
+=== TEST 3: log_by_lua_file & content_by_lua
+--- config
+    location /lua {
+        set $counter 3;
+        content_by_lua 'ngx.var.counter = ngx.var.counter + 1 ngx.say(ngx.var.counter)';
+        log_by_lua_file html/a.lua;
+    }
+--- user_files
+>>> a.lua
+ngx.log(ngx.ERR, "Hello from log_by_lua: ", ngx.var.counter * 2)
+--- request
+GET /lua
+--- response_body
+4
+--- error_log
+Hello from log_by_lua: 8
+
+
+
+=== TEST 4: ngx.ctx available in log_by_lua (already defined)
+--- config
+    location /lua {
+        content_by_lua 'ngx.ctx.counter = 3 ngx.say(ngx.ctx.counter)';
+        log_by_lua 'ngx.log(ngx.ERR, "ngx.ctx.counter: ", ngx.ctx.counter)';
+    }
+--- request
+GET /lua
+--- response_body
+3
+--- error_log
+ngx.ctx.counter: 3
+lua release ngx.ctx
+
+
+
+=== TEST 5: ngx.ctx available in log_by_lua (not defined yet)
+--- config
+    location /lua {
+        echo hello;
+        log_by_lua '
+            ngx.log(ngx.ERR, "ngx.ctx.counter: ", ngx.ctx.counter)
+            ngx.ctx.counter = "hello world"
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+hello
+--- error_log
+ngx.ctx.counter: nil
+lua release ngx.ctx
+
+
+
+=== TEST 6: log_by_lua + shared dict
+--- http_config
+    lua_shared_dict foo 100k;
+--- config
+    location /lua {
+        echo hello;
+        log_by_lua '
+            local foo = ngx.shared.foo
+            local key = ngx.var.uri .. ngx.status
+            local newval, err = foo:incr(key, 1)
+            if not newval then
+                if err == "not found" then
+                    foo:add(key, 0)
+                    newval, err = foo:incr(key, 1)
+                    if not newval then
+                        ngx.log(ngx.ERR, "failed to incr ", key, ": ", err)
+                        return
+                    end
+                else
+                    ngx.log(ngx.ERR, "failed to incr ", key, ": ", err)
+                    return
+                end
+            end
+            print(key, ": ", foo:get(key))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+hello
+--- error_log eval
+qr{/lua200: [12]}
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: ngx.ctx used in different locations and different ctx (1)
+--- config
+    location /t {
+        echo hello;
+        log_by_lua '
+            ngx.log(ngx.ERR, "ngx.ctx.counter: ", ngx.ctx.counter)
+        ';
+    }
+
+    location /t2 {
+        content_by_lua '
+            ngx.ctx.counter = 32
+            ngx.say("hello")
+        ';
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+ngx.ctx.counter: nil
+lua release ngx.ctx
+
+
+
+=== TEST 8: ngx.ctx used in different locations and different ctx (2)
+--- config
+    location /t {
+        echo hello;
+        log_by_lua '
+            ngx.log(ngx.ERR, "ngx.ctx.counter: ", ngx.ctx.counter)
+        ';
+    }
+
+    location /t2 {
+        content_by_lua '
+            ngx.ctx.counter = 32
+            ngx.say(ngx.ctx.counter)
+        ';
+    }
+--- request
+GET /t2
+--- response_body
+32
+--- error_log
+lua release ngx.ctx
+
+
+
+=== TEST 9: lua error (string)
+--- config
+    location /lua {
+        log_by_lua 'error("Bad")';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+failed to run log_by_lua*: [string "log_by_lua"]:1: Bad
+
+
+
+=== TEST 10: lua error (nil)
+--- config
+    location /lua {
+        log_by_lua 'error(nil)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+failed to run log_by_lua*: unknown reason
+
+
+
+=== TEST 11: globals get cleared for every single request
+--- config
+    location /lua {
+        echo ok;
+        log_by_lua '
+            if not foo then
+                foo = 1
+            else
+                foo = foo + 1
+            end
+            ngx.log(ngx.WARN, "foo = ", foo)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+foo = 1
+
+
+
+=== TEST 12: no ngx.print
+--- config
+    location /lua {
+        log_by_lua "ngx.print(32) return 1";
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 13: no ngx.say
+--- config
+    location /lua {
+        log_by_lua "ngx.say(32) return 1";
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 14: no ngx.flush
+--- config
+    location /lua {
+        log_by_lua "ngx.flush()";
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 15: no ngx.eof
+--- config
+    location /lua {
+        log_by_lua "ngx.eof()";
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 16: no ngx.send_headers
+--- config
+    location /lua {
+        log_by_lua "ngx.send_headers()";
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 17: no ngx.location.capture
+--- config
+    location /lua {
+        log_by_lua 'ngx.location.capture("/sub")';
+        echo ok;
+    }
+
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 18: no ngx.location.capture_multi
+--- config
+    location /lua {
+        log_by_lua 'ngx.location.capture_multi{{"/sub"}}';
+        echo ok;
+    }
+
+    location /sub {
+        echo sub;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 19: no ngx.exit
+--- config
+    location /lua {
+        log_by_lua 'ngx.exit(0)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 20: no ngx.redirect
+--- config
+    location /lua {
+        log_by_lua 'ngx.redirect("/blah")';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 21: no ngx.exec
+--- config
+    location /lua {
+        log_by_lua 'ngx.exec("/blah")';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 22: no ngx.req.set_uri(uri, true)
+--- config
+    location /lua {
+        log_by_lua 'ngx.req.set_uri("/blah", true)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 23: ngx.req.set_uri(uri) exists
+--- config
+    location /lua {
+        log_by_lua 'ngx.req.set_uri("/blah") print("log_by_lua: uri: ", ngx.var.uri)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+log_by_lua: uri: /blah
+
+
+
+=== TEST 24: no ngx.req.read_body()
+--- config
+    location /lua {
+        log_by_lua 'ngx.req.read_body()';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 25: no ngx.req.socket()
+--- config
+    location /lua {
+        log_by_lua 'return ngx.req.socket()';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 26: no ngx.socket.tcp()
+--- config
+    location /lua {
+        log_by_lua 'return ngx.socket.tcp()';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 27: no ngx.socket.connect()
+--- config
+    location /lua {
+        log_by_lua 'return ngx.socket.connect("127.0.0.1", 80)';
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+API disabled in the context of log_by_lua*
+
+
+
+=== TEST 28: backtrace
+--- config
+    location /t {
+        echo ok;
+        log_by_lua '
+            function foo()
+                bar()
+            end
+
+            function bar()
+                error("something bad happened")
+            end
+
+            foo()
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+ok
+--- error_log
+something bad happened
+stack traceback:
+in function 'error'
+in function 'bar'
+in function 'foo'
+
+
+
+=== TEST 29: Lua file does not exist
+--- config
+    location /lua {
+        echo ok;
+        log_by_lua_file html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- response_body
+ok
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
+
+
+=== TEST 30: log_by_lua runs before access logging (github issue #254)
+--- config
+    location /lua {
+        echo ok;
+        access_log logs/foo.log;
+        log_by_lua 'print("hello")';
+    }
+--- request
+GET /lua
+--- stap
+F(ngx_http_log_handler) {
+    println("log handler")
+}
+F(ngx_http_lua_log_handler) {
+    println("lua log handler")
+}
+--- stap_out
+lua log handler
+log handler
+
+--- response_body
+ok
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/076-no-postpone.t b/src/lua/lua-nginx-module/t/076-no-postpone.t
--- a/src/lua/lua-nginx-module/t/076-no-postpone.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/076-no-postpone.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,85 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: rewrite no postpone on
+--- http_config
+    rewrite_by_lua_no_postpone on;
+--- config
+    set $foo '';
+    location /t {
+        rewrite_by_lua '
+            ngx.var.foo = 1
+        ';
+        if ($foo = 1) {
+            echo "foo: $foo";
+        }
+        echo "no foo: $foo";
+    }
+--- request
+GET /t
+--- response_body
+foo: 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: rewrite no postpone explicitly off
+--- http_config
+    rewrite_by_lua_no_postpone off;
+--- config
+    set $foo '';
+    location /t {
+        rewrite_by_lua '
+            ngx.var.foo = 1
+        ';
+        if ($foo = 1) {
+            echo "foo: $foo";
+        }
+        echo "no foo: $foo";
+    }
+--- request
+GET /t
+--- response_body
+no foo: 1
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: rewrite no postpone off by default
+--- config
+    set $foo '';
+    location /t {
+        rewrite_by_lua '
+            ngx.var.foo = 1
+        ';
+        if ($foo = 1) {
+            echo "foo: $foo";
+        }
+        echo "no foo: $foo";
+    }
+--- request
+GET /t
+--- response_body
+no foo: 1
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/077-sleep.t b/src/lua/lua-nginx-module/t/077-sleep.t
--- a/src/lua/lua-nginx-module/t/077-sleep.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/077-sleep.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,238 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * 40;
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sleep 0.5 - content
+--- config
+    location /test {
+        content_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep(0.5)
+            local now = ngx.now()
+            ngx.say(now - before)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:4[5-9]\d*|5[0-5]\d*|5)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+lua sleep timer expired: "/test?"
+
+
+
+=== TEST 2: sleep a - content
+--- config
+    location /test {
+        content_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep("a")
+            local now = ngx.now()
+            ngx.say(now - before)
+        ';
+    }
+--- request
+GET /test
+--- error_code: 500
+--- response_body_like: 500 Internal Server Error
+--- error_log
+bad argument #1 to 'sleep'
+
+
+
+=== TEST 3: sleep 0.5 in subrequest - content
+--- config
+    location /test {
+        content_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.location.capture("/sleep")
+            local now = ngx.now()
+            local delay = now - before
+            ngx.say(delay)
+        ';
+    }
+    location /sleep {
+        content_by_lua 'ngx.sleep(0.5)';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^0\.(?:4[5-9]\d*|5[0-9]\d*|5)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/sleep?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: sleep a in subrequest with bad argument
+--- config
+    location /test {
+        content_by_lua '
+            local res = ngx.location.capture("/sleep");
+        ';
+    }
+    location /sleep {
+        content_by_lua 'ngx.sleep("a")';
+    }
+--- request
+GET /test
+--- response_body_like:
+--- error_log
+bad argument #1 to 'sleep'
+
+
+
+=== TEST 5: sleep 0.33 - multi-times in content
+--- config
+    location /test {
+        content_by_lua '
+            ngx.update_time()
+            local start = ngx.now()
+            ngx.sleep(0.33)
+            ngx.sleep(0.33)
+            ngx.sleep(0.33)
+            ngx.say(ngx.now() - start)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+^(?:0\.9\d*|1\.[0-2]\d*|1)$
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: sleep 0.5 - interleaved by ngx.say() - ended by ngx.sleep
+--- config
+    location /test {
+        content_by_lua '
+            ngx.send_headers()
+            -- ngx.location.capture("/sleep")
+            ngx.sleep(1)
+            ngx.say("blah")
+            ngx.sleep(1)
+            -- ngx.location.capture("/sleep")
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.1;
+    }
+--- request
+GET /test
+--- response_body
+blah
+--- error_log
+lua ready to sleep
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: sleep 0.5 - interleaved by ngx.say() - not ended by ngx.sleep
+--- config
+    location /test {
+        content_by_lua '
+            ngx.send_headers()
+            -- ngx.location.capture("/sleep")
+            ngx.sleep(0.3)
+            ngx.say("blah")
+            ngx.sleep(0.5)
+            -- ngx.location.capture("/sleep")
+            ngx.say("hiya")
+        ';
+    }
+    location = /sleep {
+        echo_sleep 0.1;
+    }
+--- request
+GET /test
+--- response_body
+blah
+hiya
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: ngx.location.capture before and after ngx.sleep
+--- config
+    location /test {
+        content_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+
+            ngx.sleep(0.1)
+
+            res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+        ';
+    }
+    location = /hello {
+        echo hello world;
+    }
+    location = /sub {
+        proxy_pass http://127.0.0.1:$server_port/hello;
+    }
+--- request
+GET /test
+--- response_body
+hello world
+hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: sleep 0
+--- config
+    location /test {
+        content_by_lua '
+            ngx.update_time()
+            local before = ngx.now()
+            ngx.sleep(0)
+            local now = ngx.now()
+            ngx.say("elapsed: ", now - before)
+        ';
+    }
+--- request
+GET /test
+--- response_body_like chop
+elapsed: 0
+--- error_log
+lua ready to sleep for
+lua sleep timer expired: "/test?"
+lua sleep timer expired: "/test?"
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/078-hup-vars.t b/src/lua/lua-nginx-module/t/078-hup-vars.t
--- a/src/lua/lua-nginx-module/t/078-hup-vars.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/078-hup-vars.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,66 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+our $SkipReason;
+
+BEGIN {
+    if ($ENV{TEST_NGINX_CHECK_LEAK}) {
+        $SkipReason = "unavailable for the hup tests";
+
+    } else {
+        $ENV{TEST_NGINX_USE_HUP} = 1;
+        undef $ENV{TEST_NGINX_USE_STAP};
+    }
+}
+
+use lib 'lib';
+use t::TestNginxLua $SkipReason ? (skip_all => $SkipReason) : ();
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (3 * blocks());
+
+#no_diff();
+#no_long_string();
+no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: nginx variable hup bug (step 1)
+http://mailman.nginx.org/pipermail/nginx-devel/2012-May/002223.html
+--- config
+    location /t {
+        set $vv $http_host;
+        set_by_lua $i 'return ngx.var.http_host';
+        echo $i;
+    }
+--- request
+GET /t
+--- response_body
+localhost
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: nginx variable hup bug (step 2)
+http://mailman.nginx.org/pipermail/nginx-devel/2012-May/002223.html
+--- config
+    location /t {
+        #set $vv $http_host;
+        set_by_lua $i 'return ngx.var.http_host';
+        echo $i;
+    }
+--- request
+GET /t
+--- response_body
+localhost
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/079-unused-directives.t b/src/lua/lua-nginx-module/t/079-unused-directives.t
--- a/src/lua/lua-nginx-module/t/079-unused-directives.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/079-unused-directives.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,263 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (11 * blocks());
+
+#no_diff();
+#no_long_string();
+#no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: rewrite_by_lua unused
+--- config
+    location /t {
+        set_by_lua $i 'return 32';
+        #rewrite_by_lua return;
+        echo $i;
+    }
+--- request
+GET /t
+--- response_body
+32
+--- no_error_log
+lua capture header filter, uri "/t"
+lua capture body filter, uri "/t"
+lua rewrite handler, uri:"/t"
+lua access handler, uri:"/t"
+lua content handler, uri:"/t"
+lua header filter for user lua code, uri "/t"
+lua body filter for user lua code, uri "/t"
+lua log handler, uri:"/t"
+[error]
+
+
+
+=== TEST 2: rewrite_by_lua used
+--- config
+    location /t {
+        rewrite_by_lua return;
+        echo hello;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua rewrite handler, uri:"/t"
+lua capture header filter, uri "/t"
+lua capture body filter, uri "/t"
+--- no_error_log
+lua access handler, uri:"/t"
+lua content handler, uri:"/t"
+lua header filter for user lua code, uri "/t"
+lua body filter for user lua code, uri "/t"
+lua log handler, uri:"/t"
+[error]
+--- log_level: debug
+
+
+
+=== TEST 3: access_by_lua used
+--- config
+    location /t {
+        access_by_lua return;
+        echo hello;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua access handler, uri:"/t" c:1
+lua capture body filter, uri "/t"
+lua capture header filter, uri "/t"
+--- no_error_log
+lua rewrite handler, uri:"/t"
+lua content handler, uri:"/t"
+lua header filter for user lua code, uri "/t"
+lua body filter for user lua code, uri "/t"
+lua log handler, uri:"/t"
+[error]
+
+
+
+=== TEST 4: content_by_lua used
+--- config
+    location /t {
+        content_by_lua 'ngx.say("hello")';
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua content handler, uri:"/t" c:1
+lua capture body filter, uri "/t"
+lua capture header filter, uri "/t"
+--- no_error_log
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua header filter for user lua code, uri "/t"
+lua body filter for user lua code, uri "/t"
+lua log handler, uri:"/t"
+[error]
+
+
+
+=== TEST 5: header_filter_by_lua
+--- config
+    location /t {
+        echo hello;
+        header_filter_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua header filter for user lua code, uri "/t"
+--- no_error_log
+lua capture header filter, uri "/t"
+lua content handler, uri:"/t"
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua capture body filter, uri "/t"
+lua log handler, uri:"/t"
+lua body filter for user lua code, uri "/t"
+[error]
+
+
+
+=== TEST 6: log_by_lua
+--- config
+    location /t {
+        echo hello;
+        log_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua log handler, uri:"/t"
+--- no_error_log
+lua header filter for user lua code, uri "/t"
+lua capture header filter, uri "/t"
+lua content handler, uri:"/t"
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua capture body filter, uri "/t"
+lua body filter for user lua code, uri "/t"
+[error]
+
+
+
+=== TEST 7: body_filter_by_lua
+--- config
+    location /t {
+        echo hello;
+        body_filter_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua header filter for user lua code, uri "/t"
+lua body filter for user lua code, uri "/t"
+--- no_error_log
+lua capture header filter, uri "/t"
+lua content handler, uri:"/t"
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua capture body filter, uri "/t"
+lua log handler, uri:"/t"
+[error]
+
+
+
+=== TEST 8: header_filter_by_lua_file
+--- config
+    location /t {
+        echo hello;
+        header_filter_by_lua_file html/a.lua;
+    }
+--- user_files
+>>> a.lua
+return
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua header filter for user lua code, uri "/t"
+--- no_error_log
+lua capture header filter, uri "/t"
+lua content handler, uri:"/t"
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua capture body filter, uri "/t"
+lua log handler, uri:"/t"
+lua body filter for user lua code, uri "/t"
+[error]
+
+
+
+=== TEST 9: log_by_lua
+--- config
+    location /t {
+        echo hello;
+        log_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua log handler, uri:"/t"
+--- no_error_log
+lua header filter for user lua code, uri "/t"
+lua capture header filter, uri "/t"
+lua content handler, uri:"/t"
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua capture body filter, uri "/t"
+lua body filter for user lua code, uri "/t"
+[error]
+
+
+
+=== TEST 10: body_filter_by_lua
+--- config
+    location /t {
+        echo hello;
+        body_filter_by_lua return;
+    }
+--- request
+GET /t
+--- response_body
+hello
+--- error_log
+lua header filter for user lua code, uri "/t"
+lua body filter for user lua code, uri "/t"
+--- no_error_log
+lua capture header filter, uri "/t"
+lua content handler, uri:"/t"
+lua access handler, uri:"/t"
+lua rewrite handler, uri:"/t"
+lua capture body filter, uri "/t"
+lua log handler, uri:"/t"
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/080-hup-shdict.t b/src/lua/lua-nginx-module/t/080-hup-shdict.t
--- a/src/lua/lua-nginx-module/t/080-hup-shdict.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/080-hup-shdict.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,86 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+our $SkipReason;
+
+BEGIN {
+    if ($ENV{TEST_NGINX_CHECK_LEAK}) {
+        $SkipReason = "unavailable for the hup tests";
+
+    } else {
+        $ENV{TEST_NGINX_USE_HUP} = 1;
+        undef $ENV{TEST_NGINX_USE_STAP};
+    }
+}
+
+use lib 'lib';
+use t::TestNginxLua $SkipReason ? (skip_all => $SkipReason) : ();
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+no_long_string();
+#master_on();
+#workers(2);
+
+no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: initialize the fields in shdict
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 32)
+            dogs:set("bah", 10502)
+            local val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32 number
+10502 number
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: retrieve the fields in shdict after HUP reload
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+
+            -- dogs:set("foo", 32)
+            -- dogs:set("bah", 10502)
+
+            local val = dogs:get("foo")
+            ngx.say(val, " ", type(val))
+            val = dogs:get("bah")
+            ngx.say(val, " ", type(val))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+32 number
+10502 number
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/081-bytecode.t b/src/lua/lua-nginx-module/t/081-bytecode.t
--- a/src/lua/lua-nginx-module/t/081-bytecode.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/081-bytecode.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,237 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: bytecode ("ngx.say('hello');")
+--- config
+    root html;
+    location /save_call {
+        content_by_lua '
+            ngx.req.read_body();
+            local b = ngx.req.get_body_data();
+            f = io.open(ngx.var.realpath_root.."/test.lua", "w");
+            -- luajit bytecode: sub(149,-1), lua bytecode: sub(1,147)
+            if package.loaded["jit"] then
+                f:write(string.sub(b, 149));
+            else
+                f:write(string.sub(b, 1, 147));
+            end
+            f:close(); res = ngx.location.capture("/call");
+            ngx.print(res.body)
+        ';
+    }
+    location /call {
+        content_by_lua_file $realpath_root/test.lua;
+    }
+--- request eval
+"POST /save_call
+\x1b\x4c\x75\x61\x51\x00\x01\x04\x08\x04\x08\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x40\x74\x65\x73\x74\x2e\x6c\x75\x61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x05\x00\x00\x00\x05\x00\x00\x00\x06\x40\x40\x00\x41\x80\x00\x00\x1c\x40\x00\x01\x1e\x00\x80\x00\x03\x00\x00\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x6e\x67\x78\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x73\x61\x79\x00\x04\x06\x00\x00\x00\x00\x00\x00\x00\x68\x65\x6c\x6c\x6f\x00\x00\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x1b\x4c\x4a\x01\x02\x29\x02\x00\x02\x00\x03\x00\x05\x34\x00\x00\x00\x37\x00\x01\x00\x25\x01\x02\x00\x3e\x00\x02\x01\x47\x00\x01\x00\x0a\x68\x65\x6c\x6c\x6f\x08\x73\x61\x79\x08\x6e\x67\x78\x00"
+--- response_body
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: luajit load lua bytecode or lua load luajit bytecode
+--- config
+    root html;
+    location /save_call {
+        content_by_lua '
+            ngx.req.read_body();
+            local b = ngx.req.get_body_data();
+            f = io.open(ngx.var.realpath_root.."/test.lua", "w");
+            -- luajit bytecode: sub(149,-1), lua bytecode: sub(1,147)
+            if not package.loaded["jit"] then
+                f:write(string.sub(b, 149));
+            else
+                f:write(string.sub(b, 1, 147));
+            end
+            f:close(); res = ngx.location.capture("/call");
+            if res.status == 200 then
+                ngx.print(res.body)
+            else
+                ngx.say("error")
+            end
+        ';
+    }
+    location /call {
+        content_by_lua_file $realpath_root/test.lua;
+    }
+--- request eval
+"POST /save_call
+\x1b\x4c\x75\x61\x51\x00\x01\x04\x08\x04\x08\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x40\x74\x65\x73\x74\x2e\x6c\x75\x61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x05\x00\x00\x00\x05\x00\x00\x00\x06\x40\x40\x00\x41\x80\x00\x00\x1c\x40\x00\x01\x1e\x00\x80\x00\x03\x00\x00\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x6e\x67\x78\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x73\x61\x79\x00\x04\x06\x00\x00\x00\x00\x00\x00\x00\x68\x65\x6c\x6c\x6f\x00\x00\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x1b\x4c\x4a\x01\x02\x29\x02\x00\x02\x00\x03\x00\x05\x34\x00\x00\x00\x37\x00\x01\x00\x25\x01\x02\x00\x3e\x00\x02\x01\x47\x00\x01\x00\x0a\x68\x65\x6c\x6c\x6f\x08\x73\x61\x79\x08\x6e\x67\x78\x00"
+--- response_body
+error
+--- error_log
+failed to load external Lua file: bad byte-code header in
+
+
+
+=== TEST 3: unknown bytecode version
+--- config
+    root html;
+    location /save_call {
+        content_by_lua '
+            ngx.req.read_body();
+            local b = ngx.req.get_body_data();
+            f = io.open(ngx.var.realpath_root.."/test.lua", "w");
+            -- luajit bytecode: sub(149,-1), lua bytecode: sub(1,147)
+            if package.loaded["jit"] then
+                f:write(string.sub(b, 149));
+            else
+                f:write(string.sub(b, 1, 147));
+            end
+            f:close(); res = ngx.location.capture("/call");
+            if res.status == 200 then
+                ngx.print(res.body)
+            else
+                ngx.say("error")
+            end
+        ';
+    }
+    location /call {
+        content_by_lua_file $realpath_root/test.lua;
+    }
+--- request eval
+"POST /save_call
+\x1b\x4c\x75\x61\x52\x00\x01\x04\x08\x04\x08\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x40\x74\x65\x73\x74\x2e\x6c\x75\x61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x05\x00\x00\x00\x05\x00\x00\x00\x06\x40\x40\x00\x41\x80\x00\x00\x1c\x40\x00\x01\x1e\x00\x80\x00\x03\x00\x00\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x6e\x67\x78\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x73\x61\x79\x00\x04\x06\x00\x00\x00\x00\x00\x00\x00\x68\x65\x6c\x6c\x6f\x00\x00\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x1b\x4c\x4a\x02\x02\x29\x02\x00\x02\x00\x03\x00\x05\x34\x00\x00\x00\x37\x00\x01\x00\x25\x01\x02\x00\x3e\x00\x02\x01\x47\x00\x01\x00\x0a\x68\x65\x6c\x6c\x6f\x08\x73\x61\x79\x08\x6e\x67\x78\x00"
+--- response_body
+error
+--- error_log
+bad byte-code header in
+
+
+
+=== TEST 4: bytecode (big endian)
+--- config
+    root html;
+    location /save_call {
+        content_by_lua '
+            ngx.req.read_body();
+            local b = ngx.req.get_body_data();
+            f = io.open(ngx.var.realpath_root.."/test.lua", "w");
+            -- luajit bytecode: sub(149,-1), lua bytecode: sub(1,147)
+            local jit
+            if package.loaded["jit"] then
+                jit = true; f:write(string.sub(b, 149));
+            else
+                f:write(string.sub(b, 1, 147));
+            end
+            f:close(); res = ngx.location.capture("/call");
+            if jit and res.status == 200 then
+                ngx.say("ok")
+            elseif not jit and res.status == 500 then
+                ngx.say("ok")
+            else
+                ngx.say("error")
+            end
+        ';
+    }
+    location /call {
+        content_by_lua_file $realpath_root/test.lua;
+    }
+--- request eval
+"POST /save_call
+\x1b\x4c\x75\x61\x51\x00\x00\x04\x08\x04\x08\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x40\x74\x65\x73\x74\x2e\x6c\x75\x61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x05\x00\x00\x00\x05\x00\x00\x00\x06\x40\x40\x00\x41\x80\x00\x00\x1c\x40\x00\x01\x1e\x00\x80\x00\x03\x00\x00\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x6e\x67\x78\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x73\x61\x79\x00\x04\x06\x00\x00\x00\x00\x00\x00\x00\x68\x65\x6c\x6c\x6f\x00\x00\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x1b\x4c\x4a\x01\x03\x29\x02\x00\x02\x00\x03\x00\x05\x00\x00\x00\x34\x00\x01\x00\x37\x00\x02\x01\x25\x01\x02\x00\x3e\x00\x01\x00\x47\x0a\x68\x65\x6c\x6c\x6f\x08\x73\x61\x79\x08\x6e\x67\x78\x00"
+--- response_body
+ok
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: good header but bad body
+--- config
+    root html;
+    location /save_call {
+        content_by_lua '
+            ngx.req.read_body();
+            local b = ngx.req.get_body_data();
+            f = io.open(ngx.var.realpath_root.."/test.lua", "w");
+            -- luajit bytecode: sub(149,-1), lua bytecode: sub(1,147)
+            local jit;
+            if package.loaded["jit"] then
+                jit = true;
+                f:write(string.sub(b, 149));
+            else
+                f:write(string.sub(b, 1, 147));
+            end
+            if not jit then
+                f:close(); res = ngx.location.capture("/call");
+                if res.status == 200 then
+                    ngx.print("ok")
+                else
+                    ngx.say("error")
+                end
+            else
+            -- luajit will get a segmentation fault with bad bytecode,
+            -- so here just skip this case for luajit
+                ngx.say("error")
+            end
+        ';
+    }
+    location /call {
+        content_by_lua_file $realpath_root/test.lua;
+    }
+--- request eval
+"POST /save_call
+\x1b\x4c\x75\x61\x51\x00\x01\x04\x08\x04\x08\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x40\x74\x65\x73\x74\x2e\x6c\x75\x61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x05\x00\x00\x00\xff\xff\xff\xff\x06\x40\x40\x00\x41\x80\x00\x00\x1c\x40\x00\x01\x1e\x00\x80\x00\x03\x00\x00\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x6e\x67\x78\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x73\x61\x79\x00\x04\x06\x00\x00\x00\x00\x00\x00\x00\x68\x65\x6c\x6c\x6f\x00\x00\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x1b\x4c\x4a\x01\x02\x29\x02\x00\x02\x00\x03\x00\x05\xff\xff\xff\xff\x37\x00\x01\x00\x25\x01\x02\x00\x3e\x00\x02\x01\x47\x00\x01\x00\x0a\x68\x65\x6c\x6c\x6f\x08\x73\x61\x79\x08\x6e\x67\x78\x00"
+--- response_body
+error
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: stripped(lua) & no stripped(luajit)
+--- config
+    root html;
+    location /save_call {
+        content_by_lua '
+            ngx.req.read_body();
+            local b = ngx.req.get_body_data();
+            f = io.open(ngx.var.realpath_root.."/test.lua", "w");
+            -- luajit bytecode: sub(149,-1), lua bytecode: sub(1,147)
+            if package.loaded["jit"] then
+                f:write(string.sub(b, 119));
+            else
+                f:write(string.sub(b, 1, 117));
+            end
+            f:close(); res = ngx.location.capture("/call");
+            ngx.print(res.body)
+        ';
+    }
+    location /call {
+        content_by_lua_file $realpath_root/test.lua;
+    }
+--- request eval
+"POST /save_call
+\x1b\x4c\x75\x61\x51\x00\x01\x04\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x05\x00\x00\x00\x05\x00\x00\x00\x06\x40\x40\x00\x41\x80\x00\x00\x1c\x40\x00\x01\x1e\x00\x80\x00\x03\x00\x00\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x6e\x67\x78\x00\x04\x04\x00\x00\x00\x00\x00\x00\x00\x73\x61\x79\x00\x04\x06\x00\x00\x00\x00\x00\x00\x00\x68\x65\x6c\x6c\x6f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x1b\x4c\x4a\x01\x00\x09\x40\x74\x65\x73\x74\x2e\x6c\x75\x61\x32\x02\x00\x02\x00\x03\x00\x05\x06\x00\x02\x34\x00\x00\x00\x37\x00\x01\x00\x25\x01\x02\x00\x3e\x00\x02\x01\x47\x00\x01\x00\x0a\x68\x65\x6c\x6c\x6f\x08\x73\x61\x79\x08\x6e\x67\x78\x01\x01\x01\x01\x01\x00\x00"
+--- response_body
+hello
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/082-body-filter.t b/src/lua/lua-nginx-module/t/082-body-filter.t
--- a/src/lua/lua-nginx-module/t/082-body-filter.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/082-body-filter.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,527 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+log_level('debug');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 4);
+
+#no_diff();
+#no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: read chunks (inline)
+--- config
+    location /read {
+        echo -n hello world;
+        echo -n hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            print("chunk: [", chunk, "], eof: ", eof)
+        ';
+    }
+--- request
+GET /read
+--- response_body chop
+hello worldhiya globe
+--- error_log
+chunk: [hello world], eof: false
+chunk: [hiya globe], eof: false
+chunk: [], eof: true
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: read chunks (file)
+--- config
+    location /read {
+        echo -n hello world;
+        echo -n hiya globe;
+
+        body_filter_by_lua_file html/a.lua;
+    }
+--- user_files
+>>> a.lua
+local chunk, eof = ngx.arg[1], ngx.arg[2]
+print("chunk: [", chunk, "], eof: ", eof)
+--- request
+GET /read
+--- response_body chop
+hello worldhiya globe
+--- error_log
+chunk: [hello world], eof: false
+chunk: [hiya globe], eof: false
+chunk: [], eof: true
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: read chunks (user module)
+--- http_config
+    lua_package_path "$prefix/html/?.lua;;";
+--- config
+    location /read {
+        echo -n hello world;
+        echo -n hiya globe;
+
+        body_filter_by_lua '
+            local foo = require "foo"
+            foo.go()
+        ';
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+function go()
+    -- ngx.say("Hello")
+    local chunk, eof = ngx.arg[1], ngx.arg[2]
+    print("chunk: [", chunk, "], eof: ", eof)
+end
+--- request
+GET /read
+--- response_body chop
+hello worldhiya globe
+--- error_log
+chunk: [hello world], eof: false
+chunk: [hiya globe], eof: false
+chunk: [], eof: true
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: rewrite chunks (upper all)
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            ngx.arg[1] = string.upper(ngx.arg[1])
+        ';
+    }
+--- request
+GET /t
+--- response_body
+HELLO WORLD
+HIYA GLOBE
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: rewrite chunks (truncate data)
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk = ngx.arg[1]
+            if string.match(chunk, "hello") then
+                ngx.arg[1] = string.upper(chunk)
+                ngx.arg[2] = true
+                return
+            end
+
+            ngx.arg[1] = nil
+        ';
+    }
+--- request
+GET /t
+--- response_body
+HELLO WORLD
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: set eof back and forth
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk = ngx.arg[1]
+            if string.match(chunk, "hello") then
+                ngx.arg[1] = string.upper(chunk)
+                ngx.arg[2] = true
+                ngx.arg[2] = false
+                ngx.arg[2] = true
+                return
+            end
+
+            ngx.arg[1] = nil
+            ngx.arg[2] = true
+            ngx.arg[2] = false
+        ';
+    }
+--- request
+GET /t
+--- response_body
+HELLO WORLD
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: set eof to original
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            ngx.arg[2] = eof
+        ';
+    }
+--- request
+GET /t
+--- response_body
+hello world
+hiya globe
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: set eof to original
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            ngx.arg[2] = eof
+        ';
+    }
+--- request
+GET /t
+--- response_body
+hello world
+hiya globe
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: fully buffered output (string scalar)
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            local buf = ngx.ctx.buf
+
+            if eof then
+                if buf then
+                    ngx.arg[1] = "[" .. buf .. chunk .. "]"
+                    return
+                end
+
+                return
+            end
+
+            if buf then
+                ngx.ctx.buf = buf .. chunk
+            else
+                ngx.ctx.buf = chunk
+            end
+
+            ngx.arg[1] = nil
+        ';
+    }
+--- request
+GET /t
+--- response_body chop
+[hello world
+hiya globe
+]
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: fully buffered output (string table)
+--- config
+    location /t {
+        echo hello world;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            local buf = ngx.ctx.buf
+
+            if eof then
+                if buf then
+                    ngx.arg[1] = {"[", buf, chunk, "]"}
+                    return
+                end
+
+                return
+            end
+
+            if buf then
+                ngx.ctx.buf = {buf, chunk}
+            else
+                ngx.ctx.buf = chunk
+            end
+
+            ngx.arg[1] = nil
+        ';
+    }
+--- request
+GET /t
+--- response_body chop
+[hello world
+hiya globe
+]
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: abort via user error (string)
+--- config
+    location /t {
+        echo hello world;
+        echo_flush;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            if eof then
+                error("something bad happened!")
+            end
+        ';
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+failed to run body_filter_by_lua*: [string "body_filter_by_lua"]:4: something bad happened!
+
+
+
+=== TEST 12: abort via user error (nil)
+--- config
+    location /t {
+        echo hello world;
+        echo_flush;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            if eof then
+                error(nil)
+            end
+        ';
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+failed to run body_filter_by_lua*: unknown reason
+
+
+
+=== TEST 13: abort via return NGX_ERROR
+--- config
+    location /t {
+        echo hello world;
+        echo_flush;
+        echo hiya globe;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            if eof then
+                return ngx.ERROR
+            end
+        ';
+    }
+--- request
+GET /t
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: using body_filter_by_lua and header_filter_by_lua at the same time
+--- config
+    location /t {
+        content_by_lua '
+            ngx.header.content_length = 12
+            ngx.say("Hello World")
+        ';
+
+        header_filter_by_lua 'ngx.header.content_length = nil';
+
+        body_filter_by_lua '
+            ngx.arg[1] = ngx.arg[1] .. "aaa"
+        ';
+    }
+--- request
+GET /t
+--- response_body chop
+Hello World
+aaaaaa
+--- response_headers
+!content-length
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: table arguments to ngx.arg[1] (github issue #54)
+--- config
+    location /t {
+        echo -n hello;
+
+        body_filter_by_lua '
+            if ngx.arg[1] ~= "" then
+                ngx.arg[1] = {{ngx.arg[1]}, "!", "\\n"}
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+hello!
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: fully buffered output (string scalar, buffering to disk by ngx_proxy)
+--- config
+    location /t {
+        proxy_pass http://127.0.0.1:$server_port/stub;
+        proxy_buffers 2 256;
+        proxy_busy_buffers_size 256;
+        proxy_buffer_size 256;
+
+        body_filter_by_lua '
+            local chunk, eof = ngx.arg[1], ngx.arg[2]
+            local buf = ngx.ctx.buf
+
+            if eof then
+                if buf then
+                    ngx.arg[1] = "[" .. buf .. chunk .. "]"
+                    return
+                end
+
+                return
+            end
+
+            if buf then
+                ngx.ctx.buf = buf .. chunk
+            else
+                ngx.ctx.buf = chunk
+            end
+
+            ngx.arg[1] = nil
+        ';
+    }
+
+    location = /stub {
+        echo_duplicate 512 "a";
+        echo_duplicate 512 "b";
+    }
+--- request
+GET /t
+--- response_body eval
+"[" . ("a" x 512) . ("b" x 512) . "]";
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 17: backtrace
+--- config
+    location /t {
+        body_filter_by_lua '
+            function foo()
+                bar()
+            end
+
+            function bar()
+                error("something bad happened")
+            end
+
+            foo()
+        ';
+        echo ok;
+    }
+--- request
+    GET /t
+--- ignore_response
+--- error_log
+something bad happened
+stack traceback:
+in function 'error'
+in function 'bar'
+in function 'foo'
+
+
+
+=== TEST 18: setting "eof" in subrequests
+--- config
+    location /t {
+        echo_location /read;
+        echo_location /read;
+    }
+
+    location /read {
+        echo -n hello world;
+        echo -n hiya globe;
+
+        body_filter_by_lua '
+            ngx.arg[2] = 1
+        ';
+    }
+--- request
+GET /t
+--- response_body chop
+hello worldhello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: Lua file does not exist
+--- config
+    location /lua {
+        echo ok;
+        body_filter_by_lua_file html/test2.lua;
+    }
+--- user_files
+>>> test.lua
+v = ngx.var["request_uri"]
+ngx.print("request_uri: ", v, "\n")
+--- request
+GET /lua?a=1&b=2
+--- ignore_response
+--- error_log eval
+qr/failed to load external Lua file: cannot open .*? No such file or directory/
+
diff -rNu a/src/lua/lua-nginx-module/t/083-bad-sock-self.t b/src/lua/lua-nginx-module/t/083-bad-sock-self.t
--- a/src/lua/lua-nginx-module/t/083-bad-sock-self.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/083-bad-sock-self.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,140 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+#$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: receive
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            sock.receive("l")
+        ';
+    }
+--- request
+    POST /t
+--- more_headers: Content-Length: 1024
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #1 to 'receive' (table expected, got string)
+
+
+
+=== TEST 2: receiveuntil
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.req.socket()
+            sock.receiveuntil(32, "ab")
+        ';
+    }
+--- request
+    POST /t
+--- more_headers: Content-Length: 1024
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #1 to 'receiveuntil' (table expected, got number)
+
+
+
+=== TEST 3: send (bad arg number)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.socket.tcp()
+            sock.send("hello")
+        ';
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+expecting 2 arguments (including the object), but got 1
+
+
+
+=== TEST 4: send (bad self)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.socket.tcp()
+            sock.send("hello", 32)
+        ';
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #1 to 'send' (table expected, got string)
+
+
+
+=== TEST 5: getreusedtimes (bad self)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.socket.tcp()
+            sock.getreusedtimes(2)
+        ';
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #1 to 'getreusedtimes' (table expected, got number)
+
+
+
+=== TEST 6: close (bad self)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.socket.tcp()
+            sock.close(2)
+        ';
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #1 to 'close' (table expected, got number)
+
+
+
+=== TEST 7: setkeepalive (bad self)
+--- config
+    location /t {
+        content_by_lua '
+            local sock, err = ngx.socket.tcp()
+            sock.setkeepalive(2)
+        ';
+    }
+--- request
+    GET /t
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+bad argument #1 to 'setkeepalive' (table expected, got number)
+
diff -rNu a/src/lua/lua-nginx-module/t/084-inclusive-receiveuntil.t b/src/lua/lua-nginx-module/t/084-inclusive-receiveuntil.t
--- a/src/lua/lua-nginx-module/t/084-inclusive-receiveuntil.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/084-inclusive-receiveuntil.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,747 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+no_long_string();
+#no_diff();
+#log_level 'warn';
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: ambiguous boundary patterns (abcabd) - inclusive mode
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabd", { inclusive = true })
+
+            for i = 1, 3 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcabdabcabd;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabcabd
+read: abcabd
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: ambiguous boundary patterns (abcabdabcabe 4) - inclusive mode
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabdabcabe", { inclusive = true })
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo ababcabdabcabe;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: ababcabdabcabe
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: ambiguous boundary patterns (abcabd) - inclusive mode - small buffers
+--- config
+    server_tokens off;
+    lua_socket_buffer_size 1;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("abcabd", { inclusive = true })
+
+            for i = 1, 3 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcabdabcabd;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabcabd
+read: abcabd
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: inclusive option value nil
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aa", { inclusive = nil })
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcaad;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabc
+failed to read a line: closed [d
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: inclusive option value false
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aa", { inclusive = false })
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcaad;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabc
+failed to read a line: closed [d
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: inclusive option value true (aa)
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aa", { inclusive = true })
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcaad;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: abcabcaa
+failed to read a line: closed [d
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: bad inclusive option value type
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aa", { inclusive = "true" })
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcaad;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad "inclusive" option value type: string
+--- no_error_log
+[alert]
+[warn]
+
+
+
+=== TEST 8: bad option table
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("aa", { inclusive = "true" })
+
+            for i = 1, 2 do
+                line, err, part = reader()
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo abcabcaad;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- ignore_response
+--- error_log
+bad "inclusive" option value type: string
+--- no_error_log
+[alert]
+[warn]
+
+
+
+=== TEST 9: ambiguous boundary patterns (--abc), small buffer
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+        lua_socket_buffer_size 1;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("--abc", { inclusive = true })
+
+            for i = 1, 7 do
+                line, err, part = reader(4)
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a line: ", err, " [", part, "]")
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo "hello, world ----abc";
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: hell
+read: o, w
+read: orld
+read:  --
+read: --abc
+failed to read a line: nil [nil]
+failed to read a line: closed [
+]
+close: nil closed
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: ambiguous boundary patterns (--abc), small buffer, mixed by other reading calls
+--- config
+    server_tokens off;
+    location /t {
+        set $port $TEST_NGINX_SERVER_PORT;
+        lua_socket_buffer_size 1;
+
+        content_by_lua '
+            -- collectgarbage("collect")
+
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", bytes)
+
+            local read_headers = sock:receiveuntil("\\r\\n\\r\\n")
+            local headers, err, part = read_headers()
+            if not headers then
+                ngx.say("failed to read headers: ", err, " [", part, "]")
+            end
+
+            local reader = sock:receiveuntil("--abc", { inclusive = true })
+
+            for i = 1, 7 do
+                line, err, part = reader(4)
+                if line then
+                    ngx.say("read: ", line)
+
+                else
+                    ngx.say("failed to read a chunk: ", err, " [", part, "]")
+                end
+
+                local data, err, part = sock:receive(1)
+                if not data then
+                    ngx.say("failed to read a byte: ", err, " [", part, "]")
+                    break
+                else
+                    ngx.say("read one byte: ", data)
+                end
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo "hello, world ----abc";
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+qq{connected: 1
+request sent: 57
+read: hell
+read one byte: o
+read: , wo
+read one byte: r
+read: ld -
+read one byte: -
+read: --abc
+read one byte: 
+
+failed to read a chunk: nil [nil]
+failed to read a byte: closed []
+close: nil closed
+}
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/085-if.t b/src/lua/lua-nginx-module/t/085-if.t
--- a/src/lua/lua-nginx-module/t/085-if.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/085-if.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,202 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3 + 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: set_by_lua (if fails)
+--- config
+    location /t {
+        set $true $arg_a;
+        if ($true) {
+            set_by_lua $true 'return tonumber(ngx.var["true"]) + 1';
+            break;
+        }
+        set $true "empty";
+
+        echo "[$true]";
+    }
+--- request
+GET /t
+--- response_body
+[empty]
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: set_by_lua (if true)
+--- config
+    location /t {
+        set $true $arg_a;
+        if ($true) {
+            set_by_lua $true 'return tonumber(ngx.var["true"]) + 1';
+            break;
+        }
+        set $true "blah";
+
+        echo "[$true]";
+    }
+--- request
+GET /t?a=2
+--- response_body
+[3]
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: content_by_lua inherited by location if
+--- config
+    location /t {
+        set $true 1;
+        if ($true) {
+            # nothing
+        }
+
+        content_by_lua 'ngx.say("hello world")';
+    }
+--- request
+GET /t
+--- response_body
+hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: rewrite_by_lua inherited by location if
+--- config
+    location /t {
+        set $true 1;
+        if ($true) {
+            # nothing
+        }
+
+        rewrite_by_lua 'ngx.say("hello world") ngx.exit(200)';
+    }
+--- request
+GET /t
+--- response_body
+hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: access_by_lua inherited by location if
+--- config
+    location /t {
+        set $true 1;
+        if ($true) {
+            # nothing
+        }
+
+        access_by_lua 'ngx.say("hello world") ngx.exit(200)';
+    }
+--- request
+GET /t
+--- response_body
+hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: log_by_lua inherited by location if
+--- config
+    location /t {
+        set $true 1;
+        if ($true) {
+            # nothing
+        }
+
+        log_by_lua 'ngx.log(ngx.WARN, "from log by lua")';
+        echo hello world;
+    }
+--- request
+GET /t
+--- response_body
+hello world
+--- no_error_log
+[error]
+--- error_log
+from log by lua
+
+
+
+=== TEST 7: header_filter_by_lua inherited by location if
+--- config
+    location /t {
+        set $true 1;
+        if ($true) {
+            # nothing
+        }
+
+        header_filter_by_lua 'ngx.header.Foo = "bah"';
+        echo hello world;
+    }
+--- request
+GET /t
+--- response_body
+hello world
+--- response_headers
+Foo: bah
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: body_filter_by_lua inherited by location if
+--- config
+    location /t {
+        set $true 1;
+        if ($true) {
+            # nothing
+        }
+
+        body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';
+        echo hello world;
+    }
+--- request
+GET /t
+--- response_body
+HELLO WORLD
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: if is evil for ngx_proxy
+This test case requires the following patch for the nginx core:
+http://mailman.nginx.org/pipermail/nginx-devel/2012-June/002374.html
+--- config
+    location /proxy-pass-uri {
+        proxy_pass http://127.0.0.1:$TEST_NGINX_SERVER_PORT/;
+
+        set $true 1;
+
+        if ($true) {
+            # nothing
+        }
+    }
+--- request
+GET /proxy-pass-uri
+--- response_body_like: It works!
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/086-init-by.t b/src/lua/lua-nginx-module/t/086-init-by.t
--- a/src/lua/lua-nginx-module/t/086-init-by.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/086-init-by.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,276 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 2);
+
+#no_diff();
+#no_long_string();
+no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity (inline)
+--- http_config
+    init_by_lua 'foo = "hello, FOO"';
+--- config
+    location /lua {
+        content_by_lua 'ngx.say(foo)';
+    }
+--- request
+GET /lua
+--- response_body
+hello, FOO
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: sanity (file)
+--- http_config
+    init_by_lua_file html/init.lua;
+--- config
+    location /lua {
+        content_by_lua 'ngx.say(foo)';
+    }
+--- user_files
+>>> init.lua
+foo = "hello, FOO"
+--- request
+GET /lua
+--- response_body
+hello, FOO
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: require
+--- http_config
+    lua_package_path "$prefix/html/?.lua;;";
+    init_by_lua 'require "blah"';
+--- config
+    location /lua {
+        content_by_lua '
+            blah.go()
+        ';
+    }
+--- user_files
+>>> blah.lua
+module(..., package.seeall)
+
+function go()
+    ngx.say("hello, blah")
+end
+--- request
+GET /lua
+--- response_body
+hello, blah
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: shdict (single)
+--- http_config
+    lua_shared_dict dogs 1m;
+    init_by_lua '
+        local dogs = ngx.shared.dogs
+        dogs:set("Jim", 6)
+        dogs:get("Jim")
+    ';
+--- config
+    location /lua {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            ngx.say("Jim: ", dogs:get("Jim"))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Jim: 6
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: shdict (multi)
+--- http_config
+    lua_shared_dict dogs 1m;
+    lua_shared_dict cats 1m;
+    init_by_lua '
+        local dogs = ngx.shared.dogs
+        dogs:set("Jim", 6)
+        dogs:get("Jim")
+        local cats = ngx.shared.cats
+        cats:set("Tom", 2)
+        dogs:get("Tom")
+    ';
+--- config
+    location /lua {
+        content_by_lua '
+            local dogs = ngx.shared.dogs
+            ngx.say("Jim: ", dogs:get("Jim"))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+Jim: 6
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: print
+--- http_config
+    lua_shared_dict dogs 1m;
+    lua_shared_dict cats 1m;
+    init_by_lua '
+        print("log from init_by_lua")
+    ';
+--- config
+    location /lua {
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+log from init_by_lua
+
+
+
+=== TEST 7: ngx.log
+--- http_config
+    lua_shared_dict dogs 1m;
+    lua_shared_dict cats 1m;
+    init_by_lua '
+        ngx.log(ngx.NOTICE, "log from init_by_lua")
+    ';
+--- config
+    location /lua {
+        echo ok;
+    }
+--- request
+GET /lua
+--- response_body
+ok
+--- error_log
+log from init_by_lua
+
+
+
+=== TEST 8: require (with shm defined)
+--- http_config
+    lua_package_path "$prefix/html/?.lua;;";
+    lua_shared_dict dogs 1m;
+    init_by_lua 'require "blah"';
+--- config
+    location /lua {
+        content_by_lua '
+            blah.go()
+        ';
+    }
+--- user_files
+>>> blah.lua
+module(..., package.seeall)
+
+function go()
+    ngx.say("hello, blah")
+end
+--- request
+GET /lua
+--- response_body
+hello, blah
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: coroutine API (inlined init_by_lua)
+--- http_config
+    init_by_lua '
+        local function f()
+            foo = 32
+            coroutine.yield(78)
+            bar = coroutine.status(coroutine.running())
+        end
+        local co = coroutine.create(f)
+        local ok, err = coroutine.resume(co)
+        if not ok then
+            print("Failed to resume our co: ", err)
+            return
+        end
+        baz = err
+        coroutine.resume(co)
+    ';
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("foo = ", foo)
+            ngx.say("bar = ", bar)
+            ngx.say("baz = ", baz)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+foo = 32
+bar = running
+baz = 78
+--- no_error_log
+[error]
+Failed to resume our co: 
+
+
+
+=== TEST 10: coroutine API (init_by_lua_file)
+--- http_config
+    init_by_lua_file html/init.lua;
+
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("foo = ", foo)
+            ngx.say("bar = ", bar)
+            ngx.say("baz = ", baz)
+        ';
+    }
+--- request
+GET /lua
+--- user_files
+>>> init.lua
+local function f()
+    foo = 32
+    coroutine.yield(78)
+    bar = coroutine.status(coroutine.running())
+end
+local co = coroutine.create(f)
+local ok, err = coroutine.resume(co)
+if not ok then
+    print("Failed to resume our co: ", err)
+    return
+end
+baz = err
+coroutine.resume(co)
+
+--- response_body
+foo = 32
+bar = running
+baz = 78
+--- no_error_log
+[error]
+Failed to resume our co: 
+
diff -rNu a/src/lua/lua-nginx-module/t/087-udp-socket.t b/src/lua/lua-nginx-module/t/087-udp-socket.t
--- a/src/lua/lua-nginx-module/t/087-udp-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/087-udp-socket.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,808 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (3 * blocks() + 8);
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+log_level 'warn';
+
+no_long_string();
+#no_diff();
+#no_shuffle();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            local port = ngx.var.port
+            udp:settimeout(1000) -- 1 sec
+
+            local ok, err = udp:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected")
+
+            local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("received ", #data, " bytes: ", data)
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+"connected\nreceived 12 bytes: \x{00}\x{01}\x{00}\x{00}\x{00}\x{01}\x{00}\x{00}OK\x{0d}\x{0a}"
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua udp socket receive buffer size: 8192
+
+
+
+=== TEST 2: multiple parallel queries
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            local port = ngx.var.port
+            udp:settimeout(1000) -- 1 sec
+
+            local ok, err = udp:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected")
+
+            local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            req = "\\0\\2\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+            ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            ngx.sleep(0.05)
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("1: received ", #data, " bytes: ", data)
+
+            data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("2: received ", #data, " bytes: ", data)
+        ';
+    }
+--- request
+GET /t
+--- response_body_like eval
+"^connected\n"
+."1: received 12 bytes: "
+."\x{00}[\1\2]\x{00}\x{00}\x{00}\x{01}\x{00}\x{00}OK\x{0d}\x{0a}"
+."2: received 12 bytes: "
+."\x{00}[\1\2]\x{00}\x{00}\x{00}\x{01}\x{00}\x{00}OK\x{0d}\x{0a}\$"
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: access a TCP interface
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            local port = ngx.var.port
+            udp:settimeout(1000) -- 1 sec
+
+            local ok, err = udp:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected")
+
+            local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("received ", #data, " bytes: ", data)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+connected
+failed to receive data: connection refused
+--- error_log eval
+qr/recv\(\) failed \(\d+: Connection refused\)/
+
+
+
+=== TEST 4: access conflicts of connect() on shared udp objects
+--- http_config
+    lua_package_path '$prefix/html/?.lua;;';
+--- config
+    server_tokens off;
+    location /main {
+        content_by_lua '
+            local reqs = {}
+            for i = 1, 170 do
+                table.insert(reqs, {"/t"})
+            end
+            local resps = {ngx.location.capture_multi(reqs)}
+            for i = 1, 170 do
+                ngx.say(resps[i].status)
+            end
+        ';
+    }
+
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local port = ngx.var.port
+            local foo = require "foo"
+            local udp = foo.get_udp()
+
+            udp:settimeout(100) -- 100 ms
+
+            local ok, err = udp:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to connect: ", err)
+                return ngx.exit(500)
+            end
+
+            ngx.say("connected")
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("received ", #data, " bytes: ", data)
+        ';
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+local udp
+
+function get_udp()
+    if not udp then
+        udp = ngx.socket.udp()
+    end
+
+    return udp
+end
+
+--- stap2
+M(http-lua-info) {
+    printf("udp resume: %p\n", $coctx)
+    print_ubacktrace()
+}
+
+--- request
+GET /main
+--- response_body_like: \b500\b
+--- error_log
+failed to connect: socket busy
+
+
+
+=== TEST 5: access conflicts of receive() on shared udp objects
+--- http_config
+    lua_package_path '$prefix/html/?.lua;;';
+--- config
+    server_tokens off;
+    location /main {
+        content_by_lua '
+            local reqs = {}
+            for i = 1, 170 do
+                table.insert(reqs, {"/t"})
+            end
+            local resps = {ngx.location.capture_multi(reqs)}
+            for i = 1, 170 do
+                ngx.say(resps[i].status)
+            end
+        ';
+    }
+
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local port = ngx.var.port
+            local foo = require "foo"
+            local udp = foo.get_udp(port)
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.log(ngx.ERR, "failed to receive data: ", err)
+                return ngx.exit(500)
+            end
+            ngx.print("received ", #data, " bytes: ", data)
+        ';
+    }
+--- user_files
+>>> foo.lua
+module("foo", package.seeall)
+
+local udp
+
+function get_udp(port)
+    if not udp then
+        udp = ngx.socket.udp()
+
+        udp:settimeout(100) -- 100ms
+
+        local ok, err = udp:setpeername("127.0.0.1", port)
+        if not ok then
+            ngx.log(ngx.ERR, "failed to connect: ", err)
+            return ngx.exit(500)
+        end
+    end
+
+    return udp
+end
+--- request
+GET /main
+--- response_body_like: \b500\b
+--- error_log
+failed to receive data: socket busy
+
+
+
+=== TEST 6: connect again immediately
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.udp()
+            local port = ngx.var.port
+
+            local ok, err = sock:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            ok, err = sock:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected again: ", ok)
+
+            local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+            local ok, err = sock:send(req)
+            if not ok then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+            ngx.say("request sent: ", ok)
+
+            local line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            ok, err = sock:close()
+            ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body eval
+"connected: 1
+connected again: 1
+request sent: 1
+received: \0\1\0\0\0\1\0\0OK\r\n
+close: 1 nil
+"
+--- no_error_log
+[error]
+--- error_log eval
+["lua reuse socket upstream", "lua udp socket reconnect without shutting down"]
+--- log_level: debug
+
+
+
+=== TEST 7: recv timeout
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+
+        content_by_lua '
+            local port = ngx.var.port
+
+            local sock = ngx.socket.udp()
+            sock:settimeout(100) -- 100 ms
+
+            local ok, err = sock:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected: ", ok)
+
+            local line, err = sock:receive()
+            if line then
+                ngx.say("received: ", line)
+
+            else
+                ngx.say("failed to receive: ", err)
+            end
+
+            -- ok, err = sock:close()
+            -- ngx.say("close: ", ok, " ", err)
+        ';
+    }
+
+    location /foo {
+        echo foo;
+        more_clear_headers Date;
+    }
+--- request
+GET /t
+--- response_body
+connected: 1
+failed to receive: timeout
+--- error_log
+lua udp socket read timed out
+
+
+
+=== TEST 8: with an explicit receive buffer size argument
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            local port = ngx.var.port
+            udp:settimeout(1000) -- 1 sec
+
+            local ok, err = udp:setpeername("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected")
+
+            local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local data, err = udp:receive(1400)
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("received ", #data, " bytes: ", data)
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+"connected\nreceived 12 bytes: \x{00}\x{01}\x{00}\x{00}\x{00}\x{01}\x{00}\x{00}OK\x{0d}\x{0a}"
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua udp socket receive buffer size: 1400
+
+
+
+=== TEST 9: read timeout and re-receive
+--- config
+    location = /t {
+        content_by_lua '
+            local udp = ngx.socket.udp()
+            udp:settimeout(30)
+            local ok, err = udp:setpeername("127.0.0.1", 19232)
+            if not ok then
+                ngx.say("failed to setpeername: ", err)
+                return
+            end
+            local ok, err = udp:send("blah")
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+            for i = 1, 2 do
+                local data, err = udp:receive()
+                if err == "timeout" then
+                    -- continue
+                else
+                    if not data then
+                        ngx.say("failed to receive: ", err)
+                        return
+                    end
+                    ngx.say("received: ", data)
+                    return
+                end
+            end
+
+            ngx.say("timed out")
+        ';
+    }
+--- udp_listen: 19232
+--- udp_reply: hello world
+--- udp_reply_delay: 45ms
+--- request
+GET /t
+--- response_body
+received: hello world
+--- error_log
+lua udp socket read timed out
+
+
+
+=== TEST 10: access the google DNS server (using IP addr)
+--- config
+    server_tokens off;
+    location /t {
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            udp:settimeout(2000) -- 2 sec
+
+            local ok, err = udp:setpeername("8.8.8.8", 53)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local req = "\\0}\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\1\\0\\1"
+
+            -- ngx.print(req)
+            -- do return end
+
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+
+            if string.match(data, "\\3www\\6google\\3com") then
+                ngx.say("received a good response.")
+            else
+                ngx.say("received a bad response: ", #data, " bytes: ", data)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+received a good response.
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua udp socket receive buffer size: 8192
+
+
+
+=== TEST 11: access the google DNS server (using domain names)
+--- config
+    server_tokens off;
+    resolver $TEST_NGINX_RESOLVER;
+    location /t {
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            udp:settimeout(2000) -- 2 sec
+
+            local ok, err = udp:setpeername("google-public-dns-a.google.com", 53)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local req = "\\0}\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\1\\0\\1"
+
+            -- ngx.print(req)
+            -- do return end
+
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+
+            if string.match(data, "\\3www\\6google\\3com") then
+                ngx.say("received a good response.")
+            else
+                ngx.say("received a bad response: ", #data, " bytes: ", data)
+            end
+        ';
+    }
+--- request
+GET /t
+--- response_body
+received a good response.
+--- no_error_log
+[error]
+--- log_level: debug
+--- error_log
+lua udp socket receive buffer size: 8192
+
+
+
+=== TEST 12: github issue #215: Handle the posted requests in lua cosocket api (failed to resolve)
+--- config
+    resolver 8.8.8.8;
+
+    location = /sub {
+        content_by_lua '
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("xxx", 80)
+            if not ok then
+                ngx.say("failed to connect to xxx: ", err)
+                return
+            end
+            ngx.say("successfully connected to xxx!")
+            sock:close()
+        ';
+    }
+
+    location = /lua {
+        content_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /sub
+
+--- stap
+F(ngx_resolve_name_done) {
+    println("resolve name done")
+}
+
+--- stap_out
+resolve name done
+
+--- response_body_like chop
+^failed to connect to xxx: xxx could not be resolved.*?Host not found
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: github issue #215: Handle the posted requests in lua cosocket api (successfully resolved)
+--- config
+    resolver 8.8.8.8;
+    resolver_timeout 3s;
+
+    location = /sub {
+        content_by_lua '
+            if not package.i then
+                package.i = 1
+            end
+
+            local servers = {"openresty.org", "agentzh.org", "sregex.org"}
+            local server = servers[package.i]
+            package.i = package.i + 1
+
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername(server, 80)
+            if not ok then
+                ngx.say("failed to connect to agentzh.org: ", err)
+                return
+            end
+            ngx.say("successfully connected to xxx!")
+            sock:close()
+        ';
+    }
+
+    location = /lua {
+        content_by_lua '
+            local res = ngx.location.capture("/sub")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+successfully connected to xxx!
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 14: datagram unix domain socket
+--- config
+    server_tokens off;
+    location /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_MEMCACHED_PORT;
+        #set $port 1234;
+
+        content_by_lua '
+            local socket = ngx.socket
+            -- local socket = require "socket"
+
+            local udp = socket.udp()
+
+            local port = ngx.var.port
+            udp:settimeout(1000) -- 1 sec
+
+            local ok, err = udp:setpeername("unix:a.sock")
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            ngx.say("connected")
+
+            local req = "hello,\\nserver"
+            local ok, err = udp:send(req)
+            if not ok then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local data, err = udp:receive()
+            if not data then
+                ngx.say("failed to receive data: ", err)
+                return
+            end
+            ngx.print("received ", #data, " bytes: ", data)
+        ';
+    }
+--- request
+GET /t
+
+--- udp_listen: a.sock
+--- udp_reply
+hello,
+client
+
+--- response_body
+connected
+received 14 bytes: hello,
+client
+
+--- stap2
+probe syscall.socket, syscall.connect {
+    print(name, "(", argstr, ")")
+}
+
+probe syscall.socket.return, syscall.connect.return {
+    println(" = ", retstr)
+}
+--- no_error_log
+[error]
+[crit]
+--- skip_eval: 3: $^O ne 'linux'
+
diff -rNu a/src/lua/lua-nginx-module/t/088-req-method.t b/src/lua/lua-nginx-module/t/088-req-method.t
--- a/src/lua/lua-nginx-module/t/088-req-method.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/088-req-method.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,266 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: get method name in main request
+--- config
+    location /t {
+        content_by_lua '
+            ngx.say("method: [", ngx.req.get_method(), "]")
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+method: [GET]
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: get method name in subrequest
+--- config
+    location /t {
+        echo_subrequest POST /sub;
+    }
+
+    location /sub {
+        content_by_lua '
+            ngx.say("method: [", ngx.req.get_method(), "]")
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+method: [POST]
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: set GET to POST
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_POST)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location /echo {
+        echo $request_method;
+    }
+--- request
+GET /t
+--- response_body
+POST
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: set POST to GET
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_GET)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location /echo {
+        echo $request_method;
+    }
+--- request
+POST /t
+hello world
+--- response_body
+GET
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: set POST to DELETE
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_DELETE)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location /echo {
+        echo $request_method;
+    }
+--- request
+POST /t
+hello world
+--- response_body
+DELETE
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: set POST to PUT
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_PUT)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+    }
+
+    location /echo {
+        echo $request_method;
+    }
+--- request
+POST /t
+hello world
+--- response_body
+PUT
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: set POST to PUT (using $requeset_method)
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_PUT)
+        ';
+
+        echo $request_method;
+    }
+--- request
+POST /t
+hello world
+--- response_body
+PUT
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: set GET to HEAD
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_HEAD)
+        ';
+
+        proxy_pass http://127.0.0.1:$server_port/echo;
+        #proxy_pass http://127.0.0.1:8888/;
+    }
+
+    location /echo {
+        echo $request_method;
+    }
+--- request
+GET /t
+--- response_body
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: set method name in subrequest
+--- config
+    location /t {
+        echo_subrequest POST /sub;
+        echo "main: $echo_request_method";
+    }
+
+    location /sub {
+        content_by_lua '
+            ngx.req.set_method(ngx.HTTP_PUT)
+            ngx.say("sub: ", ngx.var.echo_request_method)
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+sub: PUT
+main: GET
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: set HEAD to GET
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_method(ngx.HTTP_GET)
+        ';
+
+        echo "method: $echo_request_method";
+    }
+--- request
+    HEAD /t
+--- response_body
+method: GET
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: set GET to WebDAV methods
+--- config
+    location /t {
+        content_by_lua '
+            local methods = {
+                ngx.HTTP_MKCOL,
+                ngx.HTTP_COPY,
+                ngx.HTTP_MOVE,
+                ngx.HTTP_PROPFIND,
+                ngx.HTTP_PROPPATCH,
+                ngx.HTTP_LOCK,
+                ngx.HTTP_UNLOCK,
+                ngx.HTTP_PATCH,
+                ngx.HTTP_TRACE,
+            }
+
+            for i, method in ipairs(methods) do
+                ngx.req.set_method(method)
+                ngx.say("method: ", ngx.var.echo_request_method)
+            end
+        ';
+    }
+--- request
+    HEAD /t
+--- response_body
+method: MKCOL
+method: COPY
+method: MOVE
+method: PROPFIND
+method: PROPPATCH
+method: LOCK
+method: UNLOCK
+method: PATCH
+method: TRACE
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/089-phase.t b/src/lua/lua-nginx-module/t/089-phase.t
--- a/src/lua/lua-nginx-module/t/089-phase.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/089-phase.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,162 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 2);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: get_phase in init_by_lua
+--- http_config
+    init_by_lua 'phase = ngx.get_phase()';
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(phase)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+init
+
+
+
+=== TEST 2: get_phase in set_by_lua
+--- config
+    set_by_lua $phase 'return ngx.get_phase()';
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.var.phase)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+set
+
+
+
+=== TEST 3: get_phase in rewrite_by_lua
+--- config
+    location /lua {
+        rewrite_by_lua '
+            ngx.say(ngx.get_phase())
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+rewrite
+
+
+
+=== TEST 4: get_phase in access_by_lua
+--- config
+    location /lua {
+        access_by_lua '
+            ngx.say(ngx.get_phase())
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+access
+
+
+
+=== TEST 5: get_phase in content_by_lua
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say(ngx.get_phase())
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+content
+
+
+
+=== TEST 6: get_phase in header_filter_by_lua
+--- config
+    location /lua {
+        echo "OK";
+        header_filter_by_lua '
+            ngx.header.Phase = ngx.get_phase()
+        ';
+    }
+--- request
+GET /lua
+--- response_header
+Phase: header_filter
+
+
+
+=== TEST 7: get_phase in body_filter_by_lua
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.exit(200)
+        ';
+        body_filter_by_lua '
+            ngx.arg[1] = ngx.get_phase()
+        ';
+    }
+--- request
+GET /lua
+--- response_body chop
+body_filter
+
+
+
+=== TEST 8: get_phase in log_by_lua
+--- config
+    location /lua {
+        echo "OK";
+        log_by_lua '
+            ngx.log(ngx.ERR, ngx.get_phase())
+        ';
+    }
+--- request
+GET /lua
+--- error_log
+log
+
+
+
+=== TEST 9: get_phase in ngx.timer callback
+--- config
+    location /lua {
+        echo "OK";
+        log_by_lua '
+            local function f()
+                ngx.log(ngx.WARN, "current phase: ", ngx.get_phase())
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to add timer: ", err)
+            end
+        ';
+    }
+--- request
+GET /lua
+--- no_error_log
+[error]
+--- error_log
+current phase: timer
+
diff -rNu a/src/lua/lua-nginx-module/t/090-log-socket-errors.t b/src/lua/lua-nginx-module/t/090-log-socket-errors.t
--- a/src/lua/lua-nginx-module/t/090-log-socket-errors.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/090-log-socket-errors.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,100 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: log socket errors off (tcp)
+--- config
+    location /t {
+        lua_socket_connect_timeout 1ms;
+        lua_socket_log_errors off;
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("8.8.8.8", 80)
+            ngx.say(err)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+timeout
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: log socket errors on (tcp)
+--- config
+    location /t {
+        lua_socket_connect_timeout 1ms;
+        lua_socket_log_errors on;
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("8.8.8.8", 80)
+            ngx.say(err)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+timeout
+--- error_log
+lua tcp socket connect timed out
+
+
+
+=== TEST 3: log socket errors on (udp)
+--- config
+    location /t {
+        lua_socket_log_errors on;
+        lua_socket_read_timeout 1ms;
+        content_by_lua '
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("8.8.8.8", 80)
+            ok, err = sock:receive()
+            ngx.say(err)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+timeout
+--- error_log
+lua udp socket read timed out
+
+
+
+=== TEST 4: log socket errors off (udp)
+--- config
+    location /t {
+        lua_socket_log_errors off;
+        lua_socket_read_timeout 1ms;
+        content_by_lua '
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("8.8.8.8", 80)
+            ok, err = sock:receive()
+            ngx.say(err)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+timeout
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/091-coroutine.t b/src/lua/lua-nginx-module/t/091-coroutine.t
--- a/src/lua/lua-nginx-module/t/091-coroutine.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/091-coroutine.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1093 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 3);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+our $StapScript = <<'_EOC_';
+global ids, cur
+
+function gen_id(k) {
+    if (ids[k]) return ids[k]
+    ids[k] = ++cur
+    return cur
+}
+
+F(ngx_http_handler) {
+    delete ids
+    cur = 0
+}
+
+/*
+F(ngx_http_lua_run_thread) {
+    id = gen_id($ctx->cur_co)
+    printf("run thread %d\n", id)
+}
+
+probe process("/usr/local/openresty-debug/luajit/lib/libluajit-5.1.so.2").function("lua_resume") {
+    id = gen_id($L)
+    printf("lua resume %d\n", id)
+}
+*/
+
+M(http-lua-user-coroutine-resume) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("resume %x in %x\n", c, p)
+}
+
+M(http-lua-thread-yield) {
+    println("thread yield")
+}
+
+/*
+F(ngx_http_lua_coroutine_yield) {
+    printf("yield %x\n", gen_id($L))
+}
+*/
+
+M(http-lua-user-coroutine-yield) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("yield %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_atpanic) {
+    printf("lua atpanic(%d):", gen_id($L))
+    print_ubacktrace();
+}
+
+M(http-lua-user-coroutine-create) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("create %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_ngx_exec) { println("exec") }
+
+F(ngx_http_lua_ngx_exit) { println("exit") }
+_EOC_
+
+no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: basic coroutine print
+--- config
+    location /lua {
+        content_by_lua '
+            local cc, cr, cy = coroutine.create, coroutine.resume, coroutine.yield
+
+            function f()
+                local cnt = 0
+                for i = 1, 20 do
+                    ngx.say("Hello, ", cnt)
+                    cy()
+                    cnt = cnt + 1
+                end
+            end
+
+            local c = cc(f)
+            for i=1,3 do
+                cr(c)
+                ngx.say("***")
+            end
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- response_body
+Hello, 0
+***
+Hello, 1
+***
+Hello, 2
+***
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: basic coroutine2
+--- config
+    location /lua {
+        content_by_lua '
+            function f(fid)
+                local cnt = 0
+                while true do
+                    ngx.say("cc", fid, ": ", cnt)
+                    coroutine.yield()
+                    cnt = cnt + 1
+                end
+            end
+
+            local ccs = {}
+            for i=1,3 do
+                ccs[#ccs+1] = coroutine.create(function() f(i) end)
+            end
+
+            for i=1,9 do
+                local cc = table.remove(ccs, 1)
+                coroutine.resume(cc)
+                ccs[#ccs+1] = cc
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+cc1: 0
+cc2: 0
+cc3: 0
+cc1: 1
+cc2: 1
+cc3: 1
+cc1: 2
+cc2: 2
+cc3: 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: basic coroutine and cosocket
+--- config
+    resolver $TEST_NGINX_RESOLVER;
+    location /lua {
+        content_by_lua '
+            function worker(url)
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect(url, 80)
+                coroutine.yield()
+                if not ok then
+                    ngx.say("failed to connect to: ", url, " error: ", err)
+                    return
+                end
+                coroutine.yield()
+                ngx.say("successfully connected to: ", url)
+                sock:close()
+            end
+
+            local urls = {
+                "agentzh.org",
+                "agentzh.com",
+                "openresty.org"
+            }
+
+            local ccs = {}
+            for i, url in ipairs(urls) do
+                local cc = coroutine.create(function() worker(url) end)
+                ccs[#ccs+1] = cc
+            end
+
+            while true do
+                if #ccs == 0 then break end
+                local cc = table.remove(ccs, 1)
+                local ok = coroutine.resume(cc)
+                if ok then
+                    ccs[#ccs+1] = cc
+                end
+            end
+
+            ngx.say("*** All Done ***")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+successfully connected to: agentzh.org
+successfully connected to: agentzh.com
+successfully connected to: openresty.org
+*** All Done ***
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 4: coroutine.wrap(generate prime numbers)
+--- config
+    location /lua {
+        content_by_lua '
+            -- generate all the numbers from 2 to n
+            function gen (n)
+              return coroutine.wrap(function ()
+                for i=2,n do coroutine.yield(i) end
+              end)
+            end
+
+            -- filter the numbers generated by g, removing multiples of p
+            function filter (p, g)
+              return coroutine.wrap(function ()
+                while 1 do
+                  local n = g()
+                  if n == nil then return end
+                  if math.fmod(n, p) ~= 0 then coroutine.yield(n) end
+                end
+              end)
+            end
+
+            N = 10
+            x = gen(N)		-- generate primes up to N
+            while 1 do
+              local n = x()		-- pick a number until done
+              if n == nil then break end
+              ngx.say(n)		-- must be a prime number
+              x = filter(n, x)	-- now remove its multiples
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+2
+3
+5
+7
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: coroutine.wrap(generate prime numbers,reset create and resume)
+--- config
+    location /lua {
+        content_by_lua '
+            coroutine.create = nil
+            coroutine.resume = nil
+            -- generate all the numbers from 2 to n
+            function gen (n)
+              return coroutine.wrap(function ()
+                for i=2,n do coroutine.yield(i) end
+              end)
+            end
+
+            -- filter the numbers generated by g, removing multiples of p
+            function filter (p, g)
+              return coroutine.wrap(function ()
+                while 1 do
+                  local n = g()
+                  if n == nil then return end
+                  if math.fmod(n, p) ~= 0 then coroutine.yield(n) end
+                end
+              end)
+            end
+
+            N = 10 
+            x = gen(N)		-- generate primes up to N
+            while 1 do
+              local n = x()		-- pick a number until done
+              if n == nil then break end
+              ngx.say(n)		-- must be a prime number
+              x = filter(n, x)	-- now remove its multiples
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+2
+3
+5
+7
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: coroutine.wrap(generate fib)
+--- config
+    location /lua {
+        content_by_lua '
+            function generatefib (n)
+              return coroutine.wrap(function ()
+                local a,b = 1, 1
+                while a <= n do
+                  coroutine.yield(a)
+                  a, b = b, a+b
+                end
+              end)
+            end
+
+            -- In lua, because OP_TFORLOOP uses luaD_call to execute the iterator function,
+            -- and luaD_call is a C function, so we can not yield in the iterator function.
+            -- So the following case(using for loop) will be failed.
+            -- Luajit is OK.
+            if package.loaded["jit"] then
+                for i in generatefib(1000) do ngx.say(i) end
+            else
+                local gen = generatefib(1000)
+                while true do
+                    local i = gen()
+                    if not i then break end
+                    ngx.say(i)
+                end
+            end
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+1
+1
+2
+3
+5
+8
+13
+21
+34
+55
+89
+144
+233
+377
+610
+987
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: coroutine wrap and cosocket
+--- config
+    resolver $TEST_NGINX_RESOLVER;
+    location /lua {
+        content_by_lua '
+            function worker(url)
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect(url, 80)
+                coroutine.yield()
+                if not ok then
+                    ngx.say("failed to connect to: ", url, " error: ", err)
+                    return
+                end
+                coroutine.yield()
+                ngx.say("successfully connected to: ", url)
+                sock:close()
+            end
+
+            local urls = {
+                "agentzh.org",
+                "agentzh.com",
+                "openresty.org"
+            }
+
+            local cfs = {}
+            for i, url in ipairs(urls) do
+                local cf = coroutine.wrap(function() worker(url) end)
+                cfs[#cfs+1] = cf
+            end
+
+            for i=1,3 do cfs[i]() end
+            for i=1,3 do cfs[i]() end
+            for i=1,3 do cfs[i]() end
+
+            ngx.say("*** All Done ***")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+successfully connected to: agentzh.org
+successfully connected to: agentzh.com
+successfully connected to: openresty.org
+*** All Done ***
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 8: coroutine status, running
+--- config
+    location /lua {
+        content_by_lua '
+            local cc, cr, cy = coroutine.create, coroutine.resume, coroutine.yield
+            local st, rn = coroutine.status, coroutine.running
+
+            function f(self)
+                local cnt = 0
+                if rn() ~= self then ngx.say("error"); return end
+                ngx.say("running: ", st(self)) --running
+                cy()
+                local c = cc(function(father)
+                    ngx.say("normal: ", st(father))
+                end) -- normal
+                cr(c, self)
+            end
+
+            local c = cc(f)
+            ngx.say("suspended: ", st(c)) -- suspended
+            cr(c, c)
+            ngx.say("suspended: ", st(c)) -- suspended
+            cr(c, c)
+            ngx.say("dead: ", st(c)) -- dead
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+suspended: suspended
+running: running
+suspended: suspended
+normal: normal
+dead: dead
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: entry coroutine yielded will be resumed immediately
+--- config
+    location /lua {
+        content_by_lua '
+            ngx.say("[", {coroutine.yield()}, "]")
+            ngx.say("[", {coroutine.yield(1, "a")}, "]")
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+[]
+[]
+done
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: thread traceback (multi-thread)
+--- config
+    location /lua {
+        content_by_lua '
+            local f = function(cr) coroutine.resume(cr) end
+            -- emit a error
+            local g = function() unknown.unknown = 1 end
+            local l1 = coroutine.create(f)
+            local l2 = coroutine.create(g)
+            coroutine.resume(l1, l2)
+            ngx.say("hello")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+hello
+--- error_log eval
+["stack traceback:", "coroutine 0:", "coroutine 1:", "coroutine 2:"]
+
+
+
+=== TEST 11: thread traceback (only the entry thread)
+--- config
+    location /lua {
+        content_by_lua '
+            -- emit a error
+            unknown.unknown = 1
+            ngx.say("hello")
+        ';
+    }
+--- request
+GET /lua
+--- error_code: 500
+--- error_log eval
+["stack traceback:", "coroutine 0:"]
+
+
+
+=== TEST 12: bug: resume dead coroutine with args
+--- config
+    location /lua {
+        content_by_lua '
+            function print(...)
+                local args = {...}
+                local is_first = true
+                for i,v in ipairs(args) do
+                    if is_first then
+                        is_first = false
+                    else
+                        ngx.print(" ")
+                    end
+                    ngx.print(v)
+                end
+                ngx.print("\\\n")
+            end
+
+            function foo (a)
+                print("foo", a)
+                return coroutine.yield(2*a)
+            end
+
+            co = coroutine.create(function (a,b)
+                    print("co-body", a, b)
+                    local r = foo(a+1)
+                    print("co-body", r)
+                    local r, s = coroutine.yield(a+b, a-b)
+                    print("co-body", r, s)
+                    return b, "end"
+                end)
+
+            print("main", coroutine.resume(co, 1, 10))
+            print("main", coroutine.resume(co, "r"))
+            print("main", coroutine.resume(co, "x", "y"))
+            print("main", coroutine.resume(co, "x", "y"))
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+co-body 1 10
+foo 2
+main true 4
+co-body r
+main true 11 -9
+co-body x y
+main true 10 end
+main false cannot resume dead coroutine
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: deeply nested coroutines
+--- config
+    location /lua {
+        content_by_lua '
+            local create = coroutine.create
+            local resume = coroutine.resume
+            local yield = coroutine.yield
+            function f()
+                ngx.say("f begin")
+                yield()
+                local c2 = create(g)
+                ngx.say("1: resuming c2")
+                resume(c2)
+                ngx.say("2: resuming c2")
+                resume(c2)
+                yield()
+                ngx.say("3: resuming c2")
+                resume(c2)
+                ngx.say("f done")
+            end
+
+            function g()
+                ngx.say("g begin")
+                yield()
+                ngx.say("g going")
+                yield()
+                ngx.say("g done")
+            end
+
+            local c1 = create(f)
+            ngx.say("1: resuming c1")
+            resume(c1)
+            ngx.say("2: resuming c1")
+            resume(c1)
+            ngx.say("3: resuming c1")
+            resume(c1)
+            ngx.say("main done")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+1: resuming c1
+f begin
+2: resuming c1
+1: resuming c2
+g begin
+2: resuming c2
+g going
+3: resuming c1
+3: resuming c2
+g done
+f done
+main done
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: using ngx.exit in user coroutines
+--- config
+    location /lua {
+        content_by_lua '
+            local create = coroutine.create
+            local resume = coroutine.resume
+            local yield = coroutine.yield
+
+            local code = 400
+
+            function f()
+                local c2 = create(g)
+                yield()
+                code = code + 1
+                resume(c2)
+                yield()
+                resume(c2)
+            end
+
+            function g()
+                code = code + 1
+                yield()
+                code = code + 1
+                ngx.exit(code)
+            end
+
+            local c1 = create(f)
+            resume(c1)
+            resume(c1)
+            resume(c1)
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua
+--- stap eval: $::StapScript
+--- stap_out
+create 2 in 1
+resume 2 in 1
+create 3 in 2
+yield 2 in 1
+resume 2 in 1
+resume 3 in 2
+yield 3 in 2
+yield 2 in 1
+resume 2 in 1
+resume 3 in 2
+exit
+
+--- response_body_like: 403 Forbidden
+--- error_code: 403
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: using ngx.exec in user coroutines
+--- config
+    location /lua {
+        content_by_lua '
+            local create = coroutine.create
+            local resume = coroutine.resume
+            local yield = coroutine.yield
+
+            local code = 0
+
+            function f()
+                local c2 = create(g)
+                yield()
+                code = code + 1
+                resume(c2)
+                yield()
+                resume(c2)
+            end
+
+            function g()
+                code = code + 1
+                yield()
+                code = code + 1
+                ngx.exec("/n/" .. code)
+            end
+
+            local c1 = create(f)
+            resume(c1)
+            resume(c1)
+            resume(c1)
+            ngx.say("done")
+        ';
+    }
+
+    location ~ '^/n/(\d+)' {
+        echo "num: $1";
+    }
+
+--- stap eval: $::StapScript
+--- stap_out
+create 2 in 1
+resume 2 in 1
+create 3 in 2
+yield 2 in 1
+resume 2 in 1
+resume 3 in 2
+yield 3 in 2
+yield 2 in 1
+resume 2 in 1
+resume 3 in 2
+exec
+
+--- request
+GET /lua
+--- response_body
+num: 3
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: coroutine.create in header_filter_by_lua
+--- config
+    location /lua {
+        echo hello;
+        header_filter_by_lua '
+            function f()
+                yield()
+            end
+
+            local c1 = coroutine.create(f)
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua
+--- ignore_response
+--- error_log
+API disabled in the context of header_filter_by_lua*
+
+
+
+=== TEST 17: resume coroutines from within another one that is not its parent
+--- config
+    location /t {
+        content_by_lua '
+            local print = ngx.say
+
+            local c1, c2
+
+            function f()
+                print("f 1")
+                print(coroutine.resume(c2))
+                print("f 2")
+            end
+
+            function g()
+                print("g 1")
+                -- print(coroutine.resume(c1))
+                print("g 2")
+            end
+
+            c1 = coroutine.create(f)
+            c2 = coroutine.create(g)
+
+            coroutine.resume(c1)
+        ';
+    }
+--- request
+GET /t
+--- response_body
+f 1
+g 1
+g 2
+true
+f 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: infinite recursive calls of coroutine.resume
+--- config
+    location /t {
+        content_by_lua '
+            local print = ngx.say
+
+            local c1, c2
+
+            function f()
+                print("f 1")
+                print(coroutine.resume(c2))
+                print("f 2")
+            end
+
+            function g()
+                print("g 1")
+                print(coroutine.resume(c1))
+                print("g 2")
+            end
+
+            c1 = coroutine.create(f)
+            c2 = coroutine.create(g)
+
+            coroutine.resume(c1)
+        ';
+    }
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- response_body
+f 1
+g 1
+falsecannot resume normal coroutine
+g 2
+true
+f 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: resume running (entry) coroutines
+--- config
+    location /t {
+        content_by_lua '
+            ngx.say(coroutine.status(coroutine.running()))
+            ngx.say(coroutine.resume(coroutine.running()))
+        ';
+    }
+--- request
+GET /t
+--- response_body
+running
+falsecannot resume running coroutine
+--- no_error_log
+[error]
+
+
+
+=== TEST 20: resume running (user) coroutines
+--- config
+    location /t {
+        content_by_lua '
+            local co
+            function f()
+                ngx.say("f: ", coroutine.status(co))
+                ngx.say("f: ", coroutine.resume(co))
+            end
+            co = coroutine.create(f)
+            ngx.say("chunk: ", coroutine.status(co))
+            ngx.say("chunk: ", coroutine.resume(co))
+        ';
+    }
+--- request
+GET /t
+--- response_body
+chunk: suspended
+f: running
+f: falsecannot resume running coroutine
+chunk: true
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: user coroutine end with errors, and the parent coroutine gets the right status
+--- config
+    location /t {
+        content_by_lua '
+            local co
+            function f()
+                error("bad")
+            end
+            co = coroutine.create(f)
+            ngx.say("child: resume: ", coroutine.resume(co))
+            ngx.say("child: status: ", coroutine.status(co))
+            ngx.say("parent: status: ", coroutine.status(coroutine.running()))
+        ';
+    }
+--- request
+GET /t
+--- response_body
+child: resume: false[string "content_by_lua"]:4: bad
+child: status: dead
+parent: status: running
+--- error_log
+lua coroutine: runtime error: [string "content_by_lua"]:4: bad
+
+
+
+=== TEST 22: entry coroutine is yielded by hand and still gets the right status
+--- config
+    location /t {
+        content_by_lua '
+            local co = coroutine.running()
+            ngx.say("status: ", coroutine.status(co))
+            coroutine.yield(co)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+    }
+--- request
+GET /t
+--- response_body
+status: running
+status: running
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: github issue #208: coroutine as iterator doesn't work
+--- config
+    location = /t {
+        content_by_lua '
+            local say = ngx.say
+            local wrap, yield = coroutine.wrap, coroutine.yield
+
+            local function it(it_state)
+              for i = 1, it_state.i do
+                yield(it_state.path, tostring(i))
+              end
+              return nil
+            end
+
+            local function it_factory(path)
+              local it_state = { i = 10, path = path }
+              return wrap(it), it_state
+            end
+
+            --[[
+            for path, value in it_factory("test") do
+              say(path, value)
+            end
+            ]]
+
+            do
+              local f, s, var = it_factory("test")
+              while true do
+                local path, value = f(s, var)
+                var = path
+                if var == nil then break end
+                say(path, value)
+              end
+            end
+        ';
+    }
+--- request
+    GET /t
+--- more_headers
+Cookie: abc=32
+--- stap2 eval: $::StapScript
+--- response_body
+test1
+test2
+test3
+test4
+test5
+test6
+test7
+test8
+test9
+test10
+--- no_error_log
+[error]
+
+
+
+=== TEST 24: init_by_lua + our own coroutines in content_by_lua
+--- http_config
+    init_by_lua return;
+--- config
+    resolver $TEST_NGINX_RESOLVER;
+    location /lua {
+        content_by_lua '
+            function worker(url)
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect(url, 80)
+                coroutine.yield()
+                if not ok then
+                    ngx.say("failed to connect to: ", url, " error: ", err)
+                    return
+                end
+                coroutine.yield()
+                ngx.say("successfully connected to: ", url)
+                sock:close()
+            end
+
+            local urls = {
+                "agentzh.org",
+            }
+
+            local ccs = {}
+            for i, url in ipairs(urls) do
+                local cc = coroutine.create(function() worker(url) end)
+                ccs[#ccs+1] = cc
+            end
+
+            while true do
+                if #ccs == 0 then break end
+                local cc = table.remove(ccs, 1)
+                local ok = coroutine.resume(cc)
+                if ok then
+                    ccs[#ccs+1] = cc
+                end
+            end
+
+            ngx.say("*** All Done ***")
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+successfully connected to: agentzh.org
+*** All Done ***
+--- no_error_log
+[error]
+--- timeout: 10
+
+
+
+=== TEST 25: init_by_lua_file + our own coroutines in content_by_lua
+--- http_config
+    init_by_lua_file html/init.lua;
+
+--- config
+    resolver $TEST_NGINX_RESOLVER;
+    location /lua {
+        content_by_lua '
+            function worker(url)
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect(url, 80)
+                coroutine.yield()
+                if not ok then
+                    ngx.say("failed to connect to: ", url, " error: ", err)
+                    return
+                end
+                coroutine.yield()
+                ngx.say("successfully connected to: ", url)
+                sock:close()
+            end
+
+            local urls = {
+                "agentzh.org"
+            }
+
+            local ccs = {}
+            for i, url in ipairs(urls) do
+                local cc = coroutine.create(function() worker(url) end)
+                ccs[#ccs+1] = cc
+            end
+
+            while true do
+                if #ccs == 0 then break end
+                local cc = table.remove(ccs, 1)
+                local ok = coroutine.resume(cc)
+                if ok then
+                    ccs[#ccs+1] = cc
+                end
+            end
+
+            ngx.say("*** All Done ***")
+        ';
+    }
+--- user_files
+>>> init.lua
+return
+
+--- request
+GET /lua
+--- response_body
+successfully connected to: agentzh.org
+*** All Done ***
+--- no_error_log
+[error]
+--- timeout: 10
+
diff -rNu a/src/lua/lua-nginx-module/t/092-eof.t b/src/lua/lua-nginx-module/t/092-eof.t
--- a/src/lua/lua-nginx-module/t/092-eof.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/092-eof.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,84 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 6);
+
+master_on();
+workers(2);
+no_root_location();
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: 404 parallel subrequests after ngx.eof()
+--- config
+    location = /lua {
+        content_by_lua '
+            ngx.say(1)
+            ngx.eof()
+            local res1, res2 = ngx.location.capture_multi{
+                { "/bad1" },
+                { "/bad2" }
+            }
+            ngx.log(ngx.WARN, "res1: ", res1.status)
+            ngx.log(ngx.WARN, "res2: ", res2.status)
+        ';
+    }
+--- request
+GET /lua
+--- response_body
+1
+--- no_error_log
+[alert]
+--- error_log
+res1: 404
+res2: 404
+No such file or directory
+
+
+
+=== TEST 2: parallel normal subrequests after ngx.eof()
+--- config
+    location = /t {
+        content_by_lua '
+            ngx.say(1)
+            ngx.eof()
+            local r1, r2 = ngx.location.capture_multi{
+                { "/proxy/tom" },
+                { "/proxy/jim" }
+            }
+            ngx.log(ngx.WARN, r1.body)
+            ngx.log(ngx.WARN, r2.body)
+        ';
+    }
+
+    location ~ '^/proxy/(\w+)' {
+        proxy_pass http://127.0.0.1:$server_port/hello?a=$1;
+    }
+
+    location = /hello {
+        echo_sleep 0.5;
+        echo -n "hello, $arg_a";
+    }
+--- request
+GET /t
+--- response_body
+1
+--- no_error_log
+[alert]
+[error]
+--- error_log
+hello, tom
+hello, jim
+
diff -rNu a/src/lua/lua-nginx-module/t/093-uthread-spawn.t b/src/lua/lua-nginx-module/t/093-uthread-spawn.t
--- a/src/lua/lua-nginx-module/t/093-uthread-spawn.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/093-uthread-spawn.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1676 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+worker_connections(256);
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple user thread without I/O
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: two simple user threads without I/O
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("in thread 1")
+            end
+
+            function g()
+                ngx.say("in thread 2")
+            end
+
+            ngx.say("before 1")
+            ngx.thread.spawn(f)
+            ngx.say("after 1")
+
+            ngx.say("before 2")
+            ngx.thread.spawn(g)
+            ngx.say("after 2")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+terminate 1: ok
+delete thread 2
+delete thread 3
+delete thread 1
+
+--- response_body
+before 1
+in thread 1
+after 1
+before 2
+in thread 2
+after 2
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: simple user thread with sleep
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before sleep")
+                ngx.sleep(0.1)
+                ngx.say("after sleep")
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+before thread create
+before sleep
+after thread create
+after sleep
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: two simple user threads with sleep
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("1: before sleep")
+                ngx.sleep(0.2)
+                ngx.say("1: after sleep")
+            end
+
+            function g()
+                ngx.say("2: before sleep")
+                ngx.sleep(0.1)
+                ngx.say("2: after sleep")
+            end
+
+            ngx.say("1: before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("1: after thread create")
+
+            ngx.say("2: before thread create")
+            ngx.thread.spawn(g)
+            ngx.say("2: after thread create")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2
+
+--- wait: 0.1
+--- response_body
+1: before thread create
+1: before sleep
+1: after thread create
+2: before thread create
+2: before sleep
+2: after thread create
+2: after sleep
+1: after sleep
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: error in user thread
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.blah()
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: fail
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+after
+--- error_log
+lua user thread aborted: runtime error: [string "content_by_lua"]:3: attempt to call field 'blah' (a nil value)
+
+
+
+=== TEST 6: simple user threads doing a single subrequest (entry quits early)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before capture")
+                res = ngx.location.capture("/proxy")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+        ';
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/foo;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello world;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+before thread create
+before capture
+after thread create
+after capture: hello world
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: simple user threads doing a single subrequest (entry also does a subrequest and quits early)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo -n hello bar;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+before thread create
+before capture
+after thread create
+capture: hello bar
+after capture: hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: simple user threads doing a single subrequest (entry also does a subrequest and quits late)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("after capture: ", res.body)
+            end
+
+            ngx.say("before thread create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread create")
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo_sleep 0.2;
+        echo -n hello bar;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+before thread create
+before capture
+after thread create
+after capture: hello foo
+capture: hello bar
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: two simple user threads doing single subrequests (entry also does a subrequest and quits between)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("f: before capture")
+                local res = ngx.location.capture("/proxy?foo")
+                ngx.say("f: after capture: ", res.body)
+            end
+
+            function g()
+                ngx.say("g: before capture")
+                local res = ngx.location.capture("/proxy?bah")
+                ngx.say("g: after capture: ", res.body)
+            end
+
+            ngx.say("before thread 1 create")
+            ngx.thread.spawn(f)
+            ngx.say("after thread 1 create")
+
+            ngx.say("before thread 2 create")
+            ngx.thread.spawn(g)
+            ngx.say("after thread 2 create")
+
+            local res = ngx.location.capture("/proxy?bar")
+            ngx.say("capture: ", res.body)
+        ';
+    }
+
+    location /proxy {
+        proxy_pass http://127.0.0.1:$server_port/$args;
+    }
+
+    location /foo {
+        echo_sleep 0.1;
+        echo -n hello foo;
+    }
+
+    location /bar {
+        echo_sleep 0.2;
+        echo -n hello bar;
+    }
+
+    location /bah {
+        echo_sleep 0.3;
+        echo -n hello bah;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before thread 1 create
+f: before capture
+after thread 1 create
+before thread 2 create
+g: before capture
+after thread 2 create
+f: after capture: hello foo
+capture: hello bar
+g: after capture: hello bah
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: nested user threads
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            ngx.thread.spawn(f)
+            ngx.say("after f")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 3
+delete thread 2
+
+--- response_body
+before f
+before g
+hello in g()
+after f
+after g
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: nested user threads (with I/O)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.sleep(0.1)
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            ngx.thread.spawn(f)
+            ngx.say("after f")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+before f
+before g
+after f
+after g
+hello in g()
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: coroutine status of a running user thread
+--- config
+    location /lua {
+        content_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+                ngx.sleep(0.1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+status: running
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: coroutine status of a dead user thread
+--- config
+    location /lua {
+        content_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+status: zombie
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: coroutine status of a "normal" user thread
+--- config
+    location /lua {
+        content_by_lua '
+            local co
+            function f()
+                co = coroutine.running()
+                local co2 = coroutine.create(g)
+                coroutine.resume(co2)
+            end
+
+            function g()
+                ngx.sleep(0.1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("status: ", coroutine.status(co))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 2
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+terminate 2: ok
+delete thread 2
+
+--- response_body
+status: normal
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: creating user threads in a user coroutine
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("before g")
+                ngx.thread.spawn(g)
+                ngx.say("after g")
+            end
+
+            function g()
+                ngx.say("hello in g()")
+            end
+
+            ngx.say("before f")
+            local co = coroutine.create(f)
+            coroutine.resume(co)
+            ngx.say("after f")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+terminate 2: ok
+delete thread 3
+terminate 1: ok
+delete thread 1
+
+--- response_body
+before f
+before g
+hello in g()
+after g
+after f
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: manual time slicing between a user thread and the entry thread
+--- config
+    location /lua {
+        content_by_lua '
+            local yield = coroutine.yield
+
+            function f()
+                local self = coroutine.running()
+                ngx.say("f 1")
+                yield(self)
+                ngx.say("f 2")
+                yield(self)
+                ngx.say("f 3")
+            end
+
+            local self = coroutine.running()
+            ngx.say("0")
+            yield(self)
+            ngx.say("1")
+            ngx.thread.spawn(f)
+            ngx.say("2")
+            yield(self)
+            ngx.say("3")
+            yield(self)
+            ngx.say("4")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+0
+1
+f 1
+2
+f 2
+3
+f 3
+4
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: manual time slicing between two user threads
+--- config
+    location /lua {
+        content_by_lua '
+            local yield = coroutine.yield
+
+            function f()
+                local self = coroutine.running()
+                ngx.say("f 1")
+                yield(self)
+                ngx.say("f 2")
+                yield(self)
+                ngx.say("f 3")
+            end
+
+            function g()
+                local self = coroutine.running()
+                ngx.say("g 1")
+                yield(self)
+                ngx.say("g 2")
+                yield(self)
+                ngx.say("g 3")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+f 1
+g 1
+f 2
+done
+g 2
+f 3
+g 3
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: entry thread and a user thread flushing at the same time
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                coroutine.yield(coroutine.running)
+                ngx.flush(true)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.flush(true)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 19: two user threads flushing at the same time
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello from f")
+                ngx.flush(true)
+            end
+
+            function g()
+                ngx.say("hello from g")
+                ngx.flush(true)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3|create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+terminate 1: ok
+delete thread 2
+delete thread 3
+delete thread 1)$
+
+--- response_body
+hello from f
+hello from g
+--- no_error_log
+[error]
+
+
+
+=== TEST 20: user threads + ngx.socket.tcp
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_MEMCACHED_PORT)
+                if not ok then
+                    ngx.say("failed to connect: ", err)
+                    return
+                end
+                local bytes, err = sock:send("flush_all\\r\\n")
+                if not bytes then
+                    ngx.say("failed to send query: ", err)
+                    return
+                end
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+
+                ngx.say("received: ", line)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+before
+after
+received: OK
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: user threads + ngx.socket.udp
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                local sock = ngx.socket.udp()
+                local ok, err = sock:setpeername("127.0.0.1", 12345)
+                local bytes, err = sock:send("blah")
+                if not bytes then
+                    ngx.say("failed to send query: ", err)
+                    return
+                end
+
+                local line, err = sock:receive()
+                if not line then
+                    ngx.say("failed to receive: ", err)
+                    return
+                end
+
+                ngx.say("received: ", line)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+|create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+)$
+
+--- udp_listen: 12345
+--- udp_query: blah
+--- udp_reply: hello udp
+--- response_body_like chop
+^(?:before
+after
+received: hello udp
+|before
+received: hello udp
+after)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 22: simple user thread with ngx.req.read_body()
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.req.read_body()
+                local body = ngx.req.get_body_data()
+                ngx.say("body: ", body)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+POST /lua
+hello world
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1|create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2)$
+
+--- response_body_like chop
+^(?:before
+body: hello world
+after|before
+after
+body: hello world)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: simple user thread with ngx.req.socket()
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                local sock = ngx.req.socket()
+                local body, err = sock:receive(11)
+                if not body then
+                    ngx.say("failed to read body: ", err)
+                    return
+                end
+
+                ngx.say("body: ", body)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+POST /lua
+hello world
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^(?:create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1|create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2)$
+
+--- response_body_like chop
+^(?:before
+body: hello world
+after|before
+after
+body: hello world)$
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 24: simple user thread with args
+--- config
+    location /lua {
+        content_by_lua '
+            function f(a, b)
+                ngx.say("hello ", a, " and ", b)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f, "foo", 3.14)
+            ngx.say("after")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+before
+hello foo and 3.14
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 25: multiple user threads + subrequests returning 404 immediately
+--- config
+    location /t {
+        content_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 2 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+    }
+
+    location ~ ^/proxy/(\d+) {
+        return 404;
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval
+"$::GCScript"
+.
+'
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+'
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+finalize request /t: rc:-4 c:4 a:1
+finalize request /proxy/1: rc:404 c:3 a:0
+post subreq: /proxy/1 rc=404, status=0 a=0
+subrequest /proxy/1 done
+terminate 2: ok
+delete thread 2
+finalize request /proxy/2: rc:404 c:2 a:0
+post subreq: /proxy/2 rc=404, status=0 a=0
+subrequest /proxy/2 done
+terminate 3: ok
+delete thread 3
+finalize request /t: rc:0 c:1 a:1
+(?:finalize request /t: rc:0 c:1 a:1)?$
+
+--- response_body
+ok
+status: 404
+status: 404
+--- no_error_log
+[error]
+--- timeout: 3
+
+
+
+=== TEST 26: multiple user threads + subrequests returning 404 remotely (no wait)
+--- config
+    location /t {
+        content_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 5 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+    }
+
+    location ~ ^/proxy/(\d+) {
+        proxy_pass http://127.0.0.1:$server_port/d/$1;
+    }
+
+    location /d {
+        return 404;
+        #echo $uri;
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+create 4 in 1
+spawn user thread 4 in 1
+create 5 in 1
+spawn user thread 5 in 1
+create 6 in 1
+spawn user thread 6 in 1
+terminate 1: ok
+delete thread 1
+(?:terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+terminate 5: ok
+delete thread 5
+terminate 6: ok
+delete thread 6
+|terminate 6: ok
+delete thread 6
+terminate 5: ok
+delete thread 5
+terminate 4: ok
+delete thread 4
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2)$
+
+--- response_body
+ok
+status: 404
+status: 404
+status: 404
+status: 404
+status: 404
+--- no_error_log
+[error]
+--- timeout: 6
+
+
+
+=== TEST 27: multiple user threads + subrequests returning 201 immediately
+--- config
+    location /t {
+        content_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 2 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+    }
+
+    location ~ ^/proxy/(\d+) {
+        content_by_lua 'ngx.exit(201)';
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval
+"$::GCScript"
+.
+'
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+'
+
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+finalize request /t: rc:-4 c:4 a:1
+terminate 4: ok
+delete thread 4
+finalize request /proxy/1: rc:201 c:3 a:0
+post subreq: /proxy/1 rc=201, status=201 a=0
+subrequest /proxy/1 done
+terminate 2: ok
+delete thread 2
+terminate 5: ok
+delete thread 5
+finalize request /proxy/2: rc:201 c:2 a:0
+post subreq: /proxy/2 rc=201, status=201 a=0
+subrequest /proxy/2 done
+terminate 3: ok
+delete thread 3
+finalize request /t: rc:0 c:1 a:1
+(?:finalize request /t: rc:0 c:1 a:1)?$
+
+--- response_body
+ok
+status: 201
+status: 201
+--- no_error_log
+[error]
+--- timeout: 3
+
+
+
+=== TEST 28: multiple user threads + subrequests returning 204 immediately
+--- config
+    location /t {
+        content_by_lua '
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                ngx.say("status: ", res.status)
+            end
+
+            local threads = {}
+            for i = 1, 2 do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            ngx.say("ok")
+        ';
+    }
+
+    location ~ ^/proxy/(\d+) {
+        content_by_lua 'ngx.exit(204)';
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap eval
+"$::GCScript"
+.
+'
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+'
+--- stap_out_like chop
+^create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+finalize request /t: rc:-4 c:4 a:1
+terminate 4: ok
+delete thread 4
+finalize request /proxy/1: rc:204 c:3 a:0
+post subreq: /proxy/1 rc=204, status=204 a=0
+subrequest /proxy/1 done
+terminate 2: ok
+delete thread 2
+terminate 5: ok
+delete thread 5
+finalize request /proxy/2: rc:204 c:2 a:0
+post subreq: /proxy/2 rc=204, status=204 a=0
+subrequest /proxy/2 done
+terminate 3: ok
+delete thread 3
+finalize request /t: rc:0 c:1 a:1
+(?:finalize request /t: rc:0 c:1 a:1)?$
+
+--- response_body
+ok
+status: 204
+status: 204
+--- no_error_log
+[error]
+--- timeout: 3
+
+
+
+=== TEST 29: multiple user threads + subrequests returning 404 remotely (wait)
+--- config
+    location /t {
+        content_by_lua '
+            local n = 5
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                return res.status
+            end
+
+            local threads = {}
+            for i = 1, n do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            for i = 1, n do
+                local ok, res = ngx.thread.wait(threads[i])
+                ngx.say(i, ": ", res)
+            end
+
+            ngx.say("ok")
+        ';
+    }
+
+    location ~ ^/proxy/(\d+) {
+        proxy_pass http://127.0.0.1:$server_port/d/$1;
+    }
+
+    location /d {
+        return 404;
+        #echo $uri;
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap3 eval: $::GCScript
+--- stap_out3
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+create 4 in 1
+spawn user thread 4 in 1
+create 5 in 1
+spawn user thread 5 in 1
+create 6 in 1
+spawn user thread 6 in 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+terminate 5: ok
+delete thread 5
+terminate 6: ok
+delete thread 6
+terminate 1: ok
+delete thread 1
+
+--- response_body
+1: 404
+2: 404
+3: 404
+4: 404
+5: 404
+ok
+--- no_error_log
+[error]
+--- timeout: 6
+
+
+
+=== TEST 30: multiple user threads + subrequests remotely (wait)
+--- config
+    location /t {
+        content_by_lua '
+            local n = 20
+            local capture = ngx.location.capture
+            local insert = table.insert
+
+            local function f(i)
+                local res = capture("/proxy/" .. i)
+                return res.status
+            end
+
+            local threads = {}
+            for i = 1, n do
+                local co = ngx.thread.spawn(f, i)
+                insert(threads, co)
+            end
+
+            for i = 1, n do
+                local ok, res = ngx.thread.wait(threads[i])
+                ngx.say(i, ": ", res)
+            end
+
+            ngx.say("ok")
+        ';
+    }
+
+    location ~ ^/proxy/(\d+) {
+        proxy_pass http://127.0.0.1:$server_port/d/$1;
+    }
+
+    location /d {
+        echo_sleep 0.001;
+        echo $uri;
+    }
+--- request
+    GET /t
+--- stap2 eval: $::StapScript
+--- stap3 eval: $::GCScript
+--- stap_out3
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+create 4 in 1
+spawn user thread 4 in 1
+create 5 in 1
+spawn user thread 5 in 1
+create 6 in 1
+spawn user thread 6 in 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+terminate 5: ok
+delete thread 5
+terminate 6: ok
+delete thread 6
+terminate 1: ok
+delete thread 1
+
+--- response_body
+1: 200
+2: 200
+3: 200
+4: 200
+5: 200
+6: 200
+7: 200
+8: 200
+9: 200
+10: 200
+11: 200
+12: 200
+13: 200
+14: 200
+15: 200
+16: 200
+17: 200
+18: 200
+19: 200
+20: 200
+ok
+--- no_error_log
+[error]
+[alert]
+--- timeout: 10
+
+
+
+=== TEST 31: simple user thread without I/O
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f")
+            end
+
+            ngx.thread.spawn(f)
+            collectgarbage()
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+f
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/094-uthread-exit.t b/src/lua/lua-nginx-module/t/094-uthread-exit.t
--- a/src/lua/lua-nginx-module/t/094-uthread-exit.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/094-uthread-exit.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1658 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: exit in user thread (entry thread is still pending to run)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+M(timer-add) {
+    if ($arg2 == 1000) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+before
+hello in thread
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: exit in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: exit in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f")
+                ngx.exit(0)
+            end
+
+            function g()
+                ngx.sleep(1)
+                ngx.say("g")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+free request
+
+--- response_body
+end
+f
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: exit in user thread (entry already quits)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("exiting the user thread")
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- wait: 0.1
+--- response_body
+before
+after
+exiting the user thread
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: exit in user thread (entry thread is still pending on the DNS resolver for ngx.socket.tcp)
+--- config
+    location /lua {
+        resolver agentzh.org;
+        resolver_timeout 12s;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.001)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+            local ok, err = sock:connect("agentzh.org", 80)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+F(ngx_resolve_name) {
+    printf("resolving %s\n", user_string_n($ctx->name->data, $ctx->name->len))
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 1) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_resolve_cleanup) {
+    println("lua tcp resolve cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 1
+resolving agentzh.org
+add timer 12000
+expire timer 1
+terminate 2: ok
+lua tcp resolve cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: exit in user thread (entry thread is still pending on the DNS resolver for ngx.socket.udp)
+--- config
+    location /lua {
+        resolver agentzh.org;
+        resolver_timeout 12s;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.001)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.udp()
+            local ok, err = sock:setpeername("agentzh.org", 80)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+F(ngx_resolve_name) {
+    printf("resolving %s\n", user_string_n($ctx->name->data, $ctx->name->len))
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 1) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 1) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_udp_resolve_cleanup) {
+    println("lua udp resolve cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 1
+resolving agentzh.org
+add timer 12000
+expire timer 1
+terminate 2: ok
+lua udp resolve cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: exit in user thread (entry thread is still pending on tcpsock:connect)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+            sock:settimeout(12000)
+            local ok, err = sock:connect("106.187.41.147", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 12000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: exit in user thread (entry thread is still pending on tcpsock:receive)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, ok = sock:send("blpop not_exists 2\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: exit in user thread (entry thread is still pending on tcpsock:receiveuntil's iterator)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.tcp()
+
+            local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local bytes, ok = sock:send("blpop not_exists 2\\r\\n")
+            if not bytes then
+                ngx.say("failed to send: ", err)
+                return
+            end
+
+            local it, err = sock:receiveuntil("\\r\\n")
+            if not it then
+                ngx.say("failed to receive until: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = it()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: exit in user thread (entry thread is still pending on udpsock:receive)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.socket.udp()
+
+            local ok, err = sock:setpeername("8.8.8.8", 12345)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_udp_socket_cleanup) {
+    println("lua udp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua udp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: exit in user thread (entry thread is still pending on reqsock:receive)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+            local sock = ngx.req.socket()
+
+            sock:settimeout(12000)
+
+            local data, err = sock:receive(1024)
+            if not data then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("end")
+        ';
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_tcp_socket_cleanup) {
+    println("lua tcp socket cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua tcp socket cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: exit in user thread (entry thread is still pending on ngx.req.read_body)
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.req.read_body()
+
+            ngx.say("end")
+        ';
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 12000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 12000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_req_body_cleanup) {
+    println("lua req body cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 12000
+expire timer 100
+terminate 2: ok
+lua req body cleanup
+delete timer 12000
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+before
+hello in thread
+after
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: exit(0) in user thread (entry thread is still pending on ngx.location.capture), with pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("end")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+terminate 1: ok
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- ignore_response
+--- error_log
+attempt to abort with pending subrequests
+--- no_error_log
+[alert]
+[warn]
+
+
+
+=== TEST 14: exit in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 15: exit in user thread (entry thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exit(0)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture_multi{
+                {"/echo"},
+                {"/sleep"}
+            }
+            ngx.say("end")
+        ';
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 16: exit in entry thread (user thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.location.capture_multi{
+                    {"/echo"},
+                    {"/sleep"}
+                }
+                ngx.say("end")
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.sleep(0.1)
+            ngx.exit(0)
+        ';
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 1: fail
+delete thread 2
+delete thread 1
+delete timer 200
+free request
+
+--- wait: 0.1
+--- ignore_response
+--- error_log
+attempt to abort with pending subrequests
+--- no_error_log
+[alert]
+[warn]
+
+
+
+=== TEST 17: exit(444) in user thread (entry thread is still pending on ngx.location.capture), with pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(444)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("end")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: ok
+delete thread 2
+delete thread 1
+delete timer 200
+free request
+
+--- wait: 0.1
+--- ignore_response
+--- no_error_log
+[alert]
+[error]
+[warn]
+
+
+
+=== TEST 18: exit(408) in user thread (entry thread is still pending on ngx.location.capture), with pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(408)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("end")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: ok
+delete thread 2
+delete thread 1
+delete timer 200
+free request
+
+--- wait: 0.1
+--- ignore_response
+--- no_error_log
+[alert]
+[error]
+[warn]
+
+
+
+=== TEST 19: exit(499) in user thread (entry thread is still pending on ngx.location.capture), with pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                ngx.sleep(0.1)
+                ngx.exit(499)
+            end
+
+            ngx.say("before")
+            ngx.thread.spawn(f)
+            ngx.say("after")
+
+            ngx.location.capture("/sleep")
+
+            ngx.say("end")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: ok
+delete thread 2
+delete thread 1
+delete timer 200
+free request
+
+--- wait: 0.1
+--- ignore_response
+--- no_error_log
+[alert]
+[error]
+[warn]
+
diff -rNu a/src/lua/lua-nginx-module/t/095-uthread-exec.t b/src/lua/lua-nginx-module/t/095-uthread-exec.t
--- a/src/lua/lua-nginx-module/t/095-uthread-exec.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/095-uthread-exec.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,428 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: exec in user thread (entry still pending)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("hello")
+        ';
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: exec in user thread (entry already quits)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+        ';
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: exec in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+        ';
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: exec in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            function g()
+                ngx.sleep(1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: exec in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.exec("/foo")
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+
+    location = /foo {
+        echo hello world;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+terminate 1: ok
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 6: exec in entry thread (user thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.location.capture("/sleep")
+                ngx.say("end")
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.sleep(0.1)
+            ngx.exec("/foo")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+
+    location = /foo {
+        echo hello world;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 1: fail
+delete thread 2
+delete thread 1
+delete timer 200
+free request
+
+--- ignore_response
+--- error_log
+attempt to abort with pending subrequests
+--- no_error_log
+[alert]
+[warn]
+
diff -rNu a/src/lua/lua-nginx-module/t/096-uthread-redirect.t b/src/lua/lua-nginx-module/t/096-uthread-redirect.t
--- a/src/lua/lua-nginx-module/t/096-uthread-redirect.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/096-uthread-redirect.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,283 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ngx.redirect() in user thread (entry thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.redirect(301)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture_multi{
+                {"/echo"},
+                {"/sleep"}
+            }
+            ngx.say("end")
+        ';
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+free request
+
+--- wait: 0.1
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
+
+
+=== TEST 2: redirect in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.redirect(301)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("end")
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body_like: 302 Found
+--- error_code: 302
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: ngx.redirect() in entry thread (user thread is still pending on ngx.location.capture_multi), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        content_by_lua '
+            function f()
+                ngx.location.capture_multi{
+                    {"/echo"},
+                    {"/sleep"}
+                }
+                ngx.say("end")
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.sleep(0.1)
+            ngx.redirect(301)
+        ';
+    }
+
+    location = /echo {
+        echo hello;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+post subreq /echo
+add timer 200
+expire timer 100
+terminate 1: fail
+delete thread 2
+delete thread 1
+delete timer 200
+free request
+
+--- ignore_response
+--- error_log
+attempt to abort with pending subrequests
+--- no_error_log
+[alert]
+[warn]
+
diff -rNu a/src/lua/lua-nginx-module/t/097-uthread-rewrite.t b/src/lua/lua-nginx-module/t/097-uthread-rewrite.t
--- a/src/lua/lua-nginx-module/t/097-uthread-rewrite.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/097-uthread-rewrite.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,353 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: rewrite in user thread (entry still pending)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.req.set_uri("/foo", true)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+            ngx.say("hello")
+        ';
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: rewrite in user thread (entry already quits)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.req.set_uri("/foo", true)
+            end
+
+            ngx.thread.spawn(f)
+        ';
+    }
+
+    location /foo {
+        echo i am foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+i am foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: rewrite in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.req.set_uri("/foo", true)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.sleep(1)
+        ';
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 1000
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 1
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: rewrite in a user thread (another user thread is still pending on ngx.sleep)
+--- config
+    location /lua {
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.req.set_uri("/foo", true)
+            end
+
+            function g()
+                ngx.sleep(1)
+            end
+
+            ngx.thread.spawn(f)
+            ngx.thread.spawn(g)
+        ';
+    }
+
+    location = /foo {
+        echo hello foo;
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+create 3 in 1
+spawn user thread 3 in 1
+add timer 1000
+terminate 1: ok
+delete thread 1
+expire timer 100
+terminate 2: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 2
+delete thread 3
+free request
+
+--- response_body
+hello foo
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: rewrite in user thread (entry thread is still pending on ngx.location.capture), without pending output
+--- config
+    location /lua {
+        client_body_timeout 12000ms;
+        rewrite_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.req.set_uri("/foo", true)
+            end
+
+            ngx.thread.spawn(f)
+
+            ngx.location.capture("/sleep")
+            ngx.say("end")
+        ';
+        content_by_lua return;
+    }
+
+    location = /sleep {
+        echo_sleep 0.2;
+    }
+
+    location = /foo {
+        echo hello world;
+    }
+--- request
+POST /lua
+--- more_headers
+Content-Length: 1024
+--- stap2 eval: $::StapScript
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 200 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 200 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq %s\n", ngx_http_req_uri($r))
+}
+
+_EOC_
+
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+add timer 100
+add timer 200
+expire timer 100
+terminate 2: fail
+expire timer 200
+post subreq /sleep
+terminate 1: ok
+delete thread 2
+delete thread 1
+terminate 3: ok
+delete thread 3
+free request
+
+--- response_body
+end
+--- error_log
+attempt to abort with pending subrequests
+
diff -rNu a/src/lua/lua-nginx-module/t/098-uthread-wait.t b/src/lua/lua-nginx-module/t/098-uthread-wait.t
--- a/src/lua/lua-nginx-module/t/098-uthread-wait.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/098-uthread-wait.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1225 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple user thread wait without I/O
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                return "done"
+            end
+
+            local t, err = ngx.thread.spawn(f)
+            if not t then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("thread created: ", coroutine.status(t))
+
+            collectgarbage()
+
+            local ok, res = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to run thread: ", res)
+                return
+            end
+
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+hello in thread
+thread created: zombie
+done
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: simple user thread wait with I/O
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("hello in thread")
+                return "done"
+            end
+
+            local t, err = ngx.thread.spawn(f)
+            if not t then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("thread created: ", coroutine.status(t))
+
+            local ok, res = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to wait thread: ", res)
+                return
+            end
+
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+thread created: running
+hello in thread
+done
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: wait on uthreads on the reversed order of their termination
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f: hello")
+                return "done"
+            end
+
+            function g()
+                ngx.sleep(0.2)
+                ngx.say("g: hello")
+                return "done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("f thread created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("g thread created: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tg)
+            if not ok then
+                ngx.say("failed to wait g: ", res)
+                return
+            end
+
+            ngx.say("g: ", res)
+
+            ngx.say("f thread status: ", coroutine.status(tf))
+
+            ok, res = ngx.thread.wait(tf)
+            if not ok then
+                ngx.say("failed to wait f: ", res)
+                return
+            end
+
+            ngx.say("f: ", res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+terminate 3: ok
+delete thread 3
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+f thread created: running
+g thread created: running
+f: hello
+g: hello
+g: done
+f thread status: zombie
+f: done
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: wait on uthreads on the exact order of their termination
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f: hello")
+                return "done"
+            end
+
+            function g()
+                ngx.sleep(0.2)
+                ngx.say("g: hello")
+                return "done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("f thread created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("g thread created: ", coroutine.status(tg))
+
+            ok, res = ngx.thread.wait(tf)
+            if not ok then
+                ngx.say("failed to wait f: ", res)
+                return
+            end
+
+            ngx.say("f: ", res)
+
+            ngx.say("g thread status: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tg)
+            if not ok then
+                ngx.say("failed to wait g: ", res)
+                return
+            end
+
+            ngx.say("g: ", res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 1: ok
+delete thread 1
+
+--- wait: 0.1
+--- response_body
+f thread created: running
+g thread created: running
+f: hello
+f: done
+g thread status: running
+g: hello
+g: done
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: simple user thread wait without I/O (return multiple values)
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                return "done", 3.14
+            end
+
+            local t, err = ngx.thread.spawn(f)
+            if not t then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("thread created: ", coroutine.status(t))
+
+            collectgarbage()
+
+            local ok, res1, res2 = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to run thread: ", res1)
+                return
+            end
+
+            ngx.say("res: ", res1, " ", res2)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+hello in thread
+thread created: zombie
+res: done 3.14
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: simple user thread wait with I/O, return multiple values
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("hello in thread")
+                return "done", 3.14
+            end
+
+            local t, err = ngx.thread.spawn(f)
+            if not t then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("thread created: ", coroutine.status(t))
+
+            local ok, res1, res2 = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to wait thread: ", res1)
+                return
+            end
+
+            ngx.say("res: ", res1, " ", res2)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+thread created: running
+hello in thread
+res: done 3.14
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: simple user thread wait without I/O, throw errors
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.say("hello in thread")
+                error("bad bad!")
+            end
+
+            local t, err = ngx.thread.spawn(f)
+            if not t then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("thread created: ", coroutine.status(t))
+
+            collectgarbage()
+
+            local ok, res = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to wait thread: ", res)
+                return
+            end
+
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: fail
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+hello in thread
+thread created: zombie
+failed to wait thread: bad bad!
+--- error_log
+lua user thread aborted: runtime error: [string "content_by_lua"]:4: bad bad!
+
+
+
+=== TEST 8: simple user thread wait with I/O, throw errors
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("hello in thread")
+                error("bad bad!")
+            end
+
+            local t, err = ngx.thread.spawn(f)
+            if not t then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("thread created: ", coroutine.status(t))
+
+            collectgarbage()
+
+            local ok, res = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to wait thread: ", res)
+                return
+            end
+
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: fail
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+thread created: running
+hello in thread
+failed to wait thread: bad bad!
+--- error_log
+lua user thread aborted: runtime error: [string "content_by_lua"]:5: bad bad!
+
+
+
+=== TEST 9: simple user thread wait without I/O (in a user coroutine)
+--- config
+    location /lua {
+        content_by_lua '
+            function g()
+                ngx.say("hello in thread")
+                return "done"
+            end
+
+            function f()
+                local t, err = ngx.thread.spawn(g)
+                if not t then
+                    ngx.say("failed to spawn thread: ", err)
+                    return
+                end
+
+                ngx.say("thread created: ", coroutine.status(t))
+
+                collectgarbage()
+
+                local ok, res = ngx.thread.wait(t)
+                if not ok then
+                    ngx.say("failed to run thread: ", res)
+                    return
+                end
+
+                ngx.say(res)
+            end
+
+            local co = coroutine.create(f)
+            coroutine.resume(co)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+terminate 1: ok
+delete thread 1
+
+--- response_body
+hello in thread
+thread created: zombie
+done
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: simple user thread wait with I/O (in a user coroutine)
+--- config
+    location /lua {
+        content_by_lua '
+            function g()
+                ngx.sleep(0.1)
+                ngx.say("hello in thread")
+                return "done"
+            end
+
+            function f()
+                local t, err = ngx.thread.spawn(g)
+                if not t then
+                    ngx.say("failed to spawn thread: ", err)
+                    return
+                end
+
+                ngx.say("thread created: ", coroutine.status(t))
+
+                collectgarbage()
+
+                local ok, res = ngx.thread.wait(t)
+                if not ok then
+                    ngx.say("failed to run thread: ", res)
+                    return
+                end
+
+                ngx.say(res)
+            end
+
+            local co = coroutine.create(f)
+            coroutine.resume(co)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+terminate 1: ok
+delete thread 1
+
+--- response_body
+thread created: running
+hello in thread
+done
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: waiting on two simple user threads without I/O
+--- config
+    location /lua {
+        content_by_lua '
+            -- local out = function (...) ngx.log(ngx.ERR, ...) end
+            local out = ngx.say
+
+            function f()
+                out("f: hello")
+                return "f done"
+            end
+
+            function g()
+                out("g: hello")
+                return "g done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                out("failed to spawn thread f: ", err)
+                return
+            end
+
+            out("thread f created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                out("failed to spawn thread g: ", err)
+                return
+            end
+
+            out("thread g created: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                out("failed to wait thread: ", res)
+                return
+            end
+
+            out("res: ", res)
+
+            out("f status: ", coroutine.status(tf))
+            out("g status: ", coroutine.status(tg))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: ok
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+delete thread 2
+terminate 1: ok
+delete thread 3
+delete thread 1
+
+--- response_body
+f: hello
+thread f created: zombie
+g: hello
+thread g created: zombie
+res: f done
+f status: dead
+g status: zombie
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: waiting on two simple user threads with I/O
+--- config
+    location /lua {
+        content_by_lua '
+            -- local out = function (...) ngx.log(ngx.ERR, ...) end
+            local out = ngx.say
+
+            function f()
+                ngx.sleep(0.1)
+                out("f: hello")
+                return "f done"
+            end
+
+            function g()
+                ngx.sleep(0.2)
+                out("g: hello")
+                return "g done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                out("failed to spawn thread f: ", err)
+                return
+            end
+
+            out("thread f created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                out("failed to spawn thread g: ", err)
+                return
+            end
+
+            out("thread g created: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                out("failed to wait thread: ", res)
+                return
+            end
+
+            out("res: ", res)
+
+            out("f status: ", coroutine.status(tf))
+            out("g status: ", coroutine.status(tg))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+
+--- response_body
+thread f created: running
+thread g created: running
+f: hello
+res: f done
+f status: dead
+g status: running
+g: hello
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: waiting on two simple user threads with I/O (uthreads completed in reversed order)
+--- config
+    location /lua {
+        content_by_lua '
+            -- local out = function (...) ngx.log(ngx.ERR, ...) end
+            local out = ngx.say
+
+            function f()
+                ngx.sleep(0.2)
+                out("f: hello")
+                return "f done"
+            end
+
+            function g()
+                ngx.sleep(0.1)
+                out("g: hello")
+                return "g done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                out("failed to spawn thread f: ", err)
+                return
+            end
+
+            out("thread f created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                out("failed to spawn thread g: ", err)
+                return
+            end
+
+            out("thread g created: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                out("failed to wait thread: ", res)
+                return
+            end
+
+            out("res: ", res)
+
+            out("f status: ", coroutine.status(tf))
+            out("g status: ", coroutine.status(tg))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+delete thread 3
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+thread f created: running
+thread g created: running
+g: hello
+res: g done
+f status: running
+g status: dead
+f: hello
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: waiting on two simple user threads without I/O, both aborted by errors
+--- config
+    location /lua {
+        content_by_lua '
+            -- local out = function (...) ngx.log(ngx.ERR, ...) end
+            local out = ngx.say
+
+            function f()
+                out("f: hello")
+                error("f done")
+            end
+
+            function g()
+                out("g: hello")
+                error("g done")
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                out("failed to spawn thread f: ", err)
+                return
+            end
+
+            out("thread f created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                out("failed to spawn thread g: ", err)
+                return
+            end
+
+            out("thread g created: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                out("failed to wait thread: ", res)
+            else
+                out("res: ", res)
+            end
+
+            out("f status: ", coroutine.status(tf))
+            out("g status: ", coroutine.status(tg))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 2: fail
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: fail
+delete thread 2
+terminate 1: ok
+delete thread 3
+delete thread 1
+
+--- response_body
+f: hello
+thread f created: zombie
+g: hello
+thread g created: zombie
+failed to wait thread: f done
+f status: dead
+g status: zombie
+
+--- error_log
+lua user thread aborted: runtime error: [string "content_by_lua"]:7: f done
+
+
+
+=== TEST 15: waiting on two simple user threads with I/O, both aborted by errors
+--- config
+    location /lua {
+        content_by_lua '
+            -- local out = function (...) ngx.log(ngx.ERR, ...) end
+            local out = ngx.say
+
+            function f()
+                ngx.sleep(0.1)
+                out("f: hello")
+                error("f done")
+            end
+
+            function g()
+                ngx.sleep(0.2)
+                out("g: hello")
+                error("g done")
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                out("failed to spawn thread f: ", err)
+                return
+            end
+
+            out("thread f created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                out("failed to spawn thread g: ", err)
+                return
+            end
+
+            out("thread g created: ", coroutine.status(tg))
+
+            local ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                out("failed to wait thread: ", res)
+            else
+                out("res: ", res)
+            end
+
+            out("f status: ", coroutine.status(tf))
+            out("g status: ", coroutine.status(tg))
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: fail
+delete thread 2
+terminate 1: ok
+delete thread 1
+terminate 3: fail
+delete thread 3
+
+--- response_body
+thread f created: running
+thread g created: running
+f: hello
+failed to wait thread: f done
+f status: dead
+g status: running
+g: hello
+
+--- error_log
+lua user thread aborted: runtime error: [string "content_by_lua"]:8: f done
+
+
+
+=== TEST 16: wait on uthreads on the exact order of their termination, but exit the world early
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                ngx.say("f: hello")
+                return "done"
+            end
+
+            function g()
+                ngx.sleep(0.2)
+                ngx.say("g: hello")
+                return "done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("f thread created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                ngx.say("failed to spawn thread: ", err)
+                return
+            end
+
+            ngx.say("g thread created: ", coroutine.status(tg))
+
+            ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                ngx.say("failed to wait: ", res)
+                return
+            end
+
+            ngx.say("res: ", res)
+
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 3
+delete thread 1
+
+--- response_body
+f thread created: running
+g thread created: running
+f: hello
+res: done
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: wait on uthreads on the reversed order of their termination, but exit the world early
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.2)
+                ngx.say("f: hello")
+                return "f done"
+            end
+
+            function g()
+                ngx.sleep(0.1)
+                ngx.say("g: hello")
+                return "g done"
+            end
+
+            local tf, err = ngx.thread.spawn(f)
+            if not tf then
+                ngx.say("failed to spawn thread f: ", err)
+                return
+            end
+
+            ngx.say("f thread created: ", coroutine.status(tf))
+
+            local tg, err = ngx.thread.spawn(g)
+            if not tg then
+                ngx.say("failed to spawn thread g: ", err)
+                return
+            end
+
+            ngx.say("g thread created: ", coroutine.status(tg))
+
+            ok, res = ngx.thread.wait(tf, tg)
+            if not ok then
+                ngx.say("failed to wait: ", res)
+                return
+            end
+
+            ngx.say("res: ", res)
+
+            ngx.exit(200)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 3: ok
+delete thread 3
+terminate 1: ok
+delete thread 2
+delete thread 1
+
+--- response_body
+f thread created: running
+g thread created: running
+g: hello
+res: g done
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: entry coroutine waiting on a thread not created by itself
+--- config
+    location /lua {
+        content_by_lua '
+            local t
+
+            function f()
+                ngx.sleep(0.1)
+                return "done"
+            end
+
+            function g()
+                t = ngx.thread.spawn(f)
+            end
+
+            local co = coroutine.create(g)
+            coroutine.resume(co)
+
+            local ok, res = ngx.thread.wait(t)
+            if not ok then
+                ngx.say("failed to run thread: ", res)
+                return
+            end
+
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 2: ok
+terminate 1: fail
+delete thread 3
+delete thread 1
+
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+only the parent coroutine can wait on the thread
+
+
+
+=== TEST 19: entry coroutine waiting on a user coroutine
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                coroutine.yield()
+                return "done"
+            end
+
+            local co = coroutine.create(f)
+            coroutine.resume(co)
+
+            local ok, res = ngx.thread.wait(co)
+            if not ok then
+                ngx.say("failed to run thread: ", res)
+                return
+            end
+
+            ngx.say(res)
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: fail
+delete thread 1
+
+--- response_body_like: 500 Internal Server Error
+--- error_code: 500
+--- error_log
+lua entry thread aborted: runtime error: [string "content_by_lua"]:11: attempt to wait on a coroutine that is not a user thread
+
+
+
+=== TEST 20: lua backtrace dumper may access dead parent coroutines
+--- config
+    location /lua {
+        content_by_lua '
+            function f()
+                ngx.sleep(0.1)
+                collectgarbage()
+                error("f done")
+            end
+
+            ngx.thread.spawn(f)
+            ngx.say("ok")
+
+            collectgarbage()
+        ';
+    }
+--- request
+GET /lua
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+spawn user thread 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: fail
+delete thread 2
+
+--- response_body
+ok
+
+--- error_log
+lua user thread aborted: runtime error: [string "content_by_lua"]:5: f done
+
diff -rNu a/src/lua/lua-nginx-module/t/099-c-api.t b/src/lua/lua-nginx-module/t/099-c-api.t
--- a/src/lua/lua-nginx-module/t/099-c-api.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/099-c-api.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,363 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(3);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+no_long_string();
+#master_on();
+#workers(2);
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: find zone
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local ffi = require "ffi"
+
+            ffi.cdef[[
+                void *ngx_http_lua_find_zone(char *data, size_t len);
+            ]]
+
+            local buf = ffi.new("char[?]", 4)
+            ffi.copy(buf, "foo", 3)
+            local zone = ffi.C.ngx_http_lua_find_zone(buf, 3)
+            ngx.say("foo zone: ", tonumber(ffi.cast("long", zone)) ~= 0 and "defined" or "undef")
+
+            ffi.copy(buf, "dogs", 4)
+            zone = ffi.C.ngx_http_lua_find_zone(buf, 4)
+            ngx.say("dogs zone: ", tonumber(ffi.cast("long", zone)) ~= 0 and "defined" or "undef")
+        ';
+    }
+--- request
+GET /test
+--- response_body
+foo zone: undef
+dogs zone: defined
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: number typed value
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local ffi = require "ffi"
+
+            ffi.cdef[[
+                typedef struct {
+                    size_t  len;
+                    char   *data;
+                } ngx_str_t;
+
+                typedef struct {
+                    uint8_t         type;
+
+                    union {
+                        int         b; /* boolean */
+                        double      n; /* number */
+                        ngx_str_t   s; /* string */
+                    } value;
+
+                } ngx_http_lua_value_t;
+
+                void *ngx_http_lua_find_zone(char *data, size_t len);
+                intptr_t ngx_http_lua_shared_dict_get(void *zone, char *kdata, size_t klen, ngx_http_lua_value_t *val);
+            ]]
+
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", 1234567)
+            dogs:set("bar", 3.14159)
+
+            local buf = ffi.new("char[?]", 4)
+
+            ffi.copy(buf, "dogs", 4)
+            zone = ffi.C.ngx_http_lua_find_zone(buf, 4)
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+
+            ffi.copy(buf, "foo", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("foo: rc=", tonumber(rc),
+                ", type=", val[0].type,
+                ", val=", tonumber(val[0].value.n))
+
+            ffi.copy(buf, "bar", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("bar: rc=", tonumber(rc),
+                ", type=", val[0].type,
+                ", val=", tonumber(val[0].value.n))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+foo: rc=0, type=3, val=1234567
+bar: rc=0, type=3, val=3.14159
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: boolean typed value
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local ffi = require "ffi"
+
+            ffi.cdef[[
+                typedef struct {
+                    size_t  len;
+                    char   *data;
+                } ngx_str_t;
+
+                typedef struct {
+                    uint8_t         type;
+
+                    union {
+                        int         b; /* boolean */
+                        double      n; /* number */
+                        ngx_str_t   s; /* string */
+                    } value;
+
+                } ngx_http_lua_value_t;
+
+                void *ngx_http_lua_find_zone(char *data, size_t len);
+                intptr_t ngx_http_lua_shared_dict_get(void *zone, char *kdata, size_t klen, ngx_http_lua_value_t *val);
+            ]]
+
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", true)
+            dogs:set("bar", false)
+
+            local buf = ffi.new("char[?]", 4)
+
+            ffi.copy(buf, "dogs", 4)
+            zone = ffi.C.ngx_http_lua_find_zone(buf, 4)
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+
+            ffi.copy(buf, "foo", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("foo: rc=", tonumber(rc),
+                ", type=", tonumber(val[0].type),
+                ", val=", tonumber(val[0].value.b))
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+            ffi.copy(buf, "bar", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("bar: rc=", tonumber(rc),
+                ", type=", tonumber(val[0].type),
+                ", val=", tonumber(val[0].value.b))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+foo: rc=0, type=1, val=1
+bar: rc=0, type=1, val=0
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: key not found
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local ffi = require "ffi"
+
+            ffi.cdef[[
+                typedef struct {
+                    size_t  len;
+                    char   *data;
+                } ngx_str_t;
+
+                typedef struct {
+                    uint8_t         type;
+
+                    union {
+                        int         b; /* boolean */
+                        double      n; /* number */
+                        ngx_str_t   s; /* string */
+                    } value;
+
+                } ngx_http_lua_value_t;
+
+                void *ngx_http_lua_find_zone(char *data, size_t len);
+                intptr_t ngx_http_lua_shared_dict_get(void *zone, char *kdata, size_t klen, ngx_http_lua_value_t *val);
+            ]]
+
+            local dogs = ngx.shared.dogs
+            dogs:flush_all()
+
+            local buf = ffi.new("char[?]", 4)
+
+            ffi.copy(buf, "dogs", 4)
+            zone = ffi.C.ngx_http_lua_find_zone(buf, 4)
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+
+            ffi.copy(buf, "foo", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("foo: rc=", tonumber(rc))
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+            ffi.copy(buf, "bar", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("bar: rc=", tonumber(rc))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+foo: rc=-5
+bar: rc=-5
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: string typed value
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local ffi = require "ffi"
+
+            ffi.cdef[[
+                typedef struct {
+                    size_t  len;
+                    char   *data;
+                } ngx_str_t;
+
+                typedef struct {
+                    uint8_t         type;
+
+                    union {
+                        int         b; /* boolean */
+                        double      n; /* number */
+                        ngx_str_t   s; /* string */
+                    } value;
+
+                } ngx_http_lua_value_t;
+
+                void *ngx_http_lua_find_zone(char *data, size_t len);
+                intptr_t ngx_http_lua_shared_dict_get(void *zone, char *kdata, size_t klen, ngx_http_lua_value_t *val);
+            ]]
+
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", "hello world")
+            dogs:set("bar", "")
+
+            local buf = ffi.new("char[?]", 4)
+
+            ffi.copy(buf, "dogs", 4)
+            zone = ffi.C.ngx_http_lua_find_zone(buf, 4)
+
+            local s = ffi.new("char[?]", 20)
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+            val[0].value.s.len = 20
+            val[0].value.s.data = s
+
+            ffi.copy(buf, "foo", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("foo: rc=", tonumber(rc),
+                ", type=", tonumber(val[0].type),
+                ", val=", ffi.string(val[0].value.s.data, val[0].value.s.len),
+                ", len=", tonumber(val[0].value.s.len))
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+            val[0].value.s.len = 20
+            val[0].value.s.data = s
+
+            ffi.copy(buf, "bar", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("bar: rc=", tonumber(rc),
+                ", type=", tonumber(val[0].type),
+                ", val=", ffi.string(val[0].value.s.data, val[0].value.s.len),
+                ", len=", tonumber(val[0].value.s.len))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+foo: rc=0, type=4, val=hello world, len=11
+bar: rc=0, type=4, val=, len=0
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: nil typed value
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location = /test {
+        content_by_lua '
+            local ffi = require "ffi"
+
+            ffi.cdef[[
+                typedef struct {
+                    size_t  len;
+                    char   *data;
+                } ngx_str_t;
+
+                typedef struct {
+                    uint8_t         type;
+
+                    union {
+                        int         b; /* boolean */
+                        double      n; /* number */
+                        ngx_str_t   s; /* string */
+                    } value;
+
+                } ngx_http_lua_value_t;
+
+                void *ngx_http_lua_find_zone(char *data, size_t len);
+                intptr_t ngx_http_lua_shared_dict_get(void *zone, char *kdata, size_t klen, ngx_http_lua_value_t *val);
+            ]]
+
+            local dogs = ngx.shared.dogs
+            dogs:set("foo", nil)
+
+            local buf = ffi.new("char[?]", 4)
+
+            ffi.copy(buf, "dogs", 4)
+            zone = ffi.C.ngx_http_lua_find_zone(buf, 4)
+
+            local val = ffi.new("ngx_http_lua_value_t[?]", 1)
+
+            ffi.copy(buf, "foo", 3)
+            local rc = ffi.C.ngx_http_lua_shared_dict_get(zone, buf, 3, val)
+            ngx.say("foo: rc=", tonumber(rc))
+        ';
+    }
+--- request
+GET /test
+--- response_body
+foo: rc=-5
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/100-client-abort.t b/src/lua/lua-nginx-module/t/100-client-abort.t
--- a/src/lua/lua-nginx-module/t/100-client-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/100-client-abort.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1068 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = <<_EOC_;
+$t::StapThread::GCScript
+
+F(ngx_http_lua_check_broken_connection) {
+    println("lua check broken conn")
+}
+
+F(ngx_http_lua_request_cleanup) {
+    println("lua req cleanup")
+}
+_EOC_
+
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 1);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 2: sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 3: sleep + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: subrequest + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location /sub {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 5: subrequest + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        content_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location /sub {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: fail
+lua req cleanup
+delete thread 1
+
+--- wait: 1.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- error_log
+bad things happen
+
+
+
+=== TEST 6: subrequest + stop (proxy, ignore client abort)
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location = /sub {
+        proxy_ignore_client_abort on;
+        proxy_pass http://agentzh.org:12345/;
+    }
+
+    location = /sleep {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 7: subrequest + stop (proxy, check client abort)
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.location.capture("/sub")
+            error("bad things happen")
+        ';
+    }
+
+    location = /sub {
+        proxy_ignore_client_abort off;
+        proxy_pass http://agentzh.org:12345/;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 8: need body on + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        lua_need_request_body on;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 9: ngx.req.read_body + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.sleep(1)
+        ';
+        log_by_lua '
+            ngx.log(ngx.NOTICE, "here in log by lua")
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+here in log by lua
+
+
+
+=== TEST 10: ngx.req.socket + receive() + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive()
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 11: ngx.req.socket + receive(N) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(5)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 0.1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 12: ngx.req.socket + receive(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(2)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:lua check broken conn
+terminate 1: ok
+delete thread 1
+lua req cleanup|lua check broken conn
+lua req cleanup
+delete thread 1)$
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: ngx.req.socket + m * receive(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            sock:receive(2)
+            sock:receive(2)
+            sock:receive(1)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 14: ngx.req.socket + receiveuntil + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            local it = sock:receiveuntil("\\n")
+            it()
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 15: ngx.req.socket + receiveuntil + it(n) + sleep + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            local it = sock:receiveuntil("\\n")
+            it(2)
+            it(3)
+            ngx.sleep(1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- timeout: 0.2
+--- wait: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 16: cosocket + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.req.discard_body()
+
+            local sock, err = ngx.socket.tcp()
+            if not sock then
+                ngx.log(ngx.ERR, "failed to get socket: ", err)
+                return
+            end
+
+            ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to connect: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("blpop nonexist 2\\r\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "failed to send query: ", err)
+                return
+            end
+
+            -- ngx.log(ngx.ERR, "about to receive")
+
+            local res, err = sock:receive()
+            if not res then
+                ngx.log(ngx.ERR, "failed to receive query: ", err)
+                return
+            end
+
+            ngx.log(ngx.ERR, "res: ", res)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 17: ngx.req.socket + receive n < content-length + ignore
+--- config
+    location /t {
+        lua_check_client_abort off;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            local res, err, part = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err, ": ", part)
+                return
+            end
+            error("bad")
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 100\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+failed to receive: client aborted: hello
+
+
+
+=== TEST 18: ngx.req.socket + receive n < content-length + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            local res, err, part = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err, ": ", part)
+                return
+            end
+            error("bad")
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 100\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+failed to receive: client aborted: hello
+
+
+
+=== TEST 19: ngx.req.socket + receive n == content-length + stop
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            ngx.sleep(0.1)
+            error("bad")
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 5\r
+\r
+hello"
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out_like
+^(?:lua check broken conn
+terminate 1: ok
+delete thread 1
+lua req cleanup|lua check broken conn
+lua check broken conn
+lua req cleanup
+delete thread 1)$
+
+--- shutdown
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+
+
+
+=== TEST 20: ngx.req.socket + receive n == content-length + ignore
+--- config
+    location /t {
+        content_by_lua '
+            local sock = ngx.req.socket()
+            local res, err = sock:receive("*a")
+            if not res then
+                ngx.log(ngx.NOTICE, "failed to receive: ", err)
+                return
+            end
+            ngx.say("done")
+        ';
+    }
+--- raw_request eval
+"POST /t HTTP/1.0\r
+Host: localhost\r
+Connection: close\r
+Content-Length: 5\r
+\r
+hello"
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+lua req cleanup
+
+--- shutdown: 1
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 21: ngx.req.read_body + sleep + stop (log handler still gets called)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.sleep(0.1)
+        ';
+    }
+--- request
+POST /t
+hello
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+lua check broken conn
+lua req cleanup
+delete thread 1
+
+--- shutdown: 1
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+--- SKIP
+
+
+
+=== TEST 22: exec to lua + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.exec("/t2")
+        ';
+    }
+
+    location = /t2 {
+        lua_check_client_abort off;
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+terminate 2: ok
+delete thread 2
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+
+
+
+=== TEST 23: exec to proxy + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.exec("/t2")
+        ';
+    }
+
+    location = /t2 {
+        proxy_ignore_client_abort on;
+        proxy_pass http://127.0.0.1:$server_port/sleep;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 24: exec (named location) to proxy + ignore
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.exec("@t2")
+        ';
+    }
+
+    location @t2 {
+        proxy_ignore_client_abort on;
+        proxy_pass http://127.0.0.1:$server_port/sleep;
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+lua req cleanup
+delete thread 1
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 25: bug in ngx_http_upstream_test_connect for kqueue
+--- config
+    location /t {
+        proxy_pass http://127.0.0.1:1234/;
+    }
+--- request
+GET /t
+--- response_body_like: 502 Bad Gateway
+--- error_code: 502
+--- error_log eval
+qr{connect\(\) failed \(\d+: Connection refused\) while connecting to upstream}
+--- no_error_log
+[alert]
+
+
+
+=== TEST 26: sleep (default off)
+--- config
+    location /t {
+        content_by_lua '
+            ngx.sleep(1)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+lua req cleanup
+
+--- wait: 1
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
+
+
+=== TEST 27: ngx.say
+--- config
+    location /t {
+        postpone_output 1;
+        content_by_lua '
+            ngx.sleep(0.2)
+            local ok, err = ngx.say("hello")
+            if not ok then
+                ngx.log(ngx.WARN, "say failed: ", err)
+                return
+            end
+        ';
+    }
+--- request
+GET /t
+
+--- wait: 0.2
+--- timeout: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+--- error_log
+say failed: nginx output filter error
+
+
+
+=== TEST 28: ngx.print
+--- config
+    location /t {
+        postpone_output 1;
+        content_by_lua '
+            ngx.sleep(0.2)
+            local ok, err = ngx.print("hello")
+            if not ok then
+                ngx.log(ngx.WARN, "print failed: ", err)
+                return
+            end
+        ';
+    }
+--- request
+GET /t
+
+--- wait: 0.2
+--- timeout: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+--- error_log
+print failed: nginx output filter error
+
+
+
+=== TEST 29: ngx.send_headers
+--- config
+    location /t {
+        postpone_output 1;
+        content_by_lua '
+            ngx.sleep(0.2)
+            local ok, err = ngx.send_headers()
+            if not ok then
+                ngx.log(ngx.WARN, "send headers failed: ", err)
+                return
+            end
+            ngx.log(ngx.WARN, "send headers succeeded")
+        ';
+    }
+--- request
+GET /t
+
+--- wait: 0.2
+--- timeout: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+--- error_log
+send headers succeeded
+
+
+
+=== TEST 30: ngx.flush
+--- config
+    location /t {
+        #postpone_output 1;
+        content_by_lua '
+            ngx.say("hello")
+            ngx.sleep(0.2)
+            local ok, err = ngx.flush()
+            if not ok then
+                ngx.log(ngx.WARN, "flush failed: ", err)
+                return
+            end
+            ngx.log(ngx.WARN, "flush succeeded")
+        ';
+    }
+--- request
+GET /t
+
+--- wait: 0.2
+--- timeout: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+--- error_log
+flush succeeded
+
+
+
+=== TEST 31: ngx.eof
+--- config
+    location /t {
+        postpone_output 1;
+        content_by_lua '
+            ngx.sleep(0.2)
+            local ok, err = ngx.eof()
+            if not ok then
+                ngx.log(ngx.WARN, "eof failed: ", err)
+                return
+            end
+            ngx.log(ngx.WARN, "eof succeeded")
+        ';
+    }
+--- request
+GET /t
+
+--- wait: 0.2
+--- timeout: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+eof succeeded
+--- error_log
+eof failed: nginx output filter error
+
diff -rNu a/src/lua/lua-nginx-module/t/101-on-abort.t b/src/lua/lua-nginx-module/t/101-on-abort.t
--- a/src/lua/lua-nginx-module/t/101-on-abort.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/101-on-abort.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,791 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = <<_EOC_;
+$t::StapThread::GCScript
+
+F(ngx_http_lua_check_broken_connection) {
+    println("lua check broken conn")
+}
+
+F(ngx_http_lua_request_cleanup) {
+    println("lua req cleanup")
+}
+_EOC_
+
+our $StapScript = $t::StapThread::StapScript;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 4 + 16);
+
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= '11211';
+$ENV{TEST_NGINX_REDIS_PORT} ||= '6379';
+
+#no_shuffle();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ignore the client abort event in the user callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+terminate 1: ok
+delete thread 2
+delete thread 1
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.7
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 2: abort in the user callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 3: ngx.exit(499) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 4: ngx.exit(408) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(408)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.1
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 5: ngx.exit(-1) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(-1)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 1;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 6: ngx.exit(0) with pending subrequest
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(0)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.location.capture("/sleep")
+            ngx.log(ngx.ERR, "main handler done")
+        ';
+    }
+
+    location = /sleep {
+        echo_sleep 0.7;
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: fail
+terminate 1: ok
+delete thread 2
+delete thread 1
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.6
+--- ignore_response
+--- error_log
+client prematurely closed connection
+on abort called
+lua user thread aborted: runtime error: [string "content_by_lua"]:4: attempt to abort with pending subrequests
+main handler done
+
+
+
+=== TEST 7: accessing cosocket in callback
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                local sock = ngx.socket.tcp()
+                local ok, err = sock:connect("127.0.0.1", $TEST_NGINX_REDIS_PORT)
+                if not ok then
+                    ngx.log(ngx.ERR, "failed to connect to redis: ", err)
+                    ngx.exit(499)
+                end
+                local bytes, err = sock:send("flushall\\r\\n")
+                if not bytes then
+                    ngx.log(ngx.ERR, "failed to send query: ", err)
+                    ngx.exit(499)
+                end
+
+                local res, err = sock:receive()
+                if not res then
+                    ngx.log(ngx.ERR, "failed to receive: ", err)
+                    ngx.exit(499)
+                end
+                ngx.log(ngx.NOTICE, "callback done: ", res)
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.2
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+callback done: +OK
+
+
+
+=== TEST 8: ignore the client abort event in the user callback (no check)
+--- config
+    location /t {
+        lua_check_client_abort off;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("cannot set on_abort: ", err)
+                return
+            end
+
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+terminate 1: ok
+delete thread 1
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- response_body
+cannot set on_abort: lua_check_client_abort is off
+--- no_error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 9: regsiter on_abort callback but no client abortion
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.say("done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+lua req cleanup
+delete thread 2
+
+--- response_body
+done
+--- no_error_log
+[error]
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 10: ignore the client abort event in the user callback (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.7)
+                ngx.log(ngx.NOTICE, "main handler done")
+            end)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+lua check broken conn
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+lua req cleanup
+
+--- timeout: 0.2
+--- abort
+--- wait: 0.7
+--- ignore_response
+--- no_error_log
+[error]
+--- error_log
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 11: abort in the user callback (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.7)
+                ngx.log(ngx.NOTICE, "main handler done")
+            end)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 3
+
+--- timeout: 0.2
+--- wait: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 12: regsiter on_abort callback but no client abortion (uthread)
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.1)
+                ngx.say("done")
+            end)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+spawn user thread 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+lua req cleanup
+delete thread 2
+
+--- response_body
+done
+--- no_error_log
+[error]
+client prematurely closed connection
+on abort called
+main handler done
+
+
+
+=== TEST 13: regsiter on_abort callback multiple times
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("1: cannot set on_abort: " .. err)
+                return
+            end
+
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+            end)
+
+            if not ok then
+                ngx.say("2: cannot set on_abort: " .. err)
+                return
+            end
+
+            ngx.thread.spawn(function ()
+                ngx.sleep(0.1)
+                ngx.say("done")
+            end)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+lua req cleanup
+delete thread 2
+
+--- response_body
+2: cannot set on_abort: duplicate call
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: abort with 499 in the user callback, but the header is already sent
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(499)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.send_headers()
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 15: abort with 444 in the user callback, but the header is already sent
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(444)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.send_headers()
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 16: abort with 408 in the user callback, but the header is already sent
+--- config
+    location /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            local ok, err = ngx.on_abort(function ()
+                ngx.log(ngx.NOTICE, "on abort called")
+                ngx.exit(408)
+            end)
+
+            if not ok then
+                error("cannot set on_abort: " .. err)
+            end
+
+            ngx.send_headers()
+            ngx.sleep(0.7)
+            ngx.log(ngx.NOTICE, "main handler done")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+lua check broken conn
+terminate 2: ok
+lua req cleanup
+delete thread 2
+delete thread 1
+
+--- timeout: 0.2
+--- wait: 0.1
+--- abort
+--- ignore_response
+--- no_error_log
+[error]
+main handler done
+--- error_log
+client prematurely closed connection
+on abort called
+
+
+
+=== TEST 17: GC issue with the on_abort thread object
+--- config
+    location = /t {
+        lua_check_client_abort on;
+        content_by_lua '
+            ngx.on_abort(function () end)
+            collectgarbage()
+            ngx.sleep(60)
+        ';
+    }
+--- request
+    GET /t
+--- abort
+--- timeout: 0.2
+--- ignore_response
+--- no_error_log
+[error]
+[alert]
+
diff -rNu a/src/lua/lua-nginx-module/t/102-req-start-time.t b/src/lua/lua-nginx-module/t/102-req-start-time.t
--- a/src/lua/lua-nginx-module/t/102-req-start-time.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/102-req-start-time.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,117 @@
+# -*- mode: conf -*-
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: start time
+--- config
+    location = /start {
+        content_by_lua 'ngx.say(ngx.req.start_time())';
+    }
+--- request
+GET /start
+--- response_body_like: ^\d{10,}(\.\d+)?$
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: start time in set_by_lua
+--- config
+    location = /start {
+        set_by_lua $a 'return ngx.req.start_time()';
+        echo $a;
+    }
+--- request
+GET /start
+--- response_body_like: ^\d{10,}(\.\d+)?$
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: request time
+--- config
+    location = /req_time {
+        content_by_lua '
+            ngx.sleep(0.1)
+
+            local req_time = ngx.now() - ngx.req.start_time()
+
+            ngx.say(req_time)
+            ngx.say(ngx.req.start_time() < ngx.now())
+        ';
+    }
+--- request
+GET /req_time
+--- response_body_like chop
+^(?:0\.[12]|0\.099)\d*
+true$
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: request time update
+--- config
+    location = /req_time {
+            content_by_lua '
+               ngx.sleep(0.1)
+
+               local req_time = ngx.now() - ngx.req.start_time()
+
+               ngx.sleep(0.1)
+
+               ngx.update_time()
+
+               local req_time_updated = ngx.now() - ngx.req.start_time()
+
+               ngx.say(req_time)
+               ngx.say(req_time_updated)
+               ngx.say(req_time_updated > req_time)
+            ';
+    }
+--- request
+GET /req_time
+--- response_body_like chomp
+^(?:0\.[12]|0\.099)\d*
+0\.\d+
+true$
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: init_by_lua
+--- http_config
+    init_by_lua '
+        time = ngx.req.start_time()
+    ';
+--- config
+    location = /t {
+        content_by_lua '
+            ngx.say(time)
+        ';
+    }
+--- request
+    GET /t
+--- response_body
+--- no_error_log
+[error]
+--- SKIP
+
diff -rNu a/src/lua/lua-nginx-module/t/103-req-http-ver.t b/src/lua/lua-nginx-module/t/103-req-http-ver.t
--- a/src/lua/lua-nginx-module/t/103-req-http-ver.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/103-req-http-ver.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,50 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+#repeat_each(1);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: HTTP 1.1
+--- config
+    location /t {
+        content_by_lua '
+            ngx.say(ngx.req.http_version())
+        ';
+    }
+--- request
+GET /t
+--- response_body
+1.1
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: HTTP 1.0
+--- config
+    location /t {
+        content_by_lua '
+            ngx.say(ngx.req.http_version())
+        ';
+    }
+--- request
+GET /t HTTP/1.0
+--- response_body
+1
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/104-req-raw-header.t b/src/lua/lua-nginx-module/t/104-req-raw-header.t
--- a/src/lua/lua-nginx-module/t/104-req-raw-header.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/104-req-raw-header.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,597 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3 + 6);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: small header
+--- config
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: large header
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+GET /t
+--- more_headers eval
+CORE::join "\n", map { "Header$_: value-$_" } 1..512
+
+--- response_body eval
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 3: large header (no request line)
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header(true))
+        ';
+    }
+--- request
+GET /t
+--- more_headers eval
+CORE::join "\n", map { "Header$_: value-$_" } 1..512
+
+--- response_body eval
+qq{Host: localhost\r
+Connection: Close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 4: small header (no request line)
+--- config
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header(true))
+        ';
+    }
+--- request
+GET /t
+--- response_body eval
+qq{Host: localhost\r
+Connection: Close\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: small header (no request line, with leading CRLF)
+--- config
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header(true))
+        ';
+    }
+--- raw_request eval
+"\r\nGET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+\r
+"
+--- response_body eval
+qq{Host: localhost\r
+Connection: close\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: small header, with leading CRLF
+--- config
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- raw_request eval
+"\r\nGET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+\r
+"
+--- response_body eval
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: large header, with leading CRLF
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+
+--- raw_request eval
+"\r\nGET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+".
+(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- response_body eval
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 8: large header, with leading CRLF, excluding request line
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header(true))
+        ';
+    }
+
+--- raw_request eval
+"\r\nGET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+".
+(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- response_body eval
+qq{Host: localhost\r
+Connection: close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 9: large header, with lots of leading CRLF, excluding request line
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header(true))
+        ';
+    }
+
+--- raw_request eval
+("\r\n" x 534) . "GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+".
+(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- response_body eval
+qq{Host: localhost\r
+Connection: close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 10: small header, pipelined
+--- config
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- pipelined_requests eval
+["GET /t", "GET /th"]
+
+--- more_headers
+Foo: bar
+
+--- response_body eval
+[qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: keep-alive\r
+Foo: bar\r
+\r
+}, qq{GET /th HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+Foo: bar\r
+\r
+}]
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: large header, pipelined
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- pipelined_requests eval
+["GET /t", "GET /t"]
+
+--- more_headers eval
+CORE::join "\n", map { "Header$_: value-$_" } 1..512
+
+--- response_body eval
+my $headers = (CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\n\r\n";
+
+[qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: keep-alive\r
+$headers},
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+$headers}]
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 12: small header, multi-line header
+--- config
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+Foo: bar baz\r
+  blah\r
+\r
+"
+--- response_body eval
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+Foo: bar baz\r
+  blah\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: large header, multi-line header
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 50 567;
+    location /t {
+        content_by_lua '
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+
+--- raw_request eval
+my $headers = (CORE::join "\r\n", map { "Header$_: value-$_\r\n hello $_ world blah blah" } 1..512) . "\r\n\r\n";
+
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+$headers}
+
+--- response_body eval
+qq{GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_\r\n hello $_ world blah blah" } 1..512) . "\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 14: small header (POST body)
+--- config
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+POST /t
+hello
+--- response_body eval
+qq{POST /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+Content-Length: 5\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: small header (POST body) - in subrequests
+--- config
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/t")
+            ngx.print(res.body)
+        ';
+    }
+
+--- request
+POST /main
+hello
+--- response_body eval
+qq{POST /main HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+Content-Length: 5\r
+\r
+}
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: large header (POST body)
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+POST /t
+hello
+--- more_headers eval
+CORE::join"\n", map { "Header$_: value-$_" } 1..512
+
+--- response_body eval
+qq{POST /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\nContent-Length: 5\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 17: large header (POST body) - in subrequests
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 561;
+    location /t {
+        content_by_lua '
+            ngx.req.read_body()
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+
+    location /main {
+        content_by_lua '
+            local res = ngx.location.capture("/t")
+            ngx.print(res.body)
+        ';
+    }
+--- request
+POST /main
+hello
+--- more_headers eval
+CORE::join"\n", map { "Header$_: value-$_" } 1..512
+
+--- response_body eval
+qq{POST /main HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..512) . "\r\nContent-Length: 5\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 18: large header (POST body) - r->header_end is outside r->header_in
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 564;
+    location /t {
+        content_by_lua '
+            -- ngx.req.read_body()
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+POST /t
+hello
+--- more_headers eval
+CORE::join("\n", map { "Header$_: value-$_" } 1..80) . "\nA: abcdefghijklmnopqrs\n"
+
+--- response_body eval
+qq{POST /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..80)
+. "\r\nA: abcdefghijklmnopqrs\r\nContent-Length: 5\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 19: large header (POST body) - r->header_end is outside r->header_in (2)
+--- config
+    client_header_buffer_size 10;
+    large_client_header_buffers 30 564;
+    location /t {
+        content_by_lua '
+            -- ngx.req.read_body()
+            ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+POST /t
+hello
+--- more_headers eval
+CORE::join("\n", map { "Header$_: value-$_" } 1..52) . "\nA: abcdefghijklmnopqrs\n"
+
+--- response_body eval
+qq{POST /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+}
+.(CORE::join "\r\n", map { "Header$_: value-$_" } 1..52)
+. "\r\nA: abcdefghijklmnopqrs\r\nContent-Length: 5\r\n\r\n"
+
+--- no_error_log
+[error]
+--- timeout: 5
+
+
+
+=== TEST 20: raw_header (the default header buffer can hold the request line, but not the header entries) - without request line)
+--- config
+    location /t {
+        content_by_lua '
+           ngx.print(ngx.req.raw_header(true))
+        ';
+    }
+--- request
+GET /t
+--- more_headers eval
+my $s = "User-Agent: curl\nBah: bah\n";
+$s .= "Accept: */*\n";
+$s .= "Cookie: " . "C" x 1200 . "\n";
+$s
+--- response_body eval
+"Host: localhost\r
+Connection: Close\r
+User-Agent: curl\r
+Bah: bah\r
+Accept: */*\r
+Cookie: " . ("C" x 1200) . "\r\n\r\n"
+--- no_error_log
+[error]
+
+
+
+=== TEST 21: raw_header (the default header buffer can hold the request line, but not the header entries) - with request line)
+--- config
+    location /t {
+        content_by_lua '
+           ngx.print(ngx.req.raw_header())
+        ';
+    }
+--- request
+GET /t
+--- more_headers eval
+my $s = "User-Agent: curl\nBah: bah\n";
+$s .= "Accept: */*\n";
+$s .= "Cookie: " . "C" x 1200 . "\n";
+$s
+--- response_body eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Connection: Close\r
+User-Agent: curl\r
+Bah: bah\r
+Accept: */*\r
+Cookie: " . ("C" x 1200) . "\r\n\r\n"
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/105-pressure.t b/src/lua/lua-nginx-module/t/105-pressure.t
--- a/src/lua/lua-nginx-module/t/105-pressure.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/105-pressure.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,55 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#log_level('debug');
+
+repeat_each(20);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+our $HtmlDir = html_dir;
+#warn $html_dir;
+
+our $Id;
+
+#no_diff();
+#no_long_string();
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+
+#no_shuffle();
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: memory issue in the "args" string option for ngx.location.capture
+--- config
+    location /test1 {
+        content_by_lua '
+            local res = ngx.location.capture("/test2/auth", {args = ngx.var.args})
+            ngx.print(res.body)
+        ';
+    }
+    location /test2 {
+        content_by_lua '
+            collectgarbage()
+            ngx.say(ngx.var.args)
+        ';
+    }
+
+--- request eval
+$::Id = int rand 10000;
+"GET /test1?parent=$::Id&name=2013031816214284300707&footprint=dsfasfwefklds"
+
+--- response_body eval
+"parent=$::Id&name=2013031816214284300707&footprint=dsfasfwefklds\n"
+
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/106-timer.t b/src/lua/lua-nginx-module/t/106-timer.t
--- a/src/lua/lua-nginx-module/t/106-timer.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/106-timer.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,2164 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 8 + 76);
+
+#no_diff();
+no_long_string();
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_HTML_DIR} = $HtmlDir;
+
+worker_connections(1024);
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple at
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f(premature)
+                print("elapsed: ", ngx.now() - begin)
+                print("timer prematurely expired: ", premature)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+timer prematurely expired: true
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:4[4-9]|5[0-6])\d*, context: ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"timer prematurely expired: false",
+]
+
+
+
+=== TEST 2: separated global env
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                foo = 3
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.06)
+            ngx.say("foo = ", foo)
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+foo = nil
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:4[4-9]|5[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 3: lua variable sharing via upvalue
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local foo
+            local function f()
+                foo = 3
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.06)
+            ngx.say("foo = ", foo)
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+foo = 3
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:4[4-9]|5[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 4: simple at (sleep in the timer callback)
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+                ngx.sleep(0.02)
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.12
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:6[4-9]|7[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 5: tcp cosocket in timer handler (short connections)
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+            local function f()
+                print("my lua timer handler")
+                local sock = ngx.socket.tcp()
+                local port = $TEST_NGINX_SERVER_PORT
+                local ok, err = sock:connect("127.0.0.1", port)
+                if not ok then
+                    fail("failed to connect: ", err)
+                    return
+                end
+
+                print("connected: ", ok)
+
+                local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+                -- req = "OK"
+
+                local bytes, err = sock:send(req)
+                if not bytes then
+                    fail("failed to send request: ", err)
+                    return
+                end
+
+                print("request sent: ", bytes)
+
+                while true do
+                    local line, err, part = sock:receive()
+                    if line then
+                        print("received: ", line)
+
+                    else
+                        if err == "closed" then
+                            break
+                        end
+                        fail("failed to receive a line: ", err, " [", part, "]")
+                        break
+                    end
+                end
+
+                ok, err = sock:close()
+                print("close: ", ok, " ", err)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+
+    location = /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"connected: 1",
+"request sent: 57",
+"received: HTTP/1.1 200 OK",
+qr/received: Server: \S+/,
+"received: Content-Type: text/plain",
+"received: Content-Length: 4",
+"received: Connection: close",
+"received: foo",
+"close: nil closed",
+]
+
+
+
+=== TEST 6: tcp cosocket in timer handler (keep-alive connections)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 7: 0 timer
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.05
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0(?:[^.]|\.00)/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 8: udp cosocket in timer handler
+--- config
+    location = /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+            local function f()
+                print("my lua timer handler")
+                local socket = ngx.socket
+                -- local socket = require "socket"
+
+                local udp = socket.udp()
+
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                udp:settimeout(1000) -- 1 sec
+
+                local ok, err = udp:setpeername("127.0.0.1", port)
+                if not ok then
+                    fail("failed to connect: ", err)
+                    return
+                end
+
+                print("connected: ", ok)
+
+                local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+                local ok, err = udp:send(req)
+                if not ok then
+                    fail("failed to send: ", err)
+                    return
+                end
+
+                local data, err = udp:receive()
+                if not data then
+                    fail("failed to receive data: ", err)
+                    return
+                end
+                print("received ", #data, " bytes: ", data)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+
+    location = /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"connected: 1",
+"received 12 bytes: \x{00}\x{01}\x{00}\x{00}\x{00}\x{01}\x{00}\x{00}OK\x{0d}\x{0a}"
+]
+
+
+
+=== TEST 9: simple at (sleep in the timer callback) - log_by_lua
+--- config
+    location /t {
+        echo hello world;
+        log_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+                ngx.sleep(0.02)
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+hello world
+
+--- wait: 0.12
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+qr/\[lua\] \[string "log_by_lua"\]:\d+: elapsed: 0\.0(?:6[4-9]|7[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 10: tcp cosocket in timer handler (keep-alive connections) - log_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        echo hello;
+        log_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+hello
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 11: tcp cosocket in timer handler (keep-alive connections) - header_filter_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        echo hello;
+        header_filter_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3
+global count = 0
+F(ngx_http_lua_header_filter) {
+    if (count++ == 10) {
+        println("header filter")
+        print_ubacktrace()
+    }
+}
+
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+hello
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 12: tcp cosocket in timer handler (keep-alive connections) - body_filter_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        echo hello;
+        body_filter_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set keep alive: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3
+global count = 0
+F(ngx_http_lua_header_filter) {
+    if (count++ == 10) {
+        println("header filter")
+        print_ubacktrace()
+    }
+}
+
+--- stap eval: $::GCScript
+--- stap_out_like chop
+create 2 in 1
+create 3 in 1
+(?:terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+|terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2)$
+
+--- response_body
+hello
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 13: tcp cosocket in timer handler (keep-alive connections) - set_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        set_by_lua $a '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+            return 32
+        ';
+        echo $a;
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3
+global count = 0
+F(ngx_http_lua_header_filter) {
+    if (count++ == 10) {
+        println("header filter")
+        print_ubacktrace()
+    }
+}
+
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+32
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 14: coroutine API
+--- config
+    location /t {
+        content_by_lua '
+            local cc, cr, cy = coroutine.create, coroutine.resume, coroutine.yield
+            local function f()
+                function f()
+                    local cnt = 0
+                    for i = 1, 20 do
+                        print("cnt = ", cnt)
+                        cy()
+                        cnt = cnt + 1
+                    end
+                end
+
+                local c = cc(f)
+                for i=1,3 do
+                    cr(c)
+                    print("after resume, i = ", i)
+                end
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"cnt = 0",
+"after resume, i = 1",
+"cnt = 1",
+"after resume, i = 2",
+"cnt = 2",
+"after resume, i = 3",
+]
+
+
+
+=== TEST 15: ngx.thread API
+--- config
+    location /t {
+        content_by_lua '
+            local function fail (...)
+                ngx.log(ngx.ERR, ...)
+            end
+            local function handle()
+                function f()
+                    print("hello in thread")
+                    return "done"
+                end
+
+                local t, err = ngx.thread.spawn(f)
+                if not t then
+                    fail("failed to spawn thread: ", err)
+                    return
+                end
+
+                print("thread created: ", coroutine.status(t))
+
+                collectgarbage()
+
+                local ok, res = ngx.thread.wait(t)
+                if not ok then
+                    fail("failed to run thread: ", res)
+                    return
+                end
+
+                print("wait result: ", res)
+            end
+            local ok, err = ngx.timer.at(0.01, handle)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"hello in thread",
+"thread created: zombie",
+"wait result: done",
+]
+
+
+
+=== TEST 16: shared dict
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local dogs = ngx.shared.dogs
+                dogs:set("foo", 32)
+                dogs:set("bah", 10502)
+                local val = dogs:get("foo")
+                print("get foo: ", val, " ", type(val))
+                val = dogs:get("bah")
+                print("get bah: ", val, " ", type(val))
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"get foo: 32 number",
+"get bah: 10502 number",
+]
+
+
+
+=== TEST 17: ngx.exit(0)
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local function g()
+                    print("BEFORE ngx.exit")
+                    ngx.exit(0)
+                end
+                g()
+                print("CANNOT REACH HERE")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"BEFORE ngx.exit",
+]
+--- no_error_log
+CANNOT REACH HERE
+API disabled
+
+
+
+=== TEST 18: ngx.exit(403)
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local function g()
+                    print("BEFORE ngx.exit")
+                    ngx.exit(403)
+                end
+                g()
+                print("CANNOT REACH HERE")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+CANNOT REACH HERE
+API disabled
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"BEFORE ngx.exit",
+]
+
+
+
+=== TEST 19: exit in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /t {
+        content_by_lua '
+            local function handle()
+                local function f()
+                    print("hello in thread")
+                    ngx.sleep(0.1)
+                    ngx.exit(0)
+                end
+
+                print("BEFORE thread spawn")
+                ngx.thread.spawn(f)
+                print("AFTER thread spawn")
+                ngx.sleep(1)
+                print("entry thread END")
+            end
+            local ok, err = ngx.timer.at(0.05, handle)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out_like chop
+(?:create 2 in 1
+terminate 1: ok
+delete thread 1
+free request
+create 3 in 2
+spawn user thread 3 in 2
+add timer 100
+add timer 1000
+expire timer 100
+terminate 3: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 3
+delete thread 2|create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+spawn user thread 3 in 2
+add timer 100
+add timer 1000
+free request
+expire timer 100
+terminate 3: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 3
+delete thread 2)$
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+API disabled
+entry thread END
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"BEFORE thread spawn",
+"hello in thread",
+"AFTER thread spawn",
+]
+
+
+
+=== TEST 20: chained timers (0 delay)
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                local ok, err = ngx.timer.at(0, g)
+                if not ok then
+                    fail("failed to set timer: ", err)
+                    return
+                end
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
+
+
+=== TEST 21: chained timers (non-zero delay)
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                local ok, err = ngx.timer.at(0.01, g)
+                if not ok then
+                    fail("failed to set timer: ", err)
+                    return
+                end
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
+
+
+=== TEST 22: multiple parallel timers
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                fail("failed to set timer: ", err)
+                return
+            end
+            local ok, err = ngx.timer.at(0.01, g)
+            if not ok then
+                fail("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
+
+
+=== TEST 23: lua_max_pending_timers
+--- http_config
+    lua_max_pending_timers 1;
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer f: ", err)
+                return
+            end
+            local ok, err = ngx.timer.at(0.01, g)
+            if not ok then
+                ngx.say("failed to set timer g: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+failed to set timer g: too many pending timers
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+[error]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+
+
+
+=== TEST 24: lua_max_pending_timers (just not exceeding)
+--- http_config
+    lua_max_pending_timers 2;
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer f: ", err)
+                return
+            end
+            local ok, err = ngx.timer.at(0.01, g)
+            if not ok then
+                ngx.say("failed to set timer g: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+[error]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
+
+
+=== TEST 25: lua_max_pending_timers - chained timers (non-zero delay) - not exceeding
+--- http_config
+    lua_max_pending_timers 1;
+
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                local ok, err = ngx.timer.at(0.01, g)
+                if not ok then
+                    fail("failed to set timer: ", err)
+                    return
+                end
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
+
+
+=== TEST 26: lua_max_pending_timers - chained timers (zero delay) - not exceeding
+--- http_config
+    lua_max_pending_timers 1;
+
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                local ok, err = ngx.timer.at(0, g)
+                if not ok then
+                    fail("failed to set timer: ", err)
+                    return
+                end
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
+
+
+=== TEST 27: lua_max_running_timers (just not enough)
+--- http_config
+    lua_max_running_timers 1;
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local f, g
+
+            g = function ()
+                ngx.sleep(0.01)
+            end
+
+            f = function ()
+                ngx.sleep(0.01)
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer f: ", err)
+                return
+            end
+            local ok, err = ngx.timer.at(0, g)
+            if not ok then
+                ngx.say("failed to set timer g: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[crit]
+[error]
+
+--- error_log
+1 lua_max_running_timers are not enough
+lua ngx.timer expired
+http lua close fake http connection
+
+
+
+=== TEST 28: lua_max_running_timers (just enough)
+--- http_config
+    lua_max_running_timers 2;
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local f, g
+
+            g = function ()
+                ngx.sleep(0.01)
+            end
+
+            f = function ()
+                ngx.sleep(0.01)
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer f: ", err)
+                return
+            end
+            local ok, err = ngx.timer.at(0, g)
+            if not ok then
+                ngx.say("failed to set timer g: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+[error]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+
+
+
+=== TEST 29: lua_max_running_timers (just enough) - 2
+--- http_config
+    lua_max_running_timers 2;
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local f, g
+
+            g = function ()
+                ngx.timer.at(0.02, f)
+                ngx.sleep(0.01)
+            end
+
+            f = function ()
+                ngx.sleep(0.01)
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer f: ", err)
+                return
+            end
+            local ok, err = ngx.timer.at(0, g)
+            if not ok then
+                ngx.say("failed to set timer g: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 1
+terminate 1: ok
+delete thread 1
+create 4 in 3
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 4: ok
+delete thread 4
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+[error]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+
+
+
+=== TEST 30: user args
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f(premature, a, b, c)
+                print("elapsed: ", ngx.now() - begin)
+                print("timer prematurely expired: ", premature)
+                print("timer user args: ", a, " ", b, " ", c)
+            end
+            local ok, err = ngx.timer.at(0.05, f, 1, "hello", true)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+timer prematurely expired: true
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:4[4-9]|5[0-6])\d*, context: ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"timer prematurely expired: false",
+"timer user args: 1 hello true",
+]
+
+
+
+=== TEST 31: use of ngx.ctx
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f(premature)
+                ngx.ctx.s = "hello"
+                print("elapsed: ", ngx.now() - begin)
+                print("timer prematurely expired: ", premature)
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+        log_by_lua return;
+    }
+--- request
+GET /t
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+timer prematurely expired: true
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: .*?, context: ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"timer prematurely expired: false",
+"lua release ngx.ctx at ref ",
+]
+
diff -rNu a/src/lua/lua-nginx-module/t/107-timer-errors.t b/src/lua/lua-nginx-module/t/107-timer-errors.t
--- a/src/lua/lua-nginx-module/t/107-timer-errors.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/107-timer-errors.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,1424 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 7);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: accessing nginx variables
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                print("uri: ", ngx.var.uri)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 2: reading ngx.status
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                print("uri: ", ngx.status)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 3: writing ngx.status
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.status = 200
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 4: ngx.req.raw_header
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                print("raw header: ", ngx.req.raw_header())
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 5: ngx.req.get_headers
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.get_headers()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 6: ngx.req.set_header
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.set_header("Foo", 32)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 7: ngx.req.clear_header
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.clear_header("Foo")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 8: ngx.req.set_uri
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.set_uri("/foo")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 9: ngx.req.set_uri_args
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.set_uri_args("foo")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 10: ngx.redirect()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.redirect("/foo")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 11: ngx.exec()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.exec("/foo")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 12: ngx.say()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.say("hello")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 13: ngx.print()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.print("hello")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 14: ngx.flush()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.flush()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 15: ngx.send_headers()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.send_headers()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 16: ngx.req.get_uri_args()
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.get_uri_args()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 17: ngx.req.read_body
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.read_body()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 18: ngx.req.discard_body
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.discard_body()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 19: ngx.req.init_body
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.init_body()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 20: ngx.header
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.header.Foo = 3
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 21: ngx.on_abort
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.on_abort(f)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 22: ngx.location.capture
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.location.capture("/")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 23: ngx.location.capture_multi
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.location.capture_multi{{"/"}}
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 24: ngx.req.get_method
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.get_method()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 25: ngx.req.set_method
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.set_method(ngx.HTTP_POST)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 26: ngx.req.http_version
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.http_version()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 27: ngx.req.get_post_args
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.get_post_args()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 28: ngx.req.get_body_data
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.get_body_data()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 29: ngx.req.get_body_file
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.get_body_file()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 30: ngx.req.set_body_data
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.set_body_data("hello")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 31: ngx.req.set_body_file
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.set_body_file("hello")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 32: ngx.req.append_body
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.append_body("hello")
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 33: ngx.req.finish_body
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.req.finish_body()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the current context/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 34: ngx.headers_sent
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.headers_sent()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 35: ngx.eof
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                ngx.eof()
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 36: ngx.req.socket
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local sock, err = ngx.req.socket()
+                if not sock then
+                    ngx.log(ngx.ERR, "failed to get req sock: ", err)
+                end
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[error\] .*? runtime error: \[string "content_by_lua"\]:3: API disabled in the context of ngx\.timer/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
diff -rNu a/src/lua/lua-nginx-module/t/108-timer-safe.t b/src/lua/lua-nginx-module/t/108-timer-safe.t
--- a/src/lua/lua-nginx-module/t/108-timer-safe.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/108-timer-safe.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1399 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 8 + 60);
+
+#no_diff();
+no_long_string();
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_HTML_DIR} = $HtmlDir;
+
+worker_connections(1024);
+run_tests();
+
+__DATA__
+
+=== TEST 1: simple at
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.05)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:4[4-9]|5[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 2: simple at (sleep in the timer callback)
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+                ngx.sleep(0.02)
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.05)
+        ';
+    }
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.12
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0\.0(?:6[4-9]|7[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 3: tcp cosocket in timer handler (short connections)
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+            local function f()
+                print("my lua timer handler")
+                local sock = ngx.socket.tcp()
+                local port = $TEST_NGINX_SERVER_PORT
+                local ok, err = sock:connect("127.0.0.1", port)
+                if not ok then
+                    fail("failed to connect: ", err)
+                    return
+                end
+
+                print("connected: ", ok)
+
+                local req = "GET /foo HTTP/1.0\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n"
+                -- req = "OK"
+
+                local bytes, err = sock:send(req)
+                if not bytes then
+                    fail("failed to send request: ", err)
+                    return
+                end
+
+                print("request sent: ", bytes)
+
+                while true do
+                    local line, err, part = sock:receive()
+                    if line then
+                        print("received: ", line)
+
+                    else
+                        if err == "closed" then
+                            break
+                        end
+                        fail("failed to receive a line: ", err, " [", part, "]")
+                        break
+                    end
+                end
+
+                ok, err = sock:close()
+                print("close: ", ok, " ", err)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.02)
+        ';
+    }
+
+    location = /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3 eval: $::GCScript
+--- stap_out2
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"connected: 1",
+"request sent: 57",
+"received: HTTP/1.1 200 OK",
+qr/received: Server: \S+/,
+"received: Content-Type: text/plain",
+"received: Content-Length: 4",
+"received: Connection: close",
+"received: foo",
+"close: nil closed",
+]
+
+
+
+=== TEST 4: tcp cosocket in timer handler (keep-alive connections)
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.02)
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3 eval: $::GCScript
+--- stap_out2
+create 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 5: 0 timer
+--- config
+    location /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 1: ok
+delete thread 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+registered timer
+
+--- wait: 0.02
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] \[string "content_by_lua"\]:\d+: elapsed: 0(?:[^.]|\.00)/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 6: udp cosocket in timer handler
+--- config
+    location = /t {
+        content_by_lua '
+            local begin = ngx.now()
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+            local function f()
+                print("my lua timer handler")
+                local socket = ngx.socket
+                -- local socket = require "socket"
+
+                local udp = socket.udp()
+
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                udp:settimeout(1000) -- 1 sec
+
+                local ok, err = udp:setpeername("127.0.0.1", port)
+                if not ok then
+                    fail("failed to connect: ", err)
+                    return
+                end
+
+                print("connected: ", ok)
+
+                local req = "\\0\\1\\0\\0\\0\\1\\0\\0flush_all\\r\\n"
+                local ok, err = udp:send(req)
+                if not ok then
+                    fail("failed to send: ", err)
+                    return
+                end
+
+                local data, err = udp:receive()
+                if not data then
+                    fail("failed to receive data: ", err)
+                    return
+                end
+                print("received ", #data, " bytes: ", data)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.05)
+        ';
+    }
+
+    location = /foo {
+        content_by_lua 'ngx.say("foo")';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"connected: 1",
+"received 12 bytes: \x{00}\x{01}\x{00}\x{00}\x{00}\x{01}\x{00}\x{00}OK\x{0d}\x{0a}"
+]
+
+
+
+=== TEST 7: simple at (sleep in the timer callback) - log_by_lua
+--- config
+    location /t {
+        echo hello world;
+        echo_sleep 0.07;
+        log_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+                ngx.sleep(0.02)
+                print("elapsed: ", ngx.now() - begin)
+            end
+            local ok, err = ngx.timer.at(0.05, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+hello world
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+qr/\[lua\] \[string "log_by_lua"\]:\d+: elapsed: 0\.0(?:6[4-9]|7[0-6])/,
+"lua ngx.timer expired",
+"http lua close fake http connection"
+]
+
+
+
+=== TEST 8: tcp cosocket in timer handler (keep-alive connections) - log_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        echo hello;
+        echo_sleep 0.01;
+        log_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+hello
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 9: tcp cosocket in timer handler (keep-alive connections) - header_filter_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        echo hello;
+        echo_sleep 0.01;
+        header_filter_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3
+global count = 0
+F(ngx_http_lua_header_filter) {
+    if (count++ == 10) {
+        println("header filter")
+        print_ubacktrace()
+    }
+}
+
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+hello
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 10: tcp cosocket in timer handler (keep-alive connections) - body_filter_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        echo_sleep 0.01;
+        echo hello;
+        body_filter_by_lua '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+        ';
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3
+global count = 0
+F(ngx_http_lua_header_filter) {
+    if (count++ == 10) {
+        println("header filter")
+        print_ubacktrace()
+    }
+}
+
+--- stap eval: $::GCScript
+--- stap_out_like chop
+create 2 in 1
+create 3 in 1
+(?:terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+|terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2)$
+
+--- response_body
+hello
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 11: tcp cosocket in timer handler (keep-alive connections) - set_by_lua
+--- http_config eval
+    "lua_package_path '$::HtmlDir/?.lua;./?.lua';"
+
+--- config
+    location = /t {
+        set_by_lua $a '
+            local begin = ngx.now()
+            local function f()
+                print("my lua timer handler")
+
+                local test = require "test"
+                local port = $TEST_NGINX_MEMCACHED_PORT
+                test.go(port)
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set timer: ", err)
+                return
+            end
+            print("registered timer")
+            return 32
+        ';
+        echo $a;
+        echo_sleep 0.01;
+    }
+
+--- user_files
+>>> test.lua
+module("test", package.seeall)
+
+local function fail(...)
+    ngx.log(ngx.ERR, ...)
+end
+
+function go(port)
+    local sock = ngx.socket.tcp()
+    local ok, err = sock:connect("127.0.0.1", port)
+    if not ok then
+        fail("failed to connect: ", err)
+        return
+    end
+
+    print("connected: ", ok, ", reused: ", sock:getreusedtimes())
+
+    local req = "flush_all\r\n"
+
+    local bytes, err = sock:send(req)
+    if not bytes then
+        fail("failed to send request: ", err)
+        return
+    end
+    print("request sent: ", bytes)
+
+    local line, err, part = sock:receive()
+    if line then
+        print("received: ", line)
+
+    else
+        fail("failed to receive a line: ", err, " [", part, "]")
+    end
+
+    local ok, err = sock:setkeepalive()
+    if not ok then
+        fail("failed to set reusable: ", err)
+    end
+end
+
+--- request
+GET /t
+--- stap2 eval: $::StapScript
+--- stap3
+global count = 0
+F(ngx_http_lua_header_filter) {
+    if (count++ == 10) {
+        println("header filter")
+        print_ubacktrace()
+    }
+}
+
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+
+--- response_body
+32
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"registered timer",
+qr/\[lua\] .*? my lua timer handler/,
+"lua ngx.timer expired",
+"http lua close fake http connection",
+qr/go\(\): connected: 1, reused: \d+/,
+"go(): request sent: 11",
+"go(): received: OK",
+]
+
+
+
+=== TEST 12: coroutine API
+--- config
+    location /t {
+        content_by_lua '
+            local cc, cr, cy = coroutine.create, coroutine.resume, coroutine.yield
+            local function f()
+                function f()
+                    local cnt = 0
+                    for i = 1, 20 do
+                        print("cnt = ", cnt)
+                        cy()
+                        cnt = cnt + 1
+                    end
+                end
+
+                local c = cc(f)
+                for i=1,3 do
+                    cr(c)
+                    print("after resume, i = ", i)
+                end
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.01)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"cnt = 0",
+"after resume, i = 1",
+"cnt = 1",
+"after resume, i = 2",
+"cnt = 2",
+"after resume, i = 3",
+]
+
+
+
+=== TEST 13: ngx.thread API
+--- config
+    location /t {
+        content_by_lua '
+            local function fail (...)
+                ngx.log(ngx.ERR, ...)
+            end
+            local function handle()
+                function f()
+                    print("hello in thread")
+                    return "done"
+                end
+
+                local t, err = ngx.thread.spawn(f)
+                if not t then
+                    fail("failed to spawn thread: ", err)
+                    return
+                end
+
+                print("thread created: ", coroutine.status(t))
+
+                collectgarbage()
+
+                local ok, res = ngx.thread.wait(t)
+                if not ok then
+                    fail("failed to run thread: ", res)
+                    return
+                end
+
+                print("wait result: ", res)
+            end
+            local ok, err = ngx.timer.at(0.01, handle)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.02)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+terminate 3: ok
+delete thread 3
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"hello in thread",
+"thread created: zombie",
+"wait result: done",
+]
+
+
+
+=== TEST 14: shared dict
+--- http_config
+    lua_shared_dict dogs 1m;
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local dogs = ngx.shared.dogs
+                dogs:set("foo", 32)
+                dogs:set("bah", 10502)
+                local val = dogs:get("foo")
+                print("get foo: ", val, " ", type(val))
+                val = dogs:get("bah")
+                print("get bah: ", val, " ", type(val))
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.02)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+terminate 2: ok
+delete thread 2
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"get foo: 32 number",
+"get bah: 10502 number",
+]
+
+
+
+=== TEST 15: ngx.exit(0)
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local function g()
+                    print("BEFORE ngx.exit")
+                    ngx.exit(0)
+                end
+                g()
+                print("CANNOT REACH HERE")
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.01)
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[alert]
+[crit]
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"BEFORE ngx.exit",
+]
+--- no_error_log
+CANNOT REACH HERE
+API disabled
+
+
+
+=== TEST 16: ngx.exit(403)
+--- config
+    location /t {
+        content_by_lua '
+            local function f()
+                local function g()
+                    print("BEFORE ngx.exit")
+                    ngx.exit(403)
+                end
+                g()
+                print("CANNOT REACH HERE")
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.01)
+        ';
+    }
+--- request
+GET /t
+--- stap2
+F(ngx_http_lua_timer_handler) {
+    println("lua timer handler")
+}
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+CANNOT REACH HERE
+API disabled
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"BEFORE ngx.exit",
+]
+
+
+
+=== TEST 17: exit in user thread (entry thread is still pending on ngx.sleep)
+--- config
+    location /t {
+        content_by_lua '
+            local function handle()
+                local function f()
+                    print("hello in thread")
+                    ngx.sleep(0.1)
+                    ngx.exit(0)
+                end
+
+                print("BEFORE thread spawn")
+                ngx.thread.spawn(f)
+                print("AFTER thread spawn")
+                ngx.sleep(1)
+                print("entry thread END")
+            end
+            local ok, err = ngx.timer.at(0.01, handle)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            ngx.sleep(0.12)
+        ';
+    }
+--- request
+GET /t
+--- stap eval
+<<'_EOC_' . $::GCScript;
+
+global timers
+
+F(ngx_http_free_request) {
+    println("free request")
+}
+
+M(timer-add) {
+    if ($arg2 == 1000 || $arg2 == 100) {
+        timers[$arg1] = $arg2
+        printf("add timer %d\n", $arg2)
+    }
+}
+
+M(timer-del) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("delete timer %d\n", tm)
+        delete timers[$arg1]
+    }
+    /*
+    if (tm == 1000) {
+        print_ubacktrace()
+    }
+    */
+}
+
+M(timer-expire) {
+    tm = timers[$arg1]
+    if (tm == 1000 || tm == 100) {
+        printf("expire timer %d\n", timers[$arg1])
+        delete timers[$arg1]
+    }
+}
+
+F(ngx_http_lua_sleep_cleanup) {
+    println("lua sleep cleanup")
+}
+_EOC_
+
+--- stap_out
+create 2 in 1
+create 3 in 2
+spawn user thread 3 in 2
+add timer 100
+add timer 1000
+expire timer 100
+terminate 3: ok
+lua sleep cleanup
+delete timer 1000
+delete thread 3
+delete thread 2
+terminate 1: ok
+delete thread 1
+free request
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+API disabled
+entry thread END
+
+--- error_log eval
+[
+"lua ngx.timer expired",
+"http lua close fake http connection",
+"BEFORE thread spawn",
+"hello in thread",
+"AFTER thread spawn",
+]
+
+
+
+=== TEST 18: chained timers (non-zero delay)
+--- config
+    location /t {
+        content_by_lua '
+            local s = ""
+
+            local function fail(...)
+                ngx.log(ngx.ERR, ...)
+            end
+
+            local function g()
+                s = s .. "[g]"
+                print("trace: ", s)
+            end
+
+            local function f()
+                local ok, err = ngx.timer.at(0.01, g)
+                if not ok then
+                    fail("failed to set timer: ", err)
+                    return
+                end
+                s = s .. "[f]"
+            end
+            local ok, err = ngx.timer.at(0.01, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            s = "[m]"
+            ngx.sleep(0.03)
+        ';
+    }
+--- request
+GET /t
+
+--- stap2 eval: $::StapScript
+--- stap eval: $::GCScript
+--- stap_out
+create 2 in 1
+create 3 in 2
+terminate 2: ok
+delete thread 2
+terminate 3: ok
+delete thread 3
+terminate 1: ok
+delete thread 1
+
+--- response_body
+registered timer
+
+--- wait: 0.1
+--- no_error_log
+[error]
+[alert]
+[crit]
+
+--- error_log
+lua ngx.timer expired
+http lua close fake http connection
+trace: [m][f][g]
+
diff -rNu a/src/lua/lua-nginx-module/t/109-timer-hup.t b/src/lua/lua-nginx-module/t/109-timer-hup.t
--- a/src/lua/lua-nginx-module/t/109-timer-hup.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/109-timer-hup.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,216 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+our $SkipReason;
+
+BEGIN {
+    if ($ENV{TEST_NGINX_CHECK_LEAK}) {
+        $SkipReason = "unavailable for the hup tests";
+
+    } else {
+        $ENV{TEST_NGINX_USE_HUP} = 1;
+        undef $ENV{TEST_NGINX_USE_STAP};
+    }
+}
+
+use lib 'lib';
+use t::TestNginxLua $SkipReason ? (skip_all => $SkipReason) : ();
+
+
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * 45;
+
+#no_diff();
+no_long_string();
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_HTML_DIR} = $HtmlDir;
+
+worker_connections(1024);
+run_tests();
+
+__DATA__
+
+=== TEST 1: single timer
+--- config
+    location /t {
+        content_by_lua '
+            local f, err = io.open("t/servroot/logs/nginx.pid", "r")
+            if not f then
+                ngx.say("failed to open nginx.pid: ", err)
+                return
+            end
+
+            local pid = f:read()
+            -- ngx.say("master pid: [", pid, "]")
+
+            f:close()
+
+            local i = 0
+            local function f(premature)
+                i = i + 1
+                print("timer prematurely expired: ", premature)
+                print("in callback: hello, ", i)
+            end
+            local ok, err = ngx.timer.at(3, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            os.execute("kill -HUP " .. pid)
+        ';
+    }
+--- request
+GET /t
+
+--- response_body
+registered timer
+
+--- wait: 0.3
+--- no_error_log
+[error]
+[alert]
+[crit]
+in callback: hello, 2
+timer prematurely expired: false
+
+--- error_log
+lua abort pending timers
+lua ngx.timer expired
+http lua close fake http connection
+in callback: hello, 1
+timer prematurely expired: true
+
+
+
+=== TEST 2: multiple timers
+--- config
+    location /t {
+        content_by_lua '
+            local f, err = io.open("t/servroot/logs/nginx.pid", "r")
+            if not f then
+                ngx.say("failed to open nginx.pid: ", err)
+                return
+            end
+
+            local pid = f:read()
+            -- ngx.say("master pid: [", pid, "]")
+
+            f:close()
+
+            local i = 0
+            local function f(premature)
+                i = i + 1
+                print("timer prematurely expired: ", premature)
+                print("in callback: hello, ", i, "!")
+            end
+            for i = 1, 10 do
+                local ok, err = ngx.timer.at(3, f)
+                if not ok then
+                    ngx.say("failed to set timer: ", err)
+                    return
+                end
+            end
+            ngx.say("registered timers")
+            os.execute("kill -HUP " .. pid)
+        ';
+    }
+--- request
+GET /t
+
+--- response_body
+registered timers
+
+--- wait: 0.3
+--- no_error_log
+[error]
+[alert]
+[crit]
+in callback: hello, 11!
+timer prematurely expired: false
+
+--- error_log
+lua abort pending timers
+lua ngx.timer expired
+http lua close fake http connection
+in callback: hello, 1!
+in callback: hello, 2!
+in callback: hello, 3!
+in callback: hello, 4!
+in callback: hello, 5!
+in callback: hello, 6!
+in callback: hello, 7!
+in callback: hello, 8!
+in callback: hello, 9!
+in callback: hello, 10!
+timer prematurely expired: true
+
+
+
+=== TEST 3: trying to add new timer after HUP reload
+--- config
+    location /t {
+        content_by_lua '
+            local f, err = io.open("t/servroot/logs/nginx.pid", "r")
+            if not f then
+                ngx.say("failed to open nginx.pid: ", err)
+                return
+            end
+
+            local pid = f:read()
+            -- ngx.say("master pid: [", pid, "]")
+
+            f:close()
+
+            local function f(premature)
+                print("timer prematurely expired: ", premature)
+                local ok, err = ngx.timer.at(0, f)
+                if not ok then
+                    print("failed to register a new timer after reload: ", err)
+                else
+                    print("registered a new timer after reload")
+                end
+            end
+            local ok, err = ngx.timer.at(3, f)
+            if not ok then
+                ngx.say("failed to set timer: ", err)
+                return
+            end
+            ngx.say("registered timer")
+            os.execute("kill -HUP " .. pid)
+        ';
+    }
+--- request
+GET /t
+
+--- response_body
+registered timer
+
+--- wait: 0.2
+--- no_error_log
+[error]
+[alert]
+[crit]
+in callback: hello, 2
+timer prematurely expired: false
+
+--- error_log
+lua abort pending timers
+lua ngx.timer expired
+http lua close fake http connection
+timer prematurely expired: true
+failed to register a new timer after reload: process exiting, context: ngx.timer
+
diff -rNu a/src/lua/lua-nginx-module/t/110-etag.t b/src/lua/lua-nginx-module/t/110-etag.t
--- a/src/lua/lua-nginx-module/t/110-etag.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/110-etag.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,85 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: If-None-Match true
+--- config
+    location /t {
+        content_by_lua '
+            ngx.header["ETag"] = "123456789"
+            ngx.header.last_modified = "Thu, 10 May 2012 07:50:59 GMT"
+            ngx.say(ngx.var.http_if_none_match)
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+If-None-Match: 123456789
+If-Modified-Since: Thu, 10 May 2012 07:50:59 GMT
+--- response_body
+--- error_code: 304
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: If-None-Match false
+--- config
+    location /t {
+        etag on;
+        content_by_lua '
+            ngx.header["ETag"] = "123456789"
+            ngx.header.last_modified = "Thu, 10 May 2012 07:50:59 GMT"
+            ngx.say(ngx.var.http_if_none_match)
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+If-None-Match: 123456780
+If-Modified-Since: Thu, 10 May 2012 07:50:59 GMT
+--- response_body
+123456780
+--- no_error_log
+[error]
+--- skip_nginx: 3: < 1.3.3
+
+
+
+=== TEST 3: Etag clear
+--- config
+    location /t {
+        etag on;
+        content_by_lua '
+            ngx.header["ETag"] = "123456789"
+            ngx.header.last_modified = "Thu, 10 May 2012 07:50:59 GMT"
+            ngx.header["ETag"] = nil
+            ngx.say(ngx.var.http_if_none_match)
+        ';
+    }
+--- request
+GET /t
+--- more_headers
+If-None-Match: 123456789
+If-Modified-Since: Thu, 10 May 2012 07:50:59 GMT
+--- response_body
+123456789
+--- no_error_log
+[error]
+--- skip_nginx: 3: < 1.3.3
+
diff -rNu a/src/lua/lua-nginx-module/t/111-req-header-ua.t b/src/lua/lua-nginx-module/t/111-req-header-ua.t
--- a/src/lua/lua-nginx-module/t/111-req-header-ua.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/111-req-header-ua.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,677 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (4 * blocks());
+
+#no_diff();
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: clear Opera user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Opera/9.80 (Macintosh; Intel Mac OS X 10.7.4; U; en) Presto/2.10.229 Version/11.62
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: opera: %d\n", $r->headers_in->opera)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: opera: %d\n", $r->headers_in->opera)
+}
+
+--- stap_out
+rewrite: opera: 1
+content: opera: 0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: clear MSIE 4 user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT 5.0)
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=1 msie6=1
+content: msie=0 msie6=0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: set custom MSIE 4 user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/4.0 (compatible; MSIE 4.01; Windows NT 5.0)")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=0 msie6=0
+content: msie=1 msie6=1
+
+--- response_body
+User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT 5.0)
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: clear MSIE 5 user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows 95; MSIECrawler)
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=1 msie6=1
+content: msie=0 msie6=0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: set custom MSIE 5 user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.01; Windows 95; MSIECrawler)")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=0 msie6=0
+content: msie=1 msie6=1
+
+--- response_body
+User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows 95; MSIECrawler)
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: clear MSIE 6 (without SV1) user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; Google Wireless Transcoder;)
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=1 msie6=1
+content: msie=0 msie6=0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 7: set custom MSIE 6 (without SV1) user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; Google Wireless Transcoder;)")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=0 msie6=0
+content: msie=1 msie6=1
+
+--- response_body
+User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; Google Wireless Transcoder;)
+--- no_error_log
+[error]
+
+
+
+=== TEST 8: clear MSIE 6 (with SV1) user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.1)
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=1 msie6=0
+content: msie=0 msie6=0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 9: set custom MSIE 6 (with SV1) user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.1)")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=0 msie6=0
+content: msie=1 msie6=0
+
+--- response_body
+User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.1)
+--- no_error_log
+[error]
+
+
+
+=== TEST 10: set custom MSIE 7 user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; winfx; .NET CLR 1.1.4322; .NET CLR 2.0.50727; Zune 2.0)")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: msie=%d msie6=%d\n",
+           $r->headers_in->msie,
+           $r->headers_in->msie6)
+}
+
+--- stap_out
+rewrite: msie=0 msie6=0
+content: msie=1 msie6=0
+
+--- response_body
+User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; winfx; .NET CLR 1.1.4322; .NET CLR 2.0.50727; Zune 2.0)
+--- no_error_log
+[error]
+
+
+
+=== TEST 11: clear Gecko user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/5.0 (Android; Mobile; rv:13.0) Gecko/13.0 Firefox/13.0
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: gecko: %d\n", $r->headers_in->gecko)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: gecko: %d\n", $r->headers_in->gecko)
+}
+
+--- stap_out
+rewrite: gecko: 1
+content: gecko: 0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 12: set custom Gecko user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/5.0 (Android; Mobile; rv:13.0) Gecko/13.0 Firefox/13.0")
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: gecko: %d\n", $r->headers_in->gecko)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: gecko: %d\n", $r->headers_in->gecko)
+}
+
+--- stap_out
+rewrite: gecko: 0
+content: gecko: 1
+
+--- response_body
+User-Agent: Mozilla/5.0 (Android; Mobile; rv:13.0) Gecko/13.0 Firefox/13.0
+--- no_error_log
+[error]
+
+
+
+=== TEST 13: clear Chrome user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.151 Safari/535.19
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: chrome: %d\n", $r->headers_in->chrome)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: chrome: %d\n", $r->headers_in->chrome)
+}
+
+--- stap_out
+rewrite: chrome: 1
+content: chrome: 0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 14: set custom Chrome user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.151 Safari/535.19")
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: chrome: %d\n", $r->headers_in->chrome)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: chrome: %d\n", $r->headers_in->chrome)
+}
+
+--- stap_out
+rewrite: chrome: 0
+content: chrome: 1
+
+--- response_body
+User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.151 Safari/535.19
+--- no_error_log
+[error]
+
+
+
+=== TEST 15: clear Safari (Mac OS X) user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/125.2 (KHTML, like Gecko) Safari/125.8
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: safari: %d\n", $r->headers_in->safari)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: safari: %d\n", $r->headers_in->safari)
+}
+
+--- stap_out
+rewrite: safari: 1
+content: safari: 0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 16: set custom Safari user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/125.2 (KHTML, like Gecko) Safari/125.8")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: safari: %d\n", $r->headers_in->safari)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: safari: %d\n", $r->headers_in->safari)
+}
+
+--- stap_out
+rewrite: safari: 0
+content: safari: 1
+
+--- response_body
+User-Agent: Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/125.2 (KHTML, like Gecko) Safari/125.8
+--- no_error_log
+[error]
+
+
+
+=== TEST 17: clear Konqueror user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", nil)
+
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- more_headers
+User-Agent: Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.10 (like Gecko) (Kubuntu)
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: konqueror: %d\n", $r->headers_in->konqueror)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: konqueror: %d\n", $r->headers_in->konqueror)
+}
+
+--- stap_out
+rewrite: konqueror: 1
+content: konqueror: 0
+
+--- response_body
+User-Agent: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 18: set custom Konqueror user-agent
+--- config
+    location /t {
+        rewrite_by_lua '
+            ngx.req.set_header("User-Agent", "Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.10 (like Gecko) (Kubuntu)")
+        ';
+        echo "User-Agent: $http_user_agent";
+    }
+
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: konqueror: %d\n", $r->headers_in->konqueror)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: konqueror: %d\n", $r->headers_in->konqueror)
+}
+
+--- stap_out
+rewrite: konqueror: 0
+content: konqueror: 1
+
+--- response_body
+User-Agent: Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.10 (like Gecko) (Kubuntu)
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/112-req-header-conn.t b/src/lua/lua-nginx-module/t/112-req-header-conn.t
--- a/src/lua/lua-nginx-module/t/112-req-header-conn.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/112-req-header-conn.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,150 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (4 * blocks());
+
+#no_diff();
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: clear the Connection req header
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("Connection", nil);
+        ';
+
+        echo "connection: $http_connection";
+    }
+--- request
+GET /req-header
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+--- stap_out
+rewrite: conn type: 1
+content: conn type: 0
+
+--- response_body
+connection: 
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: set custom Connection req header (close)
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("Connection", "CLOSE");
+        ';
+
+        echo "connection: $http_connection";
+    }
+--- request
+GET /req-header
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+--- stap_out
+rewrite: conn type: 1
+content: conn type: 1
+
+--- response_body
+connection: CLOSE
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: set custom Connection req header (keep-alive)
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("Connection", "keep-alive");
+        ';
+
+        echo "connection: $http_connection";
+    }
+--- request
+GET /req-header
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+--- stap_out
+rewrite: conn type: 1
+content: conn type: 2
+
+--- response_body
+connection: keep-alive
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: set custom Connection req header (bad)
+--- config
+    location /req-header {
+        rewrite_by_lua '
+            ngx.req.set_header("Connection", "bad");
+        ';
+
+        echo "connection: $http_connection";
+    }
+--- request
+GET /req-header
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+
+F(ngx_http_core_content_phase) {
+    printf("content: conn type: %d\n", $r->headers_in->connection_type)
+}
+
+--- stap_out
+rewrite: conn type: 1
+content: conn type: 0
+
+--- response_body
+connection: bad
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/113-req-header-cookie.t b/src/lua/lua-nginx-module/t/113-req-header-cookie.t
--- a/src/lua/lua-nginx-module/t/113-req-header-cookie.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/113-req-header-cookie.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,251 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_process_enabled(1);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (4 * blocks());
+
+#no_diff();
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: clear cookie (with existing cookies)
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Cookie", nil)
+        ';
+        echo "Cookie foo: $cookie_foo";
+        echo "Cookie baz: $cookie_baz";
+        echo "Cookie: $http_cookie";
+    }
+--- request
+GET /t
+--- more_headers
+Cookie: foo=bar
+Cookie: baz=blah
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+--- stap_out
+rewrite: cookies: 2
+content: cookies: 0
+
+--- response_body
+Cookie foo: 
+Cookie baz: 
+Cookie: 
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: clear cookie (without existing cookies)
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Cookie", nil)
+        ';
+        echo "Cookie foo: $cookie_foo";
+        echo "Cookie baz: $cookie_baz";
+        echo "Cookie: $http_cookie";
+    }
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+--- stap_out
+rewrite: cookies: 0
+content: cookies: 0
+
+--- response_body
+Cookie foo: 
+Cookie baz: 
+Cookie: 
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: set one custom cookie (with existing cookies)
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Cookie", "boo=123")
+        ';
+        echo "Cookie foo: $cookie_foo";
+        echo "Cookie baz: $cookie_baz";
+        echo "Cookie boo: $cookie_boo";
+        echo "Cookie: $http_cookie";
+    }
+--- request
+GET /t
+--- more_headers
+Cookie: foo=bar
+Cookie: baz=blah
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+--- stap_out
+rewrite: cookies: 2
+content: cookies: 1
+
+--- response_body
+Cookie foo: 
+Cookie baz: 
+Cookie boo: 123
+Cookie: boo=123
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: set one custom cookie (without existing cookies)
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Cookie", "boo=123")
+        ';
+        echo "Cookie foo: $cookie_foo";
+        echo "Cookie baz: $cookie_baz";
+        echo "Cookie boo: $cookie_boo";
+        echo "Cookie: $http_cookie";
+    }
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+--- stap_out
+rewrite: cookies: 0
+content: cookies: 1
+
+--- response_body
+Cookie foo: 
+Cookie baz: 
+Cookie boo: 123
+Cookie: boo=123
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 5: set multiple custom cookies (with existing cookies)
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Cookie", {"boo=123","foo=78"})
+        ';
+        echo "Cookie foo: $cookie_foo";
+        echo "Cookie baz: $cookie_baz";
+        echo "Cookie boo: $cookie_boo";
+        echo "Cookie: $http_cookie";
+    }
+--- request
+GET /t
+--- more_headers
+Cookie: foo=bar
+Cookie: baz=blah
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+--- stap_out
+rewrite: cookies: 2
+content: cookies: 2
+
+--- response_body
+Cookie foo: 78
+Cookie baz: 
+Cookie boo: 123
+Cookie: boo=123; foo=78
+
+--- no_error_log
+[error]
+
+
+
+=== TEST 6: set multiple custom cookies (without existing cookies)
+--- config
+    location /t {
+        rewrite_by_lua '
+           ngx.req.set_header("Cookie", {"boo=123", "foo=bar"})
+        ';
+        echo "Cookie foo: $cookie_foo";
+        echo "Cookie baz: $cookie_baz";
+        echo "Cookie boo: $cookie_boo";
+        echo "Cookie: $http_cookie";
+    }
+--- request
+GET /t
+
+--- stap
+F(ngx_http_lua_rewrite_by_chunk) {
+    printf("rewrite: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+F(ngx_http_core_content_phase) {
+    printf("content: cookies: %d\n", $r->headers_in->cookies->nelts)
+}
+
+--- stap_out
+rewrite: cookies: 0
+content: cookies: 2
+
+--- response_body
+Cookie foo: bar
+Cookie baz: 
+Cookie boo: 123
+Cookie: boo=123; foo=bar
+
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/114-config.t b/src/lua/lua-nginx-module/t/114-config.t
--- a/src/lua/lua-nginx-module/t/114-config.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/114-config.t	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,33 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+use lib 'lib';
+use t::TestNginxLua;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+#no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: ngx.config.debug
+--- config
+    location /t {
+        content_by_lua '
+            ngx.say("debug: ", ngx.config.debug)
+        ';
+    }
+--- request
+GET /t
+--- response_body_like chop
+^debug: (?:true|false)$
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/115-quote-sql-str.t b/src/lua/lua-nginx-module/t/115-quote-sql-str.t
--- a/src/lua/lua-nginx-module/t/115-quote-sql-str.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/115-quote-sql-str.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,78 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#log_level("warn");
+no_long_string();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: \0
+--- config
+    location = /set {
+        content_by_lua '
+            ngx.say(ngx.quote_sql_str("a\\0b\\0"))
+        ';
+    }
+--- request
+GET /set
+--- response_body
+'a\0b\0'
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: \t
+--- config
+    location = /set {
+        content_by_lua '
+            ngx.say(ngx.quote_sql_str("a\\tb\\t"))
+        ';
+    }
+--- request
+GET /set
+--- response_body
+'a\tb\t'
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: \b
+--- config
+    location = /set {
+        content_by_lua '
+            ngx.say(ngx.quote_sql_str("a\\bb\\b"))
+        ';
+    }
+--- request
+GET /set
+--- response_body
+'a\bb\b'
+--- no_error_log
+[error]
+
+
+
+=== TEST 4: \z
+--- config
+    location = /set {
+        content_by_lua '
+            ngx.say(ngx.quote_sql_str("a\\026b\\026"))
+        ';
+    }
+--- request
+GET /set
+--- response_body
+'a\zb\z'
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/116-raw-req-socket.t b/src/lua/lua-nginx-module/t/116-raw-req-socket.t
--- a/src/lua/lua-nginx-module/t/116-raw-req-socket.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/116-raw-req-socket.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,697 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+use lib 'lib';
+use t::TestNginxLua;
+
+repeat_each(2);
+
+plan tests => repeat_each() * 29;
+
+our $HtmlDir = html_dir;
+
+$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;
+$ENV{TEST_NGINX_RESOLVER} ||= '8.8.8.8';
+
+#log_level 'warn';
+log_level 'debug';
+
+#no_long_string();
+#no_diff();
+run_tests();
+
+__DATA__
+
+=== TEST 1: sanity
+--- config
+    server_tokens off;
+    location = /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local req = "GET /mysock HTTP/1.1\\r\\nUpgrade: mysock\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\nhello"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local data, err, partial = reader()
+            if not data then
+                ngx.say("no response header found")
+                return
+            end
+
+            local msg, err = sock:receive()
+            if not msg then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("msg: ", msg)
+
+            ok, err = sock:close()
+            if not ok then
+                ngx.say("failed to close socket: ", err)
+                return
+            end
+        ';
+    }
+
+    location = /mysock {
+        content_by_lua '
+            ngx.status = 101
+            ngx.send_headers()
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+
+            local data, err = sock:receive(5)
+            if not data then
+                ngx.log(ngx.ERR, "server: failed to receive: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("1: received: " .. data .. "\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "server: failed to send: ", err)
+                return
+            end
+        ';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+msg: 1: received: hello
+--- error_log
+lua raw req socket tcp_nodelay
+--- no_error_log
+[error]
+
+
+
+=== TEST 2: header not sent yet
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.status = 101
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            local ok, err = sock:send("HTTP/1.1 200 OK\\r\\nContent-Length: 5\\r\\n\\r\\nhello")
+            if not ok then
+                ngx.log(ngx.ERR, "failed to send: ", err)
+                return
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.0\r
+Host: localhost\r
+Content-Length: 5\r
+\r
+hello"
+--- response_headers
+Content-Length: 5
+--- response_body chop
+hello
+--- no_error_log
+[error]
+
+
+
+=== TEST 3: http 1.0 buffering
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.say("hello")
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return ngx.exit(500)
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.0\r
+Host: localhost\r
+Upgrade: mysocket\r
+\r
+hello"
+--- stap2
+F(ngx_http_header_filter) {
+    println("header filter")
+}
+F(ngx_http_lua_req_socket) {
+    println("lua req socket")
+}
+--- ignore_response
+--- error_log
+server: failed to get raw req socket: http 1.0 buffering
+
+
+
+=== TEST 4: multiple raw req sockets
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.say("hello")
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            local sock2, err = ngx.req.socket(true)
+            if not sock2 then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket2: ", err)
+                return
+            end
+
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+\r
+hello"
+--- stap2
+F(ngx_http_header_filter) {
+    println("header filter")
+}
+F(ngx_http_lua_req_socket) {
+    println("lua req socket")
+}
+--- ignore_response
+--- error_log
+server: failed to get raw req socket2: duplicate call
+
+
+
+=== TEST 5: ngx.say after ngx.req.socket(true)
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            local ok, err = ngx.say("ok")
+            if not ok then
+                ngx.log(ngx.ERR, "failed to say: ", err)
+                return
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+\r
+hello"
+--- ignore_response
+--- error_log
+failed to say: raw request socket acquired
+
+
+
+=== TEST 6: ngx.print after ngx.req.socket(true)
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            local ok, err = ngx.print("ok")
+            if not ok then
+                ngx.log(ngx.ERR, "failed to print: ", err)
+                return
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+\r
+hello"
+--- ignore_response
+--- error_log
+failed to print: raw request socket acquired
+
+
+
+=== TEST 7: ngx.eof after ngx.req.socket(true)
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            local ok, err = ngx.eof()
+            if not ok then
+                ngx.log(ngx.ERR, "failed to eof: ", err)
+                return
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+\r
+hello"
+--- ignore_response
+--- error_log
+failed to eof: raw request socket acquired
+
+
+
+=== TEST 8: ngx.flush after ngx.req.socket(true)
+--- config
+    server_tokens off;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            local ok, err = ngx.flush()
+            if not ok then
+                ngx.log(ngx.ERR, "failed to flush: ", err)
+                return
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+\r
+hello"
+--- ignore_response
+--- error_log
+failed to flush: raw request socket acquired
+
+
+
+=== TEST 9: receive timeout
+--- config
+    server_tokens off;
+    postpone_output 1;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.req.read_body()
+            ngx.flush(true)
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+
+            sock:settimeout(100)
+
+            local data, err, partial = sock:receive(10)
+            if not data then
+                ngx.log(ngx.ERR, "server: 1: failed to receive: ", err, ", received: ", partial)
+            end
+
+            data, err, partial = sock:receive(10)
+            if not data then
+                ngx.log(ngx.ERR, "server: 2: failed to receive: ", err, ", received: ", partial)
+            end
+
+            ngx.exit(444)
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+Connection: close\r
+\r
+ab"
+--- ignore_response
+--- wait: 0.1
+--- error_log
+lua tcp socket read timed out
+server: 1: failed to receive: timeout, received: ab,
+server: 2: failed to receive: timeout, received: ,
+--- no_error_log
+[alert]
+
+
+
+=== TEST 10: on_abort called during ngx.sleep()
+--- config
+    server_tokens off;
+    lua_check_client_abort on;
+    location = /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local req = "GET /mysock HTTP/1.1\\r\\nUpgrade: mysock\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\nhello"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local data, err, partial = reader()
+            if not data then
+                ngx.say("no response header found")
+                return
+            end
+
+            local msg, err = sock:receive()
+            if not msg then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("msg: ", msg)
+
+            ngx.sleep(0.1)
+
+            ok, err = sock:close()
+            if not ok then
+                ngx.say("failed to close socket: ", err)
+                return
+            end
+        ';
+    }
+
+    location = /mysock {
+        content_by_lua '
+            ngx.status = 101
+            ngx.send_headers()
+            ngx.flush(true)
+
+            local ok, err = ngx.on_abort(function (premature) ngx.log(ngx.WARN, "mysock handler aborted") end)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set on_abort handler: ", err)
+                return
+            end
+
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+
+            local data, err = sock:receive(5)
+            if not data then
+                ngx.log(ngx.ERR, "server: failed to receive: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("1: received: " .. data .. "\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "server: failed to send: ", err)
+                return
+            end
+
+            ngx.sleep(1)
+        ';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+msg: 1: received: hello
+--- error_log
+mysock handler aborted
+--- no_error_log
+[error]
+--- wait: 0.1
+
+
+
+=== TEST 11: on_abort called during sock:receive()
+--- config
+    server_tokens off;
+    lua_check_client_abort on;
+    location = /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local req = "GET /mysock HTTP/1.1\\r\\nUpgrade: mysock\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\nhello"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local data, err, partial = reader()
+            if not data then
+                ngx.say("no response header found")
+                return
+            end
+
+            local msg, err = sock:receive()
+            if not msg then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("msg: ", msg)
+
+            ngx.sleep(0.1)
+
+            ok, err = sock:close()
+            if not ok then
+                ngx.say("failed to close socket: ", err)
+                return
+            end
+        ';
+    }
+
+    location = /mysock {
+        content_by_lua '
+            ngx.status = 101
+            ngx.send_headers()
+            ngx.flush(true)
+
+            local ok, err = ngx.on_abort(function (premature) ngx.log(ngx.WARN, "mysock handler aborted") end)
+            if not ok then
+                ngx.log(ngx.ERR, "failed to set on_abort handler: ", err)
+                return
+            end
+
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+
+            local data, err = sock:receive(5)
+            if not data then
+                ngx.log(ngx.ERR, "server: failed to receive: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("1: received: " .. data .. "\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "server: failed to send: ", err)
+                return
+            end
+
+            local data, err = sock:receive()
+            if not data then
+                ngx.log(ngx.WARN, "failed to receive a line: ", err)
+                return
+            end
+        ';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+msg: 1: received: hello
+--- error_log
+failed to receive a line: client aborted
+--- no_error_log
+[error]
+--- wait: 0.1
+
+
+
+=== TEST 12: receiveuntil
+--- config
+    server_tokens off;
+    location = /t {
+        #set $port 5000;
+        set $port $TEST_NGINX_SERVER_PORT;
+
+        content_by_lua '
+            local sock = ngx.socket.tcp()
+            local port = ngx.var.port
+            local ok, err = sock:connect("127.0.0.1", port)
+            if not ok then
+                ngx.say("failed to connect: ", err)
+                return
+            end
+
+            local req = "GET /mysock HTTP/1.1\\r\\nUpgrade: mysock\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\nhello"
+            -- req = "OK"
+
+            local bytes, err = sock:send(req)
+            if not bytes then
+                ngx.say("failed to send request: ", err)
+                return
+            end
+
+            local bytes, err = sock:send(", ")
+            if not bytes then
+                ngx.say("failed to send packet 1: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("world")
+            if not bytes then
+                ngx.say("failed to send packet 2: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("\\r\\n\\r\\n")
+            local data, err, partial = reader()
+            if not data then
+                ngx.say("no response header found")
+                return
+            end
+
+            local msg, err = sock:receive()
+            if not msg then
+                ngx.say("failed to receive: ", err)
+                return
+            end
+
+            ngx.say("msg: ", msg)
+
+            ok, err = sock:close()
+            if not ok then
+                ngx.say("failed to close socket: ", err)
+                return
+            end
+        ';
+    }
+
+    location = /mysock {
+        content_by_lua '
+            ngx.status = 101
+            ngx.send_headers()
+            ngx.flush(true)
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+
+            local reader = sock:receiveuntil("rld")
+            local data, err = reader()
+            if not data then
+                ngx.log(ngx.ERR, "server: failed to receive: ", err)
+                return
+            end
+
+            local bytes, err = sock:send("1: received: " .. data .. "\\n")
+            if not bytes then
+                ngx.log(ngx.ERR, "server: failed to send: ", err)
+                return
+            end
+        ';
+        more_clear_headers Date;
+    }
+
+--- request
+GET /t
+--- response_body
+msg: 1: received: hello, wo
+--- no_error_log
+[error]
+
diff -rNu a/src/lua/lua-nginx-module/t/117-raw-req-socket-timeout.t b/src/lua/lua-nginx-module/t/117-raw-req-socket-timeout.t
--- a/src/lua/lua-nginx-module/t/117-raw-req-socket-timeout.t	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/117-raw-req-socket-timeout.t	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,118 @@
+# vim:set ft= ts=4 sw=4 et fdm=marker:
+
+BEGIN {
+    if (!defined $ENV{LD_PRELOAD}) {
+        $ENV{LD_PRELOAD} = '';
+    }
+
+    if ($ENV{LD_PRELOAD} !~ /\bmockeagain\.so\b/) {
+        $ENV{LD_PRELOAD} = "mockeagain.so $ENV{LD_PRELOAD}";
+    }
+
+    if ($ENV{MOCKEAGAIN} eq 'r') {
+        $ENV{MOCKEAGAIN} = 'rw';
+
+    } else {
+        $ENV{MOCKEAGAIN} = 'w';
+    }
+
+    $ENV{TEST_NGINX_EVENT_TYPE} = 'poll';
+    $ENV{MOCKEAGAIN_WRITE_TIMEOUT_PATTERN} = 'hello, world';
+    $ENV{TEST_NGINX_POSTPONE_OUTPUT} = 1;
+}
+
+use lib 'lib';
+use t::TestNginxLua;
+use t::StapThread;
+
+our $GCScript = $t::StapThread::GCScript;
+our $StapScript = $t::StapThread::StapScript;
+
+#worker_connections(1014);
+#master_on();
+#workers(2);
+#log_level('warn');
+
+repeat_each(2);
+
+plan tests => repeat_each() * (blocks() * 3);
+
+#no_diff();
+no_long_string();
+run_tests();
+
+__DATA__
+
+=== TEST 1: pending response header data
+--- config
+    server_tokens off;
+    postpone_output 1;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.req.read_body()
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+Connection: close\r
+\r
+"
+--- stap2
+F(ngx_http_header_filter) {
+    println("header filter")
+}
+F(ngx_http_lua_req_socket) {
+    println("lua req socket")
+}
+--- response_body
+--- error_log
+server: failed to get raw req socket: pending data to write
+
+
+
+=== TEST 2: send timeout
+--- config
+    server_tokens off;
+    postpone_output 1;
+    location = /t {
+        content_by_lua '
+            ngx.send_headers()
+            ngx.req.read_body()
+            ngx.flush(true)
+            local sock, err = ngx.req.socket(true)
+            if not sock then
+                ngx.log(ngx.ERR, "server: failed to get raw req socket: ", err)
+                return
+            end
+            sock:settimeout(100)
+            local ok, err = sock:send("hello, world!")
+            if not ok then
+                ngx.log(ngx.ERR, "server: failed to send: ", err)
+            end
+            ngx.exit(444)
+        ';
+    }
+
+--- raw_request eval
+"GET /t HTTP/1.1\r
+Host: localhost\r
+Upgrade: mysocket\r
+Connection: close\r
+\r
+"
+--- ignore_response
+--- error_log
+lua tcp socket write timed out
+server: failed to send: timeout
+--- no_error_log
+[alert]
+
diff -rNu a/src/lua/lua-nginx-module/t/.gitignore b/src/lua/lua-nginx-module/t/.gitignore
--- a/src/lua/lua-nginx-module/t/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/.gitignore	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,2 @@
+servroot
+
diff -rNu a/src/lua/lua-nginx-module/t/lib/CRC32.lua b/src/lua/lua-nginx-module/t/lib/CRC32.lua
--- a/src/lua/lua-nginx-module/t/lib/CRC32.lua	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/lib/CRC32.lua	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,173 @@
+--Copyright (c) 2007-2008 Neil Richardson (nrich@iinet.net.au)
+--
+--Permission is hereby granted, free of charge, to any person obtaining a copy 
+--of this software and associated documentation files (the "Software"), to deal
+--in the Software without restriction, including without limitation the rights 
+--to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
+--copies of the Software, and to permit persons to whom the Software is 
+--furnished to do so, subject to the following conditions:
+--
+--The above copyright notice and this permission notice shall be included in all
+--copies or substantial portions of the Software.
+--
+--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+--OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
+--IN THE SOFTWARE.
+
+module('CRC32', package.seeall)
+
+local max = 2^32 -1
+
+local CRC32 = {
+    0,79764919,159529838,222504665,319059676,
+    398814059,445009330,507990021,638119352,
+    583659535,797628118,726387553,890018660,
+    835552979,1015980042,944750013,1276238704,
+    1221641927,1167319070,1095957929,1595256236,
+    1540665371,1452775106,1381403509,1780037320,
+    1859660671,1671105958,1733955601,2031960084,
+    2111593891,1889500026,1952343757,2552477408,
+    2632100695,2443283854,2506133561,2334638140,
+    2414271883,2191915858,2254759653,3190512472,
+    3135915759,3081330742,3009969537,2905550212,
+    2850959411,2762807018,2691435357,3560074640,
+    3505614887,3719321342,3648080713,3342211916,
+    3287746299,3467911202,3396681109,4063920168,
+    4143685023,4223187782,4286162673,3779000052,
+    3858754371,3904687514,3967668269,881225847,
+    809987520,1023691545,969234094,662832811,
+    591600412,771767749,717299826,311336399,
+    374308984,453813921,533576470,25881363,
+    88864420,134795389,214552010,2023205639,
+    2086057648,1897238633,1976864222,1804852699,
+    1867694188,1645340341,1724971778,1587496639,
+    1516133128,1461550545,1406951526,1302016099,
+    1230646740,1142491917,1087903418,2896545431,
+    2825181984,2770861561,2716262478,3215044683,
+    3143675388,3055782693,3001194130,2326604591,
+    2389456536,2200899649,2280525302,2578013683,
+    2640855108,2418763421,2498394922,3769900519,
+    3832873040,3912640137,3992402750,4088425275,
+    4151408268,4197601365,4277358050,3334271071,
+    3263032808,3476998961,3422541446,3585640067,
+    3514407732,3694837229,3640369242,1762451694,
+    1842216281,1619975040,1682949687,2047383090,
+    2127137669,1938468188,2001449195,1325665622,
+    1271206113,1183200824,1111960463,1543535498,
+    1489069629,1434599652,1363369299,622672798,
+    568075817,748617968,677256519,907627842,
+    853037301,1067152940,995781531,51762726,
+    131386257,177728840,240578815,269590778,
+    349224269,429104020,491947555,4046411278,
+    4126034873,4172115296,4234965207,3794477266,
+    3874110821,3953728444,4016571915,3609705398,
+    3555108353,3735388376,3664026991,3290680682,
+    3236090077,3449943556,3378572211,3174993278,
+    3120533705,3032266256,2961025959,2923101090,
+    2868635157,2813903052,2742672763,2604032198,
+    2683796849,2461293480,2524268063,2284983834,
+    2364738477,2175806836,2238787779,1569362073,
+    1498123566,1409854455,1355396672,1317987909,
+    1246755826,1192025387,1137557660,2072149281,
+    2135122070,1912620623,1992383480,1753615357,
+    1816598090,1627664531,1707420964,295390185,
+    358241886,404320391,483945776,43990325,
+    106832002,186451547,266083308,932423249,
+    861060070,1041341759,986742920,613929101,
+    542559546,756411363,701822548,3316196985,
+    3244833742,3425377559,3370778784,3601682597,
+    3530312978,3744426955,3689838204,3819031489,
+    3881883254,3928223919,4007849240,4037393693,
+    4100235434,4180117107,4259748804,2310601993,
+    2373574846,2151335527,2231098320,2596047829,
+    2659030626,2470359227,2550115596,2947551409,
+    2876312838,2788305887,2733848168,3165939309,
+    3094707162,3040238851,2985771188,
+}
+
+local function xor(a, b)
+    local calc = 0    
+
+    for i = 32, 0, -1 do
+	local val = 2 ^ i
+	local aa = false
+	local bb = false
+
+	if a == 0 then
+	    calc = calc + b
+	    break
+	end
+
+	if b == 0 then
+	    calc = calc + a
+	    break
+	end
+
+	if a >= val then
+	    aa = true
+	    a = a - val
+	end
+
+	if b >= val then
+	    bb = true
+	    b = b - val
+	end
+
+	if not (aa and bb) and (aa or bb) then
+	    calc = calc + val
+	end
+    end
+
+    return calc
+end
+
+local function lshift(num, left)
+    local res = num * (2 ^ left)
+    return res % (2 ^ 32)
+end
+
+local function rshift(num, right)
+    local res = num / (2 ^ right)
+    return math.floor(res)
+end
+
+function Hash(str)
+    local count = string.len(tostring(str))
+    local crc = max
+    
+    local i = 1
+    while count > 0 do
+	local byte = string.byte(str, i)
+
+	crc = xor(lshift(crc, 8), CRC32[xor(rshift(crc, 24), byte) + 1])
+
+	i = i + 1
+	count = count - 1
+    end
+
+    return crc
+end
+
+
+--
+-- CRC32.lua
+--
+-- A pure Lua implementation of a CRC32 hashing algorithm. Slower than using a C implemtation,
+-- but useful having no other dependancies.
+--
+--
+-- Synopsis
+--
+-- require('CRC32')
+--
+-- crchash = CRC32.Hash('a string')
+--
+-- Methods:
+--
+-- hashval = CRC32.Hash(val)
+--    Calculates and returns (as an integer) the CRC32 hash of the parameter 'val'. 
+
diff -rNu a/src/lua/lua-nginx-module/t/lib/Memcached.lua b/src/lua/lua-nginx-module/t/lib/Memcached.lua
--- a/src/lua/lua-nginx-module/t/lib/Memcached.lua	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/lib/Memcached.lua	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,567 @@
+--Copyright (c) 2006-2008 Neil Richardson (nrich@iinet.net.au)
+--
+--Permission is hereby granted, free of charge, to any person obtaining a copy 
+--of this software and associated documentation files (the "Software"), to deal
+--in the Software without restriction, including without limitation the rights 
+--to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
+--copies of the Software, and to permit persons to whom the Software is 
+--furnished to do so, subject to the following conditions:
+--
+--The above copyright notice and this permission notice shall be included in all
+--copies or substantial portions of the Software.
+--
+--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+--OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
+--IN THE SOFTWARE.
+
+module('Memcached', package.seeall)
+
+require('socket')
+require('CRC32')
+
+local SERVER_RETRIES = 10
+
+local STATS_KEYS = {
+    malloc = true,
+    sizes = true,
+    slabs = true,
+    items = true,
+}
+
+local FLAGS = {
+    'STORABLE',
+    'COMPRESSED',
+    'SERIALISED',
+}
+
+local function warn(str)
+    io.stderr:write(string.format('Warning: %s\n', tostring(str)))
+end
+
+local function _select_server(cache, key)
+    local server_count = #cache.servers
+
+    local hashfunc = cache.hash or CRC32.Hash
+
+    if server_count == 1 then
+	return cache.servers[1].socket
+    else
+	local serverhash = hashfunc(key)
+
+	for i = 0, SERVER_RETRIES do
+	    local index = (serverhash % server_count) + 1
+	    local server = cache.servers[index].socket
+
+	    if not server then
+		serverhash = hashfunc(serverhash .. i)
+	    else
+		return server
+	    end
+	end
+    end
+
+    error('No servers found')
+    return nil
+end
+
+local function _retrieve(cache, key, str)
+    local server = _select_server(cache, key)
+
+    server:send(str .. '\r\n')
+
+    local function toboolean(value)
+	if type(value) == 'string' then
+	    if value == 'true' then
+		return true
+	    elseif value == 'false' then
+		return false 
+	    end
+	end
+
+	return nil
+    end
+
+    local function extract_flags(str)
+	local num = tonumber(str)
+	local flags = {}
+
+	for i = table.maxn(FLAGS), 1, -1 do
+	    local bf = 2 ^ (i - 1)
+
+	    if num >= bf then
+		flags[FLAGS[i]] = true
+		num = num - bf
+	    end
+	end
+
+	return flags
+    end
+
+    local returndata = {}
+    while true do
+	local line, err = server:receive()
+
+	if line == 'END' then
+	    break
+	elseif string.sub(line, 1, 5) == 'VALUE' then
+	    local key,flagstr,size,cas = string.match(line, 'VALUE (%S+) (%d+) (%d+)')
+	    flags = extract_flags(flagstr)
+
+	    local data = server:receive(size)
+
+	    if flags.COMPRESSED and cache.compress_enabled then
+		data = cache.decompress(data)
+	    end
+
+            if flags.SERIALISED then
+                returndata[key] = cache.decode(data)
+            else
+                local ldata = tonumber(data) or toboolean(data) 
+
+                if ldata == nil then
+                    if data == 'nil' then
+                        returndata[key] = nil
+                    else
+                        returndata[key] = data
+                    end
+                else
+                    returndata[key] = ldata
+                end
+            end
+	end
+    end
+
+    return returndata
+end
+
+local function _send(cache, key, str)
+    local server = _select_server(cache, key)
+
+    server:send(str .. "\r\n")
+    local line, err = server:receive()
+    
+    if not err then return line end
+end
+
+local function _store(cache, op, key, value, expiry)
+    local str
+    local flags = 0
+
+    if type(value) == 'table' then
+	str = cache.encode(value)    
+	-- TODO lookup rather than hard code 
+        flags = flags + 4
+    else
+	str = tostring(value)
+    end
+
+    if cache.compress_enabled and string.len(str) > cache.compress_threshold then
+	local cstr = cache.compress(str)
+
+	if string.len(cstr) < (string.len(str) * 0.8) then
+	    str = cstr
+
+	    -- TODO lookup rather than hard code 
+	    flags = flags + 2
+	end
+    end
+
+    local len = string.len(str)
+
+    expiry = expiry or 0
+
+    local cmd = op .. ' ' .. key .. ' ' .. flags .. ' ' .. expiry .. ' ' .. len .. '\r\n' .. str
+
+    local res = _send(cache, key, cmd)
+
+    if res ~= 'STORED' then
+	return false, res
+    end
+
+    return true
+end
+
+local function set(cache, key, value, expiry)
+    return _store(cache, 'set', key, value, expiry)
+end
+
+local function add(cache, key, value, expiry)
+    return _store(cache, 'add', key, value, expiry)
+end
+
+local function replace(cache, key, value, expiry)
+    return _store(cache, 'replace', key, value, expiry)
+end
+
+local function get(cache, key)
+    local dataset = _retrieve(cache, key, 'get ' .. key)
+    return dataset[key]
+end
+
+local function delete(cache, key)
+    local res = _send(cache, key, 'delete ' .. key)
+
+    if res == 'NOT_FOUND' then
+	return false
+    end
+
+    if res ~= 'DELETED' then
+	return false, res
+    end
+
+    return true
+end
+
+local function incr(cache, key, val)
+    val = val or 1
+	
+    local res = _send(cache, key, 'incr ' .. key .. ' ' .. val)
+
+    if res == 'ERROR' or res == 'CLIENT_ERROR' then
+        return false, res
+    end
+
+    return res
+end
+
+local function decr(cache, key, val)
+    val = val or 1
+
+    local res = _send(cache, key, 'decr ' .. key .. ' ' .. val)
+
+    if res == 'ERROR' or res == 'CLIENT_ERROR' then
+        return false, res
+    end
+
+    return res
+end
+
+local function stats(cache, key)
+    local servers = {}
+
+    key = key or ''
+
+    if string.len(key) > 0 and not STATS_KEYS[key] then
+	error(string.format("Unknown stats key '%s'", key))
+    end
+
+    for i,server in pairs(cache.servers) do
+	server.socket:send('stats ' .. key .. '\r\n')
+
+	local stats = {}
+
+	while true do
+	    local line, err = server.socket:receive()
+
+	    if line == 'END' or line == 'ERROR' then
+		break
+	    end
+
+	    local k,v = string.match(line, 'STAT (%S+) (%S+)')
+
+	    if k then
+		stats[k] = v
+	    end
+	end
+
+	servers[server.name] = stats
+    end
+
+    return servers
+end 
+
+local function get_multi(cache, ...)
+    local dataset = nil
+
+    if table.maxn(cache.servers) > 1 then
+	dataset = {}
+
+	for i,k in ipairs(arg) do
+	    local data = _retrieve(cache, k, 'get ' .. k)
+	    dataset[k] = data[k]
+	end
+    else
+	local keys = table.concat(arg, ' ')
+	dataset = _retrieve(cache, keys, 'get ' .. keys)
+    end
+
+    return dataset
+end
+
+local function flush_all(cache)
+    local success = true
+
+    for i,server in ipairs(cache.servers) do
+	server.socket:send('flush_all\r\n')
+	local res = assert(server.socket:receive())
+
+	if res ~= 'OK' then
+	    success = false
+	end
+    end
+
+    return success
+end
+
+local function disconnect_all(cache)
+    while true do
+	local server = table.remove(cache.servers)
+
+	if not server then
+	    break
+	end
+
+	server.socket:close()
+    end    
+end
+
+local function set_hash(cache, hashfunc)
+    cache.hash = hashfunc
+end
+
+local function set_encode(cache, func)
+    cache.encode = func
+end
+
+local function set_decode(cache, func)
+    cache.decode = func
+end
+
+local function set_compress(cache, func)
+    cache.compress = func
+end
+
+local function set_decompress(cache, func)
+    cache.decompress = func
+end
+
+function Connect(hostlist, port)
+    local servers = {}
+
+    if type(hostlist) == 'table' then
+	for i,host in pairs(hostlist) do
+	    local h, p
+
+	    if type(host) == 'table' then
+		h = host[1]
+		p = host[2]
+	    elseif type(host) == 'string' then
+		h = host
+	    elseif type(host) == 'number' then
+		p = host
+		h = nil
+	    end
+
+	    if not h then
+		h = '127.0.0.1'
+	    end
+
+	    if not p then 
+		p = 11211
+	    end
+
+	    local server = socket.connect(h, p)
+
+	    if not server then
+		warn('Could not connect to ' .. h .. ':' .. p)
+	    else
+		table.insert(servers, {socket = server, name = string.format('%s:%d', h, p)})
+	    end
+	end
+    else
+	local address = hostlist
+
+	if type(address) == 'number' then
+	    port = address
+	    address = nil
+	end
+
+	if address == nil then
+	    address = '127.0.0.1'
+	end
+
+	if port == nil then
+	    port = 11211
+	end
+
+	local server = socket.connect(address, port)
+
+	if not server then
+	    warn('Could not connect to ' .. address .. ':' .. port)
+	else
+	    servers = {{socket = server, name = string.format('%s:%d', address, port)}}
+	end
+    end
+
+    if table.maxn(servers) < 1 then
+	error('No servers available')
+    end
+
+    local cache = {
+	servers = servers,
+
+	set_hash = set_hash,
+	set_encode = set_encode,
+	set_decode = set_decode,
+	set_decompress = set_decompress,
+	set_compress = set_compress,
+
+	compress_enabled = false,
+	enable_compression = function(self, on)
+	    self.compress_enabled = on
+	end,
+
+	hash = nil,
+	encode = function()
+	    error('No encode function set')
+	end,
+
+	decode = function()
+	    error('No decode function set')
+	end,
+
+	compress = function()
+	    error('No compress function set')
+	end,
+
+	decompress = function()
+	    error('No decompress function set')
+	end,
+
+	-- 10K default
+	compress_threshold = 10240,
+	set_compress_threshold = function(self, threshold)
+	    if threshold == nil then
+		self:enable_compression(false)
+	    else
+		self.compress_threshold = threshold
+	    end
+	end,
+
+	set = set,
+	add = add,
+	replace = replace,
+	get = get,
+	delete = delete,
+	incr = incr,
+	decr = decr,
+
+	get_multi = get_multi,
+	stats = stats,
+	flush_all = flush_all,
+	disconnect_all = disconnect_all,
+    }
+
+    return cache
+end
+
+function New(hostlist, port)
+    return Connect(hostlist, port)
+end
+
+-- 
+-- Memcached.lua
+-- 
+-- A pure Lua implementation of a simple memcached client. 1 or more memcached server(s) are currently supported. Requires the luasocket library.
+-- See http://www.danga.com/memcached/ for more information about memcached.
+--
+--
+--
+-- Synopsis
+--
+-- require('Memcached')
+--
+-- memcache = Memcached.Connect('some.host.com', 11000)
+--    OR
+-- memcache = Memcached.New('some.host.com', 11000)
+--
+-- memcache:set('some_key', 1234)
+-- memcache:add('new_key', 'add new value')
+-- memcache:replace('existing_key', 'replace old value')
+--
+-- cached_data = memcache:get('some_key')
+--
+-- memcache:delete('old_key')
+--
+--
+--
+-- Methods:
+--
+-- memcache = Memcached.Connect()
+--    Connect to memcached server at localhost on port number 11211. 
+--
+-- memcache = Memcached.Connect(host[, port])
+--    Connect to memcached server at 'host' on port number 'port'. If port is not provided, port 11211 is used.  
+--
+---memcache = Memcached.Connect(port)
+--    Connect to memcached server at localhost on port number 'port'.
+--
+-- memcache = Memcached.Connect({{'host', port}, 'host', port})  
+--    Connect to multiple memcached servers.
+--
+-- memcache:set(key, value[, expiry])
+--    Unconditionally sets a key to a given value in the memcache. The value for 'expiry' is the expiration
+--    time (default is 0, never expire).
+--     
+-- memcache:add(key, value[, expiry])
+--    Like set, but only stores in memcache if the key doesn't already exist.
+--    
+-- memcache:replace(key, value[, expiry])
+--    Like set, but only stores in memcache if the key already exists. The opposite of add.
+--    
+-- value = memcache:get(key)
+--    Retrieves a key from the memcache. Returns the value or nil
+--    
+-- values = memcache:get_multi(...)
+--    Retrieves multiple keys from the memcache doing just one query.  Returns a table of key/value pairs that were available.
+--    
+-- memcache:delete(key)
+--    Deletes a key. Returns true on deletion, false if the key was not found.
+--    
+-- value = memcache:incr(key[, value])
+--    Sends a command to the server to atomically increment the value for key by value, or by 1 if value is nil. 
+--    Returns nil if key doesn't exist on server, otherwise it returns the new value after incrementing. Value should be zero or greater.
+--    
+-- value = memcache:decr(key[, value])
+--    Like incr, but decrements. Unlike incr, underflow is checked and new values are capped at 0. If server value is 1, a decrement of 2 returns 0, not -1.
+--
+-- servers = memcache:stats([key])
+--    Returns a table of statistical data regarding the memcache server(s). Allowed keys are:
+--	'', 'malloc', 'sizes', 'slabs', 'items'
+--
+--  success = memcache:flush_all()
+--     Runs the memcached "flush_all" command on all configured hosts, emptying all their caches. 
+--
+--  memcache:disconnect_all()
+--     Closes all cached sockets to all memcached servers.
+--
+--  memcache:set_hash(hashfunc)
+--     Sets a custom hash function for key values. The default is a CRC32 hashing function.
+--     'hashfunc' should be defined receiving a single string parameter and returing a single integer value.
+--
+--  memcache:set_encode(func)
+--     Sets a custom encode function for serialising table values. 'func' should be defined receiving a single
+--     table value and returning a single string value.
+--
+--  memcache:set_decode(func)
+--     Sets a custom decode function for deserialising table values. 'func' should be defined receiving a 
+--     single single and returning a single table value
+--
+--  memcache:enable_compression(onflag)
+--     Turns data compression support on or off.
+--
+--  memcache:set_compress_threshold(size)
+--     Set the compression threshold. If the value to be stored is larger than `size' bytes (and compression 
+--     is enabled), compress before storing.
+--
+--  memcache:set_compress(func)
+--     Sets a custom data compression function. 'func' should be defined receiving a single string value and
+--     returning a single string value.
+--
+--  memcache:set_decompress(func)
+--     Sets a custom data decompression function. 'func' should be defined receiving a single string value and
+--     returning a single string value.
diff -rNu a/src/lua/lua-nginx-module/t/lib/Redis.lua b/src/lua/lua-nginx-module/t/lib/Redis.lua
--- a/src/lua/lua-nginx-module/t/lib/Redis.lua	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/lib/Redis.lua	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,1120 @@
+--[[
+Copyright (c) 2009-2011 Daniele Alessandri
+ 
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+ 
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+ 
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+]]
+
+module('Redis', package.seeall)
+
+local commands, network, request, response = {}, {}, {}, {}
+
+local defaults = {
+    host        = '127.0.0.1',
+    port        = 6379,
+    tcp_nodelay = true,
+    path        = nil
+}
+
+local protocol = {
+    newline = '\r\n',
+    ok      = 'OK',
+    err     = 'ERR',
+    queued  = 'QUEUED',
+    null    = 'nil'
+}
+
+local lua_error = error
+local function default_error_fn(message, level)
+    lua_error(message, (level or 1) + 1)
+end
+
+local function merge_defaults(parameters)
+    if parameters == nil then
+        parameters = {}
+    end
+    for k, v in pairs(defaults) do
+        if parameters[k] == nil then
+            parameters[k] = defaults[k]
+        end
+    end
+    return parameters
+end
+
+local function parse_boolean(v)
+    if v == '1' or v == 'true' or v == 'TRUE' then
+        return true
+    elseif v == '0' or v == 'false' or v == 'FALSE' then
+        return false
+    else
+        return nil
+    end
+end
+
+local function toboolean(value) return value == 1 end
+
+local function fire_and_forget(client, command)
+    -- let's fire and forget! the connection is closed as soon
+    -- as the SHUTDOWN command is received by the server.
+    client.network.write(client, command .. protocol.newline)
+    return false
+end
+
+local function zset_range_request(client, command, ...)
+    local args, opts = {...}, { }
+
+    if #args >= 1 and type(args[#args]) == 'table' then
+        local options = table.remove(args, #args)
+        if options.withscores then
+            table.insert(opts, 'WITHSCORES')
+        end
+    end
+
+    for _, v in pairs(opts) do table.insert(args, v) end
+    request.multibulk(client, command, args)
+end
+
+local function zset_range_byscore_request(client, command, ...)
+    local args, opts = {...}, { }
+
+    if #args >= 1 and type(args[#args]) == 'table' then
+        local options = table.remove(args, #args)
+        if options.limit then
+            table.insert(opts, 'LIMIT')
+            table.insert(opts, options.limit.offset or options.limit[1])
+            table.insert(opts, options.limit.count or options.limit[2])
+        end
+        if options.withscores then
+            table.insert(opts, 'WITHSCORES')
+        end
+    end
+
+    for _, v in pairs(opts) do table.insert(args, v) end
+    request.multibulk(client, command, args)
+end
+
+local function zset_range_reply(reply, command, ...)
+    local args = {...}
+    local opts = args[4]
+    if opts and (opts.withscores or string.lower(tostring(opts)) == 'withscores') then
+        local new_reply = { }
+        for i = 1, #reply, 2 do
+            table.insert(new_reply, { reply[i], reply[i + 1] })
+        end
+        return new_reply
+    else
+        return reply
+    end
+end
+
+local function zset_store_request(client, command, ...)
+    local args, opts = {...}, { }
+
+    if #args >= 1 and type(args[#args]) == 'table' then
+        local options = table.remove(args, #args)
+        if options.weights and type(options.weights) == 'table' then
+            table.insert(opts, 'WEIGHTS')
+            for _, weight in ipairs(options.weights) do
+                table.insert(opts, weight)
+            end
+        end
+        if options.aggregate then
+            table.insert(opts, 'AGGREGATE')
+            table.insert(opts, options.aggregate)
+        end
+    end
+
+    for _, v in pairs(opts) do table.insert(args, v) end
+    request.multibulk(client, command, args)
+end
+
+local function mset_filter_args(client, command, ...)
+    local args, arguments = {...}, {}
+    if (#args == 1 and type(args[1]) == 'table') then
+        for k,v in pairs(args[1]) do
+            table.insert(arguments, k)
+            table.insert(arguments, v)
+        end
+    else
+        arguments = args
+    end
+    request.multibulk(client, command, arguments)
+end
+
+local function hash_multi_request_builder(builder_callback)
+    return function(client, command, ...)
+        local args, arguments = {...}, { }
+        if #args == 2 then
+            table.insert(arguments, args[1])
+            for k, v in pairs(args[2]) do
+                builder_callback(arguments, k, v)
+            end
+        else
+            arguments = args
+        end
+        request.multibulk(client, command, arguments)
+    end
+end
+
+local function parse_info(response)
+    local info = {}
+    response:gsub('([^\r\n]*)\r\n', function(kv)
+        local k,v = kv:match(('([^:]*):([^:]*)'):rep(1))
+        if (k:match('db%d+')) then
+            info[k] = {}
+            v:gsub(',', function(dbkv)
+                local dbk,dbv = kv:match('([^:]*)=([^:]*)')
+                info[k][dbk] = dbv
+            end)
+        else
+            info[k] = v
+        end
+    end)
+    return info
+end
+
+local function parse_info_new(response)
+    local info, current = {}, nil
+    response:gsub('([^\r\n]*)\r\n', function(kv)
+        if kv == '' then return end
+
+        local section = kv:match(('^# (%w+)'):rep(1))
+        if section then
+            current = section:lower()
+            info[current] = {}
+            return
+        end
+
+        local k,v = kv:match(('([^:]*):([^:]*)'):rep(1))
+        if (k:match('db%d+')) then
+            info[current][k] = {}
+            v:gsub(',', function(dbkv)
+                local dbk,dbv = kv:match('([^:]*)=([^:]*)')
+                info[current][dbk] = dbv
+            end)
+        else
+            info[current][k] = v
+        end
+    end)
+    return info
+end
+
+local function load_methods(proto, methods)
+    local redis = setmetatable ({}, getmetatable(proto))
+    for i, v in pairs(proto) do redis[i] = v end
+    for i, v in pairs(methods) do redis[i] = v end
+    return redis
+end
+
+local function create_client(proto, client_socket, methods)
+    local redis = load_methods(proto, methods)
+    redis.network = {
+        socket = client_socket,
+        read   = network.read,
+        write  = network.write,
+    }
+    redis.requests = {
+        multibulk = request.multibulk,
+    }
+    return redis
+end
+
+-- ############################################################################
+
+function network.write(client, buffer)
+    local _, err = client.network.socket:send(buffer)
+    if err then client.error(err) end
+end
+
+function network.read(client, len)
+    if len == nil then len = '*l' end
+    local line, err = client.network.socket:receive(len)
+    if not err then return line else client.error('connection error: ' .. err) end
+end
+
+-- ############################################################################
+
+function response.read(client)
+    local res = client.network.read(client)
+    local prefix  = res:sub(1, -#res)
+    local handler = protocol.prefixes[prefix]
+    if not handler then
+        client.error('unknown response prefix: '..prefix)
+    end
+    return handler(client, res)
+end
+
+function response.status(client, data)
+    local sub = data:sub(2)
+
+    if sub == protocol.ok then
+        return true
+    elseif sub == protocol.queued then
+        return { queued = true }
+    else
+        return sub
+    end
+end
+
+function response.error(client, data)
+    local err_line = data:sub(2)
+
+    if err_line:sub(1, 3) == protocol.err then
+        client.error('redis error: ' .. err_line:sub(5))
+    else
+        client.error('redis error: ' .. err_line)
+    end
+end
+
+function response.bulk(client, data)
+    local str = data:sub(2)
+    local len = tonumber(str)
+    if not len then
+        client.error('cannot parse ' .. str .. ' as data length')
+    end
+
+    if len == -1 then return nil end
+    local next_chunk = client.network.read(client, len + 2)
+    return next_chunk:sub(1, -3);
+end
+
+function response.multibulk(client, data)
+    local str = data:sub(2)
+    local list_count = tonumber(str)
+
+    if list_count == -1 then
+        return nil
+    else
+        local list = {}
+        if list_count > 0 then
+            for i = 1, list_count do
+                table.insert(list, i, response.read(client))
+            end
+        end
+        return list
+    end
+end
+
+function response.integer(client, data)
+    local res = data:sub(2)
+    local number = tonumber(res)
+
+    if not number then
+        if res == protocol.null then
+            return nil
+        end
+        client.error('cannot parse '..res..' as a numeric response.')
+    end
+
+    return number
+end
+
+protocol.prefixes = {
+    ['+'] = response.status,
+    ['-'] = response.error,
+    ['$'] = response.bulk,
+    ['*'] = response.multibulk,
+    [':'] = response.integer,
+}
+
+-- ############################################################################
+
+function request.raw(client, buffer)
+    local bufferType = type(buffer)
+
+    if bufferType == 'table' then
+        client.network.write(client, table.concat(buffer))
+    elseif bufferType == 'string' then
+        client.network.write(client, buffer)
+    else
+        client.error('argument error: ' .. bufferType)
+    end
+end
+
+function request.multibulk(client, command, ...)
+    local args      = {...}
+    local args_len  = #args
+    local buffer    = { true, true }
+    local proto_nl  = protocol.newline
+
+    if args_len == 1 and type(args[1]) == 'table' then
+        args_len, args = #args[1], args[1]
+    end
+
+    buffer[1] = '*' .. tostring(args_len + 1) .. proto_nl
+    buffer[2] = '$' .. #command .. proto_nl .. command .. proto_nl
+
+    for _, argument in pairs(args) do
+        s_argument = tostring(argument)
+        table.insert(buffer, '$' .. #s_argument .. proto_nl .. s_argument .. proto_nl)
+    end
+
+    request.raw(client, buffer)
+end
+
+-- ############################################################################
+
+local function custom(command, send, parse)
+    return function(client, ...)
+        local has_reply = send(client, command, ...)
+        if has_reply == false then return end
+        local reply = response.read(client)
+
+        if type(reply) == 'table' and reply.queued then
+            reply.parser = parse
+            return reply
+        else
+            if parse then
+                return parse(reply, command, ...)
+            else
+                return reply
+            end
+        end
+    end
+end
+
+function command(command, opts)
+    if opts == nil or type(opts) == 'function' then
+        return custom(command, request.multibulk, opts)
+    else
+        return custom(command, opts.request or request.multibulk, opts.response)
+    end
+end
+
+local define_command_impl = function(target, name, opts)
+    local opts = opts or {}
+    target[string.lower(name)] = custom(
+        opts.command or string.upper(name),
+        opts.request or request.multibulk,
+        opts.response or nil
+    )
+end
+
+function define_command(name, opts)
+    define_command_impl(commands, name, opts)
+end
+
+local undefine_command_impl = function(target, name)
+    target[string.lower(name)] = nil
+end
+
+function undefine_command(name)
+    undefine_command_impl(commands, name)
+end
+
+-- ############################################################################
+
+local client_prototype = {}
+
+client_prototype.raw_cmd = function(client, buffer)
+    request.raw(client, buffer .. protocol.newline)
+    return response.read(client)
+end
+
+client_prototype.define_command = function(client, name, opts)
+    define_command_impl(client, name, opts)
+end
+
+client_prototype.undefine_command = function(client, name)
+    undefine_command_impl(client, name)
+end
+
+-- Command pipelining
+
+client_prototype.pipeline = function(client, block)
+    local requests, replies, parsers = {}, {}, {}
+    local socket_write, socket_read = client.network.write, client.network.read
+
+    client.network.write = function(_, buffer)
+        table.insert(requests, buffer)
+    end
+
+    -- TODO: this hack is necessary to temporarily reuse the current
+    --       request -> response handling implementation of redis-lua
+    --       without further changes in the code, but it will surely
+    --       disappear when the new command-definition infrastructure
+    --       will finally be in place.
+    client.network.read = function() return '+QUEUED' end
+
+    local pipeline = setmetatable({}, {
+        __index = function(env, name)
+            local cmd = client[name]
+            if not cmd then
+                client.error('unknown redis command: ' .. name, 2)
+            end
+            return function(self, ...)
+                local reply = cmd(client, ...)
+                table.insert(parsers, #requests, reply.parser)
+                return reply
+            end
+        end
+    })
+
+    local success, retval = pcall(block, pipeline)
+
+    client.network.write, client.network.read = socket_write, socket_read
+    if not success then client.error(retval, 0) end
+
+    client.network.write(client, table.concat(requests, ''))
+
+    for i = 1, #requests do
+        local reply, parser = response.read(client), parsers[i]
+        if parser then
+            reply = parser(reply)
+        end
+        table.insert(replies, i, reply)
+    end
+
+    return replies, #requests
+end
+
+-- Publish/Subscribe
+
+do
+    local channels = function(channels)
+        if type(channels) == 'string' then
+            channels = { channels }
+        end
+        return channels
+    end
+
+    local subscribe = function(client, ...)
+        request.multibulk(client, 'subscribe', ...)
+    end
+    local psubscribe = function(client, ...)
+        request.multibulk(client, 'psubscribe', ...)
+    end
+    local unsubscribe = function(client, ...)
+        request.multibulk(client, 'unsubscribe')
+    end
+    local punsubscribe = function(client, ...)
+        request.multibulk(client, 'punsubscribe')
+    end
+
+    local consumer_loop = function(client)
+        local aborting, subscriptions = false, 0
+
+        local abort = function()
+            if not aborting then
+                unsubscribe(client)
+                punsubscribe(client)
+                aborting = true
+            end
+        end
+
+        return coroutine.wrap(function()
+            while true do
+                local message
+                local response = response.read(client)
+
+                if response[1] == 'pmessage' then
+                    message = {
+                        kind    = response[1],
+                        pattern = response[2],
+                        channel = response[3],
+                        payload = response[4],
+                    }
+                else
+                    message = {
+                        kind    = response[1],
+                        channel = response[2],
+                        payload = response[3],
+                    }
+                end
+
+                if string.match(message.kind, '^p?subscribe$') then
+                    subscriptions = subscriptions + 1
+                end
+                if string.match(message.kind, '^p?unsubscribe$') then
+                    subscriptions = subscriptions - 1
+                end
+
+                if aborting and subscriptions == 0 then
+                    break
+                end
+                coroutine.yield(message, abort)
+            end
+        end)
+    end
+
+    client_prototype.pubsub = function(client, subscriptions)
+        if type(subscriptions) == 'table' then
+            if subscriptions.subscribe then
+                subscribe(client, channels(subscriptions.subscribe))
+            end
+            if subscriptions.psubscribe then
+                psubscribe(client, channels(subscriptions.psubscribe))
+            end
+        end
+        return consumer_loop(client)
+    end
+end
+
+-- Redis transactions (MULTI/EXEC)
+
+do
+    local function identity(...) return ... end
+    local emptytable = {}
+
+    local function initialize_transaction(client, options, block, queued_parsers)
+        local coro = coroutine.create(block)
+
+        if options.watch then
+            local watch_keys = {}
+            for _, key in pairs(options.watch) do
+                table.insert(watch_keys, key)
+            end
+            if #watch_keys > 0 then
+                client:watch(unpack(watch_keys))
+            end
+        end
+
+        local transaction_client = setmetatable({}, {__index=client})
+        transaction_client.exec  = function(...)
+            client.error('cannot use EXEC inside a transaction block')
+        end
+        transaction_client.multi = function(...)
+            coroutine.yield()
+        end
+        transaction_client.commands_queued = function()
+            return #queued_parsers
+        end
+
+        assert(coroutine.resume(coro, transaction_client))
+
+        transaction_client.multi = nil
+        transaction_client.discard = function(...)
+            local reply = client:discard()
+            for i, v in pairs(queued_parsers) do
+                queued_parsers[i]=nil
+            end
+            coro = initialize_transaction(client, options, block, queued_parsers)
+            return reply
+        end
+        transaction_client.watch = function(...)
+            client.error('WATCH inside MULTI is not allowed')
+        end
+        setmetatable(transaction_client, { __index = function(t, k)
+                local cmd = client[k]
+                if type(cmd) == "function" then
+                    local function queuey(self, ...)
+                        local reply = cmd(client, ...)
+                        assert((reply or emptytable).queued == true, 'a QUEUED reply was expected')
+                        table.insert(queued_parsers, reply.parser or identity)
+                        return reply
+                    end
+                    t[k]=queuey
+                    return queuey
+                else
+                    return cmd
+                end
+            end
+        })
+        client:multi()
+        return coro
+    end
+
+    local function transaction(client, options, coroutine_block, attempts)
+        local queued_parsers, replies = {}, {}
+        local retry = tonumber(attempts) or tonumber(options.retry) or 2
+        local coro = initialize_transaction(client, options, coroutine_block, queued_parsers)
+
+        local success, retval
+        if coroutine.status(coro) == 'suspended' then
+            success, retval = coroutine.resume(coro)
+        else
+            -- do not fail if the coroutine has not been resumed (missing t:multi() with CAS)
+            success, retval = true, 'empty transaction'
+        end
+        if #queued_parsers == 0 or not success then
+            client:discard()
+            assert(success, retval)
+            return replies, 0
+        end
+
+        local raw_replies = client:exec()
+        if not raw_replies then
+            if (retry or 0) <= 0 then
+                client.error("MULTI/EXEC transaction aborted by the server")
+            else
+                --we're not quite done yet
+                return transaction(client, options, coroutine_block, retry - 1)
+            end
+        end
+
+        for i, parser in pairs(queued_parsers) do
+            table.insert(replies, i, parser(raw_replies[i]))
+        end
+
+        return replies, #queued_parsers
+    end
+
+    client_prototype.transaction = function(client, arg1, arg2)
+        local options, block
+        if not arg2 then
+            options, block = {}, arg1
+        elseif arg1 then --and arg2, implicitly
+            options, block = type(arg1)=="table" and arg1 or { arg1 }, arg2
+        else
+            client.error("Invalid parameters for redis transaction.")
+        end
+
+        if not options.watch then
+            watch_keys = { }
+            for i, v in pairs(options) do
+                if tonumber(i) then
+                    table.insert(watch_keys, v)
+                    options[i] = nil
+                end
+            end
+            options.watch = watch_keys
+        elseif not (type(options.watch) == 'table') then
+            options.watch = { options.watch }
+        end
+
+        if not options.cas then
+            local tx_block = block
+            block = function(client, ...)
+                client:multi()
+                return tx_block(client, ...) --can't wrap this in pcall because we're in a coroutine.
+            end
+        end
+
+        return transaction(client, options, block)
+    end
+end
+
+-- ############################################################################
+
+local function connect_tcp(socket, parameters)
+    local host, port = parameters.host, tonumber(parameters.port)
+    local ok, err = socket:connect(host, port)
+    if not ok then
+        default_error_fn('could not connect to '..host..':'..port..' ['..err..']')
+    end
+    socket:setoption('tcp-nodelay', parameters.tcp_nodelay)
+    return socket
+end
+
+local function connect_unix(socket, parameters)
+    local ok, err = socket:connect(parameters.path)
+    if not ok then
+        default_error_fn('could not connect to '..parameters.path..' ['..err..']')
+    end
+    return socket
+end
+
+local function create_connection(parameters)
+    local perform_connection, socket
+
+    if parameters.scheme == 'unix' then
+        perform_connection, socket = connect_unix, require('socket.unix')
+        assert(socket, 'your build of LuaSocket does not support UNIX domain sockets')
+    else
+        if parameters.scheme then
+            local scheme = parameters.scheme
+            assert(scheme == 'redis' or scheme == 'tcp', 'invalid scheme: '..scheme)
+        end
+        perform_connection, socket = connect_tcp, require('socket').tcp
+    end
+
+    return perform_connection(socket(), parameters)
+end
+
+function connect(...)
+    local args, parameters = {...}, nil
+
+    if #args == 1 then
+        if type(args[1]) == 'table' then
+            parameters = args[1]
+        else
+            local uri = require('socket.url')
+            parameters = uri.parse(select(1, ...))
+            if parameters.scheme then
+                if parameters.query then
+                    for k, v in parameters.query:gmatch('([-_%w]+)=([-_%w]+)') do
+                        if k == 'tcp_nodelay' or k == 'tcp-nodelay' then
+                            parameters.tcp_nodelay = parse_boolean(v)
+                        end
+                    end
+                end
+            else
+                parameters.host = parameters.path
+            end
+        end
+    elseif #args > 1 then
+        local host, port = unpack(args)
+        parameters = { host = host, port = port }
+    end
+
+    local socket = create_connection(merge_defaults(parameters))
+    local client = create_client(client_prototype, socket, commands)
+    
+    client.error = default_error_fn
+
+    return client
+end
+
+-- ############################################################################
+
+commands = {
+    -- commands operating on the key space
+    exists           = command('EXISTS', {
+        response = toboolean
+    }),
+    del              = command('DEL'),
+    type             = command('TYPE'),
+    rename           = command('RENAME'),
+    renamenx         = command('RENAMENX', {
+        response = toboolean
+    }),
+    expire           = command('EXPIRE', {
+        response = toboolean
+    }),
+    pexpire          = command('PEXPIRE', {     -- >= 2.6
+        response = toboolean
+    }),
+    expireat         = command('EXPIREAT', {
+        response = toboolean
+    }),
+    pexpireat        = command('PEXPIREAT', {   -- >= 2.6
+        response = toboolean
+    }),
+    ttl              = command('TTL'),
+    pttl             = command('PTTL'),         -- >= 2.6
+    move             = command('MOVE', {
+        response = toboolean
+    }),
+    dbsize           = command('DBSIZE'),
+    persist          = command('PERSIST', {     -- >= 2.2
+        response = toboolean
+    }),
+    keys             = command('KEYS', {
+        response = function(response)
+            if type(response) == 'string' then
+                -- backwards compatibility path for Redis < 2.0
+                local keys = {}
+                response:gsub('[^%s]+', function(key)
+                    table.insert(keys, key)
+                end)
+                response = keys
+            end
+            return response
+        end
+    }),
+    randomkey        = command('RANDOMKEY', {
+        response = function(response)
+            if response == '' then
+                return nil
+            else
+                return response
+            end
+        end
+    }),
+    sort             = command('SORT', {
+        request = function(client, command, key, params)
+            --[[ params = {
+                    by    = 'weight_*',
+                    get   = 'object_*',
+                    limit = { 0, 10 },
+                    sort  = 'desc',
+                    alpha = true,
+                } --]]
+            local query = { key }
+
+            if params then
+                if params.by then
+                    table.insert(query, 'BY')
+                    table.insert(query, params.by)
+                end
+
+                if type(params.limit) == 'table' then
+                    -- TODO: check for lower and upper limits
+                    table.insert(query, 'LIMIT')
+                    table.insert(query, params.limit[1])
+                    table.insert(query, params.limit[2])
+                end
+
+                if params.get then
+                    if (type(params.get) == 'table') then
+                        for _, getarg in pairs(params.get) do
+                            table.insert(query, 'GET')
+                            table.insert(query, getarg)
+                        end
+                    else
+                        table.insert(query, 'GET')
+                        table.insert(query, params.get)
+                    end
+                end
+
+                if params.sort then
+                    table.insert(query, params.sort)
+                end
+
+                if params.alpha == true then
+                    table.insert(query, 'ALPHA')
+                end
+
+                if params.store then
+                    table.insert(query, 'STORE')
+                    table.insert(query, params.store)
+                end
+            end
+
+            request.multibulk(client, command, query)
+        end
+    }),
+
+    -- commands operating on string values
+    set              = command('SET'),
+    setnx            = command('SETNX', {
+        response = toboolean
+    }),
+    setex            = command('SETEX'),        -- >= 2.0
+    psetex           = command('PSETEX'),       -- >= 2.6
+    mset             = command('MSET', {
+        request = mset_filter_args
+    }),
+    msetnx           = command('MSETNX', {
+        request  = mset_filter_args,
+        response = toboolean
+    }),
+    get              = command('GET'),
+    mget             = command('MGET'),
+    getset           = command('GETSET'),
+    incr             = command('INCR'),
+    incrby           = command('INCRBY'),
+    incrbyfloat      = command('INCRBYFLOAT', { -- >= 2.6
+        response = function(reply, command, ...)
+            return tonumber(reply)
+        end,
+    }),
+    decr             = command('DECR'),
+    decrby           = command('DECRBY'),
+    append           = command('APPEND'),       -- >= 2.0
+    substr           = command('SUBSTR'),       -- >= 2.0
+    strlen           = command('STRLEN'),       -- >= 2.2
+    setrange         = command('SETRANGE'),     -- >= 2.2
+    getrange         = command('GETRANGE'),     -- >= 2.2
+    setbit           = command('SETBIT'),       -- >= 2.2
+    getbit           = command('GETBIT'),       -- >= 2.2
+
+    -- commands operating on lists
+    rpush            = command('RPUSH'),
+    lpush            = command('LPUSH'),
+    llen             = command('LLEN'),
+    lrange           = command('LRANGE'),
+    ltrim            = command('LTRIM'),
+    lindex           = command('LINDEX'),
+    lset             = command('LSET'),
+    lrem             = command('LREM'),
+    lpop             = command('LPOP'),
+    rpop             = command('RPOP'),
+    rpoplpush        = command('RPOPLPUSH'),
+    blpop            = command('BLPOP'),        -- >= 2.0
+    brpop            = command('BRPOP'),        -- >= 2.0
+    rpushx           = command('RPUSHX'),       -- >= 2.2
+    lpushx           = command('LPUSHX'),       -- >= 2.2
+    linsert          = command('LINSERT'),      -- >= 2.2
+    brpoplpush       = command('BRPOPLPUSH'),   -- >= 2.2
+
+    -- commands operating on sets
+    sadd             = command('SADD', {
+        response = toboolean
+    }),
+    srem             = command('SREM', {
+        response = toboolean
+    }),
+    spop             = command('SPOP'),
+    smove            = command('SMOVE', {
+        response = toboolean
+    }),
+    scard            = command('SCARD'),
+    sismember        = command('SISMEMBER', {
+        response = toboolean
+    }),
+    sinter           = command('SINTER'),
+    sinterstore      = command('SINTERSTORE'),
+    sunion           = command('SUNION'),
+    sunionstore      = command('SUNIONSTORE'),
+    sdiff            = command('SDIFF'),
+    sdiffstore       = command('SDIFFSTORE'),
+    smembers         = command('SMEMBERS'),
+    srandmember      = command('SRANDMEMBER'),
+
+    -- commands operating on sorted sets
+    zadd             = command('ZADD', {
+        response = toboolean
+    }),
+    zincrby          = command('ZINCRBY'),
+    zrem             = command('ZREM', {
+        response = toboolean
+    }),
+    zrange           = command('ZRANGE', {
+        request  = zset_range_request,
+        response = zset_range_reply,
+    }),
+    zrevrange        = command('ZREVRANGE', {
+        request  = zset_range_request,
+        response = zset_range_reply,
+    }),
+    zrangebyscore    = command('ZRANGEBYSCORE', {
+        request  = zset_range_byscore_request,
+        response = zset_range_reply,
+    }),
+    zrevrangebyscore = command('ZREVRANGEBYSCORE', {    -- >= 2.2
+        request  = zset_range_byscore_request,
+        response = zset_range_reply,
+    }),
+    zunionstore      = command('ZUNIONSTORE', {         -- >= 2.0
+        request = zset_store_request
+    }),
+    zinterstore      = command('ZINTERSTORE', {         -- >= 2.0
+        request = zset_store_request
+    }),
+    zcount           = command('ZCOUNT'),
+    zcard            = command('ZCARD'),
+    zscore           = command('ZSCORE'),
+    zremrangebyscore = command('ZREMRANGEBYSCORE'),
+    zrank            = command('ZRANK'),                -- >= 2.0
+    zrevrank         = command('ZREVRANK'),             -- >= 2.0
+    zremrangebyrank  = command('ZREMRANGEBYRANK'),      -- >= 2.0
+
+    -- commands operating on hashes
+    hset             = command('HSET', {        -- >= 2.0
+        response = toboolean
+    }),
+    hsetnx           = command('HSETNX', {      -- >= 2.0
+        response = toboolean
+    }),
+    hmset            = command('HMSET', {       -- >= 2.0
+        request  = hash_multi_request_builder(function(args, k, v)
+            table.insert(args, k)
+            table.insert(args, v)
+        end),
+    }),
+    hincrby          = command('HINCRBY'),      -- >= 2.0
+    hincrbyfloat     = command('HINCRBYFLOAT', {-- >= 2.6
+        response = function(reply, command, ...)
+            return tonumber(reply)
+        end,
+    }),
+    hget             = command('HGET'),         -- >= 2.0
+    hmget            = command('HMGET', {       -- >= 2.0
+        request  = hash_multi_request_builder(function(args, k, v)
+            table.insert(args, v)
+        end),
+    }),
+    hdel             = command('HDEL', {        -- >= 2.0
+        response = toboolean
+    }),
+    hexists          = command('HEXISTS', {     -- >= 2.0
+        response = toboolean
+    }),
+    hlen             = command('HLEN'),         -- >= 2.0
+    hkeys            = command('HKEYS'),        -- >= 2.0
+    hvals            = command('HVALS'),        -- >= 2.0
+    hgetall          = command('HGETALL', {     -- >= 2.0
+        response = function(reply, command, ...)
+            local new_reply = { }
+            for i = 1, #reply, 2 do new_reply[reply[i]] = reply[i + 1] end
+            return new_reply
+        end
+    }),
+
+    -- connection related commands
+    ping             = command('PING', {
+        response = function(response) return response == 'PONG' end
+    }),
+    echo             = command('ECHO'),
+    auth             = command('AUTH'),
+    select           = command('SELECT'),
+    quit             = command('QUIT', {
+        request = fire_and_forget
+    }),
+
+    -- transactions
+    multi            = command('MULTI'),        -- >= 2.0
+    exec             = command('EXEC'),         -- >= 2.0
+    discard          = command('DISCARD'),      -- >= 2.0
+    watch            = command('WATCH'),        -- >= 2.2
+    unwatch          = command('UNWATCH'),      -- >= 2.2
+
+    -- publish - subscribe
+    subscribe        = command('SUBSCRIBE'),    -- >= 2.0
+    unsubscribe      = command('UNSUBSCRIBE'),  -- >= 2.0
+    psubscribe       = command('PSUBSCRIBE'),   -- >= 2.0
+    punsubscribe     = command('PUNSUBSCRIBE'), -- >= 2.0
+    publish          = command('PUBLISH'),      -- >= 2.0
+
+    -- redis scripting
+    eval             = command('EVAL'),         -- >= 2.6
+    evalsha          = command('EVALSHA'),      -- >= 2.6
+    script           = command('SCRIPT'),       -- >= 2.6
+
+    -- remote server control commands
+    bgrewriteaof     = command('BGREWRITEAOF'),
+    config           = command('CONFIG', {     -- >= 2.0
+        response = function(reply, command, ...)
+            if (type(reply) == 'table') then
+                local new_reply = { }
+                for i = 1, #reply, 2 do new_reply[reply[i]] = reply[i + 1] end
+                return new_reply
+            end
+
+            return reply
+        end
+    }),
+    client           = command('CLIENT'),       -- >= 2.4
+    slaveof          = command('SLAVEOF'),
+    save             = command('SAVE'),
+    bgsave           = command('BGSAVE'),
+    lastsave         = command('LASTSAVE'),
+    flushdb          = command('FLUSHDB'),
+    flushall         = command('FLUSHALL'),
+    shutdown         = command('SHUTDOWN', {
+        request = fire_and_forget
+    }),
+    slowlog          = command('SLOWLOG', {     -- >= 2.2.13
+        response = function(reply, command, ...)
+            if (type(reply) == 'table') then
+                local structured = { }
+                for index, entry in ipairs(reply) do
+                    structured[index] = {
+                        id = tonumber(entry[1]),
+                        timestamp = tonumber(entry[2]),
+                        duration = tonumber(entry[3]),
+                        command = entry[4],
+                    }
+                end
+                return structured
+            end
+
+            return reply
+        end
+    }),
+    info             = command('INFO', {
+        response = function(response)
+            if string.find(response, '^# ') then
+                return parse_info_new(response)
+            end
+            return parse_info(response)
+        end
+    }),
+}
diff -rNu a/src/lua/lua-nginx-module/t/StapThread.pm b/src/lua/lua-nginx-module/t/StapThread.pm
--- a/src/lua/lua-nginx-module/t/StapThread.pm	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/StapThread.pm	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,277 @@
+package t::StapThread;
+
+use strict;
+use warnings;
+
+our $GCScript = <<'_EOC_';
+global ids, cur
+global in_req = 0
+global alive_reqs
+
+function gen_id(k) {
+    if (ids[k]) return ids[k]
+    ids[k] = ++cur
+    return cur
+}
+
+F(ngx_http_handler) {
+    if (!alive_reqs[$r] && $r == $r->main) {
+        in_req++
+        alive_reqs[$r] = 1
+
+        if (in_req == 1) {
+            delete ids
+            cur = 0
+        }
+    }
+}
+
+F(ngx_http_free_request) {
+    if (alive_reqs[$r]) {
+        in_req--
+        delete alive_reqs[$r]
+    }
+}
+
+F(ngx_http_terminate_request) {
+    if (alive_reqs[$r]) {
+        in_req--
+        delete alive_reqs[$r]
+    }
+}
+
+M(http-lua-user-thread-spawn) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("spawn user thread %x in %x\n", c, p)
+}
+
+M(http-lua-thread-delete) {
+    t = gen_id($arg2)
+    printf("delete thread %x\n", t)
+}
+
+M(http-lua-user-coroutine-create) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("create %x in %x\n", c, p)
+}
+
+M(http-lua-coroutine-done) {
+    t = gen_id($arg2)
+    printf("terminate %d: %s\n", t, $arg3 ? "ok" : "fail")
+    #print_ubacktrace()
+}
+
+_EOC_
+
+our $StapScript = <<'_EOC_';
+global ids, cur
+global timers
+global in_req = 0
+global co_status
+global alive_reqs
+
+function gen_id(k) {
+    if (ids[k]) return ids[k]
+    ids[k] = ++cur
+    return cur
+}
+
+F(ngx_http_handler) {
+    if (!alive_reqs[$r] && $r == $r->main) {
+        in_req++
+        alive_reqs[$r] = 1
+
+        printf("in req: %d\n", in_req)
+
+        if (in_req == 1) {
+            delete ids
+            cur = 0
+            co_status[0] = "running"
+            co_status[1] = "suspended"
+            co_status[2] = "normal"
+            co_status[3] = "dead"
+        }
+    }
+}
+
+F(ngx_http_free_request) {
+    if (alive_reqs[$r]) {
+        in_req--
+        println("free request")
+        delete alive_reqs[$r]
+    }
+}
+
+F(ngx_http_terminate_request) {
+    if (alive_reqs[$r]) {
+        in_req--
+        println("terminate request")
+        delete alive_reqs[$r]
+    }
+}
+
+F(ngx_http_lua_post_thread) {
+    id = gen_id($coctx->co)
+    printf("post thread %d\n", id)
+}
+
+M(timer-add) {
+    timers[$arg1] = $arg2
+    printf("add timer %d\n", $arg2)
+}
+
+M(timer-del) {
+    printf("delete timer %d\n", timers[$arg1])
+    delete timers[$arg1]
+}
+
+M(timer-expire) {
+    printf("expire timer %d\n", timers[$arg1])
+    delete timers[$arg1]
+}
+
+F(ngx_http_lua_sleep_handler) {
+    printf("sleep handler called\n")
+}
+
+F(ngx_http_lua_run_thread) {
+    id = gen_id($ctx->cur_co_ctx->co)
+    printf("run thread %d\n", id)
+    #if (id == 1) {
+        #print_ubacktrace()
+    #}
+}
+
+probe process("/usr/local/openresty-debug/luajit/lib/libluajit-5.1.so.2").function("lua_resume") {
+    id = gen_id($L)
+    printf("lua resume %d\n", id)
+}
+
+M(http-lua-user-thread-spawn) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("spawn uthread %x in %x\n", c, p)
+}
+
+M(http-lua-thread-delete) {
+    t = gen_id($arg2)
+    uthreads = @cast($arg3, "ngx_http_lua_ctx_t")->uthreads
+    printf("delete thread %x (uthreads %d)\n", t, uthreads)
+    #print_ubacktrace()
+}
+
+M(http-lua-run-posted-thread) {
+    t = gen_id($arg2)
+    printf("run posted thread %d (status %s)\n", t, co_status[$arg3])
+}
+
+M(http-lua-user-coroutine-resume) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("resume %x in %x\n", c, p)
+}
+
+M(http-lua-thread-yield) {
+    t = gen_id($arg2)
+    printf("thread %d yield\n", t)
+}
+
+/*
+F(ngx_http_lua_coroutine_yield) {
+    printf("yield %x\n", gen_id($L))
+}
+*/
+
+M(http-lua-user-coroutine-yield) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("yield %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_atpanic) {
+    printf("lua atpanic(%d):", gen_id($L))
+    print_ubacktrace();
+}
+
+F(ngx_http_lua_run_posted_threads) {
+    printf("run posted threads\n")
+}
+
+F(ngx_http_finalize_request) {
+    printf("finalize request %s: rc:%d c:%d a:%d\n", ngx_http_req_uri($r), $rc, $r->main->count, $r == $r->main);
+    #if ($rc == -1) {
+        #print_ubacktrace()
+    #}
+}
+F(ngx_http_lua_post_subrequest) {
+    printf("post subreq: %s rc=%d, status=%d a=%d\n", ngx_http_req_uri($r), $rc,
+         $r->headers_out->status, $r == $r->main)
+    #print_ubacktrace()
+}
+M(http-subrequest-done) {
+    printf("subrequest %s done\n", ngx_http_req_uri($r))
+}
+M(http-subrequest-wake-parent) {
+    printf("subrequest wake parent %s\n", ngx_http_req_uri($r->parent))
+}
+M(http-lua-user-coroutine-create) {
+    p = gen_id($arg2)
+    c = gen_id($arg3)
+    printf("create %x in %x\n", c, p)
+}
+
+F(ngx_http_lua_ngx_exec) { println("exec") }
+
+F(ngx_http_lua_ngx_exit) { println("exit") }
+
+F(ngx_http_lua_req_body_cleanup) {
+    println("lua req body cleanup")
+}
+
+F(ngx_http_read_client_request_body) {
+    println("read client request body")
+}
+
+F(ngx_http_lua_finalize_coroutines) {
+    println("finalize coroutines")
+}
+
+F(ngx_http_lua_ngx_exit) {
+    println("ngx.exit() called")
+}
+
+F(ngx_http_lua_sleep_resume) {
+    println("lua sleep resume")
+}
+
+M(http-lua-coroutine-done) {
+    t = gen_id($arg2)
+    printf("terminate coro %d: %s, waited by parent:%d, child cocotx: %p\n", t, $arg3 ? "ok" : "fail", $ctx->cur_co_ctx->waited_by_parent, $ctx->cur_co_ctx)
+    //print_ubacktrace()
+}
+
+F(ngx_http_lua_ngx_echo) {
+    println("ngx.print or ngx.say")
+}
+
+F(ngx_http_lua_del_all_threads) {
+    println("del all threads")
+}
+
+/*
+M(http-lua-info) {
+    msg = user_string($arg1)
+    printf("lua info: %s\n", msg)
+}
+*/
+
+M(http-lua-user-thread-wait) {
+    p = gen_id($arg1)
+    c = gen_id($arg2)
+    printf("lua thread %d waiting on %d, child coctx: %p\n", p, c, $sub_coctx)
+}
+_EOC_
+
+1;
diff -rNu a/src/lua/lua-nginx-module/t/TestNginxLua.pm b/src/lua/lua-nginx-module/t/TestNginxLua.pm
--- a/src/lua/lua-nginx-module/t/TestNginxLua.pm	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/t/TestNginxLua.pm	2013-10-22 14:31:20.026679803 +0800
@@ -0,0 +1,21 @@
+use Test::Nginx::Socket -Base;
+
+my $code = $ENV{TEST_NGINX_INIT_BY_LUA};
+
+if ($code) {
+    $code =~ s/\\/\\\\/g;
+    $code =~ s/['"]/\\$&/g;
+
+    Test::Nginx::Socket::set_http_config_filter(sub {
+        my $config = shift;
+        if ($config =~ /init_by_lua_file/) {
+            return $config;
+        }
+        unless ($config =~ s{init_by_lua\s*(['"])((?:\\.|.)*)\1\s*;}{init_by_lua $1$code$2$1;}s) {
+            $config .= "init_by_lua '$code';";
+        }
+        return $config;
+    });
+}
+
+1;
diff -rNu a/src/lua/lua-nginx-module/tapset/ngx_lua.stp b/src/lua/lua-nginx-module/tapset/ngx_lua.stp
--- a/src/lua/lua-nginx-module/tapset/ngx_lua.stp	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/tapset/ngx_lua.stp	2013-10-22 14:31:20.034679593 +0800
@@ -0,0 +1,5 @@
+function ngx_http_lua_ctx_context(r)
+{
+
+}
+
diff -rNu a/src/lua/lua-nginx-module/util/build2.sh b/src/lua/lua-nginx-module/util/build2.sh
--- a/src/lua/lua-nginx-module/util/build2.sh	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/build2.sh	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,52 @@
+#!/usr/bin/env bash
+
+# this file is mostly meant to be used by the author himself.
+
+root=`pwd`
+version=${1:-1.4.1}
+home=~
+force=$2
+
+# the ngx-build script is from https://github.com/agentzh/nginx-devel-utils
+
+            #--add-module=$home/work/nginx_upload_module-2.2.0 \
+
+            #--without-pcre \
+            #--without-http_rewrite_module \
+            #--without-http_autoindex_module \
+            #--with-cc=gcc46 \
+            #--with-cc=clang \
+            #--without-http_referer_module \
+
+time ngx-build $force $version \
+            --with-cc-opt="-I$PCRE_INC" \
+            --with-http_realip_module \
+        --with-http_ssl_module \
+            --add-module=$root/../ndk-nginx-module \
+            --add-module=$root/../set-misc-nginx-module \
+            --with-ld-opt="-L$PCRE_LIB -Wl,-rpath,$PCRE_LIB:$LIBDRIZZLE_LIB:$LUAJIT_LIB:/usr/local/lib" \
+            --with-http_spdy_module \
+            --without-mail_pop3_module \
+            --without-mail_imap_module \
+            --without-mail_smtp_module \
+            --without-http_upstream_ip_hash_module \
+            --without-http_empty_gif_module \
+            --without-http_memcached_module \
+            --without-http_auth_basic_module \
+            --without-http_userid_module \
+                --add-module=$home/work/nginx/ngx_http_auth_request_module-0.2 \
+                --add-module=$root/../echo-nginx-module \
+                --add-module=$root/../memc-nginx-module \
+                --add-module=$root/../srcache-nginx-module \
+                --add-module=$root \
+              --add-module=$root/../headers-more-nginx-module \
+                --add-module=$root/../drizzle-nginx-module \
+                --add-module=$root/../rds-json-nginx-module \
+                --add-module=$root/../coolkit-nginx-module \
+                --add-module=$root/../redis2-nginx-module \
+          --with-select_module \
+          --with-poll_module \
+          --with-rtsig_module \
+                $opts \
+                --with-debug
+
diff -rNu a/src/lua/lua-nginx-module/util/build.sh b/src/lua/lua-nginx-module/util/build.sh
--- a/src/lua/lua-nginx-module/util/build.sh	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/build.sh	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,39 @@
+#!/bin/bash
+
+# this file is mostly meant to be used by the author himself.
+
+version=${1:-0.8.54}
+opts=$2
+
+root=$(cd ${0%/*}/.. && echo $PWD)
+mkdir -p $root/{build,work}
+
+cd $root
+git submodule update --init
+
+cd $root/build
+if [ ! -s nginx-$version.tar.gz ]; then
+    wget "http://sysoev.ru/nginx/nginx-$version.tar.gz" -O nginx-$version.tar.gz
+fi
+tar -xzvf nginx-$version.tar.gz
+
+cd nginx-$version/
+if [[ "$BUILD_CLEAN" -eq 1 || ! -f Makefile || "$root/config" -nt Makefile || "$root/util/build.sh" -nt Makefile ]]; then
+	./configure --prefix=$root/work \
+				--add-module=$root \
+				--add-module=$root/deps/ngx_devel_kit \
+				$opts \
+                                --with-debug
+fi
+
+if [ -f $root/work/sbin/nginx ]; then
+    rm -f $root/work/sbin/nginx
+fi
+
+if [ -f $root/work/logs/nginx.pid ]; then
+    kill `cat $root/work/logs/nginx.pid`
+fi
+
+make -j2
+make install
+
diff -rNu a/src/lua/lua-nginx-module/util/fix-comments b/src/lua/lua-nginx-module/util/fix-comments
--- a/src/lua/lua-nginx-module/util/fix-comments	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/fix-comments	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,27 @@
+#!/usr/bin/env perl
+
+use strict;
+use warnings;
+
+for my $infile (@ARGV) {
+    warn "Processing $infile...\n";
+    open my $in, $infile or
+        die "Cannot open $infile for reading: $!\n";
+    my $s;
+    my $changed = 0;
+    while (<$in>) {
+        $changed += s{//(.*)}{/* $1 */};
+        $s .= $_;
+    }
+    close $in;
+
+    if ($changed) {
+        my $outfile = $infile;
+        open my $out, ">$outfile" or
+            die "Cannot open $outfile for writing: $!\n";
+        print $out $s;
+        close $out;
+        warn "Wrote $outfile\n";
+    }
+}
+
diff -rNu a/src/lua/lua-nginx-module/util/gdbinit b/src/lua/lua-nginx-module/util/gdbinit
--- a/src/lua/lua-nginx-module/util/gdbinit	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/gdbinit	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,415 @@
+# This gdb script provides several useful routines for debugging ngx_lua or
+# standalone Lua/LuaJIT.
+#
+# You need gdb >= v7.3 to make this script working correctly.
+#
+# Installation: place it at $HOME/.gdbinit
+#
+# -- chaoslawful <at> gmail <dot> com
+
+#### Lua type defines ####
+
+set $__LUA_TNONE = -1
+set $__LUA_TNIL = 0
+set $__LUA_TBOOLEAN = 1
+set $__LUA_TLIGHTUSERDATA = 2
+set $__LUA_TNUMBER = 3
+set $__LUA_TSTRING = 4
+set $__LUA_TTABLE = 5
+set $__LUA_TFUNCTION = 6
+set $__LUA_TUSERDATA = 7
+set $__LUA_TTHREAD = 8
+
+#### Lua constants ####
+
+set $__LUA_GLOBALSINDEX = -10002
+set $__LUA_ENVIRONINDEX = -10001
+set $__LUA_REGISTRYINDEX = -10000
+
+#### Auxiliary methods ####
+
+define __lua_debug_instance
+	if !$__lua_debug_instance
+		set $__lua_debug_instance = (lua_Debug*)malloc(sizeof(lua_Debug))
+	end
+end
+
+define __free_lua_debug_instance
+	if $__lua_debug_instance
+		set $rc = free($__lua_debug_instance)
+		set $__lua_debug_instance = 0
+	end
+end
+
+set $__BUCKET_SIZE = 16
+define __set_instance
+	if !$__set_instance
+		set $__set_instance = (void*(*(*))[2])malloc($__BUCKET_SIZE*sizeof(void*(*)[2]))
+		set $rc = memset($__set_instance, 0, $__BUCKET_SIZE*sizeof(void*(*)[2]))
+	end
+end
+
+define __free_set_instance
+	if $__set_instance
+		__set_clean
+		set $rc = free($__set_instance)
+		set $__set_instance = 0
+	end
+end
+
+define __set_add
+	set $p = (void*)$arg0
+	set $__bkt_idx = (int)$p%$__BUCKET_SIZE
+
+	__set_instance
+	set $__elem = (void*(*)[2])$__set_instance[$__bkt_idx]
+	set $__found = 0
+	while $__elem
+		if (*$__elem)[0] == $p
+			set $__found = 1
+			loop_break
+		end
+		set $__elem = (void*(*)[2])(*$__elem)[1]
+	end
+	if $__found
+		set $existed_in_set = 1
+	else
+		set $existed_in_set = 0
+
+		set $rc = (void*(*)[2])calloc(1, sizeof(void*)*2)
+		set (*$rc)[0] = $p
+		set (*$rc)[1] = $__set_instance[$__bkt_idx]
+		set $__set_instance[$__bkt_idx] = $rc
+	end
+end
+
+define __set_is_exist
+	set $p = (void*)$arg0
+	set $__bkt_idx = (int)$p%$__BUCKET_SIZE
+
+	__set_instance
+	set $__elem = (void*(*)[2])$__set_instance[$__bkt_idx]
+	set $__found = 0
+	while $__elem
+		if (*$__elem)[0] == $p
+			set $__found = 1
+			loop_break
+		end
+		set $__elem = (void*(*)[2])(*$__elem)[1]
+	end
+	if $__found
+		set $existed_in_set = 1
+	else
+		set $existed_in_set = 0
+	end
+end
+
+define __set_clean
+	__set_instance
+
+	set $__bkt_idx = 0
+	while $__bkt_idx < $__BUCKET_SIZE
+		set $__elem = (void*(*)[2])$__set_instance[$__bkt_idx]
+		while $__elem
+			set $__next = (void*(*)[2])(*$__elem)[1]
+			set $rc = free($__elem)
+			set $__elem = $__next
+		end
+		set $__set_instance[$__bkt_idx] = 0
+		set $__bkt_idx = $__bkt_idx+1
+	end
+end
+
+define hook-quit
+	__free_lua_debug_instance
+	__free_set_instance
+end
+
+define hook-detach
+	__free_lua_debug_instance
+	__free_set_instance
+end
+
+define hook-disconnect
+	__free_lua_debug_instance
+	__free_set_instance
+end
+
+define _lua_pop
+	set $l = (lua_State*)$arg0
+	set $_n = (int)$arg1
+	set $_rc = lua_settop($l, -$_n-1)
+end
+
+define _lua_dump_locals
+	set $l = (lua_State*)$arg0
+	set $dbg = (lua_Debug*)$arg1
+	set $idx = 1
+
+	set $rc = lua_getlocal($l, $dbg, $idx)
+	if $rc
+		printf "\t----[[ Locals ]]----\n"
+		while $rc
+			printf "\t%d:\t'%s' = ", $idx, $rc
+			__lua_dump_stack $l -1
+			printf "\n"
+
+			_lua_pop $l 1
+			set $idx = $idx + 1
+			set $rc = lua_getlocal($l, $dbg, $idx)
+		end
+	else
+		printf "\tNo locals!\n"
+	end
+	printf "\n"
+end
+
+define _lua_dump_upvalues
+	set $l = (lua_State*)$arg0
+	set $dbg = (lua_Debug*)$arg1
+	set $idx = 1
+
+	set $rc = lua_getinfo($l, "f", $dbg)
+	if $rc
+		set $rc = lua_getupvalue($l, -1, $idx)
+		if $rc
+			printf "\t----[[ Upvalues ]]----\n"
+			while $rc
+				printf "\t%d:\t'%s' = ", $idx, $rc
+				__lua_dump_stack $l -1
+				printf "\n"
+
+				_lua_pop $l 1
+				set $idx = $idx + 1
+				set $rc = lua_getupvalue($l, -1, $idx)
+			end
+		else
+			printf "\tNo upvalues!\n"
+		end
+		_lua_pop $l 1
+	else
+		printf "\tFailed to get function closure!\n"
+	end
+	printf "\n"
+end
+
+define __lua_dump_stack
+	__set_clean
+	__lua_dump_stack_aux $arg0 $arg1 0
+end
+
+define __lua_dump_stack_aux
+	set $l = (lua_State*)$arg0
+	set $nidx_$arg2 = (int)$arg1
+	set $cidx_$arg2 = (int)$arg2+1
+
+	# relative stack index to absolute index
+	if $nidx_$arg2 < 0 && $nidx_$arg2 > $__LUA_REGISTRYINDEX
+		set $nidx_$arg2 = $nidx_$arg2 + (int)lua_gettop($l) + 1
+	end
+
+	set $vt_$arg2 = (int)lua_type($l, $nidx_$arg2)
+
+	if $vt_$arg2 == $__LUA_TNONE
+		echo <invalid index>
+	end
+	if $vt_$arg2 == $__LUA_TNIL
+		echo (nil)
+	end
+	if $vt_$arg2 == $__LUA_TBOOLEAN
+		printf "(bool) %d", lua_toboolean($l, $nidx_$arg2)
+	end
+	if $vt_$arg2 == $__LUA_TLIGHTUSERDATA
+		printf "(ludata) %p", lua_touserdata($l, $nidx_$arg2)
+	end
+	if $vt_$arg2 == $__LUA_TNUMBER
+		printf "%g", lua_tonumber($l, $nidx_$arg2)
+	end
+	if $vt_$arg2 == $__LUA_TSTRING
+		set $tmplen = (size_t*)malloc(sizeof(size_t))
+		set $tmp = lua_pushvalue($l, $nidx_$arg2)
+		set $tmp = lua_tolstring($l, -1, $tmplen)
+#printf "(string:%d) ", *$tmplen
+		eval "output/r *(const char (*)[%d])$tmp", *$tmplen
+		_lua_pop $l 1
+		set $tmp = free($tmplen)
+	end
+	if $vt_$arg2 == $__LUA_TTABLE
+		set $rc = lua_topointer($l, $nidx_$arg2)
+#printf "(table) %p { ", $rc
+		printf "{ "
+		__set_add $rc
+		if $existed_in_set
+			printf "... "
+		else
+			set $rc = lua_pushnil($l)
+			set $rc = lua_next($l, $nidx_$arg2)
+			while $rc != 0
+				printf "["
+				__lua_dump_stack_aux $l -2 $cidx_$arg2
+				printf "]"
+				printf " = "
+				__lua_dump_stack_aux $l -1 $cidx_$arg2
+				printf ", "
+				_lua_pop $l 1
+				set $rc = lua_next($l, $nidx_$arg2)
+			end
+		end
+		printf "}"
+	end
+	if $vt_$arg2 == $__LUA_TFUNCTION
+		printf "(func) %p", lua_topointer($l, $nidx_$arg2)
+	end
+	if $vt_$arg2 == $__LUA_TUSERDATA
+		printf "(udata) %p", lua_topointer($l, $nidx_$arg2)
+	end
+	if $vt_$arg2 == $__LUA_TTHREAD
+		printf "(thread) %p", lua_topointer($l, $nidx_$arg2)
+	else
+		if $vt_$arg2 > $__LUA_TTHREAD || $vt_$arg2 < 0
+			echo <unknown type>
+		end
+	end
+end
+
+#### Command methods ####
+
+define lbt 
+	if $argc < 1
+		echo Please specify Lua state and/or dump flag!\n
+	else
+		set $l = (lua_State*)$arg0
+		if $argc > 1
+			set $dump_local = ($arg1&1)==1
+			set $dump_upvalue = ($arg1&2)==2
+		else
+			set $dump_local = 0
+			set $dump_upvalue = 0
+		end
+
+		__lua_debug_instance
+		set $dbg = $__lua_debug_instance
+
+		set $level = 0
+		set $rc = lua_getstack($l, $level, $dbg)
+		while $rc > 0
+			set $rc = lua_getinfo($l, "Sln", $dbg)
+			set $name = $dbg->name
+			if !$name
+				set $name = "???"
+			end
+
+			printf "#%d\t%s\t[%s]\tat %s:%d\n", $level, $name, $dbg->what, $dbg->source, $dbg->currentline
+
+			if $dump_local
+				_lua_dump_locals $l $dbg
+			end
+			if $dump_upvalue
+				_lua_dump_upvalues $l $dbg
+			end
+
+			set $level = $level+1
+			set $rc = lua_getstack($l, $level, $dbg)
+		end
+	end
+end
+
+document lbt
+lbt <lua state> [<dump>]: Dump the backtrace of the specified Lua state. <dump> is a mask value, whose bit 1/2 controls the dump of locals/upvalues at each stack frame correspondingly. So set <dump> to 1 dumps only locals; set to 2 dumps only upvalues; and set to 3 dumps both locals and upvalues.
+end
+
+define ll
+	if $argc != 2
+		echo Please specify Lua state and stack frame number (0-based)!\n
+	else
+		set $l = (lua_State*)$arg0
+		set $level = (int)$arg1
+
+		__lua_debug_instance
+		set $dbg = $__lua_debug_instance
+
+		set $rc = lua_getstack($l, $level, $dbg)
+		if $rc > 0
+			_lua_dump_locals $l $dbg
+		else
+			echo Failed to get Lua stack frame!\n
+		end
+	end
+end
+
+document ll
+ll <lua state> <frameno>: Dump all local vars in the specified Lua stack frame (0-based).
+end
+
+define lu
+	if $argc != 2
+		echo Please specify Lua state and stack frame number (0-based)!\n
+	else
+		set $l = (lua_State*)$arg0
+		set $level = (int)$arg1
+
+		__lua_debug_instance
+		set $dbg = $__lua_debug_instance
+
+		set $rc = lua_getstack($l, $level, $dbg)
+		if $rc > 0
+			_lua_dump_upvalues $l $dbg
+		else
+			echo Failed to get Lua stack frame!\n
+		end
+	end
+end
+
+document lu
+lu <lua state> <frameno>: Dump all upvalues in the specified Lua stack frame (0-based).
+end
+
+define lg
+	if $argc != 1
+		echo Please specify Lua state!\n
+	else
+		set $l = (lua_State*)$arg0
+		__lua_dump_stack $l $__LUA_GLOBALSINDEX
+		printf "\n"
+	end
+end
+
+document lg
+lg <lua state>: Dump all entries in Lua global table.
+end
+
+define lr
+	if $argc != 1
+		echo Please specify Lua state!\n
+	else
+		set $l = (lua_State*)$arg0
+		__lua_dump_stack $l $__LUA_REGISTRYINDEX
+		printf "\n"
+	end
+end
+
+document lr
+lr <lua state>: Dump all entries in Lua registry table.
+end
+
+define ls
+	if $argc != 1
+		echo Please specify Lua state!\n
+	else
+		set $l = (lua_State*)$arg0
+		set $idx = lua_gettop($l)
+		while $idx >= 1
+			printf "#%d ", $idx
+			__lua_dump_stack $l $idx
+			printf "\n"
+			set $idx = $idx - 1
+		end
+	end
+end
+
+document ls
+ls <lua state>: Dump all entries in call stack.
+end
+
+# vi:ft=gdb ts=4 sw=4
+
diff -rNu a/src/lua/lua-nginx-module/util/ngx-links b/src/lua/lua-nginx-module/util/ngx-links
--- a/src/lua/lua-nginx-module/util/ngx-links	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/ngx-links	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,62 @@
+#!/usr/bin/env perl
+
+use strict;
+use warnings;
+
+use Cwd qw( cwd );
+use Getopt::Std;
+
+my %opts;
+getopts('f', \%opts) or
+    die "Usage: $0 [-f]
+Options:
+    -f          Override exising symbolic links with force
+";
+
+my $root = shift || 'src';
+
+my $force = $opts{f};
+
+opendir my $dir, $root
+    or die "Can't open directory src/ for reading: $!\n";
+
+my @links;
+
+while (my $entry = readdir $dir) {
+    my ($base, $ext);
+
+    my $source = "$root/$entry";
+
+    if (-l $source || -d $source) {
+        warn "skipping $source\n";
+        next;
+    }
+
+    if ($entry =~ m{ ^ ngx_ (?: \w+ _ )+ (\w+) \. ([ch]|rl) $}x) {
+        ($base, $ext) = ($1, $2);
+    } else {
+        next;
+    }
+
+    my $target = "$root/$base.$ext";
+    if (-e $target && ! -l $target) {
+        die "target $target already exists, and not a symlink, not overriding...Abort.\n";
+    } elsif (-l $target) {
+        #warn "it's a link";
+        if ( ! $force ) {
+            die "target $target already exists, not overriding...Abort.\n";
+        }
+        warn "overriding existing symlink $target\n";
+    }
+    #warn "creating $target --> $root/$entry\n";
+    system("ln -svf `pwd`/$source $target") == 0 or
+        die "Failed to create the symlink\n";;
+
+    push @links, $target;
+}
+
+print join("\n", @links), "\n";
+
+close $dir;
+
+
diff -rNu a/src/lua/lua-nginx-module/util/reindex b/src/lua/lua-nginx-module/util/reindex
--- a/src/lua/lua-nginx-module/util/reindex	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/reindex	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,64 @@
+#!/usr/bin/perl
+#: reindex.pl
+#: reindex .t files for Test::Base based test files
+#: Copyright (c) 2006 Agent Zhang
+#: 2006-04-27 2006-05-09
+
+use strict;
+use warnings;
+
+#use File::Copy;
+use Getopt::Std;
+
+my %opts;
+getopts('hb:', \%opts);
+if ($opts{h} or ! @ARGV) {
+    die "Usage: reindex [-b 0] t/*.t\n";
+}
+
+my $init = $opts{b};
+$init = 1 if not defined $init;
+
+my @files = map glob, @ARGV;
+for my $file (@files) {
+    next if -d $file or $file !~ /\.t_?$/;
+    reindex($file);
+}
+
+sub reindex {
+    my $file = $_[0];
+    open my $in, $file or
+        die "Can't open $file for reading: $!";
+    my @lines;
+    my $counter = $init;
+    my $changed;
+    while (<$in>) {
+        s/\r$//;
+        my $num;
+        s/ ^ === \s+ TEST \s+ (\d+)/$num=$1; "=== TEST " . $counter++/xie;
+        next if !defined $num;
+        if ($num != $counter-1) {
+            $changed++;
+        }
+    } continue {
+        push @lines, $_;
+    }
+    close $in;
+    my $text = join '', @lines;
+    $text =~ s/(?x) \n+ === \s+ TEST/\n\n\n\n=== TEST/ixsg;
+    $text =~ s/__(DATA|END)__\n+=== TEST/__${1}__\n\n=== TEST/;
+    #$text =~ s/\n+$/\n\n/s;
+    if (! $changed and $text eq join '', @lines) {
+        warn "reindex: $file:\tskipped.\n";
+        return;
+    }
+    #File::Copy::copy( $file, "$file.bak" );
+    open my $out, "> $file" or
+        die "Can't open $file for writing: $!";
+    binmode $out;
+    print $out $text;
+    close $out;
+
+    warn "reindex: $file:\tdone.\n";
+}
+
diff -rNu a/src/lua/lua-nginx-module/util/releng b/src/lua/lua-nginx-module/util/releng
--- a/src/lua/lua-nginx-module/util/releng	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/releng	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+./update-readme
+ack '(?<=\#define)\s*DDEBUG\s*1' src
+echo ====================================================
+ack '(?<=_version_string) "\d+\.\d+\.\d+"' src
+ack '(?<=This document describes rds-json-nginx-module v)\d+\.\d+' README
+
diff -rNu a/src/lua/lua-nginx-module/util/retab b/src/lua/lua-nginx-module/util/retab
--- a/src/lua/lua-nginx-module/util/retab	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/retab	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+for f in $*; do
+	if [ -f "$f" ]; then
+		vim -c retab -c x $f
+	fi
+done
+
diff -rNu a/src/lua/lua-nginx-module/util/revim b/src/lua/lua-nginx-module/util/revim
--- a/src/lua/lua-nginx-module/util/revim	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/revim	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+# vim:set ft=perl ts=4 sw=4 et fdm=marker:
+#
+# revim - add customized vim modeline for given files
+# Copyright (c) 2010 chaoslawful
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+my %opts;
+
+getopts('hm:', \%opts);
+
+if($opts{h} or !@ARGV) {
+    die <<EOT;
+Usage: revim [-m <vim modeline>] src/*
+
+In <vim modeline>, the following placeholder(s) can be used:
+
+    * %t - Expands to vim file type. E.g. 'c' for .c files, 'perl' for .pl files.
+EOT
+}
+
+my $vim_ml = $opts{m} || "vim:set ft=%t ts=4 sw=4 et fdm=marker:";
+my @files = map glob, @ARGV;
+for my $file (@files) {
+    next if -d $file;
+    my ($ft, $ml) = detect_filetype($file, $vim_ml);
+    next if !defined($ft);
+    revim($file, $ml);
+}
+
+sub detect_filetype
+{
+    my ($f, $tmpl) = @_;
+    my ($ft, $lcmt, $rcmt);
+    my %phs;
+
+    if($f =~ /.([cC]|[hH])$/) {
+        $ft = "c";
+        ($lcmt, $rcmt) = ("/* ", " */");
+    } elsif($f =~ /.(pl|pm)$/) {
+        $ft = "perl";
+        ($lcmt, $rcmt) = ("# ", "");
+    } elsif($f =~ /.t_?$/) {
+        # assuming tests are written in perl
+        $ft = "perl";
+        ($lcmt, $rcmt) = ("# ", "");
+    } else {
+        $ft = undef;
+    }
+
+    if(defined($ft)) {
+        %phs = (
+            "%t" => $ft,
+        );
+
+        $tmpl =~ s/(%[a-z])/$phs{$1}/ge;
+        $tmpl =~ s/^/$lcmt/;
+        $tmpl =~ s/$/$rcmt/;
+
+        return ($ft, $tmpl);
+    }
+
+    return (undef, undef);
+}
+
+sub revim
+{
+    my ($f, $ml) = @_;
+    my @lines;
+
+    open my $in, $f
+        or die "Can't open $f for reading: $!";
+    while(<$in>) {
+        push(@lines, $_);
+    }
+    close $in;
+
+    my @nlines = grep {!/\bvim?:/} @lines;
+    warn "revim: $f:\tremoved existing vim modeline.\n"
+        if(@nlines != @lines);
+
+    if($nlines[0] =~ /^#!/) {    # has shebang line
+        my $shebang = shift @nlines;
+        unshift(@nlines, $shebang, "$ml\n");
+    } else {
+        unshift(@nlines, "$ml\n");
+    }
+
+    my $text = join '', @nlines;
+
+    open my $out, "> $f"
+        or die "Can't open $f for writing: $!";
+    binmode $out;
+    print $out $text;
+    close $out;
+
+    warn "revim: $f:\tdone.\n";
+}
+
diff -rNu a/src/lua/lua-nginx-module/util/run_test.sh b/src/lua/lua-nginx-module/util/run_test.sh
--- a/src/lua/lua-nginx-module/util/run_test.sh	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/run_test.sh	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,10 @@
+#!/bin/bash
+script_dir=$(dirname $0)
+root=$(readlink -f $script_dir/..)
+testfile=${1:-$root/t/*.t $root/t/*/*.t}
+cd $root
+$script_dir/reindex $testfile
+export PATH=$root/work/sbin:$PATH
+killall nginx
+prove -I$root/../test-nginx/lib $testfile
+
diff -rNu a/src/lua/lua-nginx-module/util/update-readme.sh b/src/lua/lua-nginx-module/util/update-readme.sh
--- a/src/lua/lua-nginx-module/util/update-readme.sh	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/util/update-readme.sh	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+perl util/wiki2pod.pl doc/manpage.wiki > /tmp/a.pod && pod2text /tmp/a.pod > README
+
diff -rNu a/src/lua/lua-nginx-module/valgrind.suppress b/src/lua/lua-nginx-module/valgrind.suppress
--- a/src/lua/lua-nginx-module/valgrind.suppress	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/lua-nginx-module/valgrind.suppress	2013-10-22 14:31:20.030679672 +0800
@@ -0,0 +1,208 @@
+{
+<insert_a_suppression_name_here>
+Memcheck:Addr1
+fun:ngx_init_cycle
+fun:ngx_master_process_cycle
+fun:main
+}
+{
+<insert_a_suppression_name_here>
+Memcheck:Addr4
+fun:ngx_init_cycle
+fun:ngx_master_process_cycle
+fun:main
+}
+
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:lj_str_new
+}
+{
+<insert_a_suppression_name_here>
+Memcheck:Cond
+fun:lj_str_new
+fun:countint
+fun:index2adr
+fun:lua_type
+fun:ngx_http_lua_ngx_echo
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:lj_str_new
+   obj:*
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:ngx_vslprintf
+   fun:ngx_snprintf
+   fun:ngx_sock_ntop
+   fun:ngx_event_accept
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:ngx_vslprintf
+   fun:ngx_snprintf
+   fun:ngx_sock_ntop
+   fun:ngx_event_accept
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Addr1
+   fun:ngx_vslprintf
+   fun:ngx_snprintf
+   fun:ngx_sock_ntop
+   fun:ngx_event_accept
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:lj_str_new
+   fun:lua_pushlstring
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:lj_str_new
+   fun:lua_pushlstring
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:ngx_http_lua_ndk_set_var_get
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:lj_str_new
+   fun:lua_getfield
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:lj_str_new
+   fun:lua_setfield
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:ngx_http_variables_init_vars
+   fun:ngx_http_block
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:ngx_conf_parse
+}
+{
+   <insert_a_suppression_name_here>
+   exp-sgcheck:SorG
+   fun:ngx_vslprintf
+   fun:ngx_log_error_core
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Addr4
+   fun:lj_str_new
+   fun:lua_setfield
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Addr4
+   fun:lj_str_new
+   fun:lua_getfield
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Param
+   epoll_ctl(event)
+   fun:epoll_ctl
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:ngx_conf_flush_files
+   fun:ngx_single_process_cycle
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:memcpy
+   fun:ngx_vslprintf
+   fun:ngx_log_error_core
+   fun:ngx_http_charset_header_filter
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Addr4
+   fun:lj_str_new
+   fun:lua_pushlstring
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:lj_str_new
+   fun:lj_str_fromnum
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:lj_str_new
+   fun:lua_pushlstring
+}
+{
+   <false_alarm_due_to_u32_alignment_in_luajit2>
+   Memcheck:Addr4
+   fun:lj_str_new
+   fun:lua_setfield
+   fun:ngx_http_lua_cache_store_code
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:lj_str_new
+   fun:lua_getfield
+   fun:ngx_http_lua_cache_load_code
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:lj_str_new
+   fun:lua_setfield
+   fun:ngx_http_lua_cache_store_code
+}
+{
+   <false_alarm_due_to_u32_alignment_in_luajit2>
+   Memcheck:Addr4
+   fun:lj_str_new
+   fun:lua_getfield
+   fun:ngx_http_lua_cache_load_code
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Param
+   socketcall.setsockopt(optval)
+   fun:setsockopt
+   fun:drizzle_state_connect
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Cond
+   fun:ngx_conf_flush_files
+   fun:ngx_single_process_cycle
+   fun:main
+}
+{
+   <insert_a_suppression_name_here>
+   Memcheck:Leak
+   fun:malloc
+   fun:ngx_alloc
+   fun:ngx_event_process_init
+}
diff -rNu a/src/lua/ngx_devel_kit/auto/actions/array b/src/lua/ngx_devel_kit/auto/actions/array
--- a/src/lua/ngx_devel_kit/auto/actions/array	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/actions/array	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,10 @@
+
+array_create        (a,pl,n,sz)     a = %1%_array_create (pl,n,sz); if (a == NULL) %A%
+array_init          (a,pl,n,sz)     if (%1%_array_init (a,pl,n,sz) == %E%) %A%
+array_push          (p,a)           p = %1%_array_push (a);     if (p == NULL) %A%
+array_push_clean    (p,a)           p = %1%_array_push (a);     if (p == NULL) %A%; %2%_zerop (p)
+array_push_n        (p,a,n)         p = %1%_array_push_n (a,n); if (p == NULL) %A%
+array_push_n_clean  (p,a,n)         p = %1%_array_push_n (a,n); if (p == NULL) %A%; %2%_zeropn (p,n)
+
+
+
diff -rNu a/src/lua/ngx_devel_kit/auto/actions/palloc b/src/lua/ngx_devel_kit/auto/actions/palloc
--- a/src/lua/ngx_devel_kit/auto/actions/palloc	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/actions/palloc	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,8 @@
+
+palloc              (p,pl,sz)       p = %1%_palloc (pl,sz);    if (p == NULL) %A%
+pallocp             (p,pl)          %2%_pallocp (p,pl);        if (p == NULL) %A%
+pallocpn            (p,pl,n)        %2%_pallocpn (p,pl,n);     if (p == NULL) %A%
+pcalloc             (p,pl,sz)       p = %1%_pcalloc (pl,sz);   if (p == NULL) %A%
+pcallocp            (p,pl)          %2%_pcallocp (p,pl);       if (p == NULL) %A%
+pcallocpn           (p,pl,n)        %2%_pcallocpn (p,pl,n);    if (p == NULL) %A%
+
diff -rNu a/src/lua/ngx_devel_kit/auto/build b/src/lua/ngx_devel_kit/auto/build
--- a/src/lua/ngx_devel_kit/auto/build	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/build	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,597 @@
+#! /bin/bash
+
+cd `dirname $0`
+
+if [ $# -eq 2 ];
+then
+  if [ `expr $2 : /` -eq 1 ];
+  then
+    output_dir=$2
+  else
+    output_dir=$1/$2
+  fi
+else
+    output_dir=../objs
+fi
+
+list_file=data/action_list
+types_file=data/action_types
+reps_file=data/action_replacements
+prefix_file=data/prefixes 
+header_file=data/header_files
+optional_modules_file=data/modules_optional
+headers_file=data/headers
+module_dependencies_file=data/module_dependencies
+conf_macros_file=data/conf_macros
+conf_locs_file=data/conf_locs
+conf_args_file=data/conf_args
+
+autogen_notice=text/autogen
+
+actions_dir=actions
+srcs_dir=src
+include_prefix=
+file_prefix=ndk_
+auto_file_name=config
+auto_includes_name=includes
+
+conf_merge_filename=conf_merge.h
+conf_cmd_basic_filename=conf_cmd_basic.h
+conf_cmd_extra_filename=conf_cmd_extra.h
+
+
+spacer=¬
+
+sed_delete_empty_lines='t_NEL;d;:_NEL'
+
+
+function trim_lines {
+    sed -e '/./,$!d' -e :a -e '/^\n*$/{$d;N;ba' -e '}'
+}
+
+
+function strtoupper {
+    [ $# -eq 1 ] || return 1
+    local _str _cu _cl _x
+    _cu=(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
+    _cl=(a b c d e f g h i j k l m n o p q r s t u v w x y z)
+    _str=$1
+    for ((_x=0;_x<${#_cl[*]};_x++)); do
+        _str=${_str//${_cl[$_x]}/${_cu[$_x]}}
+    done
+    echo $_str
+}
+
+
+function sed_pad_right {
+    len=$1
+    spacer=$2
+    prefix=_PR$3
+
+    # returns a SED script that pads out (spaces) to the right to alignment $len
+    # this script should be used inside a call to sed
+    # NOTE : a spacer character $spacer should have already been written into the parsed string
+
+    echo "t${prefix}a;:${prefix}a;s/^[^$spacer]{$len}/&/;\
+t${prefix}b;s/^[^$spacer]*/& /;t${prefix}a;:${prefix}b;s/$spacer/ /"
+}
+
+
+function sed_pad_left {
+
+    len=$1
+    spacer=$2
+    prefix=_PL$3
+
+   # echo "t${prefix}a;:${prefix}a;s/^[^$spacer]{$len}/& /;t${prefix}a"     # NOT CORRECT?
+}
+
+
+function add_notice {
+
+    echo > $1
+    cat $autogen_notice | trim_lines >> $1
+    echo >> $1
+    echo >> $1
+}
+
+function add_non_generated_content {
+
+    file=src/$1.h
+    [ ! -f $file ] && return
+
+    echo "/* Non-generated macros */" >> $2
+    echo >> $2
+
+    cat $file | trim_lines >> $2
+
+    echo >> $2
+    echo >> $2
+}
+
+
+function add_action_macros {
+
+    list_file=$actions_dir/$1
+
+    [ ! -f $list_file ] && return
+
+    out=$2
+
+
+    # alignment settings
+
+    align1=20
+    align2=35
+    align3=62
+    base_shrink=12
+    define="#define     "
+
+
+
+    # base macros
+
+    echo "/* base action macro macros */" >> $out
+    echo >> $out
+
+    cat $list_file | trim_lines | sed -r \
+    -e "s/^[ ]*([a-zA-Z0-9_]+)([ ]*)\(([a-zA-Z0-9_,]+)\)([ ]*)(.*)/$define%2%_\1_ac(\3,ac)\2\4  {\5;}/" \
+    -e "s/[ ]{$base_shrink}\{/\{/" \
+    -e 's/%A%/ac/g' \
+    >> $out
+
+    echo >> $out
+    echo >> $out
+
+
+
+    # generated macros
+
+    echo "/* generated action macros */" >> $out
+    echo >> $out
+
+    cat -s $list_file | while read list_line; do
+
+        [ "x`echo $list_line`" = 'x' ] && continue
+
+        cat $types_file | while read type_line; do
+
+            [ "x`echo $type_line`" = 'x' ] && continue  
+
+            #ext=`echo $type_line | grep -E '^[a-zA-Z0-9_]+' | cut -d " " -f1`
+            ext=`echo $type_line | sed -r 's/^([a-zA-Z0-9_]+).*/\1/'`
+            params=`echo $type_line | sed -r 's/^[a-zA-Z0-9_]+[ ]*\((.*)\).*/\1/;ta;d;:a'`
+            act=`echo $type_line | sed -r 's/^[a-zA-Z0-9_]+[ ]*(\(.*\))?(.*)/\2/'`
+            [ "x$params" != "x" ] && params=",$params"
+
+            echo $list_line | sed -r \
+            -e "s/^([a-zA-Z0-9_]+)[ ]*\(([a-zA-Z0-9_,]+)\).*/%2%_\1_$ext(\2$params)$spacer%2%_\1_ac$spacer(\2,$act)/" \
+            -e 's/[ ]*,[ ]*/,/g' \
+            -e "`sed_pad_right $align2 $spacer 1`" \
+            -e "`sed_pad_right $align3 $spacer 2`" \
+            -e "s/.*/$define&/" \
+            >> $out
+        done
+        echo >> $out
+    done
+}
+
+
+function replace_prefixes {
+
+    temp=.temp
+
+    file=`cat $prefix_file`
+
+    prefix1=
+    prefix2=
+
+    for prefix in $file ; do
+        [ "x$prefix2" != "x" ] && echo "Too many prefixes in prefix file $prefix_file" && exit 1
+        [ "x$prefix1" != "x" ] && prefix2=$prefix && continue
+        prefix1=$prefix
+    done
+
+    sed -r "s/%1%/$prefix1/g;s/%2%/$prefix2/g" < $1 > $temp
+
+    mv -f $temp $1
+}
+
+
+function replace_other_strings {
+
+    temp=.temp
+
+    cat $reps_file | while read line; do
+
+        rep1=
+        rep2=
+
+        for rep in $line ; do
+            [ "x$rep2" != "x" ] && echo "Too many replacments in replacements file $reps_file" && exit 1
+            [ "x$rep1" != "x" ] && rep2=$rep && continue
+            rep1=$rep
+        done
+
+        sed -r "s/%$rep1%/$rep2/g" < $1 > $temp
+        mv -f $temp $1
+    done
+}
+
+
+function generate_header_file {
+
+    name=$1
+    out=$output_dir/$file_prefix$name.h
+
+    add_notice $out
+    add_non_generated_content $name $out
+    add_action_macros $name $out
+    replace_prefixes $out
+    replace_other_strings $out
+}
+
+
+function add_auto_include {
+    echo "#include  <${file_prefix}$2>" >> $1
+}
+
+
+function add_include {
+    echo "#include  <${include_prefix}${file_prefix}$2>" >> $1
+}
+
+
+function generate_non_optional_h_includes {
+
+    # TODO : split into auto-generated and non-auto-generated ones
+
+    echo "/* non-optional includes */" >> $1
+    echo >> $1
+
+    for mod in `cat $headers_file | sort`; do
+
+        add_auto_include  $1  $mod.h
+    done
+
+    echo >> $1
+    echo >> $1
+}
+
+
+function generate_include_all_includes {
+
+    echo "/* include all optional modules */" >> $1
+    echo >> $1
+    echo "#ifdef NDK_ALL" >> $1
+    echo >> $1
+
+    modules=`cat $optional_modules_file | sed 's/*//g' | sort`
+
+    for mod in $modules; do
+        def="NDK_`strtoupper $mod`"
+        echo "#ifndef $def" >> $1
+        echo "#define $def 1" >> $1
+        echo "#endif" >> $1
+    done
+
+    echo >> $1
+    echo "#endif" >> $1
+    echo >> $1
+    echo >> $1
+}
+
+
+function generate_dependent_includes {
+
+    echo "/* module dependencies */" >> $1
+    echo >> $1
+
+    cat $module_dependencies_file | while read line; do
+
+        first=1
+
+        for mod in $line; do
+
+            def="NDK_`strtoupper $mod`"
+
+            if [ $first = 1 ] ; then
+
+                echo "#ifdef  $def" >> $1
+                first=0
+            else
+                echo "#ifndef $def" >> $1
+                echo "#define $def 1" >> $1
+                echo "#endif" >> $1
+            fi
+        done
+
+        [ $first = 0 ] && echo "#endif" >> $1
+    done
+
+    echo >> $1
+    echo >> $1
+}
+
+
+
+function generate_optional_h_includes {
+
+    echo "/* optional includes */" >> $1
+    echo >> $1
+
+    for mod in $modules; do
+        def="NDK_`strtoupper $mod`"
+        echo "#if ($def)" >> $1
+        add_include  $1  $mod.h
+        echo "#endif" >> $1
+    done
+
+    echo >> $1
+    echo >> $1
+}
+
+
+
+
+
+function generate_conf_merge_macros_file {
+
+    file=$conf_merge_filename
+    out_file=${file_prefix}$file
+    out=$output_dir/$out_file
+
+    add_notice $out
+
+    echo "/* conf-merge-value macros */" >> $out
+    echo >> $out
+
+    cat $srcs_dir/$file | trim_lines >> $out
+    echo >> $out
+    echo >> $out
+
+    echo "/* conf-merge-prop macros */" >> $out
+    echo >> $out
+
+    echo "#define     ndk_conf_merge_prop(prop,default)\\" >> $out
+    echo "            ndk_conf_merge_value\\" >> $out
+    echo "                (conf->prop, prev->prop, default)" >> $out
+    echo >> $out
+
+    # loads macros, removes empty elements, sorts and translates to merge-prop macros
+
+    cat $conf_macros_file | sed -r 's/^[A-Z0-9_]+[ ]*[A-Z0-9_]+[ ]*([a-z0-9_]+).*$/\1/;ta;d;:a' \
+        | sort | sed -r \
+        's/(.*)/#define     ndk_conf_merge_\1_prop(prop,default,...)\\\
+            ndk_conf_merge_\1_value\\\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)\
+    /' \
+    >> $out
+
+    add_auto_include $1 $file
+}
+
+
+
+
+function generate_conf_cmd_basic_file {
+
+    temp=.rep
+    file=$conf_cmd_basic_filename
+    out_file=${file_prefix}$file
+    out=$output_dir/$out_file
+
+    align1=35
+
+    # initial text
+
+    add_notice $out
+
+
+    # add ndk bitmasks
+
+    echo "/* conf cmd core values/bitmasks */" >> $out
+    echo >> $out
+
+
+    cat $conf_args_file | sort | trim_lines | sed -r \
+    -e "s/^([A-Z0-9_]+)/${define}NDK_\1${spacer}NGX_\1/" \
+    -e $sed_delete_empty_lines \
+    -e  "`sed_pad_right $align1 $spacer`" \
+    >> $out
+
+    echo >> $out
+    echo >> $out
+
+
+    # add additional bitmasks stored in file
+
+    echo "/* conf cmd bitmasks */" >> $out
+    echo >> $out
+
+    cat $srcs_dir/$conf_cmd_basic_filename | trim_lines >> $out
+
+    echo >> $out
+    echo >> $out
+
+    echo "/* conf cmd basic macros */" >> $out
+    echo >> $out
+
+
+    # build replacement string
+
+    echo -n "s/^([A-Z0-9_]+)$/" > $temp
+
+    cat $conf_locs_file | sed \
+    -r -e 's/^([A-Z0-9_]+) *([A-Z0-9_]+).*/#define     NDK_\1_CONF_\\1\(name,func,off1,off2,post)\\\\\\\
+                                    {ngx_string (name),\\\\\\\
+                                    NGX_CONF_\\1|NDK_\1_CONF,\\\\\\\
+                                    func, off1, off2, post},\\\
+\\/' -e $sed_delete_empty_lines \
+    >> $temp
+
+    echo -n "/;$sed_delete_empty_lines" >> $temp
+
+
+    # apply the replacement string to the 
+
+    cat $conf_args_file | sort | trim_lines | sed -rf $temp >> $out
+    rm -f $temp
+
+    add_auto_include $1 $file
+}
+
+
+
+function generate_conf_cmd_extra_file {
+
+    temp=.rep
+    file=$conf_cmd_extra_filename
+    out=$output_dir/${file_prefix}$file
+
+    align1=35
+
+    # initial text
+
+    add_notice $out
+
+    echo "/* conf command macros */" >> $out
+    echo >> $out
+
+
+    # build replacement string
+
+    echo -n 's/^([A-Z0-9_]+)[ ]*([A-Z0-9_]+)[ ]*([a-z0-9_]+).*$/' > $temp
+
+    cat $conf_locs_file | sed \
+    -r -e 's/^([A-Z0-9_]+)[ ]*([A-Z0-9_]+)[ ]*([a-zA-Z0-9_]+)/#define     NDK_\1_CONF_\\1(name,p,post\)\\\\\\\
+            NDK_\1_CONF_\\2\\\\\\\
+                (name,\\\\\\\
+                ndk_conf_set_\\3_slot,\\\\\\\
+                NGX_\2_CONF_OFFSET,\\\\\\\
+                offsetof (ndk_module_\3_conf_t, p),\\\\\\\
+                post)\\\
+\\/' -e $sed_delete_empty_lines \
+    >> $temp
+
+    echo -n "/;$sed_delete_empty_lines" >> $temp
+    #echo -n ";`sed_pad_right 60 $spacer`" >> $temp
+
+
+    # apply the replacement string to the 
+
+    cat $conf_macros_file | sort | trim_lines | sed -rf $temp -e "`sed_pad_right 60 $spacer`" >> $out
+    rm -f $temp
+
+    add_auto_include $1 $file
+}
+
+
+
+function generate_auto_generated_h_includes {
+
+    echo "/* auto-generated headers */" >> $1
+    echo >> $1
+
+    for name in `cat $header_file | sort` ; do
+
+        generate_header_file $name
+        add_auto_include $1 $name.h
+    done
+
+    generate_conf_merge_macros_file $1
+    generate_conf_cmd_basic_file $1
+    generate_conf_cmd_extra_file $1
+
+    echo >> $1
+    echo >> $1
+}
+
+
+
+function generate_optional_c_includes {
+
+    echo "/* optional includes */" >> $1
+    echo >> $1
+
+    modules=`cat $optional_modules_file | sed 's/*//g' | sort`
+
+    for mod in $modules; do
+        def="NDK_`strtoupper "$mod"`"
+        echo "#if ($def)" >> $1
+        add_include $1 $mod.c
+        echo "#endif" >> $1
+    done
+
+    echo >> $1
+    echo >> $1
+}
+
+
+function generate_commands {
+
+    echo "/* module commands */" >> $1
+    echo >> $1
+    echo "static ngx_command_t  ndk_http_commands[] = {" >> $1
+
+    cat $optional_modules_file | sort | while read line; do
+
+        cmds=`echo "$line" | grep -E '\*'`
+
+        [ "x$cmds" = "x" ] && continue
+
+        mod=`echo "$line" | grep -E '^[a-zA-Z0-9_]+' | cut -d " " -f1`
+        up=`strtoupper $mod`
+        def="NDK_$up"
+        defcmd="NDK_${up}_CMDS"
+
+        echo "#if ($def)"                   >> $1
+        echo "#define $defcmd 1"            >> $1
+        add_include  $1  $mod.h
+        echo "#undef  $defcmd"              >> $1
+        echo "#endif"                       >> $1
+
+    done
+
+    echo -e "    ngx_null_command\n};"      >> $1
+}
+
+
+function generate_all_h_files {
+
+    out=$output_dir/${file_prefix}$auto_file_name.h
+
+    add_notice $out
+
+    generate_include_all_includes $out
+    generate_dependent_includes $out
+
+    out=$output_dir/${file_prefix}$auto_includes_name.h
+
+    generate_optional_h_includes $out
+    generate_non_optional_h_includes $out
+    generate_auto_generated_h_includes $out $list
+}
+
+
+function generate_all_c_files {
+
+    out=$output_dir/${file_prefix}$auto_file_name.c
+
+    add_notice $out
+    generate_optional_c_includes $out
+    generate_commands $out
+}
+
+
+
+function generate_all_files {
+
+    mkdir -p $output_dir
+    rm -f $output_dir/*
+
+    generate_all_h_files
+    generate_all_c_files
+}
+
+generate_all_files
diff -rNu a/src/lua/ngx_devel_kit/auto/data/action_replacements b/src/lua/ngx_devel_kit/auto/data/action_replacements
--- a/src/lua/ngx_devel_kit/auto/data/action_replacements	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/action_replacements	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,5 @@
+
+OK      NGX_OK
+E       NGX_ERROR
+CE      NGX_CONF_ERROR
+COK     NGX_CONF_OK
diff -rNu a/src/lua/ngx_devel_kit/auto/data/action_types b/src/lua/ngx_devel_kit/auto/data/action_types
--- a/src/lua/ngx_devel_kit/auto/data/action_types	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/action_types	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,12 @@
+r0          return 0
+r1          return 1
+r_1         return -1
+rok         return %OK%
+rce         return %CE%
+rcok        return %COK%
+re          return %E%
+rn          return NULL
+rse         {ngx_script_error (e); return;}
+sce         {ngx_script_configure_error (c); return;}
+g(_lb)      goto _lb
+ge          goto error
diff -rNu a/src/lua/ngx_devel_kit/auto/data/conf_args b/src/lua/ngx_devel_kit/auto/data/conf_args
--- a/src/lua/ngx_devel_kit/auto/data/conf_args	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/conf_args	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,22 @@
+ 
+TAKE1
+TAKE2
+TAKE3
+TAKE4
+TAKE5
+TAKE6
+TAKE7
+TAKE8
+TAKE12
+TAKE13
+TAKE23
+TAKE123
+TAKE1234
+1MORE
+2MORE
+ANY
+FLAG
+BLOCK
+MULTI
+ARGS_NUMBER
+
diff -rNu a/src/lua/ngx_devel_kit/auto/data/conf_locs b/src/lua/ngx_devel_kit/auto/data/conf_locs
--- a/src/lua/ngx_devel_kit/auto/data/conf_locs	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/conf_locs	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,25 @@
+
+HTTP_MAIN                   HTTP_MAIN       main
+HTTP_SRV                    HTTP_SRV        srv
+HTTP_SIF                    HTTP_SRV        srv
+HTTP_LOC                    HTTP_LOC        loc
+HTTP_LIF                    HTTP_LOC        loc
+
+HTTP_MAIN_SRV               HTTP_SRV        srv
+HTTP_MAIN_SIF               HTTP_SRV        srv
+HTTP_MAIN_LOC               HTTP_LOC        loc
+HTTP_MAIN_LIF               HTTP_LOC        loc
+
+HTTP_SRV_LOC                HTTP_LOC        loc
+HTTP_SRV_LIF                HTTP_LOC        loc
+HTTP_SIF_LOC                HTTP_LOC        loc
+HTTP_SIF_LIF                HTTP_LOC        loc
+
+HTTP_MAIN_SRV_LOC           HTTP_LOC        loc
+HTTP_MAIN_SRV_LIF           HTTP_LOC        loc
+HTTP_MAIN_SIF_LOC           HTTP_LOC        loc
+HTTP_MAIN_SRV_SIF_LOC       HTTP_LOC        loc
+HTTP                        HTTP_LOC        loc
+HTTP_UPS                    HTTP_LOC        loc
+HTTP_ANY                    HTTP_LOC        loc
+ANY                         HTTP_LOC        loc
diff -rNu a/src/lua/ngx_devel_kit/auto/data/conf_macros b/src/lua/ngx_devel_kit/auto/data/conf_macros
--- a/src/lua/ngx_devel_kit/auto/data/conf_macros	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/conf_macros	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,35 @@
+
+BITMASK             1MORE       bitmask
+BUFS                TAKE1       bufs
+COMPLEX_KEYVAL      TAKE2       http_complex_keyval
+COMPLEX_PATH        TAKE1       http_complex_path
+COMPLEX_VALUE       TAKE1       http_complex_value
+COMPLEX_VALUE_ARRAY 1MORE       http_complex_value_array
+ENCODING            TAKE1       encoding
+ENUM                TAKE1       enum
+FALSE               NOARGS      false
+FULL_PATH           TAKE1       full_path
+KEYVAL              TAKE2       keyval
+KEYVAL1             TAKE2       keyval1
+MSEC                TAKE1       msec
+NULL                NOARGS      null
+NUM                 TAKE1       num
+NUM64               TAKE1       num64
+NUM_FLAG            TAKE1       num_flag
+ONOFF               FLAG        flag
+OFF                 TAKE1       off
+PATH                TAKE1       split_path
+REXEX               TAKE1       regex
+REGEX_CL            TAKE1       regex_caseless
+REGEX_ARRAY         1MORE       regex_array
+REGEX_ARRAY_CL      1MORE       regex_array_caseless
+PTR                 NOARGS      ptr
+SEC                 TAKE1       sec
+SEC_FLAG            TAKE2       sec_flag
+SIZE                TAKE1       size
+STR                 TAKE1       str
+STR_ARRAY           1MORE       str_array_multi
+STR_ARRAY1          TAKE1       str_array
+TRUE                NOARGS      true
+
+ 
diff -rNu a/src/lua/ngx_devel_kit/auto/data/contexts b/src/lua/ngx_devel_kit/auto/data/contexts
--- a/src/lua/ngx_devel_kit/auto/data/contexts	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/contexts	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,22 @@
+ 
+MAIN
+SRV
+SIF
+LOC
+LIF
+
+MAIN_SRV
+MAIN_SIF
+MAIN_LOC
+MAIN_LIF
+SRV_LOC
+SRV_LIF
+SIF_LOC
+SIF_LIF
+
+MAIN_SRV_LOC
+MAIN_SRV_LIF
+MAIN_SIF_LOC
+MAIN_SIF_LIF
+ANY_MAIN
+
diff -rNu a/src/lua/ngx_devel_kit/auto/data/header_files b/src/lua/ngx_devel_kit/auto/data/header_files
--- a/src/lua/ngx_devel_kit/auto/data/header_files	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/header_files	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,3 @@
+array
+palloc
+
diff -rNu a/src/lua/ngx_devel_kit/auto/data/headers b/src/lua/ngx_devel_kit/auto/data/headers
--- a/src/lua/ngx_devel_kit/auto/data/headers	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/headers	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,4 @@
+http_headers
+log
+parse
+string_util
diff -rNu a/src/lua/ngx_devel_kit/auto/data/module_dependencies b/src/lua/ngx_devel_kit/auto/data/module_dependencies
--- a/src/lua/ngx_devel_kit/auto/data/module_dependencies	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/module_dependencies	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,5 @@
+complex_path    complex_value   path
+conf_file       string
+hash            string
+set_var         rewrite
+upstream_list   http_create_main_conf
diff -rNu a/src/lua/ngx_devel_kit/auto/data/modules_optional b/src/lua/ngx_devel_kit/auto/data/modules_optional
--- a/src/lua/ngx_devel_kit/auto/data/modules_optional	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/modules_optional	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,15 @@
+buf
+complex_path
+complex_value
+conf_file
+encoding
+hash
+http
+path
+process
+regex
+rewrite
+set_var
+string
+upstream_list   *
+uri
diff -rNu a/src/lua/ngx_devel_kit/auto/data/prefixes b/src/lua/ngx_devel_kit/auto/data/prefixes
--- a/src/lua/ngx_devel_kit/auto/data/prefixes	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/data/prefixes	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,2 @@
+ngx
+ndk 
diff -rNu a/src/lua/ngx_devel_kit/auto/src/array.h b/src/lua/ngx_devel_kit/auto/src/array.h
--- a/src/lua/ngx_devel_kit/auto/src/array.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/src/array.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,7 @@
+
+#define     %2%_array_count(a)                  ((a)->nelts)
+#define     %2%_array_get_first(a)              ((a)->elts)
+#define     %2%_array_get_index(a,n)            ((void*) ((char*) (a)->elts + (a)->size * n))
+#define     %2%_array_get_last(a)               ((void*) ((char*) (a)->elts + (a)->size * ((a)->nelts - 1)))
+#define     %2%_array_get_reverse_index(a,n)    ((void*) ((char*) (a)->elts + (a)->size * ((a)->nelts - 1 - n)))
+#define     %2%_array_push_clean(p,a)           {p = %1%_array_push (a); %2%_zerop (p);}
diff -rNu a/src/lua/ngx_devel_kit/auto/src/conf_cmd_basic.h b/src/lua/ngx_devel_kit/auto/src/conf_cmd_basic.h
--- a/src/lua/ngx_devel_kit/auto/src/conf_cmd_basic.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/src/conf_cmd_basic.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,43 @@
+
+/* TODO : finish this */
+
+#define     NDK_HTTP_MAIN_CONF              NGX_HTTP_MAIN_CONF
+#define     NDK_HTTP_SRV_CONF               NGX_HTTP_SRV_CONF
+#define     NDK_HTTP_SIF_CONF               NGX_HTTP_SIF_CONF
+#define     NDK_HTTP_LOC_CONF               NGX_HTTP_LOC_CONF
+#define     NDK_HTTP_LIF_CONF               NGX_HTTP_LIF_CONF
+#define     NDK_HTTP_UPS_CONF               NGX_HTTP_UPS_CONF
+#define     NDK_MAIN_CONF                   NGX_MAIN_CONF
+#define     NDK_ANY_CONF                    NGX_ANY_CONF
+
+
+/* compound locations */
+
+#define     NDK_HTTP_MAIN_SRV_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_CONF
+#define     NDK_HTTP_MAIN_SIF_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_SIF_CONF
+#define     NDK_HTTP_MAIN_LOC_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_LOC_CONF
+#define     NDK_HTTP_MAIN_LIF_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_LOC_LIF_CONF
+
+#define     NDK_HTTP_SRV_SIF_CONF                   NDK_HTTP_SRV_CONF|NDK_HTTP_SIF_CONF
+#define     NDK_HTTP_SRV_LOC_CONF                   NDK_HTTP_SRV_CONF|NDK_HTTP_LOC_CONF
+#define     NDK_HTTP_SRV_LOC_LIF_CONF               NDK_HTTP_SRV_CONF|NDK_HTTP_LOC_LIF_CONF
+#define     NDK_HTTP_SRV_SIF_LOC_CONF               NDK_HTTP_SRV_SIF_CONF|NDK_HTTP_LOC_CONF
+#define     NDK_HTTP_SRV_SIF_LOC_LIF_CONF           NDK_HTTP_SRV_SIF_CONF|NDK_HTTP_LOC_LIF_CONF
+
+#define     NDK_HTTP_LOC_LIF_CONF                   NDK_HTTP_LOC_CONF|NDK_HTTP_LIF_CONF
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF              NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_LOC_CONF
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF              NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_LIF_CONF
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF              NDK_HTTP_MAIN_CONF|NDK_HTTP_SIF_LOC_CONF
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_LIF_CONF      NDK_HTTP_SRV_SIF_LOC_LIF_CONF|NDK_MAIN_CONF
+#define     NDK_HTTP_CONF                           NDK_HTTP_MAIN_SRV_SIF_LOC_LIF_CONF
+#define     NDK_HTTP_ANY_CONF                       NDK_HTTP_CONF|NDK_HTTP_UPS_CONF
+
+
+/* property offsets     NOTE : ngx_module_main_conf_t etc should be defined in the module's .c file before the commands */
+
+#define     NDK_HTTP_MAIN_CONF_PROP(p)      NGX_HTTP_MAIN_CONF_OFFSET, offsetof (ndk_module_main_conf_t, p)
+#define     NDK_HTTP_SRV_CONF_PROP(p)       NGX_HTTP_SRV_CONF_OFFSET, offsetof (ndk_module_srv_conf_t, p)
+#define     NDK_HTTP_LOC_CONF_PROP(p)       NGX_HTTP_LOC_CONF_OFFSET, offsetof (ndk_module_loc_conf_t, p)
+
+
diff -rNu a/src/lua/ngx_devel_kit/auto/src/conf_merge.h b/src/lua/ngx_devel_kit/auto/src/conf_merge.h
--- a/src/lua/ngx_devel_kit/auto/src/conf_merge.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/src/conf_merge.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,78 @@
+
+/* TODO : check that all the main types have a corresponding merge function */
+
+#define     ndk_conf_merge_value            ngx_conf_merge_value
+#define     ndk_conf_merge_off_value        ngx_conf_merge_off_value 
+#define     ndk_conf_merge_ptr_value        ngx_conf_merge_ptr_value
+#define     ndk_conf_merge_str_value        ngx_conf_merge_str_value
+#define     ndk_conf_merge_size_value       ngx_conf_merge_size_value 
+
+
+#define     ndk_conf_merge_keyval_value(conf,prev,default)                                  \
+                                                                                            \
+                conf = prev ? prev : default;
+
+#define     ndk_conf_merge_str_array_value(conf,prev,val1,...)                              \
+                                                                                            \
+                if (conf == NGX_CONF_UNSET_PTR) {                                           \
+                    if (prev == NGX_CONF_UNSET_PTR) {                                       \
+                        if (val1 == NULL) {                                                 \
+                            conf = NULL;                                                    \
+                        } else {                                                            \
+                            char * elts[] = {val1,##__VA_ARGS__};                           \
+                            int    n = sizeof(elts)/sizeof(char*);                          \
+                                                                                            \
+                            conf = ndk_str_array_create (cf->pool, elts, n);                \
+                                                                                            \
+                            if (conf == NULL)                                               \
+                                return  NGX_CONF_ERROR;                                     \
+                        }                                                                   \
+                    } else {                                                                \
+                        conf = prev;                                                        \
+                    }                                                                       \
+                }
+
+#define     ndk_conf_merge_http_complex_value_value(conf,prev,default)                      \
+                                                                                            \
+                if (!conf.str.len) {                                                        \
+                    if (prev.str.len) {                                                     \
+                        conf = prev;                                                        \
+                    } else {                                                                \
+                        conf.str.data = (u_char *) default;                                 \
+                        conf.str.len = sizeof (default) - 1;                                \
+                                                                                            \
+                        if (ndk_http_complex_value_compile (cf, &conf))                     \
+                            return  NGX_CONF_ERROR;                                         \
+                    }                                                                       \
+                }
+
+#define     ndk_conf_merge_http_complex_value_array_value(conf,prev,val1,...)               \
+                                                                                            \
+                if (conf == NGX_CONF_UNSET_PTR) {                                           \
+                    if (prev == NGX_CONF_UNSET_PTR) {                                       \
+                        if (val1 == NULL)                                                   \
+                            conf = NULL;                                                    \
+                        else {                                                              \
+                            char * elts[] = {val1,##__VA_ARGS__};                           \
+                            int    n = sizeof(elts)/sizeof(char*);                          \
+                                                                                            \
+                            conf = ndk_http_complex_value_array_create (cf, elts, n);       \
+                                                                                            \
+                            if (conf == NULL)                                               \
+                                return  NGX_CONF_ERROR;                                     \
+                        }                                                                   \
+                    } else {                                                                \
+                        conf = prev;                                                        \
+                    }                                                                       \
+                }
+
+#define     ndk_conf_merge_http_complex_path_value(conf,prev,...)                           \
+                ndk_conf_merge_http_complex_value_array_value (conf.a, prev.a, __VA_ARGS__)
+
+#define     ndk_conf_merge_split_path_value(conf,prev,path)                                 \
+                                                                                            \
+                if (conf == NGX_CONF_UNSET_PTR)  {                                          \
+                    conf = (prev == NGX_CONF_UNSET_PTR ?                                    \
+                        ndk_split_path_create_raw (cf, path) : prev);                       \
+                }
+
diff -rNu a/src/lua/ngx_devel_kit/auto/src/palloc.h b/src/lua/ngx_devel_kit/auto/src/palloc.h
--- a/src/lua/ngx_devel_kit/auto/src/palloc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/src/palloc.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,6 @@
+
+#define     %2%_pallocp(p,pl)                   p = %1%_palloc (pl,sizeof(*p))
+#define     %2%_pallocpn(p,pl,n)                p = %1%_palloc (pl,sizeof(*p)*(n))
+
+#define     %2%_pcallocp(p,pl)                  p = %1%_pcalloc (pl,sizeof(*p))
+#define     %2%_pcallocpn(p,pl,n)               p = %1%_pcalloc (pl,sizeof(*p)*(n))
diff -rNu a/src/lua/ngx_devel_kit/auto/text/autogen b/src/lua/ngx_devel_kit/auto/text/autogen
--- a/src/lua/ngx_devel_kit/auto/text/autogen	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/auto/text/autogen	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,12 @@
+
+/* 
+ * 2010 (C) Marcus Clyne 
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
diff -rNu a/src/lua/ngx_devel_kit/config b/src/lua/ngx_devel_kit/config
--- a/src/lua/ngx_devel_kit/config	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/config	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,49 @@
+
+###############
+## FUNCTIONS ##
+###############
+
+# TODO : provide information about checking versions of sed etc
+# TODO : an optional patch function
+
+ndk_generate_files() {
+    echo "building Nginx Development Kit utility functions and macros ..."
+
+    autobuild="$ngx_addon_dir/auto/build"
+    chmod +x $autobuild
+    $autobuild `pwd` $NGX_OBJS/addon/ndk || exit 1
+}
+
+ndk_get_nginx_version() {
+    # We get the Nginx version number from the string form rather than
+    # nginx_version because it is available in more (every?) version
+
+    cat src/core/nginx.h                                | 
+    grep  '#define NGINX_VERSION'                       | 
+    sed -r                                              \
+        -e 's/[^0-9.]*([0-9.]+).*/\1/'                  \
+        -e 's/([0-9]+\.[0-9]+\.)([0-9]{1})$/\100\2/'    \
+        -e 's/([0-9]+\.[0-9]+\.)([0-9]{2})$/\10\2/'     \
+        -e 's/\.//g'                                    \
+        -e 's/^0+(.*)/\1/'
+}
+
+#####################
+## CONFIG SETTINGS ##
+#####################
+
+ngx_addon_name=ngx_devel_kit
+ngx_objs_dirs="$ngx_addon_dir/objs $NGX_OBJS/addon/ndk"
+
+CORE_INCS="$CORE_INCS $ngx_objs_dirs"
+HTTP_INCS="$HTTP_INCS $ngx_addon_dir/src $ngx_objs_dir"
+HTTP_MODULES="$HTTP_MODULES ndk_http_module"
+NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/src/ndk.c"
+
+have=NDK . auto/have
+
+##############
+## INCLUDES ##
+##############
+
+. $ngx_addon_dir/ngx_auto_lib_core
\ No newline at end of file
diff -rNu a/src/lua/ngx_devel_kit/docs/core/action_macros b/src/lua/ngx_devel_kit/docs/core/action_macros
--- a/src/lua/ngx_devel_kit/docs/core/action_macros	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/docs/core/action_macros	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,63 @@
+
+    GENERAL NOTES
+    -------------
+
+    These functions and macros have been provided as a tool for Nginx module developers.  They have
+    been created with four main purposes:
+
+        - to speed up code-writing
+        - to reduce the code you have to read on file
+        - to add additional generic functionality similar to exising Nginx functions 
+        - to reduce code errors
+
+    Most of the utility macros are just wrappers around commonly used code, especially checking for
+    NULL and returning a value, zeroing data etc.  The functions add things like extra conf_set_X_slot
+    functions that don't exist in the standard Nginx distribution, but which might be useful in more
+    than one module.
+
+    A consistent approach has been taken to creating the macros, so that in theory you should be able
+    to 'know' the macro name from using the few rules below and your knowledge of the existing Nginx
+    functions.  As much as possible, the ordering of variables used within the underlying functions
+    remain the same, to reduce the learning time.  Also, a constent naming pattern has been used to
+    make it easier to read the macros above.
+
+    Obviously not all programmers will want to use all or any of these macros, but they are provided
+    as a tool for those who wish to use them.
+
+    If you have any comments about them, including any additions or errors please let me know at 
+    'eugaia at gmail dot com'.  I don't promise to include all additions people send, but if they seem
+    like they could be of use to multiple developers, I will.
+
+
+    UTILITY MACRO PARAMS
+    --------------------
+    p       pointer                 - used to set the result of a function to a pointer
+    a       array
+    pl      pool
+    n       multiplication factor   - for allocating multiple pointers & pushing 'n' elts in arrays etc
+    sz      size
+    l       log
+    rv      return value
+
+
+
+    UTILITY MACRO FUNCTION SUFFIXES
+    -------------------------------
+
+ - general
+
+    p       p = [FUNCTION] ()
+    _r      [ if result of function is NULL | NGX_ERROR (as appropriate) ] return rv
+    _rce    rv = NGX_CONF_ERROR
+    _re     rv = NGX_ERROR
+    _rn     rv = NULL
+
+ - (p)(c)alloc functions
+
+    p       p = [function] (pool, sizeof (*p))
+    pn      p = [function] (pool, sizeof (*p) * n)
+
+
+    UTILITY MACRO PARAMS ORDER
+    --------------------------
+    p, pl|a, sz|n, l, rv 
diff -rNu a/src/lua/ngx_devel_kit/docs/core/conf_cmds b/src/lua/ngx_devel_kit/docs/core/conf_cmds
--- a/src/lua/ngx_devel_kit/docs/core/conf_cmds	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/docs/core/conf_cmds	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,62 @@
+
+Conf command macros
+-------------------
+
+The build script generates a large number of macros for reducing the code required for command
+definitions.
+
+There are basically three types of macros :
+
+- combination bitmasks
+
+    e.g. NDK_HTTP_MAIN_SRV_CONF  =  (NGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF)
+
+- base command structures
+
+    e.g. NDK_HTTP_MAIN_CONF_TAKE1
+
+- conf-set command structures
+
+    e.g. NDK_HTTP_CONF_STR
+
+
+Combination bitmasks
+--------------------
+
+Basically combinations of existing bitmasks for locations, with general > specific order
+
+NDK_HTTP_CONF = (NGX_HTTP_MAIN_CONF | NGX_HTTP_SVR_CONF | NGX_HTTP_SIF_CONF | NGX_HTTP_LOC_CONF | NGX_HTTP_LIF_CONF)
+
+
+Base command structures
+-----------------------
+
+These macros are basically there as wrappers for the conf-set command structures, and but incorporate 
+the bitmask element into the name of the macro.
+
+
+Conf-set command structures
+---------------------------
+
+These macros simplify creating commands that use any of the build-in conf-set functions or any of those
+added by the NDK.
+
+e.g.  NGX_HTTP_MAIN_SRV_STR ("name", prop, NULL)
+
+where prop is the name of the property that is a ngx_str_t.  Whether this is in the loc conf, main conf
+or svr conf is generated automatically in by the macro.
+
+NOTE : you need to set the following if they will be used (using macro definitions) :
+
+ndk_module_main_conf_t
+ndk_module_srv_conf_t
+ndk_module_loc_conf_t
+
+e.g
+
+#define     ndk_module_loc_conf_t       ngx_http_my_module_loc_conf_t
+
+
+TODO
+----
+Much better documentation for this
diff -rNu a/src/lua/ngx_devel_kit/docs/modules/set_var b/src/lua/ngx_devel_kit/docs/modules/set_var
--- a/src/lua/ngx_devel_kit/docs/modules/set_var	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/docs/modules/set_var	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,124 @@
+
+set var tools
+=============
+
+OVERVIEW
+--------
+This collection of tools is designed to make it easier to set Nginx variables
+using a common interface.  It works by plugging into and extending the features
+of the internal rewrite module, and operations performed by this module are
+therefore done at the rewrite phase of handling.
+
+
+ADVANTAGES OF USING THIS MODULE
+-------------------------------
+
+- simple interface - you don't have to worry about lots of http script compiling
+- it plugs into the rewrite module, so setting (and getting) vars will happen
+  in the order you expect based on how they appear in the configuration file
+- you do not have to worry about overriding the v->get_handler (useful if
+  a variable of a specific name could be set in multiple different ways)
+
+
+WHEN TO USE THIS AND WHEN TO USE v->get_handler = my_func
+---------------------------------------------------------
+
+- if you want a variable to always be generated using a specific function,
+    and should not be over-ridden by 'set' functions (e.g. $request_uri, 
+    $document_root), then you should use v->get_handler
+
+- if you want to allow a variable to be set using many possible methods,
+    including using the 'set' directive, then this module provides an easy way
+    for you to do so (if you use the v->get_handler method in this case, you may
+    run into problems because the get_handler may over-ride previous uses of the
+    set directive)
+
+
+USAGE
+-----
+
+- decide on the type of function you'll need to write
+
+    type                                use when there are these requirements
+    ----                                -------------------------------------
+    NDK_SET_VAR_BASIC                   0 variable values, no extra data
+    NDK_SET_VAR_DATA                    0 variable values, extra data
+    NDK_SET_VAR_VALUE                   1 variable value, no extra data
+    NDK_SET_VAR_VALUE_DATA              1 variable value, extra data
+    NDK_SET_VAR_MULTI_VALUE             2+ variable values, no extra data
+    NDK_SET_VAR_MULTI_VALUE_DATA        2+ variable values, extra data
+    NDK_SET_VAR_HASH                    the space needed for the result string 
+                                        value is known in advance (usually 
+                                        used in a hash function)
+
+    NOTE : if none of these generic calling types suit your needs, it is
+    easy to extend the list of types in the .c file (and you if you let me know
+    I'll add them to the list
+
+
+- define the filter function with the respective prototype
+
+    type                                prototype
+    ----                                ---------
+    NDK_SET_VAR_BASIC                   ndk_set_var_pt
+    NDK_SET_VAR_DATA                    ndk_set_var_data_pt
+    NDK_SET_VAR_VALUE                   ndk_set_var_value_pt
+    NDK_SET_VAR_DATA_VALUE              ndk_set_var_value_data_pt
+    NDK_SET_VAR_MULTI_VALUE             ndk_set_var_value_pt
+    NDK_SET_VAR_MULTI_VALUE_DATA        ndk_set_var_value_data_pt
+    NDK_SET_VAR_HASH                    ndk_set_var_hash_pt
+
+    (See ngx_tools_module.h for the prototype definitions.)
+
+    Note : For the multi_value functions, the variable value pointer is to the
+    first value (with the others being in an array following it)
+
+
+to use one of the default setup functions
+-----------------------------------------
+
+- define one or multiple ngx_http_var_filter_t's at the global scope, setting :
+
+    type = (one of types above)
+    func = function to call
+    size = (for multi value)        the number of variable values
+           (for hash)               length of buffer to allocate
+    data = (for data functions)     additional data (see note below)
+
+- define a configuration directive (see in the .c file for examples), where the
+    function is 'ngx_http_set_var' and the 'post' is a pointer your filter definition
+
+
+to setup in a customized way
+----------------------------
+
+- define a configuration directive which has your own specific configuration function
+
+- inside your config function, define one or several ngx_http_var_filter_t's like
+    above, and call one of the ngx_http_set_var_..._core functions, passing the 
+    variable name and value pointers as appropriate - see examples section
+
+Note : if you're passing extra data to the function, then you will probably want
+to use this second method and store the data either in the loc conf, or just
+allocate the space for it using one of the ngx_palloc functions.
+
+If the values that will be used for processing are in the same order as in the
+config file and there aren't any additional values that are input, then you can
+just use the (ngx_str_t *) (cf->args->elts) + 1 as your base for the values or 
+possibly not use the _core versions of the functions.
+
+
+That's it!
+
+
+FEEDBACK
+--------
+
+If you have any comments (good/bad), or have found any bugs, please let me know at:
+ngx.eugaia AT gmail DOT com
+
+
+TODO
+----
+- add more documentation/examples
+
diff -rNu a/src/lua/ngx_devel_kit/docs/patches/more_logging_info b/src/lua/ngx_devel_kit/docs/patches/more_logging_info
--- a/src/lua/ngx_devel_kit/docs/patches/more_logging_info	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/docs/patches/more_logging_info	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,48 @@
+When tracking down some potential issues in the nginx constellation,
+we've found it useful to understand where particular error messages
+are coming from, since many of the same messages are repeated in
+various places. This patch will write the source file from which the
+message originated, the function name, and the line number if you're
+using GCC to compile nginx. Here's an example:
+
+Old Output:
+2010/01/12 14:43:10 [notice] 67772#0: nginx/0.7.64
+2010/01/12 14:43:10 [notice] 67772#0: built by gcc 4.0.1 (Apple Inc. build 5490)
+2010/01/12 14:43:10 [notice] 67772#0: OS: Darwin 9.8.0
+2010/01/12 14:43:10 [notice] 67772#0: hw.ncpu: 2
+2010/01/12 14:43:10 [notice] 67772#0: net.inet.tcp.sendspace: 65536
+2010/01/12 14:43:10 [notice] 67772#0: kern.ipc.somaxconn: 128
+2010/01/12 14:43:10 [notice] 67772#0: getrlimit(RLIMIT_NOFILE):
+256:9223372036854775807
+2010/01/12 14:43:10 [notice] 67772#0: start worker processes
+2010/01/12 14:43:10 [notice] 67772#0: start worker process 67785
+2010/01/12 14:43:16 [notice] 67772#0: signal 20 (SIGCHLD) received
+
+New Output:
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_posix_init.c
+ngx_os_status(   80) nginx/0.7.64
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_posix_init.c
+ngx_os_status(   83) built by gcc 4.0.1 (Apple Inc. build 5490)
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_darwin_init.c
+ngx_os_specific_status(  153) OS: Darwin 9.8.0
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_darwin_init.c
+ngx_os_specific_status(  166) hw.ncpu: 2
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_darwin_init.c
+ngx_os_specific_status(  166) net.inet.tcp.sendspace: 65536
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_darwin_init.c
+ngx_os_specific_status(  166) kern.ipc.somaxconn: 128
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_posix_init.c
+ngx_os_status(   92) getrlimit(RLIMIT_NOFILE):
+2560:9223372036854775807
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_process_cycle.c
+ngx_start_worker_processes(  337) start worker processes
+2010/01/14 16:35:09 [notice] 27241#0: src/os/unix/ngx_process.c
+ngx_spawn_process(  201) start worker process 27254
+2010/01/14 16:35:14 [notice] 27241#0: src/os/unix/ngx_process.c
+ngx_signal_handler(  420) signal 20 (SIGCHLD) received
+
+Formatting the filename and function name fields into fixed-width
+fields would be nicer, however that would require further changes in
+src/core/ngx_string.c
+
+(C) Brian Moran - bmoran@onehub.com  (posted to nginx-devel mailing list on 15/01/10)
diff -rNu a/src/lua/ngx_devel_kit/docs/upstream/list b/src/lua/ngx_devel_kit/docs/upstream/list
--- a/src/lua/ngx_devel_kit/docs/upstream/list	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/docs/upstream/list	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,45 @@
+
+NDK_UPSTREAM_LIST
+-----------------
+
+This submodule provides a directive that creates a list of upstreams, with
+optional weighting. This list can then be used by other modules to hash over
+the upstreams however they choose.
+
+
+USAGE IN CONF FILE
+------------------
+
+e.g. upstream_list   name    backend1  4:backend2    3:backend3;
+
+
+
+USAGE WITH OTHER MODULES
+------------------------
+
+Add a line like
+
+CFLAGS="$CFLAGS -DNDK_UPSTREAM_LIST"
+
+to the config file of your module.
+
+
+
+INTEGRATING WITH YOUR MODULE
+----------------------------
+
+The upstream lists are stored in the array given in the lists.h file, which is
+an array of ndk_upstream_list_t elts.  The elts are currently all pointers to 
+strings which have been distributed according to the weight - so if there are
+two backends, with weight 3 and 4 respectively, there will be 7 pointers in
+total with the first 3 pointing to the first backend and the last 4 to the 
+second.
+
+
+
+TODO
+----
+-   replace strings with pointers to upstreams if they are available (and if 
+    this is possible)
+-   add additional 'http://' to strings if necessary
+-   improve this documentation
diff -rNu a/src/lua/ngx_devel_kit/examples/http/set_var/config b/src/lua/ngx_devel_kit/examples/http/set_var/config
--- a/src/lua/ngx_devel_kit/examples/http/set_var/config	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/examples/http/set_var/config	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,4 @@
+ngx_addon_name=ngx_http_set_var_examples_module
+HTTP_MODULES="$HTTP_MODULES ngx_http_set_var_examples_module"
+NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_set_var_examples_module.c"
+have=NDK_SET_VAR . auto/have
\ No newline at end of file
diff -rNu a/src/lua/ngx_devel_kit/examples/http/set_var/ngx_http_set_var_examples_module.c b/src/lua/ngx_devel_kit/examples/http/set_var/ngx_http_set_var_examples_module.c
--- a/src/lua/ngx_devel_kit/examples/http/set_var/ngx_http_set_var_examples_module.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/examples/http/set_var/ngx_http_set_var_examples_module.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,136 @@
+
+/*
+ * 2010 (C) Marcus Clyne
+ */
+ 
+
+#include    <ndk.h>
+
+
+static ngx_int_t    ngx_http_set_var_concat2    (ngx_http_request_t *r, ngx_str_t *val, ngx_http_variable_value_t *v);
+static char *       ngx_http_set_prepend_hello   (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+
+static  ndk_set_var_t      ngx_http_var_set_concat2 = {
+    NDK_SET_VAR_MULTI_VALUE,
+    ngx_http_set_var_concat2,
+    2,
+    NULL
+};
+
+
+static ngx_command_t  ngx_http_set_var_examples_commands[] = {
+    {
+        ngx_string ("set_concat2"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_SIF_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE3,
+        ndk_set_var_multi_value,
+        0,
+        0,
+        &ngx_http_var_set_concat2
+    },
+    {
+        ngx_string ("set_prepend_hello"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_SIF_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+        ngx_http_set_prepend_hello,
+        0,
+        0,
+        NULL
+    },
+    ngx_null_command
+};
+
+
+ngx_http_module_t     ngx_http_set_var_examples_module_ctx = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+ngx_module_t          ngx_http_set_var_examples_module = {
+
+    NGX_MODULE_V1,
+    &ngx_http_set_var_examples_module_ctx,  // module context
+    ngx_http_set_var_examples_commands,     // module directives
+    NGX_HTTP_MODULE,                        // module type
+    NULL,                                   // init master
+    NULL,                                   // init module
+    NULL,                                   // init process
+    NULL,                                   // init thread
+    NULL,                                   // exit thread
+    NULL,                                   // exit process
+    NULL,                                   // exit master
+    NGX_MODULE_V1_PADDING
+};
+
+
+/*
+    This function is called by both examples, takes two variable values and concatenates them
+    to give a third string.
+*/
+
+static ngx_int_t
+ngx_http_set_var_concat2 (ngx_http_request_t *r, ngx_str_t *val, ngx_http_variable_value_t *v)
+{
+    size_t                      len;
+    ngx_http_variable_value_t   *v2;
+    u_char                      *p;
+
+    v2 = v + 1;
+
+    len = v->len + v2->len;
+
+	/*
+	 * NDK provided abbreviation for the following code:
+	 *
+	 * p = ngx_palloc (r->pool, len);
+	 * if (p == NULL)
+	 * 		return  NGX_ERROR;
+	 *
+	 * */
+	ndk_palloc_re(p, r->pool, len);
+
+    val->data = p;
+    val->len = len;
+
+    ngx_memzero (p, len);
+
+    p = ngx_cpymem (p, v->data, v->len);
+    ngx_memcpy (p, v2->data, v2->len);
+
+    return  NGX_OK;
+}
+
+
+
+/*  
+    This function demonstrates using the 'core' function in a function that appends the word
+    'hello_' to the beginning of a variable.
+
+    set                 $var      world;
+    set_prepend_hello    $var      $var;
+
+    If the arguments used in the variable value filter do not all come directly from the conf
+    file, or are not given in the order
+
+    direcive    $var_name   val1 "val2 string $var" ...
+
+    then the _core functions should be used inside the function that is called when the directive
+    is read.
+*/
+
+static char *
+ngx_http_set_prepend_hello (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t               s[2], *var_name;
+    ndk_set_var_t      filter;
+
+    var_name = cf->args->elts;
+    var_name++;
+
+    s[0].data = (u_char*) "hello_";
+    s[0].len = 6;
+
+    s[1] = *(var_name + 1);
+
+    filter.type = NDK_SET_VAR_MULTI_VALUE;
+    filter.func = ngx_http_set_var_concat2;
+    filter.size = 2;
+
+    return  ndk_set_var_multi_value_core (cf, var_name, (ngx_str_t *) s, &filter);
+}
+
diff -rNu a/src/lua/ngx_devel_kit/examples/README b/src/lua/ngx_devel_kit/examples/README
--- a/src/lua/ngx_devel_kit/examples/README	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/examples/README	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,12 @@
+
+2010 (C) Marcus Clyne
+
+
+Examples
+--------
+
+In this section there are a number of examples of the various features of the tools
+module.  These have been given in the form of dummy modules, to make it easier to
+use as templates for your own module should you choose to do so.
+
+
diff -rNu a/src/lua/ngx_devel_kit/.gitignore b/src/lua/ngx_devel_kit/.gitignore
--- a/src/lua/ngx_devel_kit/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/.gitignore	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,4 @@
+tags
+cscope.*
+*~
+*.swp
diff -rNu a/src/lua/ngx_devel_kit/ngx_auto_lib_core b/src/lua/ngx_devel_kit/ngx_auto_lib_core
--- a/src/lua/ngx_devel_kit/ngx_auto_lib_core	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/ngx_auto_lib_core	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,797 @@
+
+## Directories to search for usable builds:
+##
+## - [$PFX]_INC and [$PFX]_LIB
+## - the dir specified by --with-[$pfx]=*
+## - each dir named [$pfx]-* under [$PFX]_BASE (descending order)
+## - each dir named [$pfx]-* under $ngx_src_dir/.. (descending order)
+## - system_paths (see below)
+##
+## Note : specifying [$PFX]_INC or [$PFX]_LIB prevents other dirs being tried
+##        specifying --with-[$pfx]= prevents autodiscovery of dirs
+##
+## Note : if this file is not in the same directory as the config file, the value
+##        for ngx_auto_lib_file should be changed to a relative path from that file
+## e.g. : $ngx_addon_dir/libs/ngx_auto_lib
+##
+## TODO : explain hooks
+
+#############
+## VERSION ##
+#############
+
+ngx_auto_lib_version=1001
+
+if [ ! $ngx_auto_lib_file_version ] || [ $ngx_auto_lib_file_version -lt $ngx_auto_lib_version ]; then
+
+    if [ ! $ngx_addon_dir ]; then
+        ngx_addon_dir=`cd $(dirname $0); pwd`
+    fi
+
+    ngx_auto_lib_file="$ngx_addon_dir/ngx_auto_lib_core"
+    ngx_auto_lib_file_version="$ngx_auto_lib_version"
+fi
+
+###############
+## VARIABLES ##
+###############
+
+v=
+v="$v       inc_path"
+v="$v       incs"
+v="$v       libs"
+v="$v       name"
+v="$v       path"
+v="$v       run"
+v="$v       test"
+ev=
+ev="$ev     add_libs"
+ev="$ev     add_path"
+ev="$ev     build_dirs"
+ev="$ev     build_inc_dirs"
+ev="$ev     build_lib_dirs"
+ev="$ev     check_macros_defined"
+ev="$ev     check_macros_non_zero"
+ev="$ev     defines"
+ev="$ev     deps"
+ev="$ev     exit_if_not_found"
+ev="$ev     haves"
+ev="$ev     inc_names"
+ev="$ev     lib_files"
+ev="$ev     lib_names"
+ev="$ev     libs_to_add"
+ev="$ev     modules"
+ev="$ev     srcs"
+ev="$ev     shared"
+ev="$ev     test_libs"
+ev="$ev     variables"
+
+ngx_feature_vars="$v"
+ngx_feature_extra_vars="$ev"
+ngx_feature_all_vars="$v $ev"
+
+NGX_AUTO_LIB_DEFAULT_SYSTEM_DIRS='/usr/local /usr /opt/local /opt /usr/pkg'
+
+####################
+## UTIL FUNCTIONS ##
+####################
+
+to_upper() {
+    echo "$@" | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+}
+
+to_lower() {
+    echo "$@" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'
+}
+
+####################
+## INIT FUNCTIONS ##
+####################
+
+ngx_auto_lib_init() {
+
+    . $ngx_auto_lib_file
+
+    ngx_auto_lib_init_latest  $@
+}
+
+ngx_auto_lib_init_latest() {
+
+    # set name and prefixes
+
+    if [ ! $1 ]; then
+        echo "ngx_auto_lib_init() requires that a name be passed"
+        exit 1
+    fi
+
+    ngx_auto_lib_name=$1
+    ngx_auto_lib_module_name=$2
+
+    if [ $2 ]; then
+        NGX_AUTO_LIB_PFX=`to_upper $2`
+    else
+        NGX_AUTO_LIB_PFX=`to_upper $1`
+    fi
+
+    ngx_auto_lib_pfx=`to_lower $NGX_AUTO_LIB_PFX`
+
+    ngx_auto_lib_clean_feature_vars
+}
+
+ngx_auto_lib_clean_feature_vars() {
+    for var in $ngx_feature_all_vars; do
+        eval ngx_feature_$var=
+    done
+}
+
+ngx_auto_lib_get_variables() {
+
+    local pfx=$ngx_auto_lib_pfx
+    local PFX=$NGX_AUTO_LIB_PFX
+
+    eval NGX_AUTO_LIB_INC=\"\$${PFX}_INC\"
+    eval NGX_AUTO_LIB_LIB=\"\$${PFX}_LIB\"
+    eval NGX_AUTO_LIB_DIR=\"\$${PFX}\"
+    eval NGX_AUTO_LIB_BASE=\"\$${PFX}_BASE\"
+    eval NGX_AUTO_LIB_SEARCH_LIB_INC=\"\$${PFX}_SEARCH_LIB_INC\"
+    eval NGX_AUTO_LIB_SEARCH_DIR=\"\$${PFX}_SEARCH_DIR\"
+    eval NGX_AUTO_LIB_SEARCH_BASE=\"\$${PFX}_SEARCH_BASE\"
+    eval NGX_AUTO_LIB_SEARCH_BASE_PREFIX=\"\$${PFX}_SEARCH_BASE_PREFIX\"
+    eval NGX_AUTO_LIB_SEARCH_PARENT=\"\$${PFX}_SEARCH_PARENT\"
+    eval NGX_AUTO_LIB_SEARCH_SYSTEM=\"\$${PFX}_SEARCH_SYSTEM\"
+    eval NGX_AUTO_LIB_SHARED=\"\$${PFX}_SHARED\"
+    eval NGX_AUTO_LIB_SYSTEM_DIRS=\"\$${PFX}_SYSTEM_DIR\"
+    eval USE_NGX_AUTO_LIB=\"\$USE_${LIB}\"
+
+    if [ ! "$NGX_AUTO_LIB_DIR" ]; then
+        NGX_AUTO_LIB_DIR=NONE
+    fi
+
+    if [ ! "$USE_NGX_AUTO_LIB" ]; then
+        if [ $ngx_feature_check_macros_defined -o $ngx_feature_check_macros_non_zero ]; then
+            USE_NGX_AUTO_LIB=MAYBE
+        elif [ "$ngx_feature_required" = no ]; then
+            USE_NGX_AUTO_LIB=MAYBE
+        else
+            USE_NGX_AUTO_LIB=YES
+        fi
+    fi
+
+    if [ ! "$NGX_AUTO_LIB_SYSTEM_DIRS" ]; then
+        NGX_AUTO_LIB_SYSTEM_DIRS=$NGX_AUTO_LIB_DEFAULT_SYSTEM_DIRS
+    fi
+
+    # TODO : add _STATIC, and do searches for both static and shared libs
+
+    if [ ! "$NGX_AUTO_LIB_SHARED" ]; then
+        if [ "$ngx_feature_shared" = no ]; then
+            NGX_AUTO_LIB_SHARED=NO
+        else
+            NGX_AUTO_LIB_SHARED=YES
+        fi
+    fi
+
+    NGX_AUTO_LIB_SEARCH_DEP=NO
+
+    # set default search methods
+    # Note : these can be over-ridden by setting NGX_AUTO_LIB_SEARCH_[type]=YES|NO
+
+    local auto=y
+
+    if [ "$NGX_AUTO_LIB_INC" ] || [ "$NGX_AUTO_LIB_LIB" ]; then
+        ngx_auto_lib_search  LIB_INC    YES
+        auto=n
+    fi
+
+    if [ "$NGX_AUTO_LIB_DIR" != NONE ]; then
+        ngx_auto_lib_search  DIR        YES
+        auto=n
+    fi
+
+    if [ "$NGX_AUTO_LIB_BASE" ]; then
+        ngx_auto_lib_search  BASE       YES
+        auto=n
+    fi
+
+    if [ $auto = y ]; then
+        ngx_auto_lib_search  PARENT     YES
+        ngx_auto_lib_search  SYSTEM     YES
+    fi
+
+    ngx_auto_lib_search  LIB_INC    NO
+    ngx_auto_lib_search  DIR        NO
+    ngx_auto_lib_search  BASE       NO
+    ngx_auto_lib_search  PARENT     NO
+    ngx_auto_lib_search  SYSTEM     NO
+
+    if [ ! "$ngx_feature_lib_names" ]; then
+        ngx_feature_lib_names=$pfx
+    fi
+
+    if [ ! "$ngx_feature_inc_names" ]; then
+        ngx_feature_inc_names=$ngx_feature_lib_names
+    fi
+
+    if [ ! "$ngx_feature_exit_if_not_found" ]; then
+        ngx_feature_exit_if_not_found=yes
+    fi
+}
+
+#######################
+## DEFAULT FUNCTIONS ##
+#######################
+
+ngx_auto_lib_set_default() {
+
+    local suffix=
+    if [ $1 ]; then
+        suffix="_$1"
+    fi
+
+    local def=$2
+    local var="NGX_AUTO_LIB$suffix"
+
+    val=
+    if [ ! `eval echo '$'$var` ]; then
+        eval $var=\"$def\"
+    fi
+
+    #eval echo "$var = \$$var"
+}
+
+ngx_auto_lib_search() {
+    ngx_auto_lib_set_default "SEARCH_$1" $2
+}
+
+####################
+## SAVE FUNCTIONS ##
+####################
+
+ngx_auto_lib_save_vars() {
+    OLD_CORE_DEPS=$CORE_DEPS
+    OLD_CORE_INCS=$CORE_INCS
+    OLD_CORE_LIBS=$CORE_LIBS
+    OLD_CORE_SRCS=$CORE_SRCS
+    OLD_LINK_DEPS=$LINK_DEPS
+
+    CORE_DEPS=
+    CORE_INCS=
+    CORE_LIBS=
+    CORE_SRCS=
+    LINK_DEPS=
+}
+
+ngx_auto_lib_reset_vars() {
+    CORE_DEPS=$OLD_CORE_DEPS
+    CORE_INCS=$OLD_CORE_INCS
+    CORE_LIBS=$OLD_CORE_LIBS
+    CORE_SRCS=$OLD_CORE_SRCS
+    LINK_DEPS=$OLD_LINK_DEPS
+}
+
+ngx_auto_lib_save_feature_vars() {
+    for var in $ngx_feature_all_vars; do
+        eval main_ngx_feature_$var=\"\$ngx_feature_$var\"
+    done
+}
+
+ngx_auto_lib_reset_feature_vars() {
+    for var in $ngx_feature_all_vars; do
+        eval ngx_feature_$var=\"\$main_ngx_feature_$var\"
+    done
+}
+
+########################
+## CHECKING FUNCTIONS ##
+########################
+
+ngx_auto_lib_check_auto_config() {
+
+    ngx_auto_lib_save_feature_vars
+    ngx_auto_lib_clean_feature_vars
+
+    ngx_feature=$1
+    ngx_feature_inc_path="`echo $CFLAGS | tr ' ' '\n' | grep -- -D | tr '\n' ' '`"
+    ngx_feature_incs="#include <$NGX_AUTO_CONFIG_H>"
+    ngx_feature_libs=
+    ngx_feature_path=`pwd`
+    ngx_feature_run=no
+    ngx_feature_test=$2
+
+    #ngx_auto_lib_print_feature_vars
+
+    . auto/feature
+
+    if [ $ngx_found = yes ]; then
+        rv=0
+    else
+        rv=1
+    fi
+
+    ngx_auto_lib_reset_feature_vars
+
+    return $rv
+}
+
+ngx_auto_lib_check_macro_defined() {
+
+    for m in $@; do
+        ngx_auto_lib_check_auto_config  "$m"  "
+    #ifndef $m
+        rubbish
+    #endif"  && return 0
+    done
+
+    return 1
+}
+
+ngx_auto_lib_check_macro_non_zero() {
+
+    for m in $@; do
+        ngx_auto_lib_check_auto_config  "$m" "
+    #if !($m)
+        rubbish
+    #endif"  && return 0
+    done
+
+    return 1
+}
+
+ngx_auto_lib_check_require() {
+
+    if [ $USE_NGX_AUTO_LIB = YES ]; then
+        return 0
+    elif [ $USE_NGX_AUTO_LIB = NO ]; then
+        return 1
+    fi
+
+
+    # check if the libraries are required elsewhere
+
+    for l in $ngx_feature_lib_names; do
+        [ ! "`echo $CORE_LIBS $ADDON_LIBS | grep -w -- -l$l`" ] && return 0
+    done
+
+
+
+    # check that any required macros are set
+
+    local d=$ngx_feature_check_macros_defined
+    local nz=$ngx_feature_check_macros_non_zero
+
+    if [ "$d" ] || [ "$nz" ]; then
+
+        ngx_auto_lib_check_macro_defined   $d  && return 0
+        ngx_auto_lib_check_macro_non_zero  $nz  && return 0
+    fi
+
+
+    ngx_auto_lib_check
+}
+
+ngx_auto_lib_check() {
+    return 1
+}
+
+##################################
+## TEST PHASE HANDLER FUNCTIONS ##
+##################################
+
+ngx_auto_lib_test() {
+    ngx_auto_lib_test_pre_setup "$@"
+    ngx_auto_lib_test_setup "$@"
+    ngx_auto_lib_test_post_setup "$@"
+    ngx_auto_lib_test_feature
+}
+
+ngx_auto_lib_test_pre_setup() {
+    return 0
+}
+
+ngx_auto_lib_test_setup() {
+
+    local INC=$1
+    local LIB=$2
+
+    ngx_auto_lib_inc_dir=$INC
+    ngx_auto_lib_lib_dir=$LIB
+
+    ngx_auto_lib_reset_feature_vars
+
+    if [ ! "$ngx_feature_path" ]; then
+        ngx_feature_path="$INC"
+    fi
+
+    ngx_feature_path="$ngx_feature_path $ngx_feature_add_path"
+
+    for sfx in $ngx_feature_path_suffixes; do
+        ngx_feature_path="$ngx_feature_path $INC/$sfx"
+    done
+
+
+    local inc=
+    local lib=
+    local incs="$ngx_feature_inc_names"
+    local libs="$ngx_feature_lib_names"
+    local lib_files="$ngx_feature_lib_files"
+
+    for inc in $incs; do
+        ngx_feature_incs="$ngx_feature_incs
+#include <$inc.h>"
+    done
+
+
+    if [ ! "$ngx_feature_libs" ]; then
+
+        if [ $NGX_AUTO_LIB_SHARED = YES ]; then
+            if [ $NGX_RPATH = YES ]; then
+                ngx_feature_libs="-R$LIB"
+            fi
+            ngx_feature_libs="$ngx_feature_libs -L$LIB"
+
+            for lib in $libs; do
+                ngx_feature_libs="$ngx_feature_libs -l$lib"
+            done
+
+            # TODO : only add --rpath when the path is not a standard system path - warn if /usr
+
+            ngx_feature_libs="$ngx_feature_libs -Wl,--rpath -Wl,$LIB"
+
+        else
+
+            for lib in $lib_files; do
+                ngx_feature_libs="$ngx_feature_libs $LIB/$lib"      
+            done
+
+            for lib in $libs; do
+                ngx_feature_libs="$ngx_feature_libs $LIB/lib$lib.a"
+            done
+        fi
+    fi
+
+    if [ ! $ngx_feature_run ]; then
+        ngx_feature_run=no
+    fi
+
+    if [ $NGX_AUTO_LIB_SHARED = YES ]; then
+
+        # Add a test to be called in auto/feature after compilation that will check 
+        # whether any libraries that are linked are in fact using the path provided to
+        # link libraries rather than a standard path. Note : this test will work on 
+        # all linked shared objects, even if supplied directly by setting 
+        # $ngx_feature_libs instead of usign $ngx_feature_lib_names
+
+        # TODO : allow for some libraries to not be checked here if desired - if part of system paths
+
+        libs="`echo $ngx_feature_libs | tr ' ' '\n' | grep -- -l | sed 's|-l||g'`"
+
+        local test="
+            for l in $libs; do
+                o="'\`ldd '$NGX_AUTOTEST' | grep '$LIB'/lib\$l\\.so\`;
+                if [ ! \"\$o\" ]; then
+                    chmod -x $NGX_AUTOTEST;
+                    echo Linker does not link to correct version
+                else
+                    chmod +x $NGX_AUTOTEST;
+                fi
+            done'
+        test="`echo "$test" | tr '\n' ' '`"
+
+        ngx_feature_test_libs="$ngx_feature_test_libs; $test"
+    fi
+
+    ngx_feature_libs="$ngx_feature_libs $ngx_feature_add_libs"
+    ngx_feature_libs_to_add="$ngx_feature_libs"
+    ngx_feature_libs="$ngx_feature_libs $ngx_feature_test_libs"
+    ngx_feature="$ngx_auto_lib_name library $ngx_feature"
+}
+
+ngx_auto_lib_test_post_setup() {
+    return 0
+}
+
+ngx_auto_lib_test_feature() {
+    #ngx_auto_lib_print_feature_vars
+    . auto/feature
+    [ $ngx_found = yes ] && return 0
+    return 1
+}
+
+########################
+## TEST DIR FUNCTIONS ##
+########################
+
+ngx_auto_lib_test_dir_pair() {
+    ngx_auto_lib_test_inc_dir=$1
+    ngx_auto_lib_test_lib_dir=$2
+
+    if [ $1 = $2 ]; then
+        ngx_feature="in $1$3"
+    else
+        ngx_feature="in $1 and $2$3"
+    fi
+    ngx_auto_lib_test "$1" "$2" "$3"
+}
+
+ngx_auto_lib_test_dir_pairs() {
+    ngx_auto_lib_test_dir_pair  "$1/include"  "$2/lib"  "$3"   && return 0
+    ngx_auto_lib_test_dir_pair  "$1"          "$2"      "$3"   && return 0
+    return 1
+}
+
+ngx_auto_lib_test_dirs() {
+
+    local msg="$1"
+    local bdir idir ldir
+
+    local bdirs=$ngx_feature_build_dirs
+    local idirs=$ngx_feature_build_inc_dirs
+    local ldirs=$ngx_feature_build_lib_dirs
+
+    shift
+
+    for dir in "$@"; do
+        ngx_auto_lib_test_dir=$dir
+
+        for ldir in $ldirs; do
+            for idir in $idirs; do
+                ngx_auto_lib_test_dir_pair   "$dir/$idir"  "$dir/$ldir"  "$msg"  && return 0
+            done
+        done
+
+        for ldir in $ldirs; do
+            ngx_auto_lib_test_dir_pair       "$dir"        "$dir/$ldir"  "$msg"  && return 0
+        done
+
+        for idir in $idirs; do
+            ngx_auto_lib_test_dir_pair       "$dir/$idir"  "$dir"        "$msg"  && return 0
+        done
+
+        for bdir in $bdirs; do
+            ngx_auto_lib_test_dir_pairs      "$dir/$bdir"  "$dir/$bdir"  "$msg"  && return 0
+        done
+
+        ngx_auto_lib_test_dir_pairs          "$dir"        "$dir"        "$msg"  && return 0
+        ngx_auto_lib_test_dir=
+    done
+
+    return 1
+}
+
+ngx_auto_lib_test_install_dirs() {
+
+    local msg="$1"
+    local dir=
+
+    shift
+
+    for dir in "$@"; do
+        ngx_auto_lib_test_dir=$dir
+        ngx_auto_lib_test_dir_pair  "$dir/include"  "$dir/lib"  "$msg"   && return 0
+        ngx_auto_lib_test_dir=
+    done
+
+    return 1
+}
+
+ngx_auto_lib_run_tests() {
+
+    local name="$ngx_auto_lib_name"
+    local pfx="$ngx_auto_lib_pfx"
+    local PFX="$NGX_AUTO_LIB_PFX"
+    local INC="$NGX_AUTO_LIB_INC"
+    local LIB="$NGX_AUTO_LIB_LIB"
+    local DIR="$NGX_AUTO_LIB_DIR"
+    local BASE="$NGX_AUTO_LIB_BASE"
+    local MSG="$NGX_AUTO_LIB_MSG"
+
+
+    ngx_found=no
+
+
+    # dependency
+
+    if [ $NGX_AUTO_LIB_SEARCH_DEP = YES ]; then
+        ngx_auto_lib_test_dir_pair  "$INC"  "$LIB"  "$MSG"
+        return $?
+    fi
+
+
+    # lib and include dirs set explicitly (e.g. $OPENSSL_INC, $OPENSSL_LIB)
+
+    if [ $NGX_AUTO_LIB_SEARCH_LIB_INC = YES ]; then
+        ngx_auto_lib_test_dir_pair  "$INC"  "$LIB"  " (specified by \$${PFX}_INC and \$${PFX}_LIB)"  && return 0
+    fi
+
+
+    # path specified by ${PFX} (e.g. $OPENSSL, $PCRE)
+    # Note : these will be set automatically by configure for OpenSSL, PCRE, Zlib etc
+    # TODO : change to searching more than one path
+
+    if [ $NGX_AUTO_LIB_SEARCH_DIR = YES ] && [ $DIR != NONE ]; then
+        ngx_auto_lib_test_dirs  " (specified by \$${PFX})"  $DIR  && return 0
+    fi
+
+
+    # directories beginning with '$pfx-' that are in $NGX_AUTO_LIB_BASE (e.g. $OPENSSL_BASE)
+
+    if [ $NGX_AUTO_LIB_SEARCH_BASE = YES ] && [ $BASE ]; then
+
+        p=$NGX_AUTO_LIB_SEARCH_BASE_PREFIX
+
+        if [ "$p" = YES ]; then
+            p="!ame $pfx-*"
+        elif [ "$p" ]; then
+            p="!ame $p*"
+        fi
+
+        ngx_auto_lib_test_dirs " (found under \$${PFX}_BASE)" \
+                `find $BASE/* -maxdepth 0 -type d $p 2> /dev/null | sort -r`  && return 0
+    fi
+
+
+    # directories beginning with '$pfx-' that are in the same directory as the Nginx source
+
+    if [ $NGX_AUTO_LIB_SEARCH_PARENT = YES ]; then
+        local src_dir=`cd ..; pwd`
+        ngx_auto_lib_test_dirs " (found under Nginx source parent dir)" \
+                `find $src_dir/* -maxdepth 0 -type d !ame $pfx-* 2> /dev/null | sort -r` && return 0
+    fi
+
+
+    # system folders
+
+    if [ $NGX_AUTO_LIB_SEARCH_SYSTEM = YES ]; then
+        ngx_auto_lib_test_install_dirs  ""  $NGX_AUTO_LIB_SYSTEM_DIRS  && return 0
+    fi
+
+    return 1
+}
+
+#######################
+## HANDLER FUNCTIONS ##
+#######################
+
+ngx_auto_lib_run() {
+    ngx_auto_lib_get_variables
+    eval AUTO_$NGX_AUTO_LIB_PFX=NO
+
+    ngx_auto_lib_check_require  || return
+    ngx_auto_lib_setup          || return
+    ngx_auto_lib_save_feature_vars
+    ngx_auto_lib_run_tests
+    ngx_auto_lib_post_tests     || return
+    ngx_auto_lib_finalize
+}
+
+ngx_auto_lib_print_feature_vars() {
+    echo ----------------------------
+    for var in $ngx_feature_vars; do
+        eval "echo ngx_feature_$var = \$ngx_feature_$var"
+    done
+    echo ----------------------------
+}
+
+ngx_auto_lib_setup() {
+    return 0
+}
+
+ngx_auto_lib_post_tests() {
+    return 0
+}
+
+#############################
+## SET VARIABLES FUNCTIONS ##
+#############################
+
+# TODO : add HTTP/ADDON settings too
+
+ngx_auto_lib_set_core_variables() {
+    # TODO : don't add includes / libs more than once
+
+    eval CORE_DEPS=\"$CORE_DEPS $ngx_feature_deps\"
+    eval CORE_INCS=\"$CORE_INCS $ngx_feature_path\"
+    eval CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs_to_add\"
+    eval CORE_SRCS=\"$CORE_SRCS $ngx_feature_srcs\"
+}
+
+ngx_auto_lib_set_generic_variables() {
+    local INC=$ngx_auto_lib_test_inc_dir
+    local LIB=$ngx_auto_lib_test_lib_dir
+
+    modules="$modules $ngx_feature_modules"
+
+    for have in $ngx_feature_haves; do
+        . auto/have
+    done
+
+    set - $ngx_feature_defines
+
+    while [ $1 ]; do
+        have=$1
+        value=$2
+        . auto/define
+    done
+
+    local PFX=$NGX_AUTO_LIB_PFX
+
+    eval USE_$PFX=NO
+
+    if [ $ngx_auto_lib_test_dir ]; then
+        eval $PFX=$ngx_auto_lib_test_dir
+    else
+        eval $PFX=$ngx_auto_lib_lib_dir
+    fi
+
+    if [ $NGX_AUTO_LIB_SHARED != YES ]; then
+        for l in $ngx_feature_lib_names; do
+            CORE_LIBS=`echo $CORE_LIBS | sed 's|-\<l$l\>||g'`
+            ADDON_LIBS=`echo $ADDON_LIBS | sed 's|-\<l$l\>||g'`
+        done
+    fi
+
+    eval ${PFX}_INC=$INC
+    eval ${PFX}_LIB=$LIB
+    eval ${PFX}_SHARED=$NGX_AUTO_LIB_SHARED
+    eval AUTO_$PFX=YES
+}
+
+ngx_auto_lib_set_custom_variables() {
+    return 0
+}
+
+########################
+## FINALIZE FUNCTIONS ##
+########################
+
+ngx_auto_lib_finalize() {
+    ngx_auto_lib_finalize_core
+}
+
+ngx_auto_lib_finalize_core() {
+
+    if [ $ngx_found = yes ]; then
+
+        ngx_auto_lib_set_core_variables
+        ngx_auto_lib_set_generic_variables
+
+        if [ "$ngx_feature_variables" ]; then
+            eval $ngx_feature_variables
+        fi
+
+        ngx_auto_lib_set_custom_variables
+
+    elif [ $ngx_feature_exit_if_not_found = yes ]; then
+
+        if [ $ngx_auto_lib_module_name ]; then
+            module_txt=" by the $ngx_auto_lib_module_name module" 
+        else
+            module_text=
+        fi        
+
+        lib=$ngx_auto_lib_name
+        pfx=$ngx_auto_lib_pfx
+        PFX=$NGX_AUTO_LIB_PFX
+
+cat << END
+
+$0: error: the $lib library is required$module_txt, but cannot
+be found using the current configuration. In order for the compilation to succeed,
+you will need to install the library using your system's package installer or point
+the configure script to the library using one of the following variables :
+
+to define a dir to find $pfx library (source or install dir)    $PFX
+to define $pfx lib and include dirs separately                  ${PFX}_LIB & ${PFX}_INC
+to define a base dir to search for dirs beginning with $pfx-    ${PFX}_BASE
+
+e.g.
+
+$ export ${PFX}_LIB=/path/to/library/lib
+$ export ${PFX}_LIB=/path/to/library/include
+$ $0 ...
+
+END
+        exit 1
+    fi
+}
+
diff -rNu a/src/lua/ngx_devel_kit/notes/CHANGES b/src/lua/ngx_devel_kit/notes/CHANGES
--- a/src/lua/ngx_devel_kit/notes/CHANGES	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/notes/CHANGES	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,17 @@
+Changelog
+---------
+
+0.1         feature : set_var functions
+0.1.1       feature : upstream_list directive and functions
+0.2         feature : conf merge functions
+            feature : conf command macros
+            feature : 'action' macros
+0.2.1       bugfix  : ndk_map_uri_to_path_add_suffix
+0.2.2       feature : regex conf functions
+0.2.3       feature : version number
+0.2.4       change  : the auto/build script is now executed automatically on compilation
+0.2.9       feature : ngx_auto_lib included with source
+0.2.11      bugfix  : hash functions did not display properly
+0.2.12      feature : patches for rewrite functions and rewrite phase handler
+0.2.13      change  : revert to old behaviour rewrite functions
+            change  : pre-generated config and macro files now provided
\ No newline at end of file
diff -rNu a/src/lua/ngx_devel_kit/notes/LICENSE b/src/lua/ngx_devel_kit/notes/LICENSE
--- a/src/lua/ngx_devel_kit/notes/LICENSE	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/notes/LICENSE	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,24 @@
+Copyright (c) 2010, Marcus Clyne, Simpl (simpl.it)
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the organization (Simpl) nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL MARCUS CLYNE OR SIMPL BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_array.h b/src/lua/ngx_devel_kit/objs/ndk_array.h
--- a/src/lua/ngx_devel_kit/objs/ndk_array.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_array.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,113 @@
+
+/* 
+ * 2010 (C) Marcus Clyne 
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* Non-generated macros */
+
+#define     ndk_array_count(a)                  ((a)->nelts)
+#define     ndk_array_get_first(a)              ((a)->elts)
+#define     ndk_array_get_index(a,n)            ((void*) ((char*) (a)->elts + (a)->size * n))
+#define     ndk_array_get_last(a)               ((void*) ((char*) (a)->elts + (a)->size * ((a)->nelts - 1)))
+#define     ndk_array_get_reverse_index(a,n)    ((void*) ((char*) (a)->elts + (a)->size * ((a)->nelts - 1 - n)))
+#define     ndk_array_push_clean(p,a)           {p = ngx_array_push (a); ndk_zerop (p);}
+
+
+/* base action macro macros */
+
+#define     ndk_array_create_ac(a,pl,n,sz,ac)   {a = ngx_array_create (pl,n,sz); if (a == NULL) ac;}
+#define     ndk_array_init_ac(a,pl,n,sz,ac)     {if (ngx_array_init (a,pl,n,sz) == NGX_ERROR) ac;}
+#define     ndk_array_push_ac(p,a,ac)           {p = ngx_array_push (a);     if (p == NULL) ac;}
+#define     ndk_array_push_clean_ac(p,a,ac)     {p = ngx_array_push (a);     if (p == NULL) ac; ndk_zerop (p);}
+#define     ndk_array_push_n_ac(p,a,n,ac)       {p = ngx_array_push_n (a,n); if (p == NULL) ac;}
+#define     ndk_array_push_n_clean_ac(p,a,n,ac) {p = ngx_array_push_n (a,n); if (p == NULL) ac; ndk_zeropn (p,n);}
+
+
+/* generated action macros */
+
+#define     ndk_array_create_r0(a,pl,n,sz)      ndk_array_create_ac        (a,pl,n,sz,return 0)
+#define     ndk_array_create_r1(a,pl,n,sz)      ndk_array_create_ac        (a,pl,n,sz,return 1)
+#define     ndk_array_create_r_1(a,pl,n,sz)     ndk_array_create_ac        (a,pl,n,sz,return -1)
+#define     ndk_array_create_rok(a,pl,n,sz)     ndk_array_create_ac        (a,pl,n,sz,return NGX_OK)
+#define     ndk_array_create_rce(a,pl,n,sz)     ndk_array_create_ac        (a,pl,n,sz,return NGX_CONF_ERROR)
+#define     ndk_array_create_rcok(a,pl,n,sz)    ndk_array_create_ac        (a,pl,n,sz,return NGX_CONF_OK)
+#define     ndk_array_create_re(a,pl,n,sz)      ndk_array_create_ac        (a,pl,n,sz,return NGX_ERROR)
+#define     ndk_array_create_rn(a,pl,n,sz)      ndk_array_create_ac        (a,pl,n,sz,return NULL)
+#define     ndk_array_create_rse(a,pl,n,sz)     ndk_array_create_ac        (a,pl,n,sz,{ngx_script_error (e); return;})
+#define     ndk_array_create_sce(a,pl,n,sz)     ndk_array_create_ac        (a,pl,n,sz,{ngx_script_configure_error (c); return;})
+#define     ndk_array_create_g(a,pl,n,sz,_lb)   ndk_array_create_ac        (a,pl,n,sz,goto _lb)
+#define     ndk_array_create_ge(a,pl,n,sz)      ndk_array_create_ac        (a,pl,n,sz,goto error)
+
+#define     ndk_array_init_r0(a,pl,n,sz)        ndk_array_init_ac          (a,pl,n,sz,return 0)
+#define     ndk_array_init_r1(a,pl,n,sz)        ndk_array_init_ac          (a,pl,n,sz,return 1)
+#define     ndk_array_init_r_1(a,pl,n,sz)       ndk_array_init_ac          (a,pl,n,sz,return -1)
+#define     ndk_array_init_rok(a,pl,n,sz)       ndk_array_init_ac          (a,pl,n,sz,return NGX_OK)
+#define     ndk_array_init_rce(a,pl,n,sz)       ndk_array_init_ac          (a,pl,n,sz,return NGX_CONF_ERROR)
+#define     ndk_array_init_rcok(a,pl,n,sz)      ndk_array_init_ac          (a,pl,n,sz,return NGX_CONF_OK)
+#define     ndk_array_init_re(a,pl,n,sz)        ndk_array_init_ac          (a,pl,n,sz,return NGX_ERROR)
+#define     ndk_array_init_rn(a,pl,n,sz)        ndk_array_init_ac          (a,pl,n,sz,return NULL)
+#define     ndk_array_init_rse(a,pl,n,sz)       ndk_array_init_ac          (a,pl,n,sz,{ngx_script_error (e); return;})
+#define     ndk_array_init_sce(a,pl,n,sz)       ndk_array_init_ac          (a,pl,n,sz,{ngx_script_configure_error (c); return;})
+#define     ndk_array_init_g(a,pl,n,sz,_lb)     ndk_array_init_ac          (a,pl,n,sz,goto _lb)
+#define     ndk_array_init_ge(a,pl,n,sz)        ndk_array_init_ac          (a,pl,n,sz,goto error)
+
+#define     ndk_array_push_r0(p,a)              ndk_array_push_ac          (p,a,return 0)
+#define     ndk_array_push_r1(p,a)              ndk_array_push_ac          (p,a,return 1)
+#define     ndk_array_push_r_1(p,a)             ndk_array_push_ac          (p,a,return -1)
+#define     ndk_array_push_rok(p,a)             ndk_array_push_ac          (p,a,return NGX_OK)
+#define     ndk_array_push_rce(p,a)             ndk_array_push_ac          (p,a,return NGX_CONF_ERROR)
+#define     ndk_array_push_rcok(p,a)            ndk_array_push_ac          (p,a,return NGX_CONF_OK)
+#define     ndk_array_push_re(p,a)              ndk_array_push_ac          (p,a,return NGX_ERROR)
+#define     ndk_array_push_rn(p,a)              ndk_array_push_ac          (p,a,return NULL)
+#define     ndk_array_push_rse(p,a)             ndk_array_push_ac          (p,a,{ngx_script_error (e); return;})
+#define     ndk_array_push_sce(p,a)             ndk_array_push_ac          (p,a,{ngx_script_configure_error (c); return;})
+#define     ndk_array_push_g(p,a,_lb)           ndk_array_push_ac          (p,a,goto _lb)
+#define     ndk_array_push_ge(p,a)              ndk_array_push_ac          (p,a,goto error)
+
+#define     ndk_array_push_clean_r0(p,a)        ndk_array_push_clean_ac    (p,a,return 0)
+#define     ndk_array_push_clean_r1(p,a)        ndk_array_push_clean_ac    (p,a,return 1)
+#define     ndk_array_push_clean_r_1(p,a)       ndk_array_push_clean_ac    (p,a,return -1)
+#define     ndk_array_push_clean_rok(p,a)       ndk_array_push_clean_ac    (p,a,return NGX_OK)
+#define     ndk_array_push_clean_rce(p,a)       ndk_array_push_clean_ac    (p,a,return NGX_CONF_ERROR)
+#define     ndk_array_push_clean_rcok(p,a)      ndk_array_push_clean_ac    (p,a,return NGX_CONF_OK)
+#define     ndk_array_push_clean_re(p,a)        ndk_array_push_clean_ac    (p,a,return NGX_ERROR)
+#define     ndk_array_push_clean_rn(p,a)        ndk_array_push_clean_ac    (p,a,return NULL)
+#define     ndk_array_push_clean_rse(p,a)       ndk_array_push_clean_ac    (p,a,{ngx_script_error (e); return;})
+#define     ndk_array_push_clean_sce(p,a)       ndk_array_push_clean_ac    (p,a,{ngx_script_configure_error (c); return;})
+#define     ndk_array_push_clean_g(p,a,_lb)     ndk_array_push_clean_ac    (p,a,goto _lb)
+#define     ndk_array_push_clean_ge(p,a)        ndk_array_push_clean_ac    (p,a,goto error)
+
+#define     ndk_array_push_n_r0(p,a,n)          ndk_array_push_n_ac        (p,a,n,return 0)
+#define     ndk_array_push_n_r1(p,a,n)          ndk_array_push_n_ac        (p,a,n,return 1)
+#define     ndk_array_push_n_r_1(p,a,n)         ndk_array_push_n_ac        (p,a,n,return -1)
+#define     ndk_array_push_n_rok(p,a,n)         ndk_array_push_n_ac        (p,a,n,return NGX_OK)
+#define     ndk_array_push_n_rce(p,a,n)         ndk_array_push_n_ac        (p,a,n,return NGX_CONF_ERROR)
+#define     ndk_array_push_n_rcok(p,a,n)        ndk_array_push_n_ac        (p,a,n,return NGX_CONF_OK)
+#define     ndk_array_push_n_re(p,a,n)          ndk_array_push_n_ac        (p,a,n,return NGX_ERROR)
+#define     ndk_array_push_n_rn(p,a,n)          ndk_array_push_n_ac        (p,a,n,return NULL)
+#define     ndk_array_push_n_rse(p,a,n)         ndk_array_push_n_ac        (p,a,n,{ngx_script_error (e); return;})
+#define     ndk_array_push_n_sce(p,a,n)         ndk_array_push_n_ac        (p,a,n,{ngx_script_configure_error (c); return;})
+#define     ndk_array_push_n_g(p,a,n,_lb)       ndk_array_push_n_ac        (p,a,n,goto _lb)
+#define     ndk_array_push_n_ge(p,a,n)          ndk_array_push_n_ac        (p,a,n,goto error)
+
+#define     ndk_array_push_n_clean_r0(p,a,n)    ndk_array_push_n_clean_ac  (p,a,n,return 0)
+#define     ndk_array_push_n_clean_r1(p,a,n)    ndk_array_push_n_clean_ac  (p,a,n,return 1)
+#define     ndk_array_push_n_clean_r_1(p,a,n)   ndk_array_push_n_clean_ac  (p,a,n,return -1)
+#define     ndk_array_push_n_clean_rok(p,a,n)   ndk_array_push_n_clean_ac  (p,a,n,return NGX_OK)
+#define     ndk_array_push_n_clean_rce(p,a,n)   ndk_array_push_n_clean_ac  (p,a,n,return NGX_CONF_ERROR)
+#define     ndk_array_push_n_clean_rcok(p,a,n)  ndk_array_push_n_clean_ac  (p,a,n,return NGX_CONF_OK)
+#define     ndk_array_push_n_clean_re(p,a,n)    ndk_array_push_n_clean_ac  (p,a,n,return NGX_ERROR)
+#define     ndk_array_push_n_clean_rn(p,a,n)    ndk_array_push_n_clean_ac  (p,a,n,return NULL)
+#define     ndk_array_push_n_clean_rse(p,a,n)   ndk_array_push_n_clean_ac  (p,a,n,{ngx_script_error (e); return;})
+#define     ndk_array_push_n_clean_sce(p,a,n)   ndk_array_push_n_clean_ac  (p,a,n,{ngx_script_configure_error (c); return;})
+#define     ndk_array_push_n_clean_g(p,a,n,_lb) ndk_array_push_n_clean_ac  (p,a,n,goto _lb)
+#define     ndk_array_push_n_clean_ge(p,a,n)    ndk_array_push_n_clean_ac  (p,a,n,goto error)
+
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_basic.h b/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_basic.h
--- a/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_basic.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_basic.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,2203 @@
+
+/*
+ * 2010 (C) Marcus Clyne
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* conf cmd core values/bitmasks */
+
+#define     NDK_1MORE               NGX_1MORE
+#define     NDK_2MORE               NGX_2MORE
+#define     NDK_ANY                 NGX_ANY
+#define     NDK_ARGS_NUMBER         NGX_ARGS_NUMBER
+#define     NDK_BLOCK               NGX_BLOCK
+#define     NDK_FLAG                NGX_FLAG
+#define     NDK_MULTI               NGX_MULTI
+#define     NDK_TAKE1               NGX_TAKE1
+#define     NDK_TAKE12              NGX_TAKE12
+#define     NDK_TAKE123             NGX_TAKE123
+#define     NDK_TAKE1234            NGX_TAKE1234
+#define     NDK_TAKE13              NGX_TAKE13
+#define     NDK_TAKE2               NGX_TAKE2
+#define     NDK_TAKE23              NGX_TAKE23
+#define     NDK_TAKE3               NGX_TAKE3
+#define     NDK_TAKE4               NGX_TAKE4
+#define     NDK_TAKE5               NGX_TAKE5
+#define     NDK_TAKE6               NGX_TAKE6
+#define     NDK_TAKE7               NGX_TAKE7
+#define     NDK_TAKE8               NGX_TAKE8
+
+
+/* conf cmd bitmasks */
+
+/* TODO : finish this */
+
+#define     NDK_HTTP_MAIN_CONF              NGX_HTTP_MAIN_CONF
+#define     NDK_HTTP_SRV_CONF               NGX_HTTP_SRV_CONF
+#define     NDK_HTTP_SIF_CONF               NGX_HTTP_SIF_CONF
+#define     NDK_HTTP_LOC_CONF               NGX_HTTP_LOC_CONF
+#define     NDK_HTTP_LIF_CONF               NGX_HTTP_LIF_CONF
+#define     NDK_HTTP_UPS_CONF               NGX_HTTP_UPS_CONF
+#define     NDK_MAIN_CONF                   NGX_MAIN_CONF
+#define     NDK_ANY_CONF                    NGX_ANY_CONF
+
+
+/* compound locations */
+
+#define     NDK_HTTP_MAIN_SRV_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_CONF
+#define     NDK_HTTP_MAIN_SIF_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_SIF_CONF
+#define     NDK_HTTP_MAIN_LOC_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_LOC_CONF
+#define     NDK_HTTP_MAIN_LIF_CONF                  NDK_HTTP_MAIN_CONF|NDK_HTTP_LOC_LIF_CONF
+
+#define     NDK_HTTP_SRV_SIF_CONF                   NDK_HTTP_SRV_CONF|NDK_HTTP_SIF_CONF
+#define     NDK_HTTP_SRV_LOC_CONF                   NDK_HTTP_SRV_CONF|NDK_HTTP_LOC_CONF
+#define     NDK_HTTP_SRV_LOC_LIF_CONF               NDK_HTTP_SRV_CONF|NDK_HTTP_LOC_LIF_CONF
+#define     NDK_HTTP_SRV_SIF_LOC_CONF               NDK_HTTP_SRV_SIF_CONF|NDK_HTTP_LOC_CONF
+#define     NDK_HTTP_SRV_SIF_LOC_LIF_CONF           NDK_HTTP_SRV_SIF_CONF|NDK_HTTP_LOC_LIF_CONF
+
+#define     NDK_HTTP_LOC_LIF_CONF                   NDK_HTTP_LOC_CONF|NDK_HTTP_LIF_CONF
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF              NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_LOC_CONF
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF              NDK_HTTP_MAIN_CONF|NDK_HTTP_SRV_LIF_CONF
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF              NDK_HTTP_MAIN_CONF|NDK_HTTP_SIF_LOC_CONF
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_LIF_CONF      NDK_HTTP_SRV_SIF_LOC_LIF_CONF|NDK_MAIN_CONF
+#define     NDK_HTTP_CONF                           NDK_HTTP_MAIN_SRV_SIF_LOC_LIF_CONF
+#define     NDK_HTTP_ANY_CONF                       NDK_HTTP_CONF|NDK_HTTP_UPS_CONF
+
+
+/* property offsets     NOTE : ngx_module_main_conf_t etc should be defined in the module's .c file before the commands */
+
+#define     NDK_HTTP_MAIN_CONF_PROP(p)      NGX_HTTP_MAIN_CONF_OFFSET, offsetof (ndk_module_main_conf_t, p)
+#define     NDK_HTTP_SRV_CONF_PROP(p)       NGX_HTTP_SRV_CONF_OFFSET, offsetof (ndk_module_srv_conf_t, p)
+#define     NDK_HTTP_LOC_CONF_PROP(p)       NGX_HTTP_LOC_CONF_OFFSET, offsetof (ndk_module_loc_conf_t, p)
+
+
+/* conf cmd basic macros */
+
+#define     NDK_HTTP_MAIN_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_1MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_1MORE|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_2MORE(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_2MORE|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_ANY(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ANY|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_ARGS_NUMBER(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_ARGS_NUMBER|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_BLOCK(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_BLOCK|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_FLAG(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_FLAG|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_MULTI(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_MULTI|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE1(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE12(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE12|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE123(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE123|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE1234(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE1234|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE13(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE13|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE2(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE2|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE23(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE23|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE3(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE3|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE4(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE4|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE5(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE5|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE6(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE6|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE7(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE7|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
+#define     NDK_HTTP_MAIN_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_LIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_SRV_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_SIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SRV_LIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_SIF_LIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_SIF_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_SRV_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_SRV_LIF_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_MAIN_SRV_SIF_LOC_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_UPS_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_UPS_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_HTTP_ANY_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_HTTP_ANY_CONF,\
+                                    func, off1, off2, post},
+
+#define     NDK_ANY_CONF_TAKE8(name,func,off1,off2,post)\
+                                    {ngx_string (name),\
+                                    NGX_CONF_TAKE8|NDK_ANY_CONF,\
+                                    func, off1, off2, post},
+
+
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_extra.h b/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_extra.h
--- a/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_extra.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_conf_cmd_extra.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,5423 @@
+
+/*
+ * 2010 (C) Marcus Clyne
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* conf command macros */
+
+#define     NDK_HTTP_MAIN_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_UPS_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_BITMASK(name,p,post)\
+            NDK_HTTP_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_BITMASK(name,p,post)\
+            NDK_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_bitmask_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_BUFS(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_BUFS(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_BUFS(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_BUFS(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_BUFS(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_BUFS(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_bufs_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_COMPLEX_KEYVAL(name,p,post)\
+            NDK_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_http_complex_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_COMPLEX_PATH(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_UPS_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_HTTP_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_COMPLEX_VALUE_ARRAY(name,p,post)\
+            NDK_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_http_complex_value_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_COMPLEX_VALUE(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_http_complex_value_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_ENCODING(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_ENCODING(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_encoding_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_ENUM(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_ENUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_ENUM(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_ENUM(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_ENUM(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_ENUM(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_enum_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_FALSE(name,p,post)\
+            NDK_HTTP_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_FALSE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_FALSE(name,p,post)\
+            NDK_HTTP_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_FALSE(name,p,post)\
+            NDK_HTTP_UPS_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_FALSE(name,p,post)\
+            NDK_HTTP_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_FALSE(name,p,post)\
+            NDK_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_false_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_FULL_PATH(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_FULL_PATH(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_full_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_KEYVAL1(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_KEYVAL1(name,p,post)\
+            NDK_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval1_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_KEYVAL(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_KEYVAL(name,p,post)\
+            NDK_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_keyval_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_MSEC(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_MSEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_MSEC(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_MSEC(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_MSEC(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_MSEC(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_msec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_NULL(name,p,post)\
+            NDK_HTTP_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NULL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_NULL(name,p,post)\
+            NDK_HTTP_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_NULL(name,p,post)\
+            NDK_HTTP_UPS_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_NULL(name,p,post)\
+            NDK_HTTP_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_NULL(name,p,post)\
+            NDK_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_null_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_NUM64(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NUM64(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_NUM64(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_NUM64(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_NUM64(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_NUM64(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num64_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_NUM_FLAG(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_NUM_FLAG(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_NUM(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NUM(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_NUM(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_NUM(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_NUM(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_NUM(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_num_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_OFF(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_OFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_OFF(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_OFF(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_OFF(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_OFF(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_off_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_SRV_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_SIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_LIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_UPS_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_ONOFF(name,p,post)\
+            NDK_HTTP_ANY_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_ONOFF(name,p,post)\
+            NDK_ANY_CONF_FLAG\
+                (name,\
+                ndk_conf_set_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_PATH(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_PATH(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_PATH(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_PATH(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_PATH(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_PATH(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_split_path_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_PTR(name,p,post)\
+            NDK_HTTP_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_PTR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_PTR(name,p,post)\
+            NDK_HTTP_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_PTR(name,p,post)\
+            NDK_HTTP_UPS_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_PTR(name,p,post)\
+            NDK_HTTP_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_PTR(name,p,post)\
+            NDK_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_ptr_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_UPS_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_HTTP_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_REGEX_ARRAY(name,p,post)\
+            NDK_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_UPS_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_HTTP_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_REGEX_ARRAY_CL(name,p,post)\
+            NDK_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_regex_array_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_REGEX_CL(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_REGEX_CL(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_caseless_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_REXEX(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_REXEX(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_REXEX(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_REXEX(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_REXEX(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_REXEX(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_regex_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_SEC_FLAG(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_SEC_FLAG(name,p,post)\
+            NDK_ANY_CONF_TAKE2\
+                (name,\
+                ndk_conf_set_sec_flag_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_SEC(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_SEC(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_SEC(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_SEC(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_SEC(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_SEC(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_sec_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_SIZE(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_SIZE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_SIZE(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_SIZE(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_SIZE(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_SIZE(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_size_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_UPS_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_STR_ARRAY(name,p,post)\
+            NDK_HTTP_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_STR_ARRAY(name,p,post)\
+            NDK_ANY_CONF_1MORE\
+                (name,\
+                ndk_conf_set_str_array_multi_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_STR_ARRAY1(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_STR_ARRAY1(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_array_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_STR(name,p,post)\
+            NDK_HTTP_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_STR(name,p,post)\
+            NDK_HTTP_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_STR(name,p,post)\
+            NDK_HTTP_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_STR(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_STR(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_STR(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_STR(name,p,post)\
+            NDK_HTTP_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_STR(name,p,post)\
+            NDK_HTTP_UPS_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_STR(name,p,post)\
+            NDK_HTTP_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_STR(name,p,post)\
+            NDK_ANY_CONF_TAKE1\
+                (name,\
+                ndk_conf_set_str_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
+#define     NDK_HTTP_MAIN_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_MAIN_CONF_OFFSET,\
+                offsetof (ndk_module_main_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_CONF_TRUE(name,p,post)\
+            NDK_HTTP_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_LIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_SRV_CONF_OFFSET,\
+                offsetof (ndk_module_srv_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_LIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SRV_LIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_SIF_LIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_SIF_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_LIF_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_LIF_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SIF_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_TRUE(name,p,post)\
+            NDK_HTTP_MAIN_SRV_SIF_LOC_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_CONF_TRUE(name,p,post)\
+            NDK_HTTP_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_UPS_CONF_TRUE(name,p,post)\
+            NDK_HTTP_UPS_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_HTTP_ANY_CONF_TRUE(name,p,post)\
+            NDK_HTTP_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+#define     NDK_ANY_CONF_TRUE(name,p,post)\
+            NDK_ANY_CONF_NOARGS\
+                (name,\
+                ndk_conf_set_true_slot,\
+                NGX_HTTP_LOC_CONF_OFFSET,\
+                offsetof (ndk_module_loc_conf_t, p),\
+                post)
+
+
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_config.c b/src/lua/ngx_devel_kit/objs/ndk_config.c
--- a/src/lua/ngx_devel_kit/objs/ndk_config.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_config.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,72 @@
+
+/*
+ * 2010 (C) Marcus Clyne
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* optional includes */
+
+#if (NDK_BUF)
+#include  <ndk_buf.c>
+#endif
+#if (NDK_COMPLEX_PATH)
+#include  <ndk_complex_path.c>
+#endif
+#if (NDK_COMPLEX_VALUE)
+#include  <ndk_complex_value.c>
+#endif
+#if (NDK_CONF_FILE)
+#include  <ndk_conf_file.c>
+#endif
+#if (NDK_ENCODING)
+#include  <ndk_encoding.c>
+#endif
+#if (NDK_HASH)
+#include  <ndk_hash.c>
+#endif
+#if (NDK_HTTP)
+#include  <ndk_http.c>
+#endif
+#if (NDK_PATH)
+#include  <ndk_path.c>
+#endif
+#if (NDK_PROCESS)
+#include  <ndk_process.c>
+#endif
+#if (NDK_REGEX)
+#include  <ndk_regex.c>
+#endif
+#if (NDK_REWRITE)
+#include  <ndk_rewrite.c>
+#endif
+#if (NDK_SET_VAR)
+#include  <ndk_set_var.c>
+#endif
+#if (NDK_STRING)
+#include  <ndk_string.c>
+#endif
+#if (NDK_UPSTREAM_LIST)
+#include  <ndk_upstream_list.c>
+#endif
+#if (NDK_URI)
+#include  <ndk_uri.c>
+#endif
+
+
+/* module commands */
+
+static ngx_command_t  ndk_http_commands[] = {
+#if (NDK_UPSTREAM_LIST)
+#define NDK_UPSTREAM_LIST_CMDS 1
+#include  <ndk_upstream_list.h>
+#undef  NDK_UPSTREAM_LIST_CMDS
+#endif
+    ngx_null_command
+};
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_config.h b/src/lua/ngx_devel_kit/objs/ndk_config.h
--- a/src/lua/ngx_devel_kit/objs/ndk_config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_config.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,98 @@
+
+/* 
+ * 2010 (C) Marcus Clyne 
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* include all optional modules */
+
+#ifdef NDK_ALL
+
+#ifndef NDK_BUF
+#define NDK_BUF 1
+#endif
+#ifndef NDK_COMPLEX_PATH
+#define NDK_COMPLEX_PATH 1
+#endif
+#ifndef NDK_COMPLEX_VALUE
+#define NDK_COMPLEX_VALUE 1
+#endif
+#ifndef NDK_CONF_FILE
+#define NDK_CONF_FILE 1
+#endif
+#ifndef NDK_ENCODING
+#define NDK_ENCODING 1
+#endif
+#ifndef NDK_HASH
+#define NDK_HASH 1
+#endif
+#ifndef NDK_HTTP
+#define NDK_HTTP 1
+#endif
+#ifndef NDK_PATH
+#define NDK_PATH 1
+#endif
+#ifndef NDK_PROCESS
+#define NDK_PROCESS 1
+#endif
+#ifndef NDK_REGEX
+#define NDK_REGEX 1
+#endif
+#ifndef NDK_REWRITE
+#define NDK_REWRITE 1
+#endif
+#ifndef NDK_SET_VAR
+#define NDK_SET_VAR 1
+#endif
+#ifndef NDK_STRING
+#define NDK_STRING 1
+#endif
+#ifndef NDK_UPSTREAM_LIST
+#define NDK_UPSTREAM_LIST 1
+#endif
+#ifndef NDK_URI
+#define NDK_URI 1
+#endif
+
+#endif
+
+
+/* module dependencies */
+
+#ifdef  NDK_COMPLEX_PATH
+#ifndef NDK_COMPLEX_VALUE
+#define NDK_COMPLEX_VALUE 1
+#endif
+#ifndef NDK_PATH
+#define NDK_PATH 1
+#endif
+#endif
+#ifdef  NDK_CONF_FILE
+#ifndef NDK_STRING
+#define NDK_STRING 1
+#endif
+#endif
+#ifdef  NDK_HASH
+#ifndef NDK_STRING
+#define NDK_STRING 1
+#endif
+#endif
+#ifdef  NDK_SET_VAR
+#ifndef NDK_REWRITE
+#define NDK_REWRITE 1
+#endif
+#endif
+#ifdef  NDK_UPSTREAM_LIST
+#ifndef NDK_HTTP_CREATE_MAIN_CONF
+#define NDK_HTTP_CREATE_MAIN_CONF 1
+#endif
+#endif
+
+
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_conf_merge.h b/src/lua/ngx_devel_kit/objs/ndk_conf_merge.h
--- a/src/lua/ngx_devel_kit/objs/ndk_conf_merge.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_conf_merge.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,227 @@
+
+/* 
+ * 2010 (C) Marcus Clyne 
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* conf-merge-value macros */
+
+/* TODO : check that all the main types have a corresponding merge function */
+
+#define     ndk_conf_merge_value            ngx_conf_merge_value
+#define     ndk_conf_merge_off_value        ngx_conf_merge_off_value 
+#define     ndk_conf_merge_ptr_value        ngx_conf_merge_ptr_value
+#define     ndk_conf_merge_str_value        ngx_conf_merge_str_value
+#define     ndk_conf_merge_size_value       ngx_conf_merge_size_value 
+
+
+#define     ndk_conf_merge_keyval_value(conf,prev,default)                                  \
+                                                                                            \
+                conf = prev ? prev : default;
+
+#define     ndk_conf_merge_str_array_value(conf,prev,val1,...)                              \
+                                                                                            \
+                if (conf == NGX_CONF_UNSET_PTR) {                                           \
+                    if (prev == NGX_CONF_UNSET_PTR) {                                       \
+                        if (val1 == NULL) {                                                 \
+                            conf = NULL;                                                    \
+                        } else {                                                            \
+                            char * elts[] = {val1,##__VA_ARGS__};                           \
+                            int    n = sizeof(elts)/sizeof(char*);                          \
+                                                                                            \
+                            conf = ndk_str_array_create (cf->pool, elts, n);                \
+                                                                                            \
+                            if (conf == NULL)                                               \
+                                return  NGX_CONF_ERROR;                                     \
+                        }                                                                   \
+                    } else {                                                                \
+                        conf = prev;                                                        \
+                    }                                                                       \
+                }
+
+#define     ndk_conf_merge_http_complex_value_value(conf,prev,default)                      \
+                                                                                            \
+                if (!conf.str.len) {                                                        \
+                    if (prev.str.len) {                                                     \
+                        conf = prev;                                                        \
+                    } else {                                                                \
+                        conf.str.data = (u_char *) default;                                 \
+                        conf.str.len = sizeof (default) - 1;                                \
+                                                                                            \
+                        if (ndk_http_complex_value_compile (cf, &conf))                     \
+                            return  NGX_CONF_ERROR;                                         \
+                    }                                                                       \
+                }
+
+#define     ndk_conf_merge_http_complex_value_array_value(conf,prev,val1,...)               \
+                                                                                            \
+                if (conf == NGX_CONF_UNSET_PTR) {                                           \
+                    if (prev == NGX_CONF_UNSET_PTR) {                                       \
+                        if (val1 == NULL)                                                   \
+                            conf = NULL;                                                    \
+                        else {                                                              \
+                            char * elts[] = {val1,##__VA_ARGS__};                           \
+                            int    n = sizeof(elts)/sizeof(char*);                          \
+                                                                                            \
+                            conf = ndk_http_complex_value_array_create (cf, elts, n);       \
+                                                                                            \
+                            if (conf == NULL)                                               \
+                                return  NGX_CONF_ERROR;                                     \
+                        }                                                                   \
+                    } else {                                                                \
+                        conf = prev;                                                        \
+                    }                                                                       \
+                }
+
+#define     ndk_conf_merge_http_complex_path_value(conf,prev,...)                           \
+                ndk_conf_merge_http_complex_value_array_value (conf.a, prev.a, __VA_ARGS__)
+
+#define     ndk_conf_merge_split_path_value(conf,prev,path)                                 \
+                                                                                            \
+                if (conf == NGX_CONF_UNSET_PTR)  {                                          \
+                    conf = (prev == NGX_CONF_UNSET_PTR ?                                    \
+                        ndk_split_path_create_raw (cf, path) : prev);                       \
+                }
+
+
+/* conf-merge-prop macros */
+
+#define     ndk_conf_merge_prop(prop,default)\
+            ndk_conf_merge_value\
+                (conf->prop, prev->prop, default)
+
+#define     ndk_conf_merge_bitmask_prop(prop,default,...)\
+            ndk_conf_merge_bitmask_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_bufs_prop(prop,default,...)\
+            ndk_conf_merge_bufs_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_encoding_prop(prop,default,...)\
+            ndk_conf_merge_encoding_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_enum_prop(prop,default,...)\
+            ndk_conf_merge_enum_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_false_prop(prop,default,...)\
+            ndk_conf_merge_false_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_flag_prop(prop,default,...)\
+            ndk_conf_merge_flag_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_full_path_prop(prop,default,...)\
+            ndk_conf_merge_full_path_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_http_complex_keyval_prop(prop,default,...)\
+            ndk_conf_merge_http_complex_keyval_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_http_complex_path_prop(prop,default,...)\
+            ndk_conf_merge_http_complex_path_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_http_complex_value_prop(prop,default,...)\
+            ndk_conf_merge_http_complex_value_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_http_complex_value_array_prop(prop,default,...)\
+            ndk_conf_merge_http_complex_value_array_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_keyval_prop(prop,default,...)\
+            ndk_conf_merge_keyval_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_keyval1_prop(prop,default,...)\
+            ndk_conf_merge_keyval1_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_msec_prop(prop,default,...)\
+            ndk_conf_merge_msec_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_null_prop(prop,default,...)\
+            ndk_conf_merge_null_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_num_prop(prop,default,...)\
+            ndk_conf_merge_num_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_num64_prop(prop,default,...)\
+            ndk_conf_merge_num64_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_num_flag_prop(prop,default,...)\
+            ndk_conf_merge_num_flag_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_off_prop(prop,default,...)\
+            ndk_conf_merge_off_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_ptr_prop(prop,default,...)\
+            ndk_conf_merge_ptr_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_regex_prop(prop,default,...)\
+            ndk_conf_merge_regex_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_regex_array_prop(prop,default,...)\
+            ndk_conf_merge_regex_array_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_regex_array_caseless_prop(prop,default,...)\
+            ndk_conf_merge_regex_array_caseless_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_regex_caseless_prop(prop,default,...)\
+            ndk_conf_merge_regex_caseless_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_sec_prop(prop,default,...)\
+            ndk_conf_merge_sec_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_sec_flag_prop(prop,default,...)\
+            ndk_conf_merge_sec_flag_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_size_prop(prop,default,...)\
+            ndk_conf_merge_size_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_split_path_prop(prop,default,...)\
+            ndk_conf_merge_split_path_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_str_prop(prop,default,...)\
+            ndk_conf_merge_str_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_str_array_prop(prop,default,...)\
+            ndk_conf_merge_str_array_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_str_array_multi_prop(prop,default,...)\
+            ndk_conf_merge_str_array_multi_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
+#define     ndk_conf_merge_true_prop(prop,default,...)\
+            ndk_conf_merge_true_value\
+                (conf->prop, prev->prop, default,##__VA_ARGS__)
+    
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_includes.h b/src/lua/ngx_devel_kit/objs/ndk_includes.h
--- a/src/lua/ngx_devel_kit/objs/ndk_includes.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_includes.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,66 @@
+/* optional includes */
+
+#if (NDK_BUF)
+#include  <ndk_buf.h>
+#endif
+#if (NDK_COMPLEX_PATH)
+#include  <ndk_complex_path.h>
+#endif
+#if (NDK_COMPLEX_VALUE)
+#include  <ndk_complex_value.h>
+#endif
+#if (NDK_CONF_FILE)
+#include  <ndk_conf_file.h>
+#endif
+#if (NDK_ENCODING)
+#include  <ndk_encoding.h>
+#endif
+#if (NDK_HASH)
+#include  <ndk_hash.h>
+#endif
+#if (NDK_HTTP)
+#include  <ndk_http.h>
+#endif
+#if (NDK_PATH)
+#include  <ndk_path.h>
+#endif
+#if (NDK_PROCESS)
+#include  <ndk_process.h>
+#endif
+#if (NDK_REGEX)
+#include  <ndk_regex.h>
+#endif
+#if (NDK_REWRITE)
+#include  <ndk_rewrite.h>
+#endif
+#if (NDK_SET_VAR)
+#include  <ndk_set_var.h>
+#endif
+#if (NDK_STRING)
+#include  <ndk_string.h>
+#endif
+#if (NDK_UPSTREAM_LIST)
+#include  <ndk_upstream_list.h>
+#endif
+#if (NDK_URI)
+#include  <ndk_uri.h>
+#endif
+
+
+/* non-optional includes */
+
+#include  <ndk_http_headers.h>
+#include  <ndk_log.h>
+#include  <ndk_parse.h>
+#include  <ndk_string_util.h>
+
+
+/* auto-generated headers */
+
+#include  <ndk_array.h>
+#include  <ndk_palloc.h>
+#include  <ndk_conf_merge.h>
+#include  <ndk_conf_cmd_basic.h>
+#include  <ndk_conf_cmd_extra.h>
+
+
diff -rNu a/src/lua/ngx_devel_kit/objs/ndk_palloc.h b/src/lua/ngx_devel_kit/objs/ndk_palloc.h
--- a/src/lua/ngx_devel_kit/objs/ndk_palloc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/objs/ndk_palloc.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,112 @@
+
+/* 
+ * 2010 (C) Marcus Clyne 
+ *
+ * DO NOT EDIT THIS FILE MANUALLY
+ * ------------------------------
+ * This file has been generated automatically from scripts in the $base/auto dir and
+ * data in the $base/auto/data dir. If you wish to edit the output of this file, then
+ * you should edit these files instead.
+ *
+*/
+
+
+/* Non-generated macros */
+
+#define     ndk_pallocp(p,pl)                   p = ngx_palloc (pl,sizeof(*p))
+#define     ndk_pallocpn(p,pl,n)                p = ngx_palloc (pl,sizeof(*p)*(n))
+
+#define     ndk_pcallocp(p,pl)                  p = ngx_pcalloc (pl,sizeof(*p))
+#define     ndk_pcallocpn(p,pl,n)               p = ngx_pcalloc (pl,sizeof(*p)*(n))
+
+
+/* base action macro macros */
+
+#define     ndk_palloc_ac(p,pl,sz,ac)           {p = ngx_palloc (pl,sz);    if (p == NULL) ac;}
+#define     ndk_pallocp_ac(p,pl,ac)             {ndk_pallocp (p,pl);        if (p == NULL) ac;}
+#define     ndk_pallocpn_ac(p,pl,n,ac)          {ndk_pallocpn (p,pl,n);     if (p == NULL) ac;}
+#define     ndk_pcalloc_ac(p,pl,sz,ac)          {p = ngx_pcalloc (pl,sz);   if (p == NULL) ac;}
+#define     ndk_pcallocp_ac(p,pl,ac)            {ndk_pcallocp (p,pl);       if (p == NULL) ac;}
+#define     ndk_pcallocpn_ac(p,pl,n,ac)         {ndk_pcallocpn (p,pl,n);    if (p == NULL) ac;}
+
+
+/* generated action macros */
+
+#define     ndk_palloc_r0(p,pl,sz)              ndk_palloc_ac              (p,pl,sz,return 0)
+#define     ndk_palloc_r1(p,pl,sz)              ndk_palloc_ac              (p,pl,sz,return 1)
+#define     ndk_palloc_r_1(p,pl,sz)             ndk_palloc_ac              (p,pl,sz,return -1)
+#define     ndk_palloc_rok(p,pl,sz)             ndk_palloc_ac              (p,pl,sz,return NGX_OK)
+#define     ndk_palloc_rce(p,pl,sz)             ndk_palloc_ac              (p,pl,sz,return NGX_CONF_ERROR)
+#define     ndk_palloc_rcok(p,pl,sz)            ndk_palloc_ac              (p,pl,sz,return NGX_CONF_OK)
+#define     ndk_palloc_re(p,pl,sz)              ndk_palloc_ac              (p,pl,sz,return NGX_ERROR)
+#define     ndk_palloc_rn(p,pl,sz)              ndk_palloc_ac              (p,pl,sz,return NULL)
+#define     ndk_palloc_rse(p,pl,sz)             ndk_palloc_ac              (p,pl,sz,{ngx_script_error (e); return;})
+#define     ndk_palloc_sce(p,pl,sz)             ndk_palloc_ac              (p,pl,sz,{ngx_script_configure_error (c); return;})
+#define     ndk_palloc_g(p,pl,sz,_lb)           ndk_palloc_ac              (p,pl,sz,goto _lb)
+#define     ndk_palloc_ge(p,pl,sz)              ndk_palloc_ac              (p,pl,sz,goto error)
+
+#define     ndk_pallocp_r0(p,pl)                ndk_pallocp_ac             (p,pl,return 0)
+#define     ndk_pallocp_r1(p,pl)                ndk_pallocp_ac             (p,pl,return 1)
+#define     ndk_pallocp_r_1(p,pl)               ndk_pallocp_ac             (p,pl,return -1)
+#define     ndk_pallocp_rok(p,pl)               ndk_pallocp_ac             (p,pl,return NGX_OK)
+#define     ndk_pallocp_rce(p,pl)               ndk_pallocp_ac             (p,pl,return NGX_CONF_ERROR)
+#define     ndk_pallocp_rcok(p,pl)              ndk_pallocp_ac             (p,pl,return NGX_CONF_OK)
+#define     ndk_pallocp_re(p,pl)                ndk_pallocp_ac             (p,pl,return NGX_ERROR)
+#define     ndk_pallocp_rn(p,pl)                ndk_pallocp_ac             (p,pl,return NULL)
+#define     ndk_pallocp_rse(p,pl)               ndk_pallocp_ac             (p,pl,{ngx_script_error (e); return;})
+#define     ndk_pallocp_sce(p,pl)               ndk_pallocp_ac             (p,pl,{ngx_script_configure_error (c); return;})
+#define     ndk_pallocp_g(p,pl,_lb)             ndk_pallocp_ac             (p,pl,goto _lb)
+#define     ndk_pallocp_ge(p,pl)                ndk_pallocp_ac             (p,pl,goto error)
+
+#define     ndk_pallocpn_r0(p,pl,n)             ndk_pallocpn_ac            (p,pl,n,return 0)
+#define     ndk_pallocpn_r1(p,pl,n)             ndk_pallocpn_ac            (p,pl,n,return 1)
+#define     ndk_pallocpn_r_1(p,pl,n)            ndk_pallocpn_ac            (p,pl,n,return -1)
+#define     ndk_pallocpn_rok(p,pl,n)            ndk_pallocpn_ac            (p,pl,n,return NGX_OK)
+#define     ndk_pallocpn_rce(p,pl,n)            ndk_pallocpn_ac            (p,pl,n,return NGX_CONF_ERROR)
+#define     ndk_pallocpn_rcok(p,pl,n)           ndk_pallocpn_ac            (p,pl,n,return NGX_CONF_OK)
+#define     ndk_pallocpn_re(p,pl,n)             ndk_pallocpn_ac            (p,pl,n,return NGX_ERROR)
+#define     ndk_pallocpn_rn(p,pl,n)             ndk_pallocpn_ac            (p,pl,n,return NULL)
+#define     ndk_pallocpn_rse(p,pl,n)            ndk_pallocpn_ac            (p,pl,n,{ngx_script_error (e); return;})
+#define     ndk_pallocpn_sce(p,pl,n)            ndk_pallocpn_ac            (p,pl,n,{ngx_script_configure_error (c); return;})
+#define     ndk_pallocpn_g(p,pl,n,_lb)          ndk_pallocpn_ac            (p,pl,n,goto _lb)
+#define     ndk_pallocpn_ge(p,pl,n)             ndk_pallocpn_ac            (p,pl,n,goto error)
+
+#define     ndk_pcalloc_r0(p,pl,sz)             ndk_pcalloc_ac             (p,pl,sz,return 0)
+#define     ndk_pcalloc_r1(p,pl,sz)             ndk_pcalloc_ac             (p,pl,sz,return 1)
+#define     ndk_pcalloc_r_1(p,pl,sz)            ndk_pcalloc_ac             (p,pl,sz,return -1)
+#define     ndk_pcalloc_rok(p,pl,sz)            ndk_pcalloc_ac             (p,pl,sz,return NGX_OK)
+#define     ndk_pcalloc_rce(p,pl,sz)            ndk_pcalloc_ac             (p,pl,sz,return NGX_CONF_ERROR)
+#define     ndk_pcalloc_rcok(p,pl,sz)           ndk_pcalloc_ac             (p,pl,sz,return NGX_CONF_OK)
+#define     ndk_pcalloc_re(p,pl,sz)             ndk_pcalloc_ac             (p,pl,sz,return NGX_ERROR)
+#define     ndk_pcalloc_rn(p,pl,sz)             ndk_pcalloc_ac             (p,pl,sz,return NULL)
+#define     ndk_pcalloc_rse(p,pl,sz)            ndk_pcalloc_ac             (p,pl,sz,{ngx_script_error (e); return;})
+#define     ndk_pcalloc_sce(p,pl,sz)            ndk_pcalloc_ac             (p,pl,sz,{ngx_script_configure_error (c); return;})
+#define     ndk_pcalloc_g(p,pl,sz,_lb)          ndk_pcalloc_ac             (p,pl,sz,goto _lb)
+#define     ndk_pcalloc_ge(p,pl,sz)             ndk_pcalloc_ac             (p,pl,sz,goto error)
+
+#define     ndk_pcallocp_r0(p,pl)               ndk_pcallocp_ac            (p,pl,return 0)
+#define     ndk_pcallocp_r1(p,pl)               ndk_pcallocp_ac            (p,pl,return 1)
+#define     ndk_pcallocp_r_1(p,pl)              ndk_pcallocp_ac            (p,pl,return -1)
+#define     ndk_pcallocp_rok(p,pl)              ndk_pcallocp_ac            (p,pl,return NGX_OK)
+#define     ndk_pcallocp_rce(p,pl)              ndk_pcallocp_ac            (p,pl,return NGX_CONF_ERROR)
+#define     ndk_pcallocp_rcok(p,pl)             ndk_pcallocp_ac            (p,pl,return NGX_CONF_OK)
+#define     ndk_pcallocp_re(p,pl)               ndk_pcallocp_ac            (p,pl,return NGX_ERROR)
+#define     ndk_pcallocp_rn(p,pl)               ndk_pcallocp_ac            (p,pl,return NULL)
+#define     ndk_pcallocp_rse(p,pl)              ndk_pcallocp_ac            (p,pl,{ngx_script_error (e); return;})
+#define     ndk_pcallocp_sce(p,pl)              ndk_pcallocp_ac            (p,pl,{ngx_script_configure_error (c); return;})
+#define     ndk_pcallocp_g(p,pl,_lb)            ndk_pcallocp_ac            (p,pl,goto _lb)
+#define     ndk_pcallocp_ge(p,pl)               ndk_pcallocp_ac            (p,pl,goto error)
+
+#define     ndk_pcallocpn_r0(p,pl,n)            ndk_pcallocpn_ac           (p,pl,n,return 0)
+#define     ndk_pcallocpn_r1(p,pl,n)            ndk_pcallocpn_ac           (p,pl,n,return 1)
+#define     ndk_pcallocpn_r_1(p,pl,n)           ndk_pcallocpn_ac           (p,pl,n,return -1)
+#define     ndk_pcallocpn_rok(p,pl,n)           ndk_pcallocpn_ac           (p,pl,n,return NGX_OK)
+#define     ndk_pcallocpn_rce(p,pl,n)           ndk_pcallocpn_ac           (p,pl,n,return NGX_CONF_ERROR)
+#define     ndk_pcallocpn_rcok(p,pl,n)          ndk_pcallocpn_ac           (p,pl,n,return NGX_CONF_OK)
+#define     ndk_pcallocpn_re(p,pl,n)            ndk_pcallocpn_ac           (p,pl,n,return NGX_ERROR)
+#define     ndk_pcallocpn_rn(p,pl,n)            ndk_pcallocpn_ac           (p,pl,n,return NULL)
+#define     ndk_pcallocpn_rse(p,pl,n)           ndk_pcallocpn_ac           (p,pl,n,{ngx_script_error (e); return;})
+#define     ndk_pcallocpn_sce(p,pl,n)           ndk_pcallocpn_ac           (p,pl,n,{ngx_script_configure_error (c); return;})
+#define     ndk_pcallocpn_g(p,pl,n,_lb)         ndk_pcallocpn_ac           (p,pl,n,goto _lb)
+#define     ndk_pcallocpn_ge(p,pl,n)            ndk_pcallocpn_ac           (p,pl,n,goto error)
+
diff -rNu a/src/lua/ngx_devel_kit/patches/auto_config b/src/lua/ngx_devel_kit/patches/auto_config
--- a/src/lua/ngx_devel_kit/patches/auto_config	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/patches/auto_config	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,16 @@
+diff -pNr a/src/core/ngx_config.h b/src/core/ngx_config.h
+*** a/src/core/ngx_config.h	2008-09-19 13:47:13.000000000 +0100
+--- b/src/core/ngx_config.h	2010-10-09 17:14:13.000000000 +0100
+*************** typedef intptr_t        ngx_flag_t;
+*** 127,131 ****
+  #define NGX_MAX_UINT32_VALUE  (uint32_t) 0xffffffff
+  #endif
+  
+! 
+  #endif /* _NGX_CONFIG_H_INCLUDED_ */
+--- 127,131 ----
+  #define NGX_MAX_UINT32_VALUE  (uint32_t) 0xffffffff
+  #endif
+  
+! #include <ndk_config.h>
+  #endif /* _NGX_CONFIG_H_INCLUDED_ */
diff -rNu a/src/lua/ngx_devel_kit/patches/expose_rewrite_functions b/src/lua/ngx_devel_kit/patches/expose_rewrite_functions
--- a/src/lua/ngx_devel_kit/patches/expose_rewrite_functions	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/patches/expose_rewrite_functions	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,291 @@
+diff -rNp a/src/http/modules/ngx_http_rewrite_module.c b/src/http/modules/ngx_http_rewrite_module.c
+*** a/src/http/modules/ngx_http_rewrite_module.c	2010-06-18 16:15:20.000000000 +0100
+--- b/src/http/modules/ngx_http_rewrite_module.c	2010-10-09 14:47:10.000000000 +0100
+***************
+*** 8,14 ****
+  #include <ngx_core.h>
+  #include <ngx_http.h>
+  
+! 
+  typedef struct {
+      ngx_array_t  *codes;        /* uintptr_t */
+  
+--- 8,14 ----
+  #include <ngx_core.h>
+  #include <ngx_http.h>
+  
+! #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+  typedef struct {
+      ngx_array_t  *codes;        /* uintptr_t */
+  
+*************** typedef struct {
+*** 17,23 ****
+      ngx_flag_t    log;
+      ngx_flag_t    uninitialized_variable_warn;
+  } ngx_http_rewrite_loc_conf_t;
+! 
+  
+  static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf);
+  static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf,
+--- 17,23 ----
+      ngx_flag_t    log;
+      ngx_flag_t    uninitialized_variable_warn;
+  } ngx_http_rewrite_loc_conf_t;
+! #endif
+  
+  static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf);
+  static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf,
+*************** static char *ngx_http_rewrite_return(ngx
+*** 28,44 ****
+      void *conf);
+  static char *ngx_http_rewrite_break(ngx_conf_t *cf, ngx_command_t *cmd,
+      void *conf);
+  static char *ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd,
+      void *conf);
+  static char * ngx_http_rewrite_if_condition(ngx_conf_t *cf,
+      ngx_http_rewrite_loc_conf_t *lcf);
+  static char *ngx_http_rewrite_variable(ngx_conf_t *cf,
+      ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
+  static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd,
+      void *conf);
+  static char * ngx_http_rewrite_value(ngx_conf_t *cf,
+      ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
+! 
+  
+  static ngx_command_t  ngx_http_rewrite_commands[] = {
+  
+--- 28,47 ----
+      void *conf);
+  static char *ngx_http_rewrite_break(ngx_conf_t *cf, ngx_command_t *cmd,
+      void *conf);
++ #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+  static char *ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd,
+      void *conf);
+  static char * ngx_http_rewrite_if_condition(ngx_conf_t *cf,
+      ngx_http_rewrite_loc_conf_t *lcf);
+  static char *ngx_http_rewrite_variable(ngx_conf_t *cf,
+      ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
++ #endif
+  static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd,
+      void *conf);
++ #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+  static char * ngx_http_rewrite_value(ngx_conf_t *cf,
+      ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
+! #endif
+  
+  static ngx_command_t  ngx_http_rewrite_commands[] = {
+  
+*************** ngx_http_rewrite_handler(ngx_http_reques
+*** 178,185 ****
+      return r->err_status;
+  }
+  
+! 
+! static ngx_int_t
+  ngx_http_rewrite_var(ngx_http_request_t *r, ngx_http_variable_value_t *v,
+      uintptr_t data)
+  {
+--- 181,190 ----
+      return r->err_status;
+  }
+  
+! #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+! static
+! #endif
+! ngx_int_t
+  ngx_http_rewrite_var(ngx_http_request_t *r, ngx_http_variable_value_t *v,
+      uintptr_t data)
+  {
+*************** ngx_http_rewrite_break(ngx_conf_t *cf, n
+*** 511,517 ****
+  }
+  
+  
+! static char *
+  ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+  {
+      ngx_http_rewrite_loc_conf_t  *lcf = conf;
+--- 516,525 ----
+  }
+  
+  
+! #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+! static
+! #endif
+! char *
+  ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+  {
+      ngx_http_rewrite_loc_conf_t  *lcf = conf;
+*************** ngx_http_rewrite_if(ngx_conf_t *cf, ngx_
+*** 627,633 ****
+  }
+  
+  
+! static char *
+  ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
+  {
+      u_char                        *p;
+--- 635,644 ----
+  }
+  
+  
+! #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+! static
+! #endif
+! char *
+  ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
+  {
+      u_char                        *p;
+*************** ngx_http_rewrite_if_condition(ngx_conf_t
+*** 847,853 ****
+  }
+  
+  
+! static char *
+  ngx_http_rewrite_variable(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+      ngx_str_t *value)
+  {
+--- 858,867 ----
+  }
+  
+  
+! #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+! static
+! #endif
+! char *
+  ngx_http_rewrite_variable(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+      ngx_str_t *value)
+  {
+*************** ngx_http_rewrite_set(ngx_conf_t *cf, ngx
+*** 948,954 ****
+  }
+  
+  
+! static char *
+  ngx_http_rewrite_value(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+      ngx_str_t *value)
+  {
+--- 962,971 ----
+  }
+  
+  
+! #if !(NDK_EXPOSE_REWRITE_FUNCTIONS)
+! static
+! #endif
+! char *
+  ngx_http_rewrite_value(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+      ngx_str_t *value)
+  {
+diff -rNp a/src/http/modules/ngx_http_rewrite_module.h b/src/http/modules/ngx_http_rewrite_module.h
+*** a/src/http/modules/ngx_http_rewrite_module.h	1970-01-01 01:00:00.000000000 +0100
+--- b/src/http/modules/ngx_http_rewrite_module.h	2010-10-09 14:38:04.000000000 +0100
+***************
+*** 0 ****
+--- 1,47 ----
++ 
++ /*
++  * Copyright (C) Marcus Clyne
++  *
++  * Note : this file has been created by the Nginx Development Kit using
++  * some code from ngx_http_rewrite_module.c
++  */
++ 
++ #if (NDK_EXPOSE_REWRITE_FUNCTIONS)
++ 
++ #ifndef _NGX_HTTP_REWRITE_H_INCLUDED_
++ #define _NGX_HTTP_REWRITE_H_INCLUDED_
++ 
++ #include <ngx_config.h>
++ #include <ngx_core.h>
++ #include <ngx_http.h>
++ 
++ 
++ extern  ngx_module_t  ngx_http_rewrite_module;
++ 
++ 
++ typedef struct {
++     ngx_array_t  *codes;        /* uintptr_t */
++ 
++     ngx_uint_t    stack_size;
++ 
++     ngx_flag_t    log;
++     ngx_flag_t    uninitialized_variable_warn;
++ } ngx_http_rewrite_loc_conf_t;
++ 
++ 
++ char *
++ ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
++ char *
++ ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf);
++ char *
++ ngx_http_rewrite_variable(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
++     ngx_str_t *value);
++ char *
++ ngx_http_rewrite_value(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
++     ngx_str_t *value);
++ ngx_int_t
++ ngx_http_rewrite_var(ngx_http_request_t *r, ngx_http_variable_value_t *v,
++     uintptr_t data);
++ 
++ #endif
++ #endif
+diff -rNp a/src/http/ngx_http.h b/src/http/ngx_http.h
+*** a/src/http/ngx_http.h	2010-06-15 16:13:34.000000000 +0100
+--- b/src/http/ngx_http.h	2010-10-09 14:25:56.000000000 +0100
+*************** typedef u_char *(*ngx_http_log_handler_p
+*** 43,48 ****
+--- 43,52 ----
+  #include <ngx_http_ssl_module.h>
+  #endif
+  
++ #if (NDK_EXPOSE_REWRITE_FUNCTIONS)
++ #include <ngx_http_rewrite_module.h>
++ #endif
++ 
+  
+  struct ngx_http_log_ctx_s {
+      ngx_connection_t    *connection;
+diff -rNp a/src/http/ngx_http_script.c b/src/http/ngx_http_script.c
+*** a/src/http/ngx_http_script.c	2010-09-13 13:44:43.000000000 +0100
+--- b/src/http/ngx_http_script.c	2010-10-09 14:36:10.000000000 +0100
+*************** static size_t ngx_http_script_full_name_
+*** 26,35 ****
+--- 26,43 ----
+  static void ngx_http_script_full_name_code(ngx_http_script_engine_t *e);
+  
+  
++ #if (NDK_EXPOSE_REWRITE_FUNCTIONS)
++ 
++ uintptr_t ngx_http_script_exit_code = (uintptr_t) NULL;
++ 
++ #else
++ 
+  #define ngx_http_script_exit  (u_char *) &ngx_http_script_exit_code
+  
+  static uintptr_t ngx_http_script_exit_code = (uintptr_t) NULL;
+  
++ #endif
++ 
+  
+  void
+  ngx_http_script_flush_complex_value(ngx_http_request_t *r,
+diff -rNp a/src/http/ngx_http_script.h b/src/http/ngx_http_script.h
+*** a/src/http/ngx_http_script.h	2010-09-13 13:44:43.000000000 +0100
+--- b/src/http/ngx_http_script.h	2010-10-09 14:33:40.000000000 +0100
+***************
+*** 12,17 ****
+--- 12,25 ----
+  #include <ngx_core.h>
+  #include <ngx_http.h>
+  
++ #if (NDK_EXPOSE_REWRITE_FUNCTIONS)
++ 
++ #define ngx_http_script_exit  (u_char *) &ngx_http_script_exit_code
++ 
++ extern uintptr_t ngx_http_script_exit_code;
++ 
++ #endif
++ 
+  
+  typedef struct {
+      u_char                     *ip;
diff -rNu a/src/lua/ngx_devel_kit/patches/rewrite_phase_handler b/src/lua/ngx_devel_kit/patches/rewrite_phase_handler
--- a/src/lua/ngx_devel_kit/patches/rewrite_phase_handler	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/patches/rewrite_phase_handler	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,19 @@
+diff -p -r a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
+*** a/src/http/ngx_http_core_module.c	2010-09-27 12:48:12.000000000 +0100
+--- b/src/http/ngx_http_core_module.c	2010-10-09 13:44:09.000000000 +0100
+*************** ngx_http_core_rewrite_phase(ngx_http_req
+*** 910,915 ****
+--- 910,922 ----
+          return NGX_AGAIN;
+      }
+  
++ #if defined(nginx_version) && nginx_version >= 8042 && (NDK_REWRITE_PHASE)
++ 
++     if (rc == NGX_AGAIN || rc == NGX_DONE) {
++         return NGX_OK;
++     }
++     
++ #endif
+      /* rc == NGX_OK || rc == NGX_ERROR || rc == NGX_HTTP_...  */
+  
+      ngx_http_finalize_request(r, rc);
diff -rNu a/src/lua/ngx_devel_kit/README b/src/lua/ngx_devel_kit/README
--- a/src/lua/ngx_devel_kit/README	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/README	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,139 @@
+    Nginx Development Kit (NDK)
+    ===========================
+
+Synopsis
+
+    The NDK is an Nginx module that is designed to extend the core functionality of the 
+    excellent Nginx webserver in a way that can be used as a basis of other Nginx modules.
+
+    It has functions and macros to deal with generic tasks that don't currently have
+    generic code as part of the core distribution.  The NDK itself adds few features
+    that are seen from a user's point of view - it's just designed to help reduce the
+    code that Nginx module developers need to write.
+
+    Nginx module developers wishing to use any of the features in the NDK should specify 
+    that the NDK is a dependency of their module, and that users will need to compile
+    it as well when they compile their own modules.  They will also need to declare in
+    their own modules which features of the NDK they wish to use (explained below).
+    
+    If you are not an Nginx module developer, then the only useful part of this project
+    will be the 'usage for users' section below.
+
+
+Status
+
+    The NDK is now considered to be stable. It is already being used in quite a few third
+    party modules.
+
+
+Features
+
+    - additional conf_set functions for regexes, complex/script values, paths...
+    - macros to simplify tasks like checking for NULL values when doing ngx_array_push
+    - patches to the main source code
+    - ngx_auto_lib_core generic external library handler is included (see separate readme)
+
+
+
+Design
+
+    modular :
+
+    The kit itself is designed in a modular way, so that only the required code is compiled.
+    It's possible to add just a single NDK module, a few or all of them.
+
+    auto-generated & easily extensible :
+
+    Many of the macros available in the NDK are auto-generated from simple configuration
+    files.  This makes creating similar macros for your own code very simple - it's usually
+    just the case of adding an extra line to a config file and re-running the build script.
+
+
+Usage for users
+
+    If another Nginx module you wish to use specifies that the NDK is a dependency, you
+    will need to do the following :
+
+    1 - download the source (http://github.com/simpl/ngx_devel_kit)
+
+    2 - unpack the source (tar -xzf $name)
+
+    3 - compile Nginx with the following extra option
+
+        --add-module=/path/to/src
+
+        e.g.
+
+        ./configure --add-module=/path/to/ndk/base  --add-module=/path/to/another/mod
+
+
+Usage for developers
+
+    To use the NDK in your own module, you need to add the following :
+
+    1 - add this line to your module
+
+        #include    <ndk.h>
+
+        note : since the NDK includes the following lines
+
+        #include    <ngx_config.h>
+        #include    <ngx_core.h>
+        #include    <ngx_http.h>
+
+        you can replace these with the single include above.
+
+    2 - add the following line in the config file for your module :
+
+        have=NDK_[module_name]  . auto/have
+
+        for each NDK module that you wish to use (you need to include auto/have multiple
+        times if you wish to use multiple NDK modules.
+
+
+    Note : the old method of setting
+
+        CFLAGS="$CFLAGS -DNDK_[module_name]"
+
+        is now deprecated. It will still work, but results in unnecessary lines being
+        displayed when compiling Nginx.
+
+
+    Warning : using NDK_ALL
+
+        You can also set NDK_ALL to include all the NDK modules.  This is primarily as
+        a convenience in the early stages of development of another module. However,
+
+        DO NOT LEAVE 'NDK_ALL' IN YOUR CONFIG FILE WHEN PUBLISHING
+
+        Although the NDK is fairly small now, it could in time become a large repository
+        of code that would, if using NDK_ALL, result in considerably more code being compiled
+        than is necessary.
+
+
+Todo
+
+    - documentation for modules that don't already have it
+    - additional phase-handler functions
+    - generically testing for needing to add a handler
+    - remove dependency of set_var on OpenSSL being compiled in
+
+
+License
+
+    BSD
+
+
+Contributing / Feedback
+
+    If you are an Nginx module developer, and have developed some functions that are
+    generic in nature (or would be easily adapted to be so), then please send them to
+    me at the address below, and I'll add them to the kit.
+
+    
+Author
+
+    Marcus Clyne (contact at simpl dot it)
+
+
+
diff -rNu a/src/lua/ngx_devel_kit/README_AUTO_LIB b/src/lua/ngx_devel_kit/README_AUTO_LIB
--- a/src/lua/ngx_devel_kit/README_AUTO_LIB	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/README_AUTO_LIB	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,395 @@
+Nginx Auto Lib Core
+===================
+
+Nginx Auto Lib Core is a generic external library-handler that has been designed to
+facilitate the inclusion of external libraries in modules for the Nginx web server.
+It has been written both for the benefit of Nginx module developers and for the end
+users of those Nginx modules, and can provide a consistent, intelligent, flexible
+cross-platform way to include external libraries.
+
+Any developers of Nginx modules are encouraged to use Auto Lib Core to handle library
+dependencies for their modules rather than writing their own custom handler from scratch.
+
+Note : the latest version can be found at github.com/simpl/ngx_auto_lib
+
+
+Information for end users
+=========================
+
+To include external libraries using Auto Lib to you may need or wish to export some
+variables before you run configure. e.g.
+
+$ export MOZJS=/path/to/mozjs
+$ export MOZJS_SHARED=NO
+$ ./configure ...
+
+In all cases below [PFX] should be replaced with the name of the library (e.g. MOZJS). The
+specific value for [PFX] should be mentioned in the README file for the module that
+uses Auto Lib Core.
+
+
+Search order for paths
+----------------------
+
+(1) [PFX]_INC and [PFX]_LIB
+(2) [PFX] (source or install dir)
+(3) any dirs under [PFX]_BASE (see below)
+(4) any dirs under the parent directory of the Nginx source dir beginning with '[pfx]-'
+(5) standard system paths (including /usr/local, /usr, /opt/local, /opt, /usr/pkg)
+
+If any of 1-3 are specified, then any set values will be searched, and the the Nginx
+source's parent directory and system paths are not searched unless [PFX]_SEARCH_[PLACE]
+variable is set to YES, where PLACE ::= PARENT | SYSTEM. e.g.
+
+$ export OPENSSL_LIB=/path/to/openssl/lib
+$ export OPENSSL_INC=/path/to/openssl/inc
+$ ./configure
+
+will search only in the lib and include paths specified, and
+
+$ export OPENSSL_LIB=/path/to/openssl/lib
+$ export OPENSSL_INC=/path/to/openssl/inc
+$ export OPENSSL_BASE=/path/to/openssl/base
+$ export OPENSSL_SEARCH_PARENT=YES
+$ ./configure --with-openssl=/path/to/openssl
+
+will search first in the lib & inc dirs specified, then in /path/to/openssl, then will
+look for directories in /path/to/openssl/base and then in the Nginx source parent
+directory, but will skip checking the system paths.
+
+Note : apart from system paths, all dirs are checked as both source and install directories,
+so static versions of installed OpenSSL, PCRE, Zlib etc libraries can be used with Nginx
+if desired.
+
+
+Specifying a path to find a library
+-----------------------------------
+
+If the version of a library you wish to include is in any of the standard paths (e.g.
+/usr/local, /usr ...), you will not need to specify a path to include the library.
+
+If you do wish to specify a specific path, in most cases just specifying 
+[PFX]=/path/to/library will be sufficient. e.g.
+
+$ export MOZJS=/path/to/mozjs
+$ ./configure ...
+
+The path can be either a source directory or an install directory. Auto Lib will search
+
+
+Searching under base paths
+--------------------------
+
+Rather than specifying a specific path to find new libraries in non-standard locations,
+you may wish to specify a base path (or just let Auto Lib search the directory that the
+Nginx source is located in). This will then automatically find the most recent versions
+of libraries and check them before older versions.
+
+e.g.
+
+You have installations
+
+/openssl/version/0.9.8m
+/openssl/version/1.0.0a
+...
+
+$ export OPENSSL_BASE=/openssl/version
+$ ./configure ...
+
+Any directories under /openssl/version will be searched IN REVERSE ORDER, i.e. most recent
+version first. Here /openssl/version/1.0.0a would be searched before /openssl/version/0.9.8m.
+
+If [PFX]_BASE_SEARCH_PREFIX=YES, then only directories beginning with '[pfx]-' are searched.
+If [PFX]_BASE_SEARCH_PREFIX=something, then only directories beginning with 'something' are
+searched.
+
+When searching under [PFX]_BASE no prefix is added to the search, but when searching under
+the directory that the Nginx source is located in, the prefix [pfx]- is automatically added.
+
+Note : there is currently a minor bug (due to the implementation of the 'sort' command) 
+means versions that include hyphens (e.g. 1.0.0-beta5) are checked before versions like 
+1.0.0a. This will be fixed soon, and searching of -build folders before normal source ones
+will be added too.
+
+
+
+Shared or static?
+-----------------
+
+The default for most libraries is to look for shared libraries, though this can be overridden
+by the user by setting [PFX]_SHARED=NO.
+
+In the near future the default action will be to look for shared libraries then to look 
+for static libraries in each directory searched unless one of [PFX]_SHARED and/or
+[PFX]_STATIC = NO. If both are set to NO, then Auto Lib will not be used at all.
+
+
+
+Variables that users can set to help find libraries
+---------------------------------------------------
+
+[PFX]                   Location of dir where the library can be found      (PATH, see below)
+[PFX]_INC               Include dir for library headers                     (PATH)
+[PFX]_LIB               Lib dir for library archive/shared objects          (PATH)
+[PFX]_BASE              Base dir under which to search for other dirs       (PATH)
+[PFX]_SEARCH_LIB_INC    Search in [PFX]_INC and [PFX]_LIB if set            (YES|NO, def=YES)
+[PFX]_SEARCH_DIR        Search [PFX] if set                                 (YES|NO, def=YES)
+[PFX]_SEARCH_BASE       Search under [PFX]_BASE if set                      (YES|NO, def=YES)
+[PFX]_SEARCH_PARENT     Search under the dir that the Nginx source is in    (YES|NO, see above)
+[PFX]_SEARCH_SYSTEM     Search in standard system paths                     (YES|NO, see above)
+[PFX]_SHARED            Use shared library rather than static               (YES|NO, def=YES)
+[PFX]_SYSTEM_DIRS       System dirs to search in (PATHS, space-separated, overrides the defaults)
+USE_[PFX]               Whether or not to install the library               (YES|NO, def=YES)
+
+
+Note : for libraries that have configure options (e.g. --with-openssl=/path), the [PFX]
+variable is set automatically by configure, so will not be used if exported.
+
+
+
+Information for module developers
+=================================
+
+How Auto Lib Core works
+-----------------------
+
+Auto Lib Core works as an interface layer between the module and the auto/feature part of
+the Nginx source. This is the file that results in the 'checking for ...' lines that you 
+see when you call ./configure.
+
+auto/feature works by using a few key variables (see below) to generate some C code, trying
+to compile it to see if it works and optionally running the code. This output file is called
+autotest.c (located under the objs/ directory whilst configure is running, but is deleted
+after each call to auto/feature).
+
+Normally, whenever an external library is required, a module developer will write a number 
+of calls to auto/feature manually in their config files - e.g. to check under a range of 
+different possible locations to find a library. Apart from being tedious, this is obviously
+potentially error-prone.
+
+Auto Lib Core will automatically generate all the calls to auto/feature for you, and will
+take into account different operating systems etc in a consistent way, 'intelligent' way.
+
+
+Including Nginx Auto Lib Core with custom modules
+-------------------------------------------------
+
+Option 1 :
+
+- include ngx_auto_lib_core in the same directory that your module config file is
+  located
+- add the following line to your config file
+
+  . $ngx_addon_dir/ngx_auto_lib_core 
+
+NOTE : if you want to include the file in a different directory to your config
+file, you will need to change both the include line in your config file AND
+the line in the ngx_auto_lib_core file that points to the file (it's the line that
+has $ngx_addon_dir/ngx_auto_lib_core in it)
+
+Option 2 :
+
+- make the Nginx Development Kit (github.com/simpl-it/ngx_devel_kit) a dependency 
+  for your module (Auto Lib Core is included automatically with it)
+
+
+Recommended way of including Auto Lib Core
+------------------------------------------
+
+If the Nginx Development Kit (NDK) is already a dependency for your module, then you do
+not need to do anything - just follow the 'using Auto Lib Core' instructions below.
+
+If the NDK is not a dependency for your module, then it is recommended to include a
+copy of ngx_auto_lib_core with your module, but to recommend to users of your module
+to include the NDK when compiling. If the module is not required for anything else, this
+will not make any difference to the Nginx binary that they compile, but will mean they
+will get the latest version of Auto Lib Core (which probably won't change much anyway,
+but you never know).
+
+You will also probably want to include a copy of this readme file for Auto Lib Core
+(at least the user section), and mention what the relevant [PFX] you use for your module
+is in your module's readme file so that users will know what to write for any variables
+that they might use to control the search paths for libraries (see above user section).
+
+
+Using Auto Lib Core
+-------------------
+
+To use Auto Lib Core, you should do the following in your config file for each
+external library that you want to include :
+
+1 - Call ngx_auto_lib_init
+2 - Define any variables used for testing
+3 - Define any hooks (custom functions)
+4 - Call ngx_auto_lib_run
+
+
+Calling ngx_auto_lib_init() and ngx_auto_lib_run()
+--------------------------------------------------
+
+You can pass either one or two variables to ngx_auto_lib_init(). The first is the name of
+the library as it will appear when running ./configure, the second is the prefix that is
+used for internal variables and looking for directory prefixes. If the second is not 
+specified, it defaults to the first.
+
+The init function resets all key variables and functions, so it must be called before 
+setting any other variables or functions that are to be used as hooks (see the notes below).
+
+ngx_auto_lib_run() should be called in the config files after all the variables and hooks
+have been defined. This will then run through all the tests to try to find the external
+library.
+
+
+Variables you can set in your config files
+------------------------------------------
+
+All the variables that you set in Auto Lib Core are similar to the ones you set for
+including libraries in the normal way.
+
+       name                           description
+----------------------------------------------------------------------------------------
+
+core variables (i.e. the ones in the core Nginx source)
+
+ngx_feature_inc_path                CFLAGS and include path info (including -I)
+ngx_feature_incs                    Include/define code inserted before main() in autotest.c
+ngx_feature_libs                    External libraries to add (see below)
+ngx_feature_path                    Space-separated include path
+ngx_feature_run                     Whether to run the autotest binary (default = no)
+ngx_feature_test                    C-code inserted inside main() in autotest.c
+
+extended variables (only work in NALC) :
+
+ngx_feature_add_libs                Add libraries (but do not add include files)
+ngx_feature_add_path                Add extra directories to include path
+ngx_feature_build_dirs              Sub dirs that builds might be found
+ngx_feature_build_inc_dirs          Sub dirs that include files might be found
+ngx_feature_build_lib_dirs          Sub dirs that lib files might be found
+ngx_feature_check_macros_defined    Lib required only if one of these macros is defined
+ngx_feature_check_macros_non_zero   Lib required only if one of these macros is non-zero
+ngx_feature_defines                 Define these macros if the library is found
+ngx_feature_deps                    Deps to add (e.g. to CORE_DEPS) if the library is found
+ngx_feature_exit_if_not_found       Quit configure if the library is not found
+ngx_feature_haves                   Set these macros to 1 if the library is found
+ngx_feature_inc_names               Names for include files (not including the .h)
+ngx_feature_lib_files               Add these files under the lib dir for static inclusions
+ngx_feature_lib_names               Names for lib files (not including -l or .a)
+ngx_feature_modules                 Modules to add if the library is found
+ngx_feature_srcs                    Sources to add (e.g. to ADDON_SRCS) if the lib is found
+ngx_feature_shared                  If set to 'no', then only use static lib versions
+ngx_feature_test_libs               Add these libs when testing, but not to the final binary
+ngx_feature_variables               Set these variables if the library is found
+
+standard variables that are completely over-written (i.e. they won't work with NALC) :
+
+ngx_feature_name                    Message that is displayed after 'checking for' in configure
+
+
+Using these variables
+---------------------
+
+You do not need to set most of these variables, since 'intelligent' guesses are made that
+will work for most cases. With the exception of ngx_feature_test, you should generally use
+the extended variables rather than the core ones, since sensible core variables will be
+automatically generated from them, and will work for both static and shared libraries.
+
+
+Variable defaults
+-----------------
+
+ngx_feature_incs            for i in $ngx_feature_inc_names { #include <$i.h> }
+ngx_feature_libs            for l in $ngx_feature_lib_names { -l$l or $LIB/lib$l.a }
+                            + $ngx_feature_add_libs
+ngx_feature_inc_names       $ngx_feature_lib_names
+ngx_feature_lib_names       $pfx
+pfx                         str_to_lower (if two variables are passed to ngx_auto_lib_init, then
+                            then $2, otherwise, $1)
+
+The easiest way to understand how all the defaults work is probably to look at the source code
+of ngx_auto_lib_test_setup() and to look at the examples in the standard Nginx Auto Lib module
+which has code for OpenSSL, PCRE, Zlib, MD5 and SHA1.
+
+
+Hooks
+-----
+
+To facilitate using Auto Lib Core in a flexible way, a number of 'hooks' have been
+placed in the testing cycle. These hooks are implemented as functions that you define
+in your config file which are called if required by the core library. In the core 
+library they are left as empty functions that return either 0 or 1. Any functions
+you write will 
+
+Note : ngx_auto_lib_init() resets the variables and functions each time it is called, so
+you must DEFINE HOOKS AFTER YOU CALL ngx_auto_lib_init.
+
+Note : an update on what hooks are available will be added later. To see what hooks are
+available, just look in the source code of ngx_auto_lib_core for any functions that just
+return 0 or 1.
+
+See the MD5 and SHA1 libraries of Nginx Auto Lib module for examples.
+
+
+
+Checking that a library is required
+-----------------------------------
+
+Although in most cases Auto Lib Core will be used where external libraries are
+definitely required (for a module to work), this may not always be the case. In the
+standard Nginx Auto Lib module (github.com/simpl-it/ngx_auto_lib) - which is designed
+to improve the inclusion of OpenSSL, PCRE and Zlib libraries and increase compilation
+speed where possible - the libraries are not always required, so checks are made to 
+see if it is necessary.
+
+
+
+How Auto Lib Core checks if a library is required - ngx_auto_lib_check_require()
+------------------------------------------------------------------------------------
+
+- search for USE_[PFX]=YES (it is set to YES by default for most modules)
+- search for any external libraries that have been included in the CORE_LIBS or ADDON_LIBS
+  variables that use the same lib name as any set in ngx_feature_lib_names
+- search for any macros that have been defined either in the CFLAGS variable or using 
+  auto/have or auto/define as set in the ngx_feature_check_macros_defined and 
+  ngx_feature_ngx_macros_non_zero variables
+- any custom checks implemented by creating an ngx_auto_lib_check hook function (which
+  should return 0 if the library is required and return 1 at the end if the module is 
+  not required)
+
+
+
+Guaranteeing that the correct version of a shared library is linked at run time
+-------------------------------------------------------------------------------
+
+Sometimes users will want to use shared libraries that are in non-standard locations
+that the linker may have a problem in locating at run time - even if the correct
+linker path (-L/path/to/lib) is supplied when checking. To make sure that the linker
+can find the library at run time, and to make sure that the linker will use the correct
+version of a library if the library is also located in a standard directory, a run path
+is added to the linker flags (using -Wl,--rpath -Wl,/path/to/lib/dir). In most cases this
+will guarantee that the correct library is used when linking - though care should be taken
+by any users specifying specific paths for libraries that the correct version of the
+library has been linked at run time (e.g. using ldd etc).
+
+As an additional check when running auto/feature, as well as the compilation of the
+autotest.c file, a check is made by ldd to see that the path of the shared library
+that the linker links to is the same as the one specified. This is done because
+
+
+To do
+-----
+
+- change how library paths are searched to include both shared and static libraries
+- touch up documentation
+
+
+License
+-------
+
+    BSD
+
+
+Copyright
+---------
+
+    Marcus Clyne (c) 2010  (http://simpl.it)
+
diff -rNu a/src/lua/ngx_devel_kit/src/hash/md5.h b/src/lua/ngx_devel_kit/src/hash/md5.h
--- a/src/lua/ngx_devel_kit/src/hash/md5.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/hash/md5.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,117 @@
+/* crypto/md5/md5.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_MD5_H
+#define HEADER_MD5_H
+
+#include <openssl/e_os2.h>
+#include <stddef.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_NO_MD5
+#error MD5 is disabled.
+#endif
+
+/*
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * ! MD5_LONG has to be at least 32 bits wide. If it's wider, then !
+ * ! MD5_LONG_LOG2 has to be defined along.			   !
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ */
+
+#if defined(__LP32__)
+#define MD5_LONG unsigned long
+#elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)
+#define MD5_LONG unsigned long
+#define MD5_LONG_LOG2 3
+/*
+ * _CRAY note. I could declare short, but I have no idea what impact
+ * does it have on performance on none-T3E machines. I could declare
+ * int, but at least on C90 sizeof(int) can be chosen at compile time.
+ * So I've chosen long...
+ *					<appro@fy.chalmers.se>
+ */
+#else
+#define MD5_LONG unsigned int
+#endif
+
+#define MD5_CBLOCK	64
+#define MD5_LBLOCK	(MD5_CBLOCK/4)
+#define MD5_DIGEST_LENGTH 16
+
+typedef struct MD5state_st
+	{
+	MD5_LONG A,B,C,D;
+	MD5_LONG Nl,Nh;
+	MD5_LONG data[MD5_LBLOCK];
+	unsigned int num;
+	} MD5_CTX;
+
+int MD5_Init(MD5_CTX *c);
+int MD5_Update(MD5_CTX *c, const void *data, size_t len);
+int MD5_Final(unsigned char *md, MD5_CTX *c);
+unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);
+void MD5_Transform(MD5_CTX *c, const unsigned char *b);
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/hash/murmurhash2.c b/src/lua/ngx_devel_kit/src/hash/murmurhash2.c
--- a/src/lua/ngx_devel_kit/src/hash/murmurhash2.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/hash/murmurhash2.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,77 @@
+
+
+#ifndef MURMURHASH2_C
+#define MURMURHASH2_C
+
+#define     MURMURHASH2_DIGEST_LENGTH   4
+
+/*
+ * -----------------------------------------------------------------------------
+ * MurmurHash2, by Austin Appleby
+
+ * Note - This code makes a few assumptions about how your machine behaves -
+
+ * 1. We can read a 4-byte value from any address without crashing
+ * 2. sizeof(int) == 4
+
+ * And it has a few limitations -
+
+ * 1. It will not work incrementally.
+ * 2. It will not produce the same results on little-endian and big-endian
+ *    machines.
+ */
+
+unsigned int MurmurHash2 ( const void * key, int len, unsigned int seed )
+{
+	/*
+         * 'm' and 'r' are mixing constants generated offline.
+	 * They're not really 'magic', they just happen to work well.
+         */
+
+	const unsigned int m = 0x5bd1e995;
+	const int r = 24;
+
+	/* Initialize the hash to a 'random' value */
+
+	unsigned int h = seed ^ len;
+
+	/* Mix 4 bytes at a time into the hash */
+
+	const unsigned char * data = (const unsigned char *)key;
+
+	while(len >= 4)
+	{
+		unsigned int k = *(unsigned int *)data;
+
+		k *= m;
+		k ^= k >> r;
+		k *= m;
+
+		h *= m;
+		h ^= k;
+
+		data += 4;
+		len -= 4;
+	}
+
+	/* Handle the last few bytes of the input array */
+
+	switch(len)
+	{
+	case 3: h ^= data[2] << 16;
+	case 2: h ^= data[1] << 8;
+	case 1: h ^= data[0];
+	        h *= m;
+	};
+
+	/* Do a few final mixes of the hash to ensure the last few
+	 * bytes are well-incorporated. */
+
+	h ^= h >> 13;
+	h *= m;
+	h ^= h >> 15;
+
+	return h;
+}
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/hash/sha.h b/src/lua/ngx_devel_kit/src/hash/sha.h
--- a/src/lua/ngx_devel_kit/src/hash/sha.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/hash/sha.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,200 @@
+/* crypto/sha/sha.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_SHA_H
+#define HEADER_SHA_H
+
+#include <openssl/e_os2.h>
+#include <stddef.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#if defined(OPENSSL_NO_SHA) || (defined(OPENSSL_NO_SHA0) && defined(OPENSSL_NO_SHA1))
+#error SHA is disabled.
+#endif
+
+#if defined(OPENSSL_FIPS)
+#define FIPS_SHA_SIZE_T size_t
+#endif
+
+/*
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * ! SHA_LONG has to be at least 32 bits wide. If it's wider, then !
+ * ! SHA_LONG_LOG2 has to be defined along.                        !
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ */
+
+#if defined(__LP32__)
+#define SHA_LONG unsigned long
+#elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)
+#define SHA_LONG unsigned long
+#define SHA_LONG_LOG2 3
+#else
+#define SHA_LONG unsigned int
+#endif
+
+#define SHA_LBLOCK	16
+#define SHA_CBLOCK	(SHA_LBLOCK*4)	/* SHA treats input data as a
+					 * contiguous array of 32 bit
+					 * wide big-endian values. */
+#define SHA_LAST_BLOCK  (SHA_CBLOCK-8)
+#define SHA_DIGEST_LENGTH 20
+
+typedef struct SHAstate_st
+	{
+	SHA_LONG h0,h1,h2,h3,h4;
+	SHA_LONG Nl,Nh;
+	SHA_LONG data[SHA_LBLOCK];
+	unsigned int num;
+	} SHA_CTX;
+
+#ifndef OPENSSL_NO_SHA0
+int SHA_Init(SHA_CTX *c);
+int SHA_Update(SHA_CTX *c, const void *data, size_t len);
+int SHA_Final(unsigned char *md, SHA_CTX *c);
+unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md);
+void SHA_Transform(SHA_CTX *c, const unsigned char *data);
+#endif
+#ifndef OPENSSL_NO_SHA1
+int SHA1_Init(SHA_CTX *c);
+int SHA1_Update(SHA_CTX *c, const void *data, size_t len);
+int SHA1_Final(unsigned char *md, SHA_CTX *c);
+unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);
+void SHA1_Transform(SHA_CTX *c, const unsigned char *data);
+#endif
+
+#define SHA256_CBLOCK	(SHA_LBLOCK*4)	/* SHA-256 treats input data as a
+					 * contiguous array of 32 bit
+					 * wide big-endian values. */
+#define SHA224_DIGEST_LENGTH	28
+#define SHA256_DIGEST_LENGTH	32
+
+typedef struct SHA256state_st
+	{
+	SHA_LONG h[8];
+	SHA_LONG Nl,Nh;
+	SHA_LONG data[SHA_LBLOCK];
+	unsigned int num,md_len;
+	} SHA256_CTX;
+
+#ifndef OPENSSL_NO_SHA256
+int SHA224_Init(SHA256_CTX *c);
+int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);
+int SHA224_Final(unsigned char *md, SHA256_CTX *c);
+unsigned char *SHA224(const unsigned char *d, size_t n,unsigned char *md);
+int SHA256_Init(SHA256_CTX *c);
+int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);
+int SHA256_Final(unsigned char *md, SHA256_CTX *c);
+unsigned char *SHA256(const unsigned char *d, size_t n,unsigned char *md);
+void SHA256_Transform(SHA256_CTX *c, const unsigned char *data);
+#endif
+
+#define SHA384_DIGEST_LENGTH	48
+#define SHA512_DIGEST_LENGTH	64
+
+#ifndef OPENSSL_NO_SHA512
+/*
+ * Unlike 32-bit digest algorithms, SHA-512 *relies* on SHA_LONG64
+ * being exactly 64-bit wide. See Implementation Notes in sha512.c
+ * for further details.
+ */
+#define SHA512_CBLOCK	(SHA_LBLOCK*8)	/* SHA-512 treats input data as a
+					 * contiguous array of 64 bit
+					 * wide big-endian values. */
+#if (defined(_WIN32) || defined(_WIN64)) && !defined(__MINGW32__)
+#define SHA_LONG64 unsigned __int64
+#define U64(C)     C##UI64
+#elif defined(__arch64__)
+#define SHA_LONG64 unsigned long
+#define U64(C)     C##UL
+#else
+#define SHA_LONG64 unsigned long long
+#define U64(C)     C##ULL
+#endif
+
+typedef struct SHA512state_st
+	{
+	SHA_LONG64 h[8];
+	SHA_LONG64 Nl,Nh;
+	union {
+		SHA_LONG64	d[SHA_LBLOCK];
+		unsigned char	p[SHA512_CBLOCK];
+	} u;
+	unsigned int num,md_len;
+	} SHA512_CTX;
+#endif
+
+#ifndef OPENSSL_NO_SHA512
+int SHA384_Init(SHA512_CTX *c);
+int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);
+int SHA384_Final(unsigned char *md, SHA512_CTX *c);
+unsigned char *SHA384(const unsigned char *d, size_t n,unsigned char *md);
+int SHA512_Init(SHA512_CTX *c);
+int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);
+int SHA512_Final(unsigned char *md, SHA512_CTX *c);
+unsigned char *SHA512(const unsigned char *d, size_t n,unsigned char *md);
+void SHA512_Transform(SHA512_CTX *c, const unsigned char *data);
+#endif
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_buf.c b/src/lua/ngx_devel_kit/src/ndk_buf.c
--- a/src/lua/ngx_devel_kit/src/ndk_buf.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_buf.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,43 @@
+
+ngx_int_t
+ndk_copy_chain_to_str (ngx_pool_t *pool, ngx_chain_t *in, ngx_str_t *str)
+{
+    ngx_chain_t     *cl;
+    size_t           len;
+    u_char          *p;
+    ngx_buf_t       *b;
+    
+    len = 0;
+    for (cl = in; cl; cl = cl->next)
+        len += ngx_buf_size (cl->buf);
+    
+    ndk_palloc_re (p, pool, len + 1);
+    
+    str->data = p;
+    str->len = len;
+    
+    for (cl = in; cl; cl = cl->next) {
+        
+        b = cl->buf;
+        
+        if (ngx_buf_in_memory (b)) {
+            p = ngx_cpymem (p, b->pos, b->last - b->pos);
+        }
+    }
+    
+    *p = '\0';
+    
+    return  NGX_OK;
+}
+
+
+char *
+ndk_copy_chain_to_charp (ngx_pool_t *pool, ngx_chain_t *in)
+{
+    ngx_str_t   str;
+    
+    if (ndk_copy_chain_to_str (pool, in, &str) != NGX_OK)
+        return  NULL;
+    
+    return  (char *) str.data;
+}
\ No newline at end of file
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_buf.h b/src/lua/ngx_devel_kit/src/ndk_buf.h
--- a/src/lua/ngx_devel_kit/src/ndk_buf.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_buf.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,5 @@
+
+
+ngx_int_t   ndk_copy_chain_to_str   (ngx_pool_t *pool, ngx_chain_t *in, ngx_str_t *str);
+char *      ndk_copy_chain_to_charp (ngx_pool_t *pool, ngx_chain_t *in);
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk.c b/src/lua/ngx_devel_kit/src/ndk.c
--- a/src/lua/ngx_devel_kit/src/ndk.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,155 @@
+
+/*
+ * 2010 (C) Marcus Clyne
+ */
+
+#include    <ndk.h>
+
+#include    <ndk_config.c>
+
+
+#if (NDK_HTTP_PRE_CONFIG)
+static  ngx_int_t   ndk_http_preconfiguration    (ngx_conf_t *cf);
+#endif
+#if (NDK_HTTP_POST_CONFIG)
+static  ngx_int_t   ndk_http_postconfiguration   (ngx_conf_t *cf);
+#endif
+#if (NDK_HTTP_CREATE_MAIN_CONF)
+static void *       ndk_http_create_main_conf    (ngx_conf_t *cf);
+#endif
+#if (NDK_HTTP_INIT_MAIN_CONF)
+static char *       ndk_http_init_main_conf      (ngx_conf_t *cf, void *conf);
+#endif
+#if (NDK_HTTP_CREATE_SRV_CONF)
+static void *       ndk_http_create_srv_conf     (ngx_conf_t *cf);
+#endif
+#if (NDK_HTTP_MERGE_SRV_CONF)
+static char *       ndk_http_merge_srv_conf      (ngx_conf_t *cf, void *parent, void *child);
+#endif
+#if (NDK_HTTP_CREATE_LOC_CONF)
+static void *       ndk_http_create_loc_conf     (ngx_conf_t *cf);
+#endif
+#if (NDK_HTTP_MERGE_LOC_CONF)
+static char *       ndk_http_merge_loc_conf      (ngx_conf_t *cf, void *parent, void *child);
+#endif
+
+
+#if (NDK_HTTP_INIT_MASTER)
+static ngx_int_t    ndk_http_init_master         (ngx_log_t *log);
+#endif
+#if (NDK_HTTP_INIT_MODULE)
+static ngx_int_t    ndk_http_init_module         (ngx_cycle_t *cycle);
+#endif
+#if (NDK_HTTP_INIT_PROCESS)
+static ngx_int_t    ndk_http_init_process        (ngx_cycle_t *cycle);
+#endif
+#if (NDK_HTTP_EXIT_PROCESS)
+static void         ndk_http_exit_process        (ngx_cycle_t *cycle);
+#endif
+#if (NDK_HTTP_EXIT_MASTER)
+static void         ndk_http_exit_master         (ngx_cycle_t *cycle);
+#endif
+
+
+ngx_http_module_t   ndk_http_module_ctx = {
+
+#if (NDK_HTTP_PRE_CONFIG)
+    ndk_http_preconfiguration,
+#else
+    NULL,
+#endif
+#if (NDK_HTTP_POST_CONFIG)
+    ndk_http_postconfiguration,
+#else
+    NULL,
+#endif
+
+#if (NDK_HTTP_CREATE_MAIN_CONF)
+    ndk_http_create_main_conf,
+#else
+    NULL,
+#endif
+#if (NDK_HTTP_INIT_MAIN_CONF)
+    ndk_http_merge_main_conf,
+#else
+    NULL,
+#endif
+
+#if (NDK_HTTP_CREATE_SVR_CONF)
+    ndk_http_create_srv_conf,
+#else
+    NULL,
+#endif
+#if (NDK_HTTP_MERGE_SVR_CONF)
+    ndk_http_merge_srv_conf,
+#else
+    NULL,
+#endif
+
+#if (NDK_HTTP_CREATE_LOC_CONF)
+    ndk_http_create_loc_conf,
+#else
+    NULL,
+#endif
+#if (NDK_HTTP_MERGE_LOC_CONF)
+    ndk_http_merge_loc_conf,
+#else
+    NULL,
+#endif
+
+};
+
+ngx_module_t          ndk_http_module = {
+
+    NGX_MODULE_V1,
+    &ndk_http_module_ctx,          /* module context */
+    ndk_http_commands,             /* module directives */
+    NGX_HTTP_MODULE,               /* module type */
+
+#if (NDK_HTTP_INIT_MASTER)
+    ndk_http_init_master,
+#else
+    NULL,
+#endif
+
+#if (NDK_HTTP_INIT_MODULE)
+    ndk_http_init_module,
+#else
+    NULL,
+#endif
+#if (NDK_HTTP_INIT_PROCESS)
+    ndk_http_init_process,
+#else
+    NULL,
+#endif
+
+    NULL,                                   /* init thread */
+    NULL,                                   /* exit thread */
+
+#if (NDK_HTTP_EXIT_PROCESS)
+    ndk_http_exit_process,
+#else
+    NULL,
+#endif
+#if (NDK_HTTP_EXIT_MASTER)
+    ndk_http_exit_master,
+#else
+    NULL,
+#endif
+    NGX_MODULE_V1_PADDING
+};
+
+
+
+#if (NDK_HTTP_CREATE_MAIN_CONF)
+static void *
+ndk_http_create_main_conf (ngx_conf_t *cf)
+{
+    ndk_http_main_conf_t    *mcf;
+
+    ndk_pcallocp_rce (mcf, cf->pool);
+
+    return  mcf;
+}
+#endif
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_complex_path.c b/src/lua/ngx_devel_kit/src/ndk_complex_path.c
--- a/src/lua/ngx_devel_kit/src/ndk_complex_path.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_complex_path.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,129 @@
+
+
+ndk_http_complex_path_value_t     ndk_empty_http_complex_path_value = {{0,NULL},0};
+
+
+ngx_int_t
+ndk_http_complex_path_value_compile (ngx_conf_t *cf, ngx_http_complex_value_t *cv, ngx_str_t *value, ngx_uint_t prefix)
+{
+    ngx_http_compile_complex_value_t   ccv;
+
+    ngx_memzero (&ccv, sizeof(ngx_http_compile_complex_value_t));
+
+    ccv.cf = cf;
+    ccv.value = value;
+    ccv.complex_value = cv;
+
+    switch (prefix) {
+
+    case    1 :
+        ccv.root_prefix = 1;
+        break;
+
+    case    2 :
+        ccv.conf_prefix = 1;
+        break;
+    }
+
+    ndk_path_to_dir_safe (value, 1, 0);
+
+    if (!value->len)
+        return  NGX_OK;
+
+    return  ngx_http_compile_complex_value (&ccv);
+}
+
+
+
+ngx_array_t *
+ndk_http_complex_path_create_compile (ngx_conf_t *cf, ngx_str_t *path, ngx_uint_t prefix)
+{
+    ndk_http_complex_path_elt_t     *cpe;
+    ngx_array_t                     *a;
+    ngx_int_t                        n;
+    u_char                          *m, *s, *e;
+    ngx_str_t                        value;
+
+    n = ndk_strcntc (path, ':') + 1;
+
+    a = ngx_array_create (cf->pool, n, sizeof (ndk_http_complex_path_elt_t));
+    if (a == NULL) {
+        return  NULL;
+    }
+
+    s = path->data;
+    e = s + path->len;
+
+
+    while (s < e) {
+
+        m = s;
+
+        while (m < e && *m != ':') m++;
+
+        if (m == s) {
+            s = m+1;
+            continue;
+        }
+
+        cpe = ngx_array_push (a);
+        if (cpe == NULL) {
+            return  NULL;
+        }
+
+        if (*s == '#') {
+            s++;
+            cpe->dynamic = 1;
+        } else {
+            cpe->dynamic = 0;
+        }
+
+        value.data = s;
+        value.len = m - s;
+
+        if (ndk_http_complex_path_value_compile (cf, &cpe->val, &value, prefix) == NGX_ERROR)
+            return  NULL;
+
+        s = m+1;
+    }
+
+    return  a;
+}
+
+
+
+
+char *
+ndk_conf_set_http_complex_path_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t                   *path;
+    ngx_array_t                 *a;
+    ngx_conf_post_t             *post;
+    ndk_http_complex_path_t     *cp;
+
+    cp = (ndk_http_complex_path_t *) (p + cmd->offset);
+
+    if (cp->a != NGX_CONF_UNSET_PTR) {
+        return  "is duplicate";
+    }
+
+    path = cf->args->elts;
+    path++;
+
+    cp->a = ndk_http_complex_path_create_compile (cf, path, cp->prefix);
+    if (cp->a == NULL)
+        /* TODO : log */
+        return  NGX_CONF_ERROR;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, a);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_complex_path.h b/src/lua/ngx_devel_kit/src/ndk_complex_path.h
--- a/src/lua/ngx_devel_kit/src/ndk_complex_path.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_complex_path.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,30 @@
+
+
+typedef struct {
+    ngx_array_t                    *a;
+    ngx_uint_t                      prefix;
+} ndk_http_complex_path_t;
+
+typedef struct {
+    ngx_http_complex_value_t        val;
+    ngx_flag_t                      dynamic;
+} ndk_http_complex_path_elt_t;
+
+typedef struct {
+    ngx_str_t                       val;
+    ngx_flag_t                      dynamic;
+} ndk_http_complex_path_value_t;
+
+typedef struct {
+    ndk_http_complex_path_value_t  *elts;
+    ngx_uint_t                      nelts;
+} ndk_http_complex_path_values_t;
+
+
+extern  ndk_http_complex_path_value_t     ndk_empty_http_complex_path_value;
+
+
+ngx_array_t *   ndk_http_complex_path_create_compile     (ngx_conf_t *cf, ngx_str_t *path, ngx_uint_t prefix);
+ngx_int_t       ndk_http_complex_path_value_compile      (ngx_conf_t *cf, ngx_http_complex_value_t *cv, 
+                                                                    ngx_str_t *value, ngx_uint_t prefix);
+char *          ndk_conf_set_http_complex_path_slot      (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_complex_value.c b/src/lua/ngx_devel_kit/src/ndk_complex_value.c
--- a/src/lua/ngx_devel_kit/src/ndk_complex_value.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_complex_value.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,192 @@
+
+
+
+ngx_int_t
+ndk_http_complex_value_compile (ngx_conf_t *cf, ngx_http_complex_value_t *cv, ngx_str_t *value)
+{
+    ngx_http_compile_complex_value_t   ccv;
+
+    ngx_memzero (&ccv, sizeof(ngx_http_compile_complex_value_t));
+
+    ccv.cf = cf;
+    ccv.value = value;
+    ccv.complex_value = cv;
+
+    return  ngx_http_compile_complex_value (&ccv);
+}
+
+
+
+
+ngx_array_t *
+ndk_http_complex_value_array_create (ngx_conf_t *cf, char **s, ngx_int_t n)
+{
+    ngx_int_t                    i;
+    ngx_http_complex_value_t    *cv;
+    ngx_array_t                 *a;
+    ngx_str_t                    value;
+
+    a = ngx_array_create (cf->pool, n, sizeof (ngx_http_complex_value_t));
+    if (a == NULL)
+        return  NULL;
+
+
+    for (i=0; i<n; i++, s++) {
+
+        cv = ngx_array_push (a);
+
+        value.data = (u_char *) *s;
+        value.len = strlen (*s);
+
+        if (ndk_http_complex_value_compile (cf, cv, &value))
+            return  NULL;
+    }
+
+    return  a;
+}
+
+
+
+ngx_int_t
+ndk_http_complex_value_array_compile (ngx_conf_t *cf, ngx_array_t *a)
+{
+    ngx_int_t                   i;
+    ngx_http_complex_value_t   *cv;
+
+    if (a == NULL || a == NGX_CONF_UNSET_PTR) {
+        return  NGX_ERROR;
+    }
+
+    cv = a->elts;
+
+    for (i=0; i<a->nelts; i++, cv++) {
+
+        if (ndk_http_complex_value_compile (cf, cv, &cv->value))
+            return  NGX_ERROR;
+    }
+
+    return  NGX_OK;
+}
+
+
+
+char *
+ndk_conf_set_http_complex_value_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_http_complex_value_t    *cv;
+    ngx_str_t                   *value;
+    ngx_conf_post_t             *post;
+
+    cv = (ngx_http_complex_value_t *) (p + cmd->offset);
+
+    if (cv->value.data) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (ndk_http_complex_value_compile (cf, cv, value + 1))
+        return  NGX_CONF_ERROR;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, cv);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_http_complex_value_array_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+
+    ngx_str_t                   *value;
+    ngx_http_complex_value_t    *cv;
+    ngx_array_t                **a;
+    ngx_conf_post_t             *post;
+    ngx_int_t                    i, alloc;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NULL || *a == NGX_CONF_UNSET_PTR) {
+
+        alloc = cf->args->nelts > 4 ? cf->args->nelts : 4;
+
+        *a = ngx_array_create (cf->pool, alloc, sizeof (ngx_http_complex_value_t));
+        if (*a == NULL) {
+            return  NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    for (i=1; i<cf->args->nelts; i++) {
+
+        cv = ngx_array_push (*a);
+        if (cv == NULL) {
+            return  NGX_CONF_ERROR;
+        }
+
+        if (ndk_http_complex_value_compile (cf, cv, &value[i]) == NGX_ERROR)
+            return  NGX_CONF_ERROR;
+    }
+
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, a);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+char *
+ndk_conf_set_http_complex_keyval_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+
+    ngx_str_t                   *value;
+    ndk_http_complex_keyval_t   *ckv;
+    ngx_array_t                **a;
+    ngx_conf_post_t             *post;
+    ngx_int_t                    alloc;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NULL || *a == NGX_CONF_UNSET_PTR) {
+
+        alloc = cf->args->nelts > 4 ? cf->args->nelts : 4;
+
+        *a = ngx_array_create (cf->pool, alloc, sizeof (ndk_http_complex_keyval_t));
+        if (*a == NULL) {
+            return  NGX_CONF_ERROR;
+        }
+    }
+
+    ckv = ngx_array_push (*a);
+    if (ckv == NULL) {
+        return  NGX_CONF_ERROR;
+    }
+
+    value = cf->args->elts;
+
+    ckv->key = value[1];
+
+    if (ndk_http_complex_value_compile (cf, &ckv->value, &value[2]) == NGX_ERROR)
+        return  NGX_CONF_ERROR;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, a);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+/* TODO : complex keyval1 */
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_complex_value.h b/src/lua/ngx_devel_kit/src/ndk_complex_value.h
--- a/src/lua/ngx_devel_kit/src/ndk_complex_value.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_complex_value.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,21 @@
+
+
+typedef struct {
+    ngx_str_t                   key;
+    ngx_http_complex_value_t    value;
+} ndk_http_complex_keyval_t;
+
+
+
+/* create/compile functions */
+
+ngx_int_t      ndk_http_complex_value_compile        (ngx_conf_t *cf, ngx_http_complex_value_t *cv, ngx_str_t *value);
+ngx_array_t *  ndk_http_complex_value_array_create   (ngx_conf_t *cf, char **s, ngx_int_t n);
+ngx_int_t      ndk_http_complex_value_array_compile  (ngx_conf_t *cf, ngx_array_t *a);
+
+
+/* conf set slot functions */
+
+char *  ndk_conf_set_http_complex_keyval_slot        (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_http_complex_value_slot         (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_http_complex_value_array_slot   (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_conf_file.c b/src/lua/ngx_devel_kit/src/ndk_conf_file.c
--- a/src/lua/ngx_devel_kit/src/ndk_conf_file.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_conf_file.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,396 @@
+
+
+/* NOTE : you will find other conf_set functions in the following files :
+ *
+ * complex_value.c
+ * encoding.c
+ * path.c
+ *
+ */
+
+
+char *
+ndk_conf_set_true_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_flag_t       *fp;
+    ngx_conf_post_t  *post;
+
+    fp = (ngx_flag_t*) (p + cmd->offset);
+
+    if (*fp != NGX_CONF_UNSET) {
+        return  "is duplicate";
+    }
+
+    *fp = 1;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, fp);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_false_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_flag_t       *fp;
+    ngx_conf_post_t  *post;
+
+    fp = (ngx_flag_t*) (p + cmd->offset);
+
+    if (*fp != NGX_CONF_UNSET) {
+        return  "is duplicate";
+    }
+
+    *fp = 0;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, fp);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+
+char *
+ndk_conf_set_ptr_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    void  **ptr;
+
+    ptr = (void**) (p + cmd->offset);
+
+    if (*ptr != NGX_CONF_UNSET_PTR) {
+        return  "is duplicate";
+    }
+
+    *ptr = cmd->post;
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_null_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    void            **pp;
+    ngx_conf_post_t  *post;
+
+    pp = (void **) (p + cmd->offset);
+
+    if (*pp != NGX_CONF_UNSET_PTR) {
+        return  "is duplicate";
+    }
+
+    *pp = NULL;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, pp);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+char *
+ndk_conf_set_num64_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    int64_t          *np;
+    ngx_str_t        *value;
+    ngx_conf_post_t  *post;
+
+
+    np = (int64_t *) (p + cmd->offset);
+
+    if (*np != NGX_CONF_UNSET) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+    *np = ndk_atoi64 (value[1].data, value[1].len);
+    if (*np == NGX_ERROR) {
+        return "invalid number";
+    }
+
+    if (cmd->post) {
+        post = cmd->post;
+        return post->post_handler(cf, post, np);
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ndk_conf_set_str_array_multi_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t         *value, *s;
+    ngx_array_t      **a;
+    ngx_conf_post_t   *post;
+    ngx_uint_t         i;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NGX_CONF_UNSET_PTR) {
+        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_str_t));
+        if (*a == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    s = NULL;
+
+    for (i=cf->args->nelts-1; i; i--) {
+
+        s = ngx_array_push(*a);
+        if (s == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        value = cf->args->elts;
+
+        *s = value[i];
+    }
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler(cf, post, s);
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_keyval1_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t           *value;
+    ngx_keyval_t        *kv;
+    ngx_conf_post_t     *post;
+
+    kv = (ngx_keyval_t *) (p + cmd->offset);
+
+    if (kv->key.data)
+        return  "is duplicate";
+
+    value = cf->args->elts;
+
+    kv->key = value[1];
+    kv->value = value[2];
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, kv);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_num_flag_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_int_t        *np;
+    ngx_str_t        *value;
+    ngx_conf_post_t  *post;
+
+    np = (ngx_int_t *) (p + cmd->offset);
+
+    if (*np != NGX_CONF_UNSET) {
+        return  "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (ngx_strcasecmp (value[1].data, (u_char *) "on") == 0) {
+        *np = NDK_CONF_SET_TRUE;
+
+    } else if (ngx_strcasecmp (value[1].data, (u_char *) "off") == 0) {
+        *np = NDK_CONF_SET_FALSE;
+
+    } else {
+        *np = ngx_atoi (value[1].data, value[1].len);
+        if (*np == NGX_ERROR) {
+            return  "invalid number and not 'on'/'off'";
+        }
+    }
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, np);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_sec_flag_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    time_t              *tp;
+    ngx_str_t           *value;
+    ngx_conf_post_t     *post;
+
+    tp = (time_t *) (p + cmd->offset);
+
+    if (*tp != NGX_CONF_UNSET) {
+        return  "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (ngx_strcasecmp (value[1].data, (u_char *) "on") == 0) {
+        *tp = NDK_CONF_SET_TRUE;
+
+    } else if (ngx_strcasecmp (value[1].data, (u_char *) "off") == 0) {
+        *tp = NDK_CONF_SET_FALSE;
+
+    } else {
+        *tp = ngx_parse_time (&value[1], 1);
+        if (*tp == NGX_ERROR) {
+            return  "has an invalid time and not 'on'/'off'";
+        }
+    }
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, tp);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+ngx_http_conf_ctx_t *
+ndk_conf_create_http_location (ngx_conf_t *cf)
+{
+    ngx_http_conf_ctx_t          *ctx, *pctx;
+    void                         *mconf;
+    ngx_http_core_loc_conf_t     *clcf, *pclcf;
+    ngx_uint_t                    i;
+    ngx_http_module_t            *module;
+
+    ndk_pcallocp_rce (ctx, cf->pool);
+
+    pctx = cf->ctx;
+    ctx->main_conf = pctx->main_conf;
+    ctx->srv_conf = pctx->srv_conf;
+
+    ndk_pcalloc_rce (ctx->loc_conf, cf->pool, sizeof(void *) * ngx_http_max_module);
+
+
+    for (i = 0; ngx_modules[i]; i++) {
+        if (ngx_modules[i]->type != NGX_HTTP_MODULE) {
+            continue;
+        }
+
+        module = ngx_modules[i]->ctx;
+
+        if (module->create_loc_conf) {
+
+            mconf = module->create_loc_conf(cf);
+            if (mconf == NULL) {
+                 return NGX_CONF_ERROR;
+            }
+
+            ctx->loc_conf[ngx_modules[i]->ctx_index] = mconf;
+        }
+    }
+
+    pclcf = pctx->loc_conf[ngx_http_core_module.ctx_index];
+
+    clcf = ctx->loc_conf[ngx_http_core_module.ctx_index];
+    clcf->loc_conf = ctx->loc_conf;
+    clcf->name = pclcf->name;
+    clcf->noname = 1;
+
+    if (ngx_http_add_location(cf, &pclcf->locations, clcf) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    return  ctx;
+}
+
+
+ngx_http_conf_ctx_t *
+ngx_conf_create_http_named_location (ngx_conf_t *cf, ngx_str_t *name)
+{
+    ngx_http_conf_ctx_t          *ctx;
+    ngx_http_core_loc_conf_t     *clcf;
+
+    ctx = ndk_conf_create_http_location (cf);
+    if (ctx == NGX_CONF_ERROR)
+        return  NGX_CONF_ERROR;
+
+    clcf = ctx->loc_conf[ngx_http_core_module.ctx_index];
+
+    /* in case the developer forgets to add '@' at the beginning of the named location */
+
+    if (name->data[0] != '@' && ndk_catstrf (cf->pool, name, "sS", "@", name) == NULL)
+        return  NGX_CONF_ERROR;
+
+    clcf->name = *name;     /* TODO : copy? */
+    clcf->noname = 0;
+    clcf->named = 1;
+
+    return  ctx;
+}
+
+
+ngx_int_t
+ndk_replace_command (ngx_command_t *new_cmd, ngx_uint_t module_type)
+{
+    ngx_uint_t       i;
+    ngx_command_t   *cmd;
+
+    for (i = 0; ngx_modules[i]; i++) {
+
+        if (ngx_modules[i]->type != module_type)
+            continue;
+
+        cmd = ngx_modules[i]->commands;
+        if (cmd == NULL) {
+            continue;
+        }
+
+        for ( /* void */ ; cmd->name.len; cmd++) {
+
+            if (ndk_cmpstr (&new_cmd->name, &cmd->name) == 0) {
+
+                ndk_memcpyp (cmd, new_cmd);
+                return  NGX_OK;
+            }
+        }
+    }
+
+    return  NGX_DECLINED;
+}
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_conf_file.h b/src/lua/ngx_devel_kit/src/ndk_conf_file.h
--- a/src/lua/ngx_devel_kit/src/ndk_conf_file.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_conf_file.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,44 @@
+
+
+/* conf set functions */
+
+char *  ndk_conf_set_true_slot              (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_false_slot             (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_full_path_slot         (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_ptr_slot               (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_null_slot              (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_str_array_multi_slot   (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_keyval1_slot           (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_num_flag               (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_num64_slot             (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_sec_flag_slot          (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+ngx_http_conf_ctx_t *   ndk_conf_create_http_location           (ngx_conf_t *cf);
+ngx_http_conf_ctx_t *   ngx_conf_create_http_named_location     (ngx_conf_t *cf, ngx_str_t *name);
+
+ngx_int_t               ndk_replace_command     (ngx_command_t *new_cmd, ngx_uint_t module_type);
+
+
+/* values for conf_set_xxx_flag */
+
+#define     NDK_CONF_SET_TRUE       -2
+#define     NDK_CONF_SET_FALSE      -3
+
+
+/* wrappers for utility macros */
+
+#define     ndk_conf_set_bitmask_slot       ngx_conf_set_bitmask_slot
+#define     ndk_conf_set_bufs_slot          ngx_conf_set_bufs_slot
+#define     ndk_conf_set_enum_slot          ngx_conf_set_enum_slot
+#define     ndk_conf_set_flag_slot          ngx_conf_set_flag_slot
+#define     ndk_conf_set_keyval_slot        ngx_conf_set_keyval_slot
+#define     ndk_conf_set_msec_slot          ngx_conf_set_msec_slot
+#define     ndk_conf_set_num_slot           ngx_conf_set_num_slot
+#define     ndk_conf_set_off_slot           ngx_conf_set_off_slot
+#define     ndk_conf_set_sec_slot           ngx_conf_set_sec_slot
+#define     ndk_conf_set_size_slot          ngx_conf_set_size_slot
+#define     ndk_conf_set_str_slot           ngx_conf_set_str_slot
+
+
+
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_debug.c b/src/lua/ngx_devel_kit/src/ndk_debug.c
--- a/src/lua/ngx_devel_kit/src/ndk_debug.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_debug.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,72 @@
+
+#if (NGX_DEBUG)
+
+void
+ndk_debug_helper (const char *func, const char *fmt, ...)
+{
+    size_t   len, flen, tlen;
+    char    *s, *p, *e;
+
+    /* check to see if the format is empty */
+
+    flen = strlen (fmt);
+
+    /* build func name */
+
+    len = strlen (func);
+
+    if (flen == 0)
+        tlen = len + 1;
+    else
+
+    char    func_name [len + flen + 1];
+
+    s = func_name;
+    e = s + len;
+
+    memcpy (s, func, len);
+
+    /* remove initial ngx_ */
+
+    if (strncmp (s, "ngx_", 4) == 0)
+        s += 4;
+
+    /* replace '_' with ' ' */
+
+    for (p=s; p<e; p++) {
+        if (*p == '_')
+            *p = ' ';
+    }
+
+    vfprintf (stderr, const char *format, va_list ap)
+}
+
+
+void
+ndk_debug_request_helper (const char *func, ngx_http_request_t *r)
+{
+    ngx_http_posted_request_t       *pr;
+
+    /* TODO : improve the format */
+
+    fprintf (stderr, "%s %.*s %.*s?%.*s c:%d m:%p r:%p ar:%p pr:%p",
+            func,
+            (int) r->method_name.len, r->method_name.data,
+            (int) r->uri.len, r->uri.data,
+            (int) r->args.len, r->args.data,
+            0/*(int) r->main->count*/, r->main,
+            r, r->connection->data, r->parent);
+
+    if (r->posted_requests) {
+        fprintf(stderr, " posted:");
+
+        for (pr = r->posted_requests; pr; pr = pr->next) {
+            fprintf (stderr, "%p,", pr);
+        }
+    }
+
+    fprintf (stderr, "\n");
+}
+
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_debug.h b/src/lua/ngx_devel_kit/src/ndk_debug.h
--- a/src/lua/ngx_devel_kit/src/ndk_debug.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_debug.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,171 @@
+#ifndef NDK_DEBUG_H
+#define NDK_DEBUG_H
+
+
+/* TODO : use the Nginx printf function */
+
+
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+/* TODO
+- andk_debug variety of debugging formats
+- global include file for all debugging - can pass declaration to cflags for the option
+*/
+
+
+#if (NDK_DEBUG)
+
+    #if (NGX_HAVE_VARIADIC_MACROS)
+
+        #define ndk_debug(...)  ndk_debug_helper (__func__,__VA_ARGS__)
+
+        #define ndk_debug_helper(func,...) \
+            fprintf(stderr, "%-60s", func); \
+            fprintf(stderr, (const char *)__VA_ARGS__); \
+            fprintf(stderr,"\n");
+            /*fprintf(stderr, " at %s line %d.\n", __FILE__, __LINE__)*/
+
+    #else
+
+        /* NOTE : these includes might not be necessary since they're probably included with the core */
+
+        #include <stdarg.h>
+        #include <stdio.h>
+        #include <stdarg.h>
+
+        static void ndk_debug (const char * fmt, ...) {
+        }
+
+    #endif
+
+    #if NDK_DEBUG > 1
+
+        #define ndk_debug_request()  ndk_debug_request_helper(r, __func__)
+
+        static ngx_inline void
+        ndk_debug_request_helper (ngx_http_request_t *r, const char *func)
+        {
+            ngx_http_posted_request_t       *pr;
+
+            /* TODO : improve the format */
+
+            fprintf (stderr, "%s %.*s %.*s?%.*s c:%d m:%p r:%p ar:%p pr:%p",
+                    func,
+                    (int) r->method_name.len, r->method_name.data,
+                    (int) r->uri.len, r->uri.data,
+                    (int) r->args.len, r->args.data,
+                    0/*(int) r->main->count*/, r->main,
+                    r, r->connection->data, r->parent);
+
+            if (r->posted_requests) {
+                fprintf(stderr, " posted:");
+
+                for (pr = r->posted_requests; pr; pr = pr->next) {
+                    fprintf (stderr, "%p,", pr);
+                }
+            }
+
+            fprintf (stderr, "\n");
+        }
+
+
+    #else
+
+        #define ndk_debug_request()
+
+    #endif
+
+
+    static ngx_inline void
+    ndk_debug_print_posted_requests (ngx_http_request_t *r)
+    {
+        ngx_http_posted_request_t   *pr;
+
+        ndk_request_log_debug_http (r, "ndk debug - http posted requests");
+
+        for (pr = r->main->posted_requests; pr; pr = pr->next) {
+
+            if (!pr->request)
+                continue;
+
+            ndk_request_log_debug_http (r, "ndk debug - http posted request:%V", &pr->request->uri);
+        }
+    }
+
+
+    #define ndk_debug_http_conf_location(cf)    ndk_debug_http_conf_location_helper (cf, __func__)
+
+    static ngx_inline void
+    ndk_debug_http_conf_location_helper (ngx_conf_t *cf, const char *func)
+    {
+        ngx_http_core_loc_conf_t        *lcf;
+
+        lcf = ngx_http_conf_get_module_loc_conf (cf, ngx_http_core_module);
+
+        ndk_debug_helper (func, "[%s]", lcf->name.data);
+    }
+
+    /*
+    static void
+    ndk_debug_log_chain (ngx_log_t *log, ngx_chain_t *cl)
+    {
+
+
+    }
+    */
+
+#else
+
+    #if (NGX_HAVE_VARIADIC_MACROS)
+
+        #define     ndk_debug(...)
+        #define     ndk_debug_request()
+
+    #else
+
+        #include <stdarg.h>
+
+        static void ndk_debug (const char * fmt, ...) {
+        }
+
+        static void ndk_debug_request() {
+        }
+
+    #endif
+
+    #define     ndk_debug_http_conf_location(cf)
+
+#endif
+
+#if (NDK_DEBUG)
+
+    #define     ndk_debug_check_read_event_handler(r)                               \
+                                                                                    \
+                    ndk_debug("r->read_event_handler = %s",                         \
+                        r->read_event_handler == ngx_http_block_reading ?           \
+                            "ngx_http_block_reading" :                              \
+                        r->read_event_handler == ngx_http_test_reading ?            \
+                            "ngx_http_test_reading" :                               \
+                        r->read_event_handler == ngx_http_request_empty_handler ?   \
+                            "ngx_http_request_empty_handler" : "UNKNOWN")
+
+    #define     ndk_debug_check_write_event_handler(r)                              \
+                                                                                    \
+                    ndk_debug ("r->write_event_handler = %s",                       \
+                        r->write_event_handler == ngx_http_handler ?                \
+                            "ngx_http_handler" :                                    \
+                        r->write_event_handler == ngx_http_core_run_phases ?        \
+                            "ngx_http_core_run_phases" :                            \
+                        r->write_event_handler == ngx_http_request_empty_handler ?  \
+                            "ngx_http_request_empty_handler" : "UNKNOWN")
+
+#else
+
+    #define     ndk_debug_check_read_event_handler(r)
+    #define     ndk_debug_check_write_event_handler(r)
+
+#endif
+
+#endif /* NDK_DEBUG_H */
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_encoding.c b/src/lua/ngx_devel_kit/src/ndk_encoding.c
--- a/src/lua/ngx_devel_kit/src/ndk_encoding.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_encoding.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,57 @@
+
+
+
+char *
+ndk_conf_set_encoding_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char    *p = conf;
+
+    ndk_encoding_t  *ep;
+    ngx_str_t       *value;
+    size_t           len;
+    iconv_t          ic;
+
+    ep = (ndk_encoding_t *) (p + cmd->offset);
+    if (ep->from && ep->to)
+        return  "is duplicate";
+
+    value = cf->args->elts;
+
+
+    if (ep->from) {
+
+        ep->to = (char *) value[1].data;
+        len = strlen (ep->from);
+
+    } else if (ep->to) {
+
+        ep->from = (char *) value[1].data;
+        len = strlen (ep->to);
+
+    } else {
+        return  "has no base encoding";
+    }
+
+
+    if (len == value[1].len && !strncasecmp (ep->to, ep->from, len)) {
+
+        ngx_log_error (NGX_LOG_WARN, cf->log, 0, 
+            "\"%V\" '%V' encoding is ignored (no conversion)", &value[0], &value[1]);
+
+        return  NGX_CONF_OK;
+    }
+
+
+    ic = iconv_open (ep->to, ep->from);
+    if (ic == (iconv_t)-1)
+        return  "has an invalid encoding";
+
+
+    if (iconv_close (ic)) {
+        ngx_log_error (NGX_LOG_EMERG, cf->log, errno, "iconv_close()");
+        return  NGX_CONF_ERROR;
+    }
+
+    return  NGX_CONF_OK;
+}
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_encoding.h b/src/lua/ngx_devel_kit/src/ndk_encoding.h
--- a/src/lua/ngx_devel_kit/src/ndk_encoding.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_encoding.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,12 @@
+
+
+#include    <iconv.h>
+
+typedef struct {
+    char        *from;
+    char        *to;
+} ndk_encoding_t;
+
+
+char *  ndk_conf_set_encoding_slot  (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk.h b/src/lua/ngx_devel_kit/src/ndk.h
--- a/src/lua/ngx_devel_kit/src/ndk.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,58 @@
+ 
+/*
+ * 2010 (C) Marcus Clyne
+*/
+
+
+#ifndef NDK_H
+#define NDK_H
+
+
+#include    <ngx_config.h>
+#include    <ngx_core.h>
+#include    <ngx_http.h>
+
+
+#define     ndk_version     2015
+#define     NDK_VERSION     "0.2.15"
+
+
+#if (NGX_DEBUG)
+#ifndef     NDK_DEBUG
+#define     NDK_DEBUG 1
+#endif
+#else
+#ifndef     NDK_DEBUG
+#define     NDK_DEBUG 0
+#endif
+#endif
+
+
+#if !(NDK)
+#error At least one module requires the Nginx Development Kit to be compiled with \
+the source (add --with-module=/path/to/devel/kit/src to configure command)
+#endif
+
+#include    <ndk_config.h>
+
+
+#if (NDK_HTTP_CREATE_MAIN_CONF)
+
+#define     ndk_http_conf_get_main_conf(cf)   ngx_http_conf_get_module_main_conf (cf, ndk_http_module)
+#define     ndk_http_get_main_conf(r)         ngx_http_get_module_main_conf (r, ndk_http_module)
+
+typedef struct {
+#if (NDK_UPSTREAM_LIST)
+    ngx_array_t         *upstreams;
+#endif
+} ndk_http_main_conf_t;
+
+#endif /* NDK_HTTP_CREATE_MAIN_CONF */
+
+#include    <ndk_includes.h>
+
+
+extern  ngx_module_t    ndk_http_module;
+
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_hash.c b/src/lua/ngx_devel_kit/src/ndk_hash.c
--- a/src/lua/ngx_devel_kit/src/ndk_hash.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_hash.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,82 @@
+
+#include <ndk_hash.h>
+
+
+
+/* openssl hashes */
+
+#define     NDK_OPENSSL_HASH(type,ctxt_type,upper)                  \
+    u_char              md [ctxt_type ## _DIGEST_LENGTH];           \
+    ctxt_type ##_CTX    c;                                          \
+                                                                    \
+    type ## _Init (&c);                                             \
+    type ## _Update (&c, data, len);                                \
+    type ## _Final (md, &c);                                        \
+                                                                    \
+    ndk_hex_dump (p, (u_char *) md, ctxt_type ## _DIGEST_LENGTH);   \
+    if (upper) {                                                    \
+        ndk_strtoupper (p, (ctxt_type ## _DIGEST_LENGTH) *2);       \
+    }
+
+
+#ifdef NDK_MD5
+
+void
+ndk_md5_hash (u_char *p, char *data, size_t len)
+{
+    NDK_OPENSSL_HASH (MD5, MD5, 0);
+}
+
+void
+ndk_md5_hash_upper (u_char *p, char *data, size_t len)
+{
+    NDK_OPENSSL_HASH (MD5, MD5, 1);
+}
+
+#endif
+#ifdef NDK_SHA1
+
+void
+ndk_sha1_hash (u_char *p, char *data, size_t len)
+{
+    NDK_OPENSSL_HASH (SHA1, SHA, 0);
+}
+
+void
+ndk_sha1_hash_upper (u_char *p, char *data, size_t len)
+{
+    NDK_OPENSSL_HASH (SHA1, SHA, 1);
+}
+
+#endif
+
+
+
+/* non-openssl hashes */
+
+#ifdef NDK_MURMUR2
+
+#include    "hash/murmurhash2.c"
+
+void
+ndk_murmur2_hash (u_char *p, char *data, size_t len)
+{
+    uint32_t    hash;
+
+    hash = MurmurHash2 (data, len, 47);
+
+    ndk_hex_dump (p, (u_char*) &hash, 4);
+}
+
+void
+ndk_murmur2_hash_upper (u_char *p, char *data, size_t len)
+{
+    uint32_t    hash;
+
+    hash = MurmurHash2 (data, len, 47);
+
+    ndk_hex_dump (p, (u_char*) &hash, 4);
+    ndk_strtoupper (p, 8);
+}
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_hash.h b/src/lua/ngx_devel_kit/src/ndk_hash.h
--- a/src/lua/ngx_devel_kit/src/ndk_hash.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_hash.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,45 @@
+
+#ifndef NDK_HASH_H
+#define NDK_HASH_H
+
+#ifdef NDK_HASH_ALL
+
+#ifndef NDK_MD5
+#define NDK_MD5
+#endif
+
+#ifndef NDK_MURMUR2
+#define NDK_MURMUR2
+#endif
+
+#ifndef NDK_SHA1
+#define NDK_SHA1
+#endif
+
+#endif
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+typedef void (*ndk_hash_pt) (u_char *p, char *data, size_t len);
+
+
+#ifdef NDK_MD5
+#include <ngx_md5.h>
+void    ndk_md5_hash            (u_char *p, char *data, size_t len);
+void    ndk_md5_hash_upper      (u_char *p, char *data, size_t len);
+#endif
+
+#ifdef NDK_MURMUR2
+#define MURMURHASH2_DIGEST_LENGTH   4
+void    ndk_murmur2_hash        (u_char *p, char *data, size_t len);
+void    ndk_murmur2_hash_upper  (u_char *p, char *data, size_t len);
+#endif
+
+#ifdef NDK_SHA1
+#include <ngx_sha1.h>
+void    ndk_sha1_hash           (u_char *p, char *data, size_t len);
+void    ndk_sha1_hash_upper     (u_char *p, char *data, size_t len);
+#endif
+
+#endif /* NDK_HASH_H */
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_http.c b/src/lua/ngx_devel_kit/src/ndk_http.c
--- a/src/lua/ngx_devel_kit/src/ndk_http.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_http.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,138 @@
+
+ngx_uint_t
+ndk_http_count_phase_handlers (ngx_http_core_main_conf_t *cmcf)
+{
+    ngx_http_phase_handler_t    *ph;
+    ngx_uint_t                   i;
+    
+    ph = cmcf->phase_engine.handlers;
+    
+    for (i=0; ph[i].checker; i++) /* void */;
+        
+    return  i;        
+}
+
+
+ngx_uint_t
+ndk_http_parse_request_method (ngx_str_t *m)
+{
+    switch (m->len) {
+
+        case 3:
+            
+#if (NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)
+        {
+            u_char    t[4];
+            
+            ngx_memcpy (t, m->data, 3);
+            t[3] = ' ';
+            
+            if (ndk_str3_cmp (t, 'G', 'E', 'T', ' ')) {
+                return  NGX_HTTP_GET;
+            }
+
+            if (ndk_str3_cmp (t, 'P', 'U', 'T', ' ')) {
+                return  NGX_HTTP_PUT;
+            }
+        }
+            
+#else
+
+            if (ndk_str3_cmp (m->data, 'G', 'E', 'T', ' ')) {
+                return  NGX_HTTP_GET;
+            }
+
+            if (ndk_str3_cmp (m->data, 'P', 'U', 'T', ' ')) {
+                return  NGX_HTTP_PUT;
+            }
+
+#endif
+            break;
+
+        case 4:
+            
+            if  (m->data[1] == 'O') {
+
+                if (ndk_str3Ocmp (m->data, 'P', 'O', 'S', 'T')) {
+                    return  NGX_HTTP_POST;
+                }
+
+                if (ndk_str3Ocmp (m->data, 'C', 'O', 'P', 'Y')) {
+                    return  NGX_HTTP_COPY;
+                }
+
+                if (ndk_str3Ocmp (m->data, 'M', 'O', 'V', 'E')) {
+                    return  NGX_HTTP_MOVE;
+                }
+
+                if (ndk_str3Ocmp (m->data, 'L', 'O', 'C', 'K')) {
+                    return  NGX_HTTP_LOCK;
+                }
+
+            } else {
+
+                if (ndk_str4cmp (m->data, 'H', 'E', 'A', 'D')) {
+                    return  NGX_HTTP_HEAD;
+                }
+            }
+
+            break;
+
+        case 5:
+            
+            if (ndk_str5cmp (m->data, 'M', 'K', 'C', 'O', 'L')) {
+                return  NGX_HTTP_MKCOL;
+            }
+
+            if (ndk_str5cmp (m->data, 'P', 'A', 'T', 'C', 'H')) {
+                return  NGX_HTTP_PATCH;
+            }
+
+            if (ndk_str5cmp (m->data, 'T', 'R', 'A', 'C', 'E')) {
+                return  NGX_HTTP_TRACE;
+            }
+
+            break;
+
+        case 6:
+            
+            if (ndk_str6cmp (m->data, 'D', 'E', 'L', 'E', 'T', 'E')) {
+                return  NGX_HTTP_DELETE;
+            }
+
+            if (ndk_str6cmp (m->data, 'U', 'N', 'L', 'O', 'C', 'K')) {
+                return  NGX_HTTP_UNLOCK;
+            }
+
+            break;
+
+        case 7:
+            
+            if (ndk_str7_cmp (m->data, 'O', 'P', 'T', 'I', 'O', 'N', 'S', ' '))
+            {
+                return  NGX_HTTP_OPTIONS;
+            }
+
+            break;
+
+        case 8:
+            
+            if (ndk_str8cmp (m->data, 'P', 'R', 'O', 'P', 'F', 'I', 'N', 'D'))
+            {
+                return  NGX_HTTP_PROPFIND;
+            }
+
+            break;
+
+        case 9:
+            
+            if (ndk_str9cmp (m->data, 'P', 'R', 'O', 'P', 'P', 'A', 'T', 'C', 'H'))
+            {
+                return  NGX_HTTP_PROPPATCH;
+            }
+
+            break;
+    }
+
+    return  0;
+}
\ No newline at end of file
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_http.h b/src/lua/ngx_devel_kit/src/ndk_http.h
--- a/src/lua/ngx_devel_kit/src/ndk_http.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_http.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,3 @@
+
+ngx_uint_t  ndk_http_count_phase_handlers       (ngx_http_core_main_conf_t *cmcf);
+ngx_uint_t  ndk_http_parse_request_method       (ngx_str_t *m);
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_http_headers.h b/src/lua/ngx_devel_kit/src/ndk_http_headers.h
--- a/src/lua/ngx_devel_kit/src/ndk_http_headers.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_http_headers.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,35 @@
+
+
+/* TODO : organize and add */
+/* TODO : check - should it be r->main? */
+
+#define     ndk_http_uri(r)                         (r)->uri
+#define     ndk_http_request_uri(r)                 (r)->unparsed_uri
+
+#define     ndk_http_header_in(r,name)              ((r)->headers_in.name ? &(r)->headers_in.name->value : NULL)
+#define     ndk_http_header_out(r,name)             ((r)->headers_out.name ? &(r)->headers_out.name->value : NULL)
+
+#define     ndk_http_host_header(r)                 ndk_http_header_in (r, host)
+#define     ndk_http_connection_header(r)           ndk_http_header_in (r, connection)
+#define     ndk_http_if_modified_since_header(r)    ndk_http_header_in (r, if_modified_since)
+#define     ndk_http_user_agent_header(r)           ndk_http_header_in (r, user_agent)
+#define     ndk_http_referer_header(r)              ndk_http_header_in (r, referer)
+#define     ndk_http_content_length_header(r)       ndk_http_header_in (r, content_length)
+#define     ndk_http_content_type_header(r)         ndk_http_header_in (r, content_type)
+#define     ndk_http_range_header(r)                ndk_http_header_in (r, range)
+#define     ndk_http_if_range_header(r)             ndk_http_header_in (r, if_range)
+#define     ndk_http_transfer_encoding_header(r)    ndk_http_header_in (r, transfer_encoding)
+#define     ndk_http_expect_header(r)               ndk_http_header_in (r, expect)
+#define     ndk_http_accept_encoding_header(r)      ndk_http_header_in (r, accept_encoding)
+#define     ndk_http_via_header(r)                  ndk_http_header_in (r, via)
+#define     ndk_http_authorization_header(r)        ndk_http_header_in (r, authorization)
+#define     ndk_http_keep_alive_header(r)           ndk_http_header_in (r, keep_alive)
+#define     ndk_http_x_forwarded_for_header(r)      ndk_http_header_in (r, x_forwarded_for)
+#define     ndk_http_x_real_ip_header(r)            ndk_http_header_in (r, x_real_ip)
+#define     ndk_http_accept_header(r)               ndk_http_header_in (r, accept)
+#define     ndk_http_accept_language_header(r)      ndk_http_header_in (r, accept_language)
+#define     ndk_http_depth_header(r)                ndk_http_header_in (r, depth)
+#define     ndk_http_destination_header(r)          ndk_http_header_in (r, destination)
+#define     ndk_http_overwrite_header(r)            ndk_http_header_in (r, overwrite)
+#define     ndk_http_date_header(r)                 ndk_http_header_in (r, date)
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_log.c b/src/lua/ngx_devel_kit/src/ndk_log.c
--- a/src/lua/ngx_devel_kit/src/ndk_log.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_log.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,3 @@
+
+
+/* TODO : the required functions if the compiler does not have variadic macros */
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_log.h b/src/lua/ngx_devel_kit/src/ndk_log.h
--- a/src/lua/ngx_devel_kit/src/ndk_log.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_log.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,165 @@
+
+/* TODO : fix the conf_log macros */
+
+#define NGX_LOG_DEBUG_SCRIPT        NGX_LOG_DEBUG_HTTP      /* TODO : add new section to log/conf directives */
+
+#define ndk_conf_to_log(cf)         ((cf)->log)
+
+#ifndef ndk_request_to_log
+#define ndk_request_to_log(r)       ((r)->connection->log)
+#endif
+
+
+/*********************************/
+
+#if (NGX_HAVE_C99_VARIADIC_MACROS)
+
+#define ndk_log_stderr(log,...)                     ngx_log_error (NGX_LOG_STDERR, log, 0, __VA_ARGS__)
+#define ndk_log_emerg(log,...)                      ngx_log_error (NGX_LOG_EMERG, log, 0, __VA_ARGS__)
+#define ndk_log_alert(log,...)                      ngx_log_error (NGX_LOG_ALERT, log, 0, __VA_ARGS__)
+#define ndk_log_crit(log,...)                       ngx_log_error (NGX_LOG_CRIT, log, 0, __VA_ARGS__)
+#define ndk_log_err(log,...)                        ngx_log_error (NGX_LOG_ERR, log, 0, __VA_ARGS__)
+#define ndk_log_warning(log,...)                    ngx_log_error (NGX_LOG_WARN, log, 0, __VA_ARGS__)
+#define ndk_log_notice(log,...)                     ngx_log_error (NGX_LOG_NOTICE, log, 0, __VA_ARGS__)
+#define ndk_log_info(log,...)                       ngx_log_error (NGX_LOG_INFO, log, 0, __VA_ARGS__)
+
+#define ndk_conf_log_stderr(cf,...)                 ngx_conf_log_error (NGX_LOG_STDERR, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_emerg(cf,...)                  ngx_conf_log_error (NGX_LOG_EMERG, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_alert(cf,...)                  ngx_conf_log_error (NGX_LOG_ALERT, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_crit(cf,...)                   ngx_conf_log_error (NGX_LOG_CRIT, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_err(cf,...)                    ngx_conf_log_error (NGX_LOG_ERR, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_warning(cf,...)                ngx_conf_log_error (NGX_LOG_WARN, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_notice(cf,...)                 ngx_conf_log_error (NGX_LOG_NOTICE, cf, 0, __VA_ARGS__)
+#define ndk_conf_log_info(cf,...)                   ngx_conf_log_error (NGX_LOG_INFO, cf, 0, __VA_ARGS__)
+
+#define ndk_request_log_stderr(r,...)               ndk_log_stderr (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_emerg(r,...)                ndk_log_emerg (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_alert(r,...)                ndk_log_alert (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_crit(r,...)                 ndk_log_crit (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_err(r,...)                  ndk_log_err (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_warning(r,...)              ndk_log_warning (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_notice(r,...)               ndk_log_notice (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_info(r,...)                 ndk_log_info (ndk_request_to_log(r), __VA_ARGS__)
+
+
+#if (NGX_DEBUG)
+
+#define ndk_log_debug_core(log,...)                 ngx_log_debug (NGX_LOG_DEBUG_CORE, log, 0, __VA_ARGS__)
+#define ndk_log_debug_alloc(log,...)                ngx_log_debug (NGX_LOG_DEBUG_ALLOC, log, 0, __VA_ARGS__)
+#define ndk_log_debug_mutex(log,...)                ngx_log_debug (NGX_LOG_DEBUG_MUTEX, log, 0, __VA_ARGS__)
+#define ndk_log_debug_event(log,...)                ngx_log_debug (NGX_LOG_DEBUG_EVENT, log, 0, __VA_ARGS__)
+#define ndk_log_debug_http(log,...)                 ngx_log_debug (NGX_LOG_DEBUG_HTTP, log, 0, __VA_ARGS__)
+#define ndk_log_debug_mail(log,...)                 ngx_log_debug (NGX_LOG_DEBUG_MAIL, log, 0, __VA_ARGS__)
+#define ndk_log_debug_mysql(log,...)                ngx_log_debug (NGX_LOG_DEBUG_MYSQL, log, 0, __VA_ARGS__)
+
+#define ndk_conf_log_debug_core(r,...)              ndk_log_debug_core (ndk_conf_to_log(r), __VA_ARGS__)
+#define ndk_conf_log_debug_alloc(r,...)             ndk_log_debug_alloc (ndk_conf_to_log(r), __VA_ARGS__)
+#define ndk_conf_log_debug_mutex(r,...)             ndk_log_debug_mutex (ndk_conf_to_log(r), __VA_ARGS__)
+#define ndk_conf_log_debug_event(r,...)             ndk_log_debug_event (ndk_conf_to_log(r), __VA_ARGS__)
+#define ndk_conf_log_debug_http(r,...)              ndk_log_debug_http (ndk_conf_to_log(r), __VA_ARGS__)
+#define ndk_conf_log_debug_mail(r,...)              ndk_log_debug_mail (ndk_conf_to_log(r), __VA_ARGS__)
+#define ndk_conf_log_debug_mysql(r,...)             ndk_log_debug_mysql (ndk_conf_to_log(r), __VA_ARGS__)
+
+#define ndk_request_log_debug_core(r,...)           ndk_log_debug_core (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_debug_alloc(r,...)          ndk_log_debug_alloc (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_debug_mutex(r,...)          ndk_log_debug_mutex (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_debug_event(r,...)          ndk_log_debug_event (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_debug_http(r,...)           ndk_log_debug_http (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_debug_mail(r,...)           ndk_log_debug_mail (ndk_request_to_log(r), __VA_ARGS__)
+#define ndk_request_log_debug_mysql(r,...)          ndk_log_debug_mysql (ndk_request_to_log(r), __VA_ARGS__)
+
+#else 
+
+#define ndk_log_debug_core(log,...)
+#define ndk_log_debug_alloc(log,...)
+#define ndk_log_debug_mutex(log,...)
+#define ndk_log_debug_event(log,...)
+#define ndk_log_debug_http(log,...)
+#define ndk_log_debug_mail(log,...)
+#define ndk_log_debug_mysql(log,...)
+
+#define ndk_conf_log_debug_core(r,...)
+#define ndk_conf_log_debug_alloc(r,...)
+#define ndk_conf_log_debug_mutex(r,...)
+#define ndk_conf_log_debug_event(r,...)
+#define ndk_conf_log_debug_http(r,...)
+#define ndk_conf_log_debug_mail(r,...)
+#define ndk_conf_log_debug_mysql(r,...)
+
+#define ndk_request_log_debug_core(r,...)
+#define ndk_request_log_debug_alloc(r,...)
+#define ndk_request_log_debug_mutex(r,...)
+#define ndk_request_log_debug_event(r,...)
+#define ndk_request_log_debug_http(r,...)
+#define ndk_request_log_debug_mail(r,...)
+#define ndk_request_log_debug_mysql(r,...)
+
+#endif
+
+
+/*********************************/
+
+#elif (NGX_HAVE_GCC_VARIADIC_MACROS)
+
+#define ndk_log_stderr(log,args...)                 ngx_log_error (NGX_LOG_STDERR, log, 0, args)
+#define ndk_log_emerg(log,args...)                  ngx_log_error (NGX_LOG_EMERG, log, 0, args)
+#define ndk_log_alert(log,args...)                  ngx_log_error (NGX_LOG_ALERT, log, 0, args)
+#define ndk_log_crit(log,args...)                   ngx_log_error (NGX_LOG_CRIT, log, 0, args)
+#define ndk_log_err(log,args...)                    ngx_log_error (NGX_LOG_ERR, log, 0, args)
+#define ndk_log_warning(log,args...)                ngx_log_error (NGX_LOG_WARN, log, 0, args)
+#define ndk_log_notice(log,args...)                 ngx_log_error (NGX_LOG_NOTICE, log, 0, args)
+#define ndk_log_info(log,args...)                   ngx_log_error (NGX_LOG_INFO, log, 0, args)
+
+#define ndk_log_debug_core(log,args...)             ngx_log_debug (NGX_LOG_DEBUG_CORE, log, 0, args)
+#define ndk_log_debug_alloc(log,args...)            ngx_log_debug (NGX_LOG_DEBUG_ALLOC, log, 0, args)
+#define ndk_log_debug_mutex(log,args...)            ngx_log_debug (NGX_LOG_DEBUG_MUTEX, log, 0, args)
+#define ndk_log_debug_event(log,args...)            ngx_log_debug (NGX_LOG_DEBUG_EVENT, log, 0, args)
+#define ndk_log_debug_http(log,args...)             ngx_log_debug (NGX_LOG_DEBUG_HTTP, log, 0, args)
+#define ndk_log_debug_mail(log,args...)             ngx_log_debug (NGX_LOG_DEBUG_MAIL, log, 0, args)
+#define ndk_log_debug_mysql(log,args...)            ngx_log_debug (NGX_LOG_DEBUG_MYSQL, log, 0, args)
+#define ndk_log_debug_script(log,args...)           ngx_log_debug (NGX_LOG_DEBUG_SCRIPT, log, 0, args)
+
+#define ndk_conf_log_stderr(cf,args...)             ngx_conf_log_error (NGX_LOG_STDERR, cf, 0, args)
+#define ndk_conf_log_emerg(cf,args...)              ngx_conf_log_error (NGX_LOG_EMERG, cf, 0, args)
+#define ndk_conf_log_alert(cf,args...)              ngx_conf_log_error (NGX_LOG_ALERT, cf, 0, args)
+#define ndk_conf_log_crit(cf,args...)               ngx_conf_log_error (NGX_LOG_CRIT, cf, 0, args)
+#define ndk_conf_log_err(cf,args...)                ngx_conf_log_error (NGX_LOG_ERR, cf, 0, args)
+#define ndk_conf_log_warning(cf,args...)            ngx_conf_log_error (NGX_LOG_WARN, cf, 0, args)
+#define ndk_conf_log_notice(cf,args...)             ngx_conf_log_error (NGX_LOG_NOTICE, cf, 0, args)
+#define ndk_conf_log_info(cf,args...)               ngx_conf_log_error (NGX_LOG_INFO, cf, 0, args)
+
+#define ndk_conf_log_debug_core(r,args...)          ndk_log_debug_core (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_alloc(r,args...)         ndk_log_debug_alloc (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_mutex(r,args...)         ndk_log_debug_mutex (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_event(r,args...)         ndk_log_debug_event (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_http(r,args...)          ndk_log_debug_http (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_mail(r,args...)          ndk_log_debug_mail (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_mysql(r,args...)         ndk_log_debug_mysql (ndk_conf_to_log(r), args)
+#define ndk_conf_log_debug_script(r,args...)        ndk_log_debug_script (ndk_conf_to_log(r), args)
+
+#define ndk_request_log_stderr(r,args...)           ndk_log_stderr (ndk_request_to_log(r), args)
+#define ndk_request_log_emerg(r,args...)            ndk_log_emerg (ndk_request_to_log(r), args)
+#define ndk_request_log_alert(r,args...)            ndk_log_alert (ndk_request_to_log(r), args)
+#define ndk_request_log_crit(r,args...)             ndk_log_crit (ndk_request_to_log(r), args)
+#define ndk_request_log_err(r,args...)              ndk_log_err (ndk_request_to_log(r), args)
+#define ndk_request_log_warning(r,args...)          ndk_log_warning (ndk_request_to_log(r), args)
+#define ndk_request_log_notice(r,args...)           ndk_log_notice (ndk_request_to_log(r), args)
+#define ndk_request_log_info(r,args...)             ndk_log_info (ndk_request_to_log(r), args)
+
+#define ndk_request_log_debug_core(r,args...)       ndk_log_debug_core (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_alloc(r,args...)      ndk_log_debug_alloc (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_mutex(r,args...)      ndk_log_debug_mutex (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_event(r,args...)      ndk_log_debug_event (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_http(r,args...)       ndk_log_debug_http (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_mail(r,args...)       ndk_log_debug_mail (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_mysql(r,args...)      ndk_log_debug_mysql (ndk_request_to_log(r), args)
+#define ndk_request_log_debug_script(r,args...)     ndk_log_debug_script (ndk_request_to_log(r), args)
+
+/*********************************/
+
+#else /* NO VARIADIC MACROS */
+
+/* #warning does not work on Windows */
+#pragma message("Nginx Devel Kit logging without variadic macros not yet implemented")
+
+#endif /* VARIADIC MACROS */
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_parse.h b/src/lua/ngx_devel_kit/src/ndk_parse.h
--- a/src/lua/ngx_devel_kit/src/ndk_parse.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_parse.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,67 @@
+
+
+
+#if (NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)
+
+#define ndk_str3_cmp(m, c0, c1, c2, c3)                                       \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)
+
+#define ndk_str3Ocmp(m, c0, c1, c2, c3)                                       \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)
+
+#define ndk_str4cmp(m, c0, c1, c2, c3)                                        \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)
+
+#define ndk_str5cmp(m, c0, c1, c2, c3, c4)                                    \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)             \
+        && m[4] == c4
+
+#define ndk_str6cmp(m, c0, c1, c2, c3, c4, c5)                                \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)             \
+        && (((uint32_t *) m)[1] & 0xffff) == ((c5 << 8) | c4)
+
+#define ndk_str7_cmp(m, c0, c1, c2, c3, c4, c5, c6, c7)                       \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)             \
+        && ((uint32_t *) m)[1] == ((c7 << 24) | (c6 << 16) | (c5 << 8) | c4)
+
+#define ndk_str8cmp(m, c0, c1, c2, c3, c4, c5, c6, c7)                        \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)             \
+        && ((uint32_t *) m)[1] == ((c7 << 24) | (c6 << 16) | (c5 << 8) | c4)
+
+#define ndk_str9cmp(m, c0, c1, c2, c3, c4, c5, c6, c7, c8)                    \
+    *(uint32_t *) m == ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0)             \
+        && ((uint32_t *) m)[1] == ((c7 << 24) | (c6 << 16) | (c5 << 8) | c4)  \
+        && m[8] == c8
+
+#else /* !(NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED) */
+
+#define ndk_str3_cmp(m, c0, c1, c2, c3)                                       \
+    m[0] == c0 && m[1] == c1 && m[2] == c2
+
+#define ndk_str3Ocmp(m, c0, c1, c2, c3)                                       \
+    m[0] == c0 && m[2] == c2 && m[3] == c3
+
+#define ndk_str4cmp(m, c0, c1, c2, c3)                                        \
+    m[0] == c0 && m[1] == c1 && m[2] == c2 && m[3] == c3
+
+#define ndk_str5cmp(m, c0, c1, c2, c3, c4)                                    \
+    m[0] == c0 && m[1] == c1 && m[2] == c2 && m[3] == c3 && m[4] == c4
+
+#define ndk_str6cmp(m, c0, c1, c2, c3, c4, c5)                                \
+    m[0] == c0 && m[1] == c1 && m[2] == c2 && m[3] == c3                      \
+        && m[4] == c4 && m[5] == c5
+
+#define ndk_str7_cmp(m, c0, c1, c2, c3, c4, c5, c6, c7)                       \
+    m[0] == c0 && m[1] == c1 && m[2] == c2 && m[3] == c3                      \
+        && m[4] == c4 && m[5] == c5 && m[6] == c6
+
+#define ndk_str8cmp(m, c0, c1, c2, c3, c4, c5, c6, c7)                        \
+    m[0] == c0 && m[1] == c1 && m[2] == c2 && m[3] == c3                      \
+        && m[4] == c4 && m[5] == c5 && m[6] == c6 && m[7] == c7
+
+#define ndk_str9cmp(m, c0, c1, c2, c3, c4, c5, c6, c7, c8)                    \
+    m[0] == c0 && m[1] == c1 && m[2] == c2 && m[3] == c3                      \
+        && m[4] == c4 && m[5] == c5 && m[6] == c6 && m[7] == c7 && m[8] == c8
+
+#endif
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_path.c b/src/lua/ngx_devel_kit/src/ndk_path.c
--- a/src/lua/ngx_devel_kit/src/ndk_path.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_path.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,583 @@
+
+
+
+/* This function cleans a path to its most basic form, performing the following transformations :
+ *
+ *  - ./ -> [empty]
+ *  - // -> /
+ *  - /base/parent/../ -> /base/
+ *
+ * If possible, it leaves the original string in place and does not copy characters, otherwise
+ * characters are copied.
+*/
+
+void
+ndk_clean_path (ngx_str_t *path, ngx_uint_t complex, size_t off)
+{
+    u_char         *s, *p, *m, *e, c, *l;
+    ngx_uint_t      root;
+
+    if (path->len == 1) {
+
+        if (path->data[0] == '.') {
+            path->len = 0;
+        }
+
+        return;
+    }
+
+    /* strip initial './' */
+
+    s = path->data;
+    e = s + path->len;
+
+    if (off) {
+        p = s + off;
+        goto check_basic;
+    }
+
+    if (*s == '/')
+        root = 1;
+    else
+        root = 0;
+
+    while (s < e) {
+
+        switch (*s) {
+
+        case    '/' :
+
+            /* '//' => '/' */
+
+            s++;
+            continue;
+
+        case    '.' :
+
+            if (s == e-1) {
+
+                if (root) {
+                    path->data[0] = '/';
+                    path->len = 1;
+                } else {
+                    path->len = 0;
+                }
+
+                return;
+            }
+
+            /* './' => '' */
+
+            if (s[1] == '/') {
+
+                s += 2;
+
+                if (s == e) {
+
+                    path->len = 0;
+                    return;
+                }
+
+                continue;
+            }
+        }
+
+        break;
+    }
+
+    if (root && *s != '/') {
+        s--;
+    }
+
+    p = s;
+
+check_basic :
+
+    for ( ; p<e; p++) {
+
+        if (*p == '/') {
+
+        new_dir_first :
+
+            if (e - p == 1)
+                break;
+
+            switch (p[1]) {
+
+            case    '/' :
+
+                /* '//' => '/' */
+
+                m = p + 2;
+                goto copy;
+
+            case    '.' :
+
+                if (e - p == 2)
+                    break;
+
+                switch (p[2]) {
+
+                case    '/' :
+
+                    /* './' => '' */
+
+                    m = p + 2;
+                    goto copy;
+
+                case    '.' :
+
+                    if (e - p == 3 || p[3] == '/') {
+
+                        if (p == s) {
+
+                            s += 3;
+                            continue;
+                        }
+
+                        if (p - s >= 2) {
+
+                            if (p[-1] == '.' && p[-2] == '.') {
+
+                                if (p - s == 2 || p[-3] == '/') {    /* = '../../' */
+
+                                    p += 2;     /* 3? */
+                                    continue;
+                                }
+                            }
+                        }
+
+                        m = p + 4;
+
+                        if (complex) {
+
+                            for (p--; p >= s; p--) {
+
+                                switch (*p) {
+
+                                case    '/' :
+                                    goto copy;
+
+                                case    '$' :
+
+                                    p = m - 1;
+
+                                    if (m == e)
+                                        goto end_basic;
+
+                                    goto new_dir_first;
+                                }
+                            }
+
+                        } else {
+
+                           for (p--; p > s; p--) {
+
+                                /* '/path/folder/../' => '/path/' */
+
+                                if (*p == '/')
+                                    break;
+                            }
+                        }
+
+                        goto copy;
+                    }
+                }
+            }
+        }
+    }
+
+end_basic :
+
+    path->data = s;
+    path->len = p - s;
+
+    return;
+
+copy :
+
+    p++;
+
+    if (m < e)
+        goto new_dir;
+
+    while (m < e) {       
+
+        c = *m;
+        *p = c;
+        p++;
+
+        if (c == '/') {
+
+            m++;
+
+        new_dir :
+
+            for ( ; m<e; m++) {
+
+                c = *m;
+                if (c != '/')
+                    break;
+            }
+
+            if (m == e)
+                break;
+
+            if (c == '.') {
+
+                if (e - m == 1)
+                    break;
+
+                switch (m[1]) {
+
+                case    '/' :
+
+                    /* './' => '' */
+
+                    m += 2;
+                    if (m == e)
+                        break;
+
+                    goto new_dir;
+
+                case    '.' :
+
+                    if (e - m == 2 || m[2] == '/') {
+
+                        if (m - s >= 3) {   /* NOTE : this is one higher than above because m has moved on 1 */
+
+                            if (p[-2] == '.' && p[-3] == '.') {
+
+                                if (m - s == 3 || p[-4] == '/') {    /* = '../../' */
+
+                                    p[0] = '.';
+                                    p[1] = '.';
+                                    p[2] = '/';
+                                    p += 3;
+                                    m += 3;
+                                    goto new_dir;
+                                }
+                            }
+                        }
+
+                        if (complex) {
+
+                            l = p;
+
+                            for (p -= 2; p >= s; p--) {
+
+                                switch (*p) {
+
+                                case    '/' :
+                                    break;
+
+                                case    '$' :
+
+                                    l[0] = '.';
+                                    l[1] = '.';
+                                    l[2] = '/';
+                                    p = l + 4;
+                                    break;
+
+                                default :
+                                    continue;
+                                }
+
+                                break;
+                            }
+
+                            m += 3;
+                            if (m == e)
+                                goto end;
+
+                            goto new_dir;
+
+                        } else {
+
+                            for (p -= 2; p > s; p--) {
+
+                                /* '/path/folder/../' => '/path/' */
+
+                                if (*p == '/')
+                                    break;
+                            }
+
+                            m += 3;
+                            if (m == e)
+                                goto end;
+
+                            goto new_dir;
+                        }
+                    }
+                }
+            }
+
+        } else {
+            m++;
+        }
+    }
+
+end :
+
+    path->data = s;
+    path->len = p - s;
+}
+
+
+/* This function converts a path to its directory version, and assumes that there is always space
+ * to allocatate an extra character on the end (which is only true if the provided strings always
+ * have NULL's at the end (hence the 'safe').
+*/
+
+void
+ndk_path_to_dir_safe (ngx_str_t *path, ngx_uint_t complex, size_t off)
+{
+    size_t   len;
+    u_char  *p, *m;
+
+    ndk_clean_path (path, complex, off);
+
+    len = path->len;
+    if (!len)
+        return;
+
+    p = path->data;
+    m = p + len - 1;
+
+    if (*m != '/') {
+
+        p [len] = '/';
+        path->len++;
+    }
+}
+
+
+/* Divides a path given by path/to/path1:path/to/path2 into separate strings and returns an
+ * array of these strings.
+*/
+
+ngx_array_t *
+ndk_split_path_create (ngx_conf_t *cf, ngx_str_t *path)
+{
+    ngx_str_t         *str;
+    int                n;
+    u_char            *m, *s, *e;
+    ngx_array_t       *a; 
+
+    if (path == NULL)
+        return  NULL;
+
+    n = ndk_strcntc (path, ':');
+
+    a = ngx_array_create (cf->pool, n + 1, sizeof (ngx_str_t));
+    if (a == NULL) {
+        return  NULL;
+    }
+
+    s = path->data;
+    e = s + path->len;
+
+    while (s < e) {
+
+        m = s;
+
+        while (m < e && *m != ':') m++;
+
+        if (m == s) {
+            s = m+1;
+            continue;
+        }
+
+        str = ngx_array_push (a);
+        if (str == NULL) {
+            return  NULL;
+        }
+
+        str->data = s;
+        str->len = m - s;
+
+        if (ngx_conf_full_name (cf->cycle, str, 0) == NGX_ERROR)
+            return  NULL;
+
+        s = m+1;
+    }
+
+    return  a;
+}
+
+
+
+ngx_array_t *
+ndk_split_path_create_raw (ngx_conf_t *cf, char *path)
+{
+    ngx_str_t         *str;
+    int                n;
+    char              *m, *s;
+    ngx_array_t       *a; 
+
+    if (path == NULL)
+        return  NULL;
+
+    n = ndk_strccnt (path, ':');
+
+    a = ngx_array_create (cf->pool, n + 1, sizeof (ngx_str_t));
+    if (a == NULL) {
+        return  NULL;
+    }
+
+    s = path;
+
+
+    while (*s != '\0') {
+
+        m = s;
+
+        while (*m != '\0' && *m != ':') m++;
+
+        if (m == s) {
+            s = m+1;
+            continue;
+        }
+
+        str = ngx_array_push (a);
+        if (str == NULL) {
+            return  NULL;
+        }
+
+        str->data = (u_char *) s;
+        str->len = m - s;
+
+        if (ngx_conf_full_name (cf->cycle, str, 0) == NGX_ERROR)
+            return  NULL;
+
+        if (*m == '\0')
+            break;
+
+        s = m+1;
+    }
+
+    return  a;
+}
+
+
+
+char *
+ndk_conf_set_full_path_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t        *path, *value;
+    ngx_conf_post_t  *post;
+
+    path = (ngx_str_t *) (p + cmd->offset);
+
+    if (path->data) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    *path = value[1];
+
+    if (ngx_conf_full_name (cf->cycle, path, 0) == NGX_ERROR)
+        return  NGX_CONF_ERROR;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return post->post_handler(cf, post, path);
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_split_path_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)     
+{
+    /* TODO : change to use the path func above */
+
+    char  *p = conf;
+
+    ngx_str_t         *value, *str;
+    ngx_array_t      **a;
+    ngx_conf_post_t   *post;
+    int                n;
+    u_char            *m, *s, *e;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a != NGX_CONF_UNSET_PTR) {
+        return  "is duplicate";
+    }
+
+    value = cf->args->elts;
+    value++;
+
+    n = ndk_strcntc (value, ':') + 1;
+
+    *a = ngx_array_create (cf->pool, n, sizeof (ngx_str_t));
+    if (*a == NULL) {
+        return  NGX_CONF_ERROR;
+    }
+
+    s = value->data;
+    e = s + value->len;
+
+    while (s < e) {
+
+        m = s;
+
+        while (m < e && *m != ':') m++;
+
+        if (m == s) {
+            s = m+1;
+            continue;
+        }
+
+        str = ngx_array_push (*a);
+        if (str == NULL) {
+            return  NGX_CONF_ERROR;
+        }
+
+        str->data = s;
+        str->len = m - s;
+
+        if (ngx_conf_full_name (cf->cycle, str, 0) == NGX_ERROR)
+            return  NGX_CONF_ERROR;
+
+        s = m+1;
+    }
+
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, a);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_full_path (ngx_conf_t *cf, void *data, ngx_str_t *path)
+{
+    if (ngx_conf_full_name (cf->cycle, path, 0) == NGX_ERROR)
+        return  NGX_CONF_ERROR;
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_full_conf_path (ngx_conf_t *cf, void *data, ngx_str_t *path)
+{
+    if (ngx_conf_full_name (cf->cycle, path, 1) == NGX_ERROR)
+        return  NGX_CONF_ERROR;
+
+    return  NGX_CONF_OK;
+}
+
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_path.h b/src/lua/ngx_devel_kit/src/ndk_path.h
--- a/src/lua/ngx_devel_kit/src/ndk_path.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_path.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,22 @@
+
+
+/* path conversion functions */
+
+void            ndk_clean_path                  (ngx_str_t *path, ngx_uint_t complex, size_t off);
+void            ndk_path_to_dir_safe            (ngx_str_t *path, ngx_uint_t complex, size_t off);
+
+/* path create functions */
+
+ngx_array_t *   ndk_split_path_create           (ngx_conf_t *cf, ngx_str_t *path);
+ngx_array_t *   ndk_split_path_create_raw       (ngx_conf_t *cf, char *path);
+
+/* conf set functions */
+
+char *          ndk_conf_set_full_path_slot     (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *          ndk_conf_set_split_path_slot    (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+/* conf set post functions */
+
+char *          ndk_conf_set_full_path          (ngx_conf_t *cf, void *data, ngx_str_t *path);
+char *          ndk_conf_set_full_conf_path     (ngx_conf_t *cf, void *data, ngx_str_t *path);
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_process.c b/src/lua/ngx_devel_kit/src/ndk_process.c
--- a/src/lua/ngx_devel_kit/src/ndk_process.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_process.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,20 @@
+
+ngx_int_t
+ndk_init_signals (ngx_signal_t *sig, ngx_log_t *log)
+{
+    struct sigaction   sa;
+
+    for ( ; sig->signo != 0; sig++) {
+        ndk_zerov (sa);
+        sa.sa_handler = sig->handler;
+        sigemptyset (&sa.sa_mask);
+        
+        if (sigaction (sig->signo, &sa, NULL) == -1) {
+            ngx_log_error (NGX_LOG_EMERG, log, ngx_errno,
+                          "sigaction(%s) failed", sig->signame);
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_process.h b/src/lua/ngx_devel_kit/src/ndk_process.h
--- a/src/lua/ngx_devel_kit/src/ndk_process.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_process.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,12 @@
+
+
+typedef struct {
+    int     signo;
+    char   *signame;
+    char   *name;
+    void  (*handler)(int signo);
+} ngx_signal_t;
+
+
+ngx_int_t   ndk_init_signals    (ngx_signal_t *sig, ngx_log_t *log);
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_regex.c b/src/lua/ngx_devel_kit/src/ndk_regex.c
--- a/src/lua/ngx_devel_kit/src/ndk_regex.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_regex.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,215 @@
+
+
+char *
+ndk_conf_set_regex_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t               *value;
+    ngx_conf_post_t         *post;
+    ngx_regex_elt_t         *re;   
+    ngx_regex_compile_t      rc;
+    u_char                   errstr[NGX_MAX_CONF_ERRSTR];
+
+    re = (ngx_regex_elt_t *) (p + cmd->offset);
+
+    if (re->name) {
+        return  "is duplicate";
+    }
+
+    value = cf->args->elts;
+    value++;
+
+    ndk_zerov (rc);
+
+    rc.pool = cf->pool;
+    rc.err.len = NGX_MAX_CONF_ERRSTR;
+    rc.err.data = errstr;
+    rc.pattern = *value;
+
+    if (ngx_regex_compile(&rc) != NGX_OK) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &rc.err);
+        return NGX_CONF_ERROR;
+    }
+
+    re->regex = rc.regex;
+    re->name = value->data;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, re);
+    }
+
+    return  NGX_CONF_OK;
+}
+ 
+
+char *
+ndk_conf_set_regex_caseless_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t               *value;
+    ngx_conf_post_t         *post;
+    ngx_regex_elt_t         *re;   
+    ngx_regex_compile_t      rc;
+    u_char                   errstr[NGX_MAX_CONF_ERRSTR];
+
+    re = (ngx_regex_elt_t *) (p + cmd->offset);
+
+    if (re->name) {
+        return  "is duplicate";
+    }
+
+    value = cf->args->elts;
+    value++;
+
+    ndk_zerov (rc);
+
+    rc.pool = cf->pool;
+    rc.err.len = NGX_MAX_CONF_ERRSTR;
+    rc.err.data = errstr;
+    rc.pattern = *value;
+    rc.options = NGX_REGEX_CASELESS;
+
+    if (ngx_regex_compile(&rc) != NGX_OK) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &rc.err);
+        return NGX_CONF_ERROR;
+    }
+
+    re->regex = rc.regex;
+    re->name = value->data;
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, re);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_regex_array_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t               *value;
+    ngx_conf_post_t         *post;
+    ngx_array_t            **a;
+    ngx_regex_elt_t         *re;   
+    ngx_regex_compile_t      rc;
+    ngx_uint_t               i, n;
+    u_char                   errstr[NGX_MAX_CONF_ERRSTR];
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a != NGX_CONF_UNSET_PTR) {
+
+        n = cf->args->nelts > 4 ? cf->args->nelts : 4;
+
+        *a = ngx_array_create (cf->pool, n, sizeof (ngx_regex_elt_t));
+        if (*a == NULL) {
+            return  NGX_CONF_ERROR;
+        }
+    }
+
+    ndk_zerov (rc);
+
+    rc.pool = cf->pool;
+    rc.err.len = NGX_MAX_CONF_ERRSTR;
+    rc.err.data = errstr;
+
+    value = cf->args->elts;
+    value++;
+
+    for (i=0; i<n; i++, value++) {
+
+        re = ngx_array_push (*a);
+        if (re == NULL)
+            return  NGX_CONF_ERROR;
+
+        rc.pattern = *value;
+
+        if (ngx_regex_compile(&rc) != NGX_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &rc.err);
+            return NGX_CONF_ERROR;
+        }
+
+        re->regex = rc.regex;
+        re->name = value->data;
+    }
+
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, a);
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+
+char *
+ndk_conf_set_regex_array_caseless_slot (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char  *p = conf;
+
+    ngx_str_t               *value;
+    ngx_conf_post_t         *post;
+    ngx_array_t            **a;
+    ngx_regex_elt_t         *re;   
+    ngx_regex_compile_t      rc;
+    ngx_uint_t               i, n;
+    u_char                   errstr[NGX_MAX_CONF_ERRSTR];
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a != NGX_CONF_UNSET_PTR) {
+
+        n = cf->args->nelts > 4 ? cf->args->nelts : 4;
+
+        *a = ngx_array_create (cf->pool, n, sizeof (ngx_regex_elt_t));
+        if (*a == NULL) {
+            return  NGX_CONF_ERROR;
+        }
+    }
+
+    ndk_zerov (rc);
+
+    rc.pool = cf->pool;
+    rc.err.len = NGX_MAX_CONF_ERRSTR;
+    rc.err.data = errstr;
+
+    value = cf->args->elts;
+    value++;
+
+    for (i=0; i<n; i++, value++) {
+
+        re = ngx_array_push (*a);
+        if (re == NULL)
+            return  NGX_CONF_ERROR;
+
+        rc.pattern = *value;
+        rc.options = NGX_REGEX_CASELESS;
+
+        if (ngx_regex_compile(&rc) != NGX_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &rc.err);
+            return NGX_CONF_ERROR;
+        }
+
+        re->regex = rc.regex;
+        re->name = value->data;
+    }
+
+
+    if (cmd->post) {
+        post = cmd->post;
+        return  post->post_handler (cf, post, a);
+    }
+
+    return  NGX_CONF_OK;
+}
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_regex.h b/src/lua/ngx_devel_kit/src/ndk_regex.h
--- a/src/lua/ngx_devel_kit/src/ndk_regex.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_regex.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,7 @@
+
+
+char *  ndk_conf_set_regex_slot                 (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_regex_caseless_slot        (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_regex_array_slot           (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_conf_set_regex_array_caseless_slot  (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_rewrite.c b/src/lua/ngx_devel_kit/src/ndk_rewrite.c
--- a/src/lua/ngx_devel_kit/src/ndk_rewrite.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_rewrite.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,103 @@
+
+
+/* these have been taken from the rewrite module and http_script file
+ * because those functions are defined as being static - a patch will
+ * be provided later to un-define them as being static
+ */
+
+
+uintptr_t ndk_http_script_exit_code = (uintptr_t) NULL;
+
+
+char *
+ndk_http_rewrite_value (ngx_conf_t *cf, ndk_http_rewrite_loc_conf_t *lcf,
+    ngx_str_t *value)
+{
+    ngx_int_t                              n;
+    ngx_http_script_compile_t              sc;
+    ngx_http_script_value_code_t          *val;
+    ngx_http_script_complex_value_code_t  *complex;
+
+    n = ngx_http_script_variables_count(value);
+
+    if (n == 0) {
+        val = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                                         sizeof(ngx_http_script_value_code_t));
+        if (val == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        n = ngx_atoi(value->data, value->len);
+
+        if (n == NGX_ERROR) {
+            n = 0;
+        }
+
+        val->code = ngx_http_script_value_code;
+        val->value = (uintptr_t) n;
+        val->text_len = (uintptr_t) value->len;
+        val->text_data = (uintptr_t) value->data;
+
+        return NGX_CONF_OK;
+    }
+
+    complex = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                                 sizeof(ngx_http_script_complex_value_code_t));
+    if (complex == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    complex->code = ngx_http_script_complex_value_code;
+    complex->lengths = NULL;
+
+    ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));
+
+    sc.cf = cf;
+    sc.source = value;
+    sc.lengths = &complex->lengths;
+    sc.values = &lcf->codes;
+    sc.variables = n;
+    sc.complete_lengths = 1;
+
+    if (ngx_http_script_compile(&sc) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+ngx_int_t
+ndk_http_rewrite_var (ngx_http_request_t *r, ngx_http_variable_value_t *v,
+    uintptr_t data)
+{
+    ngx_http_variable_t          *var;
+    ngx_http_core_main_conf_t    *cmcf;
+    ndk_http_rewrite_loc_conf_t  *rlcf;
+
+    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_rewrite_module);
+
+    if (rlcf->uninitialized_variable_warn == 0) {
+        *v = ngx_http_variable_null_value;
+        return NGX_OK;
+    }
+
+    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+    var = cmcf->variables.elts;
+
+    /*
+     * the ngx_http_rewrite_module sets variables directly in r->variables,
+     * and they should be handled by ngx_http_get_indexed_variable(),
+     * so the handler is called only if the variable is not initialized
+     */
+
+    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                  "using uninitialized \"%V\" variable", &var[data].name);
+
+    *v = ngx_http_variable_null_value;
+
+    return  NGX_OK;
+}
+
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_rewrite.h b/src/lua/ngx_devel_kit/src/ndk_rewrite.h
--- a/src/lua/ngx_devel_kit/src/ndk_rewrite.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_rewrite.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,26 @@
+
+
+/* TODO : should remove this when not needed */
+
+
+
+/* used for plugging into the rewrite module (taken from the rewrite module) */
+
+typedef struct {
+    ngx_array_t  *codes;        /* uintptr_t */
+    ngx_uint_t    stack_size;
+    ngx_flag_t    log;
+    ngx_flag_t    uninitialized_variable_warn;
+} ndk_http_rewrite_loc_conf_t;
+
+
+extern  ngx_module_t    ngx_http_rewrite_module;
+extern  uintptr_t       ndk_http_script_exit_code;
+
+char *      ndk_http_rewrite_value      (ngx_conf_t *cf, ndk_http_rewrite_loc_conf_t *lcf,
+                                            ngx_str_t *value);
+ngx_int_t   ndk_http_rewrite_var        (ngx_http_request_t *r, 
+                                            ngx_http_variable_value_t *v, uintptr_t data);
+
+#define     ndk_http_script_exit  (u_char *) &ndk_http_script_exit_code
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_set_var.c b/src/lua/ngx_devel_kit/src/ndk_set_var.c
--- a/src/lua/ngx_devel_kit/src/ndk_set_var.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_set_var.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,602 @@
+#include    <ndk.h>
+
+
+typedef struct {
+    ngx_http_script_code_pt     code;
+    void                       *func;
+} ndk_set_var_code_t;
+
+
+typedef struct {
+    ngx_http_script_code_pt     code;
+    void                       *func;
+    size_t                      size;
+} ndk_set_var_size_code_t;
+
+
+typedef struct {
+    ngx_http_script_code_pt     code;
+    void                       *func;
+    void                       *data;
+} ndk_set_var_data_code_t;
+
+
+typedef struct {
+    ngx_http_script_code_pt     code;
+    void                       *func;
+    size_t                      size;
+    void                       *data;
+} ndk_set_var_size_data_code_t;
+
+
+typedef struct {
+    ngx_int_t                        index;
+    ngx_str_t                       *value;
+    ngx_http_variable_t             *v;
+    ngx_conf_t                      *cf;
+    ndk_http_rewrite_loc_conf_t     *rlcf;
+} ndk_set_var_info_t;
+
+
+static void     ndk_set_var_code           (ngx_http_script_engine_t *e);
+static void     ndk_set_var_hash_code      (ngx_http_script_engine_t *e);
+static void     ndk_set_var_value_code     (ngx_http_script_engine_t *e);
+
+
+static ngx_inline void
+ndk_set_var_code_finalize(ngx_http_script_engine_t *e, ngx_int_t rc,
+                                ngx_http_variable_value_t *v, ngx_str_t *str)
+{
+    switch (rc) {
+
+    case NGX_OK:
+
+        v->data = str->data;
+        v->len = str->len;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                        "http script value (post filter): \"%v\"", v);
+        break;
+
+    case NGX_DECLINED:
+
+        v->valid = 0;
+        v->not_found = 1;
+        v->no_cacheable = 1;
+        break;
+
+    case NGX_ERROR:
+
+        e->ip = ndk_http_script_exit;
+        e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        break;
+    }
+}
+
+
+
+static void
+ndk_set_var_code(ngx_http_script_engine_t *e)
+{
+    ngx_int_t                    rc;
+    ngx_str_t                    str;
+    ngx_http_variable_value_t   *v;
+    ndk_set_var_code_t          *sv;
+    ndk_set_var_pt               func;
+
+    sv = (ndk_set_var_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_code_t);
+
+    v = e->sp++;
+
+    func = (ndk_set_var_pt) sv->func;
+
+    rc = func(e->request, &str);
+
+    ndk_set_var_code_finalize(e, rc, v, &str);
+}
+
+
+static void
+ndk_set_var_data_code(ngx_http_script_engine_t *e)
+{
+    ngx_int_t                    rc;
+    ngx_str_t                    str;
+    ngx_http_variable_value_t   *v;
+    ndk_set_var_data_code_t     *svd;
+    ndk_set_var_data_pt          func;
+
+    svd = (ndk_set_var_data_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_data_code_t);
+
+    v = e->sp++;
+
+    func = (ndk_set_var_data_pt) svd->func;
+
+    rc = func(e->request, &str, svd->data);
+
+    ndk_set_var_code_finalize(e, rc, v, &str);
+}
+
+
+static void
+ndk_set_var_value_code(ngx_http_script_engine_t *e)
+{
+    ngx_int_t                    rc;
+    ngx_str_t                    str;
+    ngx_http_variable_value_t   *v;
+    ndk_set_var_code_t          *sv;
+    ndk_set_var_value_pt         func;
+
+    sv = (ndk_set_var_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_code_t);
+
+    v = e->sp - 1;
+
+    func = (ndk_set_var_value_pt) sv->func;
+
+    rc = func(e->request, &str, v);
+
+    ndk_set_var_code_finalize(e, rc, v, &str);
+}
+
+
+static void
+ndk_set_var_value_data_code(ngx_http_script_engine_t *e)
+{
+    ngx_int_t                    rc;
+    ngx_str_t                    str;
+    ngx_http_variable_value_t   *v;
+    ndk_set_var_data_code_t     *svd;
+    ndk_set_var_value_data_pt    func;
+
+    svd = (ndk_set_var_data_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_data_code_t);
+
+    v = e->sp - 1;
+
+    func = (ndk_set_var_value_data_pt) svd->func;
+
+    rc = func(e->request, &str, v, svd->data);
+
+    ndk_set_var_code_finalize(e, rc, v, &str);
+}
+
+
+static void
+ndk_set_var_multi_value_code(ngx_http_script_engine_t *e)
+{
+    ngx_int_t                    rc;
+    ngx_str_t                    str;
+    ngx_http_variable_value_t   *v;
+    ndk_set_var_size_code_t     *svs;
+    ndk_set_var_value_pt         func;
+
+    svs = (ndk_set_var_size_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_size_code_t);
+
+    v = e->sp - svs->size;
+    e->sp = v + 1;
+
+    func = (ndk_set_var_value_pt) svs->func;
+
+    rc = func(e->request, &str, v);
+
+    ndk_set_var_code_finalize(e, rc, v, &str);
+}
+
+
+static void
+ndk_set_var_multi_value_data_code(ngx_http_script_engine_t *e)
+{
+    ngx_int_t                        rc;
+    ngx_str_t                        str;
+    ngx_http_variable_value_t       *v;
+    ndk_set_var_size_data_code_t    *svsd;
+    ndk_set_var_value_data_pt        func;
+
+    svsd = (ndk_set_var_size_data_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_size_data_code_t);
+
+    v = e->sp - svsd->size;
+    e->sp = v + 1;
+
+    func = (ndk_set_var_value_data_pt) svsd->func;
+
+    rc = func(e->request, &str, v, svsd->data);
+
+    ndk_set_var_code_finalize(e, rc, v, &str);
+}
+
+
+static void
+ndk_set_var_hash_code(ngx_http_script_engine_t *e)
+{
+    u_char                      *p;
+    ngx_http_variable_value_t   *v;
+    ndk_set_var_size_code_t     *svs;
+    ndk_set_var_hash_pt          func;
+
+    svs = (ndk_set_var_size_code_t *) e->ip;
+
+    e->ip += sizeof(ndk_set_var_size_code_t);
+
+    p = ngx_palloc(e->request->pool, svs->size);
+    if (p == NULL) {
+        e->ip = ndk_http_script_exit;
+        e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        return;
+    }
+
+    v = e->sp - 1;
+
+    func = (ndk_set_var_hash_pt) svs->func;
+
+    func(p, (char *) v->data, v->len);
+
+    v->data = (u_char *) p;
+    v->len = svs->size;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script hashed value: \"%v\"", v);
+}
+
+
+
+static char *
+ndk_set_var_name(ndk_set_var_info_t *info, ngx_str_t *varname)
+{
+    ngx_int_t                        index;
+    ngx_http_variable_t             *v;
+    ngx_conf_t                      *cf;
+    ndk_http_rewrite_loc_conf_t     *rlcf;
+    ngx_str_t                        name;
+
+    name = *varname;
+
+    cf = info->cf;
+    rlcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_rewrite_module);
+
+    if (name.data[0] != '$') {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid variable name \"%V\"", &name);
+        return NGX_CONF_ERROR;
+    }
+
+    name.len--;
+    name.data++;
+
+    v = ngx_http_add_variable(cf, &name, NGX_HTTP_VAR_CHANGEABLE);
+    if (v == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    index = ngx_http_get_variable_index(cf, &name);
+    if (index == NGX_ERROR) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (v->get_handler == NULL
+        && ngx_strncasecmp(name.data, (u_char *) "arg_", 4) != 0
+        && ngx_strncasecmp(name.data, (u_char *) "cookie_", 7) != 0
+        && ngx_strncasecmp(name.data, (u_char *) "http_", 5) != 0
+        && ngx_strncasecmp(name.data, (u_char *) "sent_http_", 10) != 0
+        && ngx_strncasecmp(name.data, (u_char *) "upstream_http_", 14) != 0)
+    {
+        v->get_handler = ndk_http_rewrite_var;
+        v->data = index;
+    }
+
+    info->v = v;
+    info->index = index;
+    info->rlcf = rlcf;
+
+    return NGX_CONF_OK;
+}
+
+
+
+static void
+ndk_set_variable_value_space(ndk_http_rewrite_loc_conf_t *rlcf, ngx_uint_t count)
+{
+    /* if the number of variable values that will be used is greater than 10,
+     * make sure there is enough space allocated on the rewrite value stack
+     */
+
+    if (count <= 10)
+        return;
+
+    if (rlcf->stack_size == NGX_CONF_UNSET_UINT) {
+        rlcf->stack_size = count;
+        return;
+    }
+
+    if (rlcf->stack_size < count)
+        rlcf->stack_size = count;
+}
+
+
+
+static char *
+ndk_set_var_filter(ngx_conf_t *cf, ndk_http_rewrite_loc_conf_t *rlcf,
+    ndk_set_var_t *filter)
+{
+    ndk_set_var_code_t             *sv;
+    ndk_set_var_size_code_t        *svs;
+    ndk_set_var_data_code_t        *svd;
+    ndk_set_var_size_data_code_t   *svsd;
+
+    if (filter == NULL) {
+        return "no filter set";
+    }
+
+    switch (filter->type) {
+    case NDK_SET_VAR_BASIC:
+
+        sv = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                         sizeof(ndk_set_var_code_t));
+        if (sv == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        sv->code = ndk_set_var_code;
+        sv->func = filter->func;
+        break;
+
+    case NDK_SET_VAR_DATA:
+
+        svd = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                         sizeof(ndk_set_var_data_code_t));
+        if (svd == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        svd->code = ndk_set_var_data_code;
+        svd->func = filter->func;
+        svd->data = filter->data;
+        break;
+
+    case NDK_SET_VAR_VALUE:
+
+        sv = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                         sizeof(ndk_set_var_code_t));
+        if (sv == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        sv->code = ndk_set_var_value_code;
+        sv->func = filter->func;
+        break;
+
+    case NDK_SET_VAR_VALUE_DATA:
+
+        svd = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                         sizeof(ndk_set_var_data_code_t));
+        if (svd == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        svd->code = ndk_set_var_value_data_code;
+        svd->func = filter->func;
+        svd->data = filter->data;
+        break;
+
+    case NDK_SET_VAR_MULTI_VALUE:
+
+        svs = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                          sizeof(ndk_set_var_size_code_t));
+        if (svs == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        svs->code = ndk_set_var_multi_value_code;
+        svs->func = filter->func;
+        svs->size = filter->size;
+
+        ndk_set_variable_value_space(rlcf, svs->size);
+        break;
+
+    case NDK_SET_VAR_MULTI_VALUE_DATA:
+
+        svsd = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                          sizeof(ndk_set_var_size_data_code_t));
+        if (svsd == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        svsd->code = ndk_set_var_multi_value_data_code;
+        svsd->func = filter->func;
+        svsd->size = filter->size;
+        svsd->data = filter->data;
+
+        ndk_set_variable_value_space(rlcf, svsd->size);
+        break;
+
+
+    case NDK_SET_VAR_HASH:
+
+        svs = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                          sizeof(ndk_set_var_size_code_t));
+        if (svs == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        svs->code = ndk_set_var_hash_code;
+        svs->func = filter->func;
+        svs->size = filter->size;
+        break;
+
+    default:
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid filter type \"%ul\"", filter->type);
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ndk_set_var_filter_value(ndk_set_var_info_t *info, ndk_set_var_t *filter)
+{
+    ngx_conf_t                          *cf;
+    ngx_http_variable_t                 *v;
+    ndk_http_rewrite_loc_conf_t         *rlcf;
+    ngx_http_script_var_code_t          *vcode;
+    ngx_http_script_var_handler_code_t  *vhcode;
+
+    v = info->v;
+    cf = info->cf;
+    rlcf = info->rlcf;
+
+    if (ndk_set_var_filter(cf, rlcf, filter) != NGX_CONF_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (v->set_handler) {
+        vhcode = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                   sizeof(ngx_http_script_var_handler_code_t));
+        if (vhcode == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        vhcode->code = ngx_http_script_var_set_handler_code;
+        vhcode->handler = v->set_handler;
+        vhcode->data = v->data;
+
+        return NGX_CONF_OK;
+    }
+
+    vcode = ngx_http_script_start_code(cf->pool, &rlcf->codes,
+                                       sizeof(ngx_http_script_var_code_t));
+    if (vcode == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    vcode->code = ngx_http_script_set_var_code;
+    vcode->index = (uintptr_t) info->index;
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ndk_set_var_core(ngx_conf_t *cf, ngx_str_t *name, ndk_set_var_t *filter)
+{
+    char                    *p;
+    ndk_set_var_info_t       info;
+
+    info.cf = cf;
+
+    p = ndk_set_var_name(&info, name);
+    if (p != NGX_CONF_OK) {
+        return p;
+    }
+
+    return ndk_set_var_filter_value(&info, filter);
+}
+
+
+char *
+ndk_set_var_value_core(ngx_conf_t *cf, ngx_str_t *name, ngx_str_t *value, ndk_set_var_t *filter)
+{
+    char                    *p;
+    ndk_set_var_info_t       info;
+
+    info.cf = cf;
+
+    p = ndk_set_var_name(&info, name);
+    if (p != NGX_CONF_OK) {
+        return p;
+    }
+
+    p = ndk_http_rewrite_value(cf, info.rlcf, value);
+    if (p != NGX_CONF_OK) {
+        return p;
+    }
+
+    return ndk_set_var_filter_value(&info, filter);
+}
+
+
+char *
+ndk_set_var_multi_value_core(ngx_conf_t *cf, ngx_str_t *name,
+        ngx_str_t *value, ndk_set_var_t *filter)
+{
+    char                    *p;
+    ndk_set_var_info_t       info;
+    ngx_int_t                i;
+
+    info.cf = cf;
+
+    p = ndk_set_var_name(&info, name);
+    if (p != NGX_CONF_OK) {
+        return p;
+    }
+
+    for (i = filter->size; i; i--, value++) {
+
+        p = ndk_http_rewrite_value(cf, info.rlcf, value);
+        if (p != NGX_CONF_OK) {
+            return p;
+        }
+    }
+
+    return ndk_set_var_filter_value(&info, filter);
+}
+
+
+char *
+ndk_set_var(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t               *value;
+    ndk_set_var_t      *filter;
+
+    value = cf->args->elts;
+    value++;
+
+    filter = (ndk_set_var_t *) cmd->post;
+
+    return ndk_set_var_core(cf, value, filter);
+}
+
+
+char *
+ndk_set_var_value(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t               *value;
+    ndk_set_var_t           *filter;
+
+    value = cf->args->elts;
+    value++;
+
+    filter = (ndk_set_var_t *) cmd->post;
+
+    return ndk_set_var_value_core(cf, value,
+            cf->args->nelts == 1 + 1 ? value : value + 1, filter);
+}
+
+
+char *
+ndk_set_var_multi_value(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t               *value;
+    ndk_set_var_t      *filter;
+
+    value = cf->args->elts;
+    value++;
+
+    filter = (ndk_set_var_t *) cmd->post;
+
+    return ndk_set_var_multi_value_core(cf, value, value + 1, filter);
+}
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_set_var.h b/src/lua/ngx_devel_kit/src/ndk_set_var.h
--- a/src/lua/ngx_devel_kit/src/ndk_set_var.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_set_var.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,44 @@
+/*
+ * 2010 (C) Marcus Clyne
+ */
+
+#ifndef _NDK_SET_VAR_H_INCLUDED_
+#define _NDK_SET_VAR_H_INCLUDED_
+
+
+typedef ngx_int_t   (*ndk_set_var_pt)              (ngx_http_request_t *r, ngx_str_t *val);
+typedef ngx_int_t   (*ndk_set_var_data_pt)         (ngx_http_request_t *r, ngx_str_t *val, void *data);
+typedef ngx_int_t   (*ndk_set_var_value_pt)        (ngx_http_request_t *r, ngx_str_t *val, ngx_http_variable_value_t *v);
+typedef ngx_int_t   (*ndk_set_var_value_data_pt)   (ngx_http_request_t *r, ngx_str_t *val, ngx_http_variable_value_t *v, void *data);
+typedef void        (*ndk_set_var_hash_pt)         (u_char *p, char *data, size_t len);
+
+
+typedef struct {
+    ngx_uint_t      type;
+    void           *func;
+    size_t          size;
+    void           *data;
+} ndk_set_var_t;
+
+
+enum {
+    NDK_SET_VAR_BASIC = 0,
+    NDK_SET_VAR_DATA,
+    NDK_SET_VAR_VALUE,
+    NDK_SET_VAR_VALUE_DATA,
+    NDK_SET_VAR_MULTI_VALUE,
+    NDK_SET_VAR_MULTI_VALUE_DATA,
+    NDK_SET_VAR_HASH
+};
+
+
+char *  ndk_set_var                    (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_set_var_value              (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+char *  ndk_set_var_multi_value        (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+
+char *  ndk_set_var_core               (ngx_conf_t *cf, ngx_str_t *name, ndk_set_var_t *filter);
+char *  ndk_set_var_value_core         (ngx_conf_t *cf, ngx_str_t *name, ngx_str_t *value, ndk_set_var_t *filter);
+char *  ndk_set_var_multi_value_core   (ngx_conf_t *cf, ngx_str_t *name, ngx_str_t *value, ndk_set_var_t *filter);
+
+#endif /* _NDK_SET_VAR_H_INCLUDED_ */
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_string.c b/src/lua/ngx_devel_kit/src/ndk_string.c
--- a/src/lua/ngx_devel_kit/src/ndk_string.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_string.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,434 @@
+
+
+int64_t
+ndk_atoi64 (u_char *line, size_t n)
+{
+    int64_t  value;
+
+    if (n == 0ll) {
+        return NGX_ERROR;
+    }
+
+    for (value = 0ll; n--; line++) {
+        if (*line < '0' || *line > '9') {
+            return NGX_ERROR;
+        }
+
+        value = value * 10ll + (*line - '0');
+    }
+
+    if (value < 0ll) {
+        return NGX_ERROR;
+    }
+
+    return value;
+}
+
+
+ngx_int_t
+ndk_strcntc (ngx_str_t *s, char c)
+{
+    ngx_int_t   n;
+    size_t      i;
+    u_char     *p;
+
+    i = s->len;
+    p = s->data;
+
+    for (n=0; i; i--, p++) {
+
+        if (*p == (u_char) c)
+            n++;
+    }
+
+    return  n;
+}
+
+
+ngx_int_t
+ndk_strccnt (char *s, char c)
+{
+    ngx_int_t   n;
+
+    n = 0;
+
+    while (*s != '\0') {
+
+        if (*s == 'c')
+            n++;
+
+        s++;
+    }
+
+    return  n;
+}
+
+
+
+ngx_array_t *
+ndk_str_array_create (ngx_pool_t *pool, char **s, ngx_int_t n)
+{
+    ngx_int_t        i;
+    ngx_str_t       *str;
+    ngx_array_t     *a;
+
+    a = ngx_array_create (pool, n, sizeof (ngx_str_t));
+    if (a == NULL)
+        return  NULL;
+
+
+    for (i=0; i<n; i++, s++) {
+
+        str = ngx_array_push (a);
+
+        str->data = (u_char *) *s;
+        str->len = strlen (*s);
+    }
+
+    return  a;
+}
+
+
+
+u_char *
+ndk_vcatstrf (ngx_pool_t *pool, ngx_str_t *dest, const char *fmt, va_list args)
+{
+    size_t          len, l, el;
+    int             argc;
+    u_char         *p, *m, *e, c, c1, *cp;
+
+    argc = strlen (fmt);
+
+    ngx_str_t      *s;
+    ndk_estr_t     *sp, *sp2, ss [argc];
+    u_char        cs [argc];
+
+    sp = sp2 = ss;
+    cp = cs;
+
+    len = 0;
+
+    /* TODO : maybe have 'e' at the beginning? */
+
+    /* parse format to get strings */
+
+    while (*fmt) {
+
+        switch (*fmt) {
+
+        case    'S'     :
+
+            s = va_arg (args, ngx_str_t *);
+
+            sp->data = s->data;
+            sp->len = s->len;
+            sp->escaped = 0;
+
+            len += sp->len;
+            break;
+
+        case    's'     :
+
+            sp->data = va_arg (args, u_char *);
+            sp->len = (size_t) ngx_strlen (sp->data);
+            sp->escaped = 0;
+
+            len += sp->len;
+            break;
+
+        case    'l'     :
+
+            sp->data = va_arg (args, u_char *);
+            sp->len = (size_t) va_arg (args, int);
+            sp->escaped = 0;
+
+            len += sp->len;
+            break;
+
+        case    'L'     :
+
+            sp->data = va_arg (args, u_char *);
+            sp->len = va_arg (args, size_t);
+            sp->escaped = 0;
+
+            len += sp->len;
+            break;
+
+        case    'e' :
+
+            p = va_arg (args, u_char *);
+
+            sp->data = p;
+
+            l = 0;
+            el = 0;
+            c = *p;
+
+            while (c != '\0') {
+
+                if (c == '\\') {
+                    l += 2;
+                    p += 2;
+                } else {
+                    l++;
+                    p++;
+                }
+
+                el++; 
+                c = *p;
+            }
+
+            sp->len = l;
+            sp->escaped = 1;
+
+            len += el;
+            break;
+
+        case    'E' :
+
+            s = va_arg (args, ngx_str_t *);
+
+            sp->data = s->data;
+            sp->len = s->len;
+
+            p = sp->data;
+
+            el = 0;
+            e = p + sp->len;
+
+            while (p < e) {
+
+                c = *p;
+
+                if (c == '\\') {
+                    p += 2;
+                } else {
+                    p++;
+                }
+
+                el++;                    
+            }
+
+            sp->escaped = 1;
+
+            len += el;
+            break;
+
+        case    'n' :
+
+            sp->data = va_arg (args, u_char *);
+            sp->len = (size_t) va_arg (args, int);
+
+            p = sp->data;
+
+            el = 0;
+            e = p + sp->len;
+
+            while (p < e) {
+
+                c = *p;
+
+                if (c == '\\') {
+                    p += 2;
+                } else {
+                    p++;
+                }
+
+                el++;                    
+            }
+
+            sp->escaped = 1;
+
+            len += el;
+            break;
+
+        case    'c' :
+
+            *cp = (u_char) va_arg (args, int);
+
+            sp->data = cp;
+            sp->len = (size_t) 1;
+
+            len++;
+            cp++;
+
+            break; 
+
+        default         :
+
+            ndk_log_alert (pool->log, 0, "catstrf () : format [%s] incorrect", fmt);
+
+            return  NULL;
+
+        }
+
+        sp++;
+        fmt++;
+    }
+
+
+
+    /* create space for string (assumes no NULL's in strings) */
+
+    ndk_palloc_rn (p, pool, len + 1);
+
+    dest->data = p;
+    dest->len = len;
+
+    /* copy other strings */
+
+    if (len) {
+
+        while (sp2 < sp) {
+
+            if (sp2->escaped) {
+
+                m = sp2->data;
+                e = m + sp2->len;
+
+                while (m < e) {
+
+                    c = *m;
+
+                    if (c == '\\') {
+
+                        if (m == e - 1) {
+                            *p = '\\';
+                            p++;
+                            break;
+                        }
+
+                        c1 = m[1];
+
+                        switch (c1) {
+
+                        case    'n' :
+                            *p = '\n';
+                            break;
+
+                        case    't' :
+                            *p = '\t';
+                            break;
+
+                        case    '0' :
+                            *p = '\0';
+                            break;
+
+                        case    '\\' :
+                            *p = '\\';
+                            break;
+
+                        case    's' :
+                            *p = ' ';
+                            break;
+
+                        case    'b' :
+                            *p = '\b';
+                            break;
+
+                        case    'r' :
+                            *p = '\r';
+                            break;
+
+                        default :
+
+                            *p = c1;
+                            break;
+                        }
+
+                        m += 2;
+
+                    } else {
+
+                        *p = c;
+                        m++;
+                    }
+
+                    p++;
+                }
+
+            } else {
+
+                p = ngx_cpymem (p, sp2->data, sp2->len);
+            }
+
+            sp2++;
+        }
+    }
+
+    *p = '\0';
+
+    return  dest->data;
+}
+
+
+u_char *
+ndk_catstrf (ngx_pool_t *pool, ngx_str_t *dest, const char *fmt, ...)
+{
+    u_char       *p;
+    va_list         args;
+
+    va_start (args, fmt);
+    p = ndk_vcatstrf (pool, dest, fmt, args);
+    va_end (args);
+
+    return  p;
+}
+
+
+ngx_int_t
+ndk_cmpstr (ngx_str_t *s1, ngx_str_t *s2)
+{
+    ngx_int_t   rv;
+    size_t      len1, len2;
+
+    len1 = s1->len;
+    len2 = s2->len;
+
+    if (len1 == len2) {
+        return  ngx_strncmp (s1->data, s2->data, len1);
+    }
+
+    if (len1 > len2) {
+
+        rv = ngx_strncmp (s1->data, s2->data, len2);
+        if (rv == 0)
+            return  1;
+
+        return  rv;
+    }
+
+    rv = ngx_strncmp (s1->data, s2->data, len1);
+    if (rv == 0)
+        return  -1;
+
+    return  rv;
+}
+
+
+u_char *
+ndk_dupstr (ngx_pool_t *pool, ngx_str_t *dest, ngx_str_t *src)
+{
+    u_char       *d;
+    size_t       n;
+
+    n = src->len;
+
+    ndk_palloc_rn (d, pool, n + 1);
+    ndk_strncpy (d, src->data, n);
+
+    dest->data = d;
+    dest->len = n;
+
+    return  d;
+}
+
+/*
+ngx_keyval_t *
+ndk_url_args_to_keyval_list (ngx_pool_t *pool, ngx_str_t *str)
+{
+    ngx_keyval_t    *kv;
+    ngx_st
+    
+}
+*/
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_string.h b/src/lua/ngx_devel_kit/src/ndk_string.h
--- a/src/lua/ngx_devel_kit/src/ndk_string.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_string.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,37 @@
+
+
+#if 1
+/* TODO : set ndk_hex_dump for older versions of Nginx */
+#define     ndk_hex_dump                    ngx_hex_dump
+#endif
+
+typedef struct {
+    size_t          len;
+    u_char         *data;
+    ngx_flag_t      escaped;
+} ndk_estr_t;
+
+int64_t         ndk_atoi64                  (u_char *line, size_t n);
+
+ngx_int_t       ndk_strcntc                 (ngx_str_t *s, char c);
+ngx_int_t       ndk_strccnt                 (char *s, char c);
+ngx_array_t *   ndk_str_array_create        (ngx_pool_t *pool, char **s, ngx_int_t n);
+u_char *        ndk_catstrf                 (ngx_pool_t *pool, ngx_str_t *dest, const char *fmt, ...);
+ngx_int_t       ndk_cmpstr                  (ngx_str_t *s1, ngx_str_t *s2);
+u_char *        ndk_dupstr                  (ngx_pool_t *pool, ngx_str_t *dest, ngx_str_t *src);
+
+static ngx_inline void
+ndk_strtoupper (u_char *p, size_t len)
+{
+    u_char *e = p + len;
+    for ( ; p<e; p++) {
+        *p = ngx_toupper(*p);
+    }
+}
+
+
+static ngx_inline u_char *
+ndk_strncpy (u_char *d, u_char *s, size_t n)
+{
+    return  (u_char *) strncpy ((char *) d, (char *) s, n);
+}
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_string_util.h b/src/lua/ngx_devel_kit/src/ndk_string_util.h
--- a/src/lua/ngx_devel_kit/src/ndk_string_util.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_string_util.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,14 @@
+
+
+#define     ndk_str_init(ns,s)              {(ns).data = (u_char*) s; (ns).len = sizeof (s) - 1;}
+#define     ndk_strp_init(ns,s)             {(ns)->data = (u_char*) s; (ns)->len = sizeof (s) - 1;}
+
+#define     ndk_zero(p,sz)                  memset (p,'\0',sz)
+#define     ndk_zerop(p)                    ndk_zero (p,sizeof(*p))
+#define     ndk_zeropn(p,n)                 ndk_zero (p,sizeof(*p)*(n))
+#define     ndk_zerov(v)                    ndk_zero (&v,sizeof(v))
+
+#define     ngx_null_enum   { ngx_null_string, 0 }
+
+#define     ndk_memcpyp(d,s)                ngx_memcpy(d,s,sizeof(s))
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_upstream_list.c b/src/lua/ngx_devel_kit/src/ndk_upstream_list.c
--- a/src/lua/ngx_devel_kit/src/ndk_upstream_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_upstream_list.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,205 @@
+
+
+/* TODO : generalize this into a generic list module, with weight */
+
+
+typedef struct {
+    ngx_uint_t      weight;
+    ngx_str_t       s;
+    ngx_conf_t     *cf;
+} ndk_upstream_list_parse_t;
+
+
+
+static ngx_int_t
+ndk_upstream_list_parse_weight (ndk_upstream_list_parse_t *ulp)
+{
+    size_t      i;
+    ngx_str_t   *s;
+
+    s = &ulp->s;
+
+    for (i=0; i<s->len; i++) {
+
+        if (s->data[i] < '0' || s->data[i] > '9')
+            break;
+    }
+
+    if (!i) {
+        ulp->weight = 1;
+        return  NGX_OK;
+    }
+
+    if (i == s->len) {
+        ngx_conf_log_error (NGX_LOG_EMERG, ulp->cf, 0,
+            "upstream list just consists of number \"%V\"", s);
+
+        return  NGX_ERROR;
+    }
+
+    if (s->data[i] != ':') {
+        ngx_conf_log_error (NGX_LOG_EMERG, ulp->cf, 0,
+            "upstream list not correct format \"%V\"", s);
+
+        return  NGX_ERROR;
+    }
+
+
+    ulp->weight = ngx_atoi (s->data, i);
+
+    s->data += (i + 1);
+    s->len -= (i + 1);
+
+    return  NGX_OK;
+}
+
+
+
+static char *
+ndk_upstream_list (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    /* TODO : change this for getting upstream pointer if available */
+
+    ngx_uint_t                   buckets, count, i, j;
+    ngx_str_t                   *value, **bucket, *us;
+    ngx_array_t                 *ula;
+    ndk_upstream_list_t         *ul, *ule;
+    ndk_upstream_list_parse_t    ulp;
+
+    ndk_http_main_conf_t        *mcf;
+
+    mcf = ngx_http_conf_get_module_main_conf (cf, ndk_http_module);
+
+    ula = mcf->upstreams;
+
+    /* create array of upstream lists it doesn't already exist */
+
+    if (ula == NULL) {
+
+        ula = ngx_array_create (cf->pool, 4, sizeof (ndk_upstream_list_t));
+        if (ula == NULL)
+            return  NGX_CONF_ERROR;
+
+        mcf->upstreams = ula;
+    }
+
+
+    /* check to see if the list already exists */
+
+    value = cf->args->elts;
+    value++;
+
+    ul = ula->elts;
+    ule = ul + ula->nelts;
+
+    for ( ; ul<ule; ul++) {
+
+        if (ul->name.len == value->len &&
+            ngx_strncasecmp (ul->name.data, value->data, value->len) == 0) {
+
+            ngx_conf_log_error (NGX_LOG_EMERG, cf, 0,
+                           "duplicate upstream list name \"%V\"", value);
+
+            return  NGX_CONF_ERROR;
+        }
+    }
+
+
+    /* create a new list */
+
+    ul = ngx_array_push (ula);
+    if (ul == NULL)
+        return  NGX_CONF_ERROR;
+
+    ul->name = *value;
+
+
+
+    /* copy all the upstream names */
+
+    count = cf->args->nelts - 2;
+
+    us = ngx_palloc (cf->pool, count * sizeof (ngx_str_t));
+    if (us == NULL)
+        return  NGX_CONF_ERROR;
+
+    ngx_memcpy (us, value + 1, count * sizeof (ngx_str_t));
+
+
+    /* calculate the total number of buckets */
+
+    buckets = 0;
+
+    ulp.cf = cf;
+
+    for (i=0; i<count; i++, us++) {
+
+        ulp.s = *us;
+
+        if (ndk_upstream_list_parse_weight (&ulp) != NGX_OK)
+            return  NGX_CONF_ERROR;
+
+        buckets += ulp.weight;
+    }
+
+
+    /* allocate space for all buckets */
+
+    bucket = ngx_palloc (cf->pool, buckets * sizeof (ngx_str_t **));
+    if (bucket == NULL)
+        return  NGX_CONF_ERROR;
+
+    ul->elts = bucket;
+    ul->nelts = buckets;
+
+
+    /* set values for each bucket */
+
+    us -= count;
+
+    for (i=0; i<count; i++, us++) {
+
+        ulp.s = *us;
+
+        if (ndk_upstream_list_parse_weight (&ulp) != NGX_OK)
+            return  NGX_CONF_ERROR;
+
+        us->data = ulp.s.data;
+        us->len = ulp.s.len;
+
+        /* TODO : check format of upstream */
+        /* TODO : add automatic adding of http:// in upstreams? */
+
+        for (j=0; j<ulp.weight; j++, bucket++) {
+
+            *bucket = us;
+        }
+    }
+
+    return  NGX_CONF_OK;
+}
+
+
+ndk_upstream_list_t *
+ndk_get_upstream_list (ndk_http_main_conf_t *mcf, u_char *data, size_t len)
+{
+    ndk_upstream_list_t         *ul, *ule;
+    ngx_array_t                 *ua = mcf->upstreams;
+
+    if (ua == NULL) {
+        return NULL;
+    }
+
+    ul = ua->elts;
+    ule = ul + ua->nelts;
+
+    for (; ul < ule; ul++) {
+        if (ul->name.len == len && ngx_strncasecmp(ul->name.data, data, len) == 0)
+        {
+            return ul;
+        }
+    }
+
+    return NULL;
+}
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_upstream_list.h b/src/lua/ngx_devel_kit/src/ndk_upstream_list.h
--- a/src/lua/ngx_devel_kit/src/ndk_upstream_list.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_upstream_list.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,27 @@
+
+#if (NDK_UPSTREAM_LIST_CMDS)
+
+/* TODO : use the generated commands */
+
+{
+    ngx_string ("upstream_list"),
+    NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_2MORE,
+    ndk_upstream_list,
+    0,
+    0,
+    NULL
+},
+
+#else
+
+typedef struct {
+    ngx_str_t       **elts;
+    ngx_uint_t        nelts;
+    ngx_str_t         name;
+} ndk_upstream_list_t;
+
+
+ndk_upstream_list_t *
+ndk_get_upstream_list (ndk_http_main_conf_t *mcf, u_char *data, size_t len);
+
+#endif
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_uri.c b/src/lua/ngx_devel_kit/src/ndk_uri.c
--- a/src/lua/ngx_devel_kit/src/ndk_uri.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_uri.c	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,45 @@
+
+
+/* TODO : check that this is correct */
+
+u_char *
+ndk_map_uri_to_path_add_suffix (ngx_http_request_t *r, ngx_str_t *path, ngx_str_t *suffix, ngx_int_t dot)
+{
+    size_t      root_size;
+    u_char     *p;
+
+    if (suffix->len) {
+
+        if (dot) {
+
+            p = ngx_http_map_uri_to_path (r, path, &root_size, suffix->len + 1);
+
+            if (p == NULL)
+                return  NULL;
+
+            *p = '.';
+            p++;
+
+        } else {
+
+            p = ngx_http_map_uri_to_path (r, path, &root_size, suffix->len);
+
+            if (p == NULL)
+                return  NULL;
+        }       
+
+        path->len--;
+
+        p = ngx_cpymem (p, suffix->data, suffix->len);
+        *p = '\0';
+
+        return  p;  
+    }
+
+    p = ngx_http_map_uri_to_path (r, path, &root_size, 0);
+
+    path->len--;
+
+    return  p;
+}
+
diff -rNu a/src/lua/ngx_devel_kit/src/ndk_uri.h b/src/lua/ngx_devel_kit/src/ndk_uri.h
--- a/src/lua/ngx_devel_kit/src/ndk_uri.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/src/ndk_uri.h	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1,6 @@
+
+
+
+u_char *  ndk_map_uri_to_path_add_suffix  (ngx_http_request_t *r, ngx_str_t *path, ngx_str_t *suffix, ngx_int_t dot);
+
+
diff -rNu a/src/lua/ngx_devel_kit/TODO b/src/lua/ngx_devel_kit/TODO
--- a/src/lua/ngx_devel_kit/TODO	1970-01-01 08:00:00.000000000 +0800
+++ b/src/lua/ngx_devel_kit/TODO	2013-10-22 14:31:02.650680444 +0800
@@ -0,0 +1 @@
+- for backward compatability, add the ndk_macros 
